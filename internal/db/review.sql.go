// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: review.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const calculateReviewStatsForProduct = `-- name: CalculateReviewStatsForProduct :one
SELECT
    AVG(r.rating)::NUMERIC(3,2) AS avg_rating,
    COUNT(r.rating)::INTEGER AS num_ratings
FROM reviews r
WHERE r.product_id = $1 AND r.deleted_at IS NULL
`

type CalculateReviewStatsForProductRow struct {
	AvgRating  pgtype.Numeric `json:"avg_rating"`
	NumRatings int32          `json:"num_ratings"`
}

// Calculates the average rating and count of non-deleted reviews for a specific product.
// Used to update the products table.
func (q *Queries) CalculateReviewStatsForProduct(ctx context.Context, productID uuid.UUID) (CalculateReviewStatsForProductRow, error) {
	row := q.db.QueryRow(ctx, calculateReviewStatsForProduct, productID)
	var i CalculateReviewStatsForProductRow
	err := row.Scan(&i.AvgRating, &i.NumRatings)
	return i, err
}

const createReview = `-- name: CreateReview :one
INSERT INTO reviews (
    user_id, product_id, rating
) VALUES (
    $1, $2, $3
)
RETURNING id, user_id, product_id, rating, created_at, updated_at
`

type CreateReviewParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ProductID uuid.UUID `json:"product_id"`
	Rating    int32     `json:"rating"`
}

type CreateReviewRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	ProductID uuid.UUID          `json:"product_id"`
	Rating    int32              `json:"rating"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Inserts a new review and returns its details.
// NOTE: This query alone does not update the product's avg_rating/num_ratings.
func (q *Queries) CreateReview(ctx context.Context, arg CreateReviewParams) (CreateReviewRow, error) {
	row := q.db.QueryRow(ctx, createReview, arg.UserID, arg.ProductID, arg.Rating)
	var i CreateReviewRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteReview = `-- name: DeleteReview :one
UPDATE reviews
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = $1 AND user_id = $2 -- Ensure user owns the review
RETURNING id, user_id, product_id, rating, created_at, updated_at
`

type DeleteReviewParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

type DeleteReviewRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	ProductID uuid.UUID          `json:"product_id"`
	Rating    int32              `json:"rating"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Soft deletes a review by setting deleted_at.
// NOTE: This query alone does not update the product's avg_rating/num_ratings.
func (q *Queries) DeleteReview(ctx context.Context, arg DeleteReviewParams) (DeleteReviewRow, error) {
	row := q.db.QueryRow(ctx, deleteReview, arg.ID, arg.UserID)
	var i DeleteReviewRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReviewByIDAndUser = `-- name: GetReviewByIDAndUser :one
SELECT id, user_id, product_id, rating, created_at, updated_at
FROM reviews
WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL
`

type GetReviewByIDAndUserParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

type GetReviewByIDAndUserRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	ProductID uuid.UUID          `json:"product_id"`
	Rating    int32              `json:"rating"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Retrieves a specific review by its ID and verifies the user owns it.
func (q *Queries) GetReviewByIDAndUser(ctx context.Context, arg GetReviewByIDAndUserParams) (GetReviewByIDAndUserRow, error) {
	row := q.db.QueryRow(ctx, getReviewByIDAndUser, arg.ID, arg.UserID)
	var i GetReviewByIDAndUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReviewByUserAndProduct = `-- name: GetReviewByUserAndProduct :one
SELECT id, user_id, product_id, rating, created_at, updated_at
FROM reviews
WHERE user_id = $1 AND product_id = $2 AND deleted_at IS NULL
`

type GetReviewByUserAndProductParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ProductID uuid.UUID `json:"product_id"`
}

type GetReviewByUserAndProductRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	ProductID uuid.UUID          `json:"product_id"`
	Rating    int32              `json:"rating"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Retrieves a review by a specific user for a specific product.
func (q *Queries) GetReviewByUserAndProduct(ctx context.Context, arg GetReviewByUserAndProductParams) (GetReviewByUserAndProductRow, error) {
	row := q.db.QueryRow(ctx, getReviewByUserAndProduct, arg.UserID, arg.ProductID)
	var i GetReviewByUserAndProductRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReviewsByProductID = `-- name: GetReviewsByProductID :many
SELECT 
    r.id,
    r.user_id,
    r.product_id,
    r.rating,
    r.created_at,
    r.updated_at,
    u.full_name IS NOT NULL::TEXT AS reviewer_name 
FROM reviews r
JOIN users u ON r.user_id = u.id -- INNER JOIN to link review to user
WHERE r.product_id = $1 AND r.deleted_at IS NULL
ORDER BY r.created_at DESC -- Or rating DESC, etc.
LIMIT $3 OFFSET $2
`

type GetReviewsByProductIDParams struct {
	ProductID  uuid.UUID `json:"product_id"`
	PageOffset int32     `json:"page_offset"`
	PageLimit  int32     `json:"page_limit"`
}

type GetReviewsByProductIDRow struct {
	ID           uuid.UUID          `json:"id"`
	UserID       uuid.UUID          `json:"user_id"`
	ProductID    uuid.UUID          `json:"product_id"`
	Rating       int32              `json:"rating"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	ReviewerName string             `json:"reviewer_name"`
}

// Retrieves all reviews for a specific product, including the reviewer's name, potentially paginated.
func (q *Queries) GetReviewsByProductID(ctx context.Context, arg GetReviewsByProductIDParams) ([]GetReviewsByProductIDRow, error) {
	rows, err := q.db.Query(ctx, getReviewsByProductID, arg.ProductID, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsByProductIDRow
	for rows.Next() {
		var i GetReviewsByProductIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProductID,
			&i.Rating,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReviewerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsByUserID = `-- name: GetReviewsByUserID :many
SELECT 
    r.id,
    r.user_id,
    r.product_id,
    r.rating,
    r.created_at,
    r.updated_at,
    p.name AS product_name -- Join with products table to get the name
FROM reviews r
JOIN products p ON r.product_id = p.id -- INNER JOIN to link review to product
WHERE r.user_id = $1 AND r.deleted_at IS NULL
ORDER BY r.created_at DESC
LIMIT $3 OFFSET $2
`

type GetReviewsByUserIDParams struct {
	UserID     uuid.UUID `json:"user_id"`
	PageOffset int32     `json:"page_offset"`
	PageLimit  int32     `json:"page_limit"`
}

type GetReviewsByUserIDRow struct {
	ID          uuid.UUID          `json:"id"`
	UserID      uuid.UUID          `json:"user_id"`
	ProductID   uuid.UUID          `json:"product_id"`
	Rating      int32              `json:"rating"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	ProductName string             `json:"product_name"`
}

// Retrieves all reviews submitted by a specific user, including the product name, potentially paginated.
func (q *Queries) GetReviewsByUserID(ctx context.Context, arg GetReviewsByUserIDParams) ([]GetReviewsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getReviewsByUserID, arg.UserID, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsByUserIDRow
	for rows.Next() {
		var i GetReviewsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProductID,
			&i.Rating,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductReviewStats = `-- name: UpdateProductReviewStats :exec
UPDATE products
SET
    avg_rating = $1,
    num_ratings = $2,
    updated_at = NOW() -- Optionally update the product's general updated_at too
WHERE id = $3
`

type UpdateProductReviewStatsParams struct {
	AvgRating  pgtype.Numeric `json:"avg_rating"`
	NumRatings *int32         `json:"num_ratings"`
	ProductID  uuid.UUID      `json:"product_id"`
}

// Updates the avg_rating and num_ratings fields in the products table for a specific product.
func (q *Queries) UpdateProductReviewStats(ctx context.Context, arg UpdateProductReviewStatsParams) error {
	_, err := q.db.Exec(ctx, updateProductReviewStats, arg.AvgRating, arg.NumRatings, arg.ProductID)
	return err
}

const updateReview = `-- name: UpdateReview :one
UPDATE reviews
SET rating = $1, updated_at = NOW()
WHERE id = $2 AND user_id = $3 -- Ensure user owns the review
RETURNING id, user_id, product_id, rating, created_at, updated_at
`

type UpdateReviewParams struct {
	Rating int32     `json:"rating"`
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

type UpdateReviewRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	ProductID uuid.UUID          `json:"product_id"`
	Rating    int32              `json:"rating"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Updates the rating of an existing review.
// NOTE: This query alone does not update the product's avg_rating/num_ratings.
func (q *Queries) UpdateReview(ctx context.Context, arg UpdateReviewParams) (UpdateReviewRow, error) {
	row := q.db.QueryRow(ctx, updateReview, arg.Rating, arg.ID, arg.UserID)
	var i UpdateReviewRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
