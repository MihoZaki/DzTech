// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: profile.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createPasswordResetToken = `-- name: CreatePasswordResetToken :exec

INSERT INTO password_reset_tokens (user_id, token, expires_at)
VALUES ($1, $2, $3)
`

type CreatePasswordResetTokenParams struct {
	UserID    uuid.UUID          `json:"user_id"`
	Token     string             `json:"token"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

// --- Password Reset Tokens ---
// Inserts a new password reset token record.
func (q *Queries) CreatePasswordResetToken(ctx context.Context, arg CreatePasswordResetTokenParams) error {
	_, err := q.db.Exec(ctx, createPasswordResetToken, arg.UserID, arg.Token, arg.ExpiresAt)
	return err
}

const deleteExpiredPasswordResetTokens = `-- name: DeleteExpiredPasswordResetTokens :exec

DELETE FROM password_reset_tokens
WHERE expires_at <= NOW()
`

// $1=token_string
// Deletes all password reset tokens that have expired.
func (q *Queries) DeleteExpiredPasswordResetTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredPasswordResetTokens)
	return err
}

const deletePasswordResetToken = `-- name: DeletePasswordResetToken :exec

DELETE FROM password_reset_tokens
WHERE token = $1
`

// Ensure token hasn't expired
// Deletes a specific password reset token record by its token string.
func (q *Queries) DeletePasswordResetToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, deletePasswordResetToken, token)
	return err
}

const getResetToken = `-- name: GetResetToken :one

SELECT id, user_id, token, expires_at, created_at
FROM password_reset_tokens
WHERE token = $1
`

// $1=user_id, $2=token_string, $3=expiry_time
// Fetches a password reset token record by its token string.
func (q *Queries) GetResetToken(ctx context.Context, token string) (PasswordResetToken, error) {
	row := q.db.QueryRow(ctx, getResetToken, token)
	var i PasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByResetToken = `-- name: GetUserByResetToken :one

SELECT u.id, u.email, u.full_name, u.password_hash, u.is_admin, u.created_at, u.updated_at, u.deleted_at
FROM users u
JOIN password_reset_tokens prt ON u.id = prt.user_id
WHERE prt.token = $1 -- $1=token_string
  AND prt.expires_at > NOW()
`

type GetUserByResetTokenRow struct {
	ID           uuid.UUID          `json:"id"`
	Email        string             `json:"email"`
	FullName     *string            `json:"full_name"`
	PasswordHash []byte             `json:"password_hash"`
	IsAdmin      bool               `json:"is_admin"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
}

// $1=token_string
// Fetches the user associated with a valid, non-expired reset token.
func (q *Queries) GetUserByResetToken(ctx context.Context, token string) (GetUserByResetTokenRow, error) {
	row := q.db.QueryRow(ctx, getUserByResetToken, token)
	var i GetUserByResetTokenRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.PasswordHash,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateUserEmail = `-- name: UpdateUserEmail :one
UPDATE users
SET email = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, email, full_name, is_admin, created_at, updated_at, deleted_at
`

type UpdateUserEmailParams struct {
	Email string    `json:"email"`
	ID    uuid.UUID `json:"id"`
}

type UpdateUserEmailRow struct {
	ID        uuid.UUID          `json:"id"`
	Email     string             `json:"email"`
	FullName  *string            `json:"full_name"`
	IsAdmin   bool               `json:"is_admin"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

// Updates the user's email address.
func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) (UpdateUserEmailRow, error) {
	row := q.db.QueryRow(ctx, updateUserEmail, arg.Email, arg.ID)
	var i UpdateUserEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateUserFullName = `-- name: UpdateUserFullName :one

UPDATE users
SET full_name = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, email, full_name, is_admin, created_at, updated_at, deleted_at
`

type UpdateUserFullNameParams struct {
	FullName *string   `json:"full_name"`
	ID       uuid.UUID `json:"id"`
}

type UpdateUserFullNameRow struct {
	ID        uuid.UUID          `json:"id"`
	Email     string             `json:"email"`
	FullName  *string            `json:"full_name"`
	IsAdmin   bool               `json:"is_admin"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

// --- Profile & Password Management ---
// Updates the user's full name.
func (q *Queries) UpdateUserFullName(ctx context.Context, arg UpdateUserFullNameParams) (UpdateUserFullNameRow, error) {
	row := q.db.QueryRow(ctx, updateUserFullName, arg.FullName, arg.ID)
	var i UpdateUserFullNameRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users
SET password_hash = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, email, full_name, is_admin, created_at, updated_at, deleted_at
`

type UpdateUserPasswordParams struct {
	PasswordHash []byte    `json:"password_hash"`
	ID           uuid.UUID `json:"id"`
}

type UpdateUserPasswordRow struct {
	ID        uuid.UUID          `json:"id"`
	Email     string             `json:"email"`
	FullName  *string            `json:"full_name"`
	IsAdmin   bool               `json:"is_admin"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

// Updates the user's hashed password.
func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (UpdateUserPasswordRow, error) {
	row := q.db.QueryRow(ctx, updateUserPassword, arg.PasswordHash, arg.ID)
	var i UpdateUserPasswordRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
