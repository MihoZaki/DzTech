// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getAverageFulfillmentTime = `-- name: GetAverageFulfillmentTime :one
SELECT
    AVG(EXTRACT(EPOCH FROM (o_shipped_or_delivered.updated_at - o_confirmed.updated_at))) AS avg_seconds
FROM
    orders o_confirmed
JOIN
    orders o_shipped_or_delivered ON o_confirmed.id = o_shipped_or_delivered.id
WHERE
    o_confirmed.status = 'confirmed'
    AND (o_shipped_or_delivered.status = 'shipped' OR o_shipped_or_delivered.status = 'delivered')
    AND o_confirmed.created_at BETWEEN $1 AND $2
`

type GetAverageFulfillmentTimeParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

// Calculates the average time between order confirmation and shipment/delivery completion.
// Assumes 'confirmed' status is the start and 'shipped' or 'delivered' is the end.
func (q *Queries) GetAverageFulfillmentTime(ctx context.Context, arg GetAverageFulfillmentTimeParams) (float64, error) {
	row := q.db.QueryRow(ctx, getAverageFulfillmentTime, arg.StartDate, arg.EndDate)
	var avg_seconds float64
	err := row.Scan(&avg_seconds)
	return avg_seconds, err
}

const getAverageOrderValue = `-- name: GetAverageOrderValue :one

SELECT
    COALESCE(AVG(o.total_amount_cents),0)::BIGINT AS aov_cents
FROM
    orders o
WHERE
    o.status = 'delivered'
    AND o.created_at BETWEEN $1 AND $2
`

type GetAverageOrderValueParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

// @start_date = start_date, @start_date = end_date
// Calculates the average order value (AOV) for delivered orders within a given time range.
func (q *Queries) GetAverageOrderValue(ctx context.Context, arg GetAverageOrderValueParams) (int64, error) {
	row := q.db.QueryRow(ctx, getAverageOrderValue, arg.StartDate, arg.EndDate)
	var aov_cents int64
	err := row.Scan(&aov_cents)
	return aov_cents, err
}

const getDiscountUsage = `-- name: GetDiscountUsage :many

SELECT
    d.code AS discount_code,
    d.discount_type,
    d.discount_value,
    COUNT(o.id) AS usage_count,
    SUM(o.total_amount_cents) AS total_revenue_with_discount
FROM
    orders o
JOIN
    discounts d ON o.applied_discount_code = d.code -- Assuming orders table stores the code used
WHERE
    o.status = 'delivered'
    AND o.created_at BETWEEN $1 AND $2 -- $1 = start_date, $2 = end_date
GROUP BY
    d.code, d.discount_type, d.discount_value
`

type GetDiscountUsageParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

type GetDiscountUsageRow struct {
	DiscountCode             string `json:"discount_code"`
	DiscountType             string `json:"discount_type"`
	DiscountValue            int64  `json:"discount_value"`
	UsageCount               int64  `json:"usage_count"`
	TotalRevenueWithDiscount int64  `json:"total_revenue_with_discount"`
}

// --- Discount Effectiveness ---
// Retrieves usage count and revenue attributed to specific discount codes within a time range.
func (q *Queries) GetDiscountUsage(ctx context.Context, arg GetDiscountUsageParams) ([]GetDiscountUsageRow, error) {
	rows, err := q.db.Query(ctx, getDiscountUsage, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDiscountUsageRow
	for rows.Next() {
		var i GetDiscountUsageRow
		if err := rows.Scan(
			&i.DiscountCode,
			&i.DiscountType,
			&i.DiscountValue,
			&i.UsageCount,
			&i.TotalRevenueWithDiscount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLowStockProducts = `-- name: GetLowStockProducts :many


SELECT
    id AS product_id,
    name AS product_name,
    stock_quantity
FROM
    products
WHERE
    stock_quantity < $1 -- $1 = threshold quantity
    AND deleted_at IS NULL
ORDER BY
    stock_quantity ASC
`

type GetLowStockProductsRow struct {
	ProductID     uuid.UUID `json:"product_id"`
	ProductName   string    `json:"product_name"`
	StockQuantity int32     `json:"stock_quantity"`
}

// $3 = number of top products to return (N)
// --- Product Performance ---
// Retrieves products with stock quantity below a specified threshold.
func (q *Queries) GetLowStockProducts(ctx context.Context, stockQuantity int32) ([]GetLowStockProductsRow, error) {
	rows, err := q.db.Query(ctx, getLowStockProducts, stockQuantity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLowStockProductsRow
	for rows.Next() {
		var i GetLowStockProductsRow
		if err := rows.Scan(&i.ProductID, &i.ProductName, &i.StockQuantity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewCustomersCount = `-- name: GetNewCustomersCount :one

SELECT
    COUNT(*) AS new_customers_count
FROM
    users
WHERE
    created_at BETWEEN $1 AND $2-- $1 = start_date, $2 = end_date
    AND deleted_at IS NULL
`

type GetNewCustomersCountParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

// --- Customer Insights ---
// Counts the number of new customers registered within a given time range.
func (q *Queries) GetNewCustomersCount(ctx context.Context, arg GetNewCustomersCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getNewCustomersCount, arg.StartDate, arg.EndDate)
	var new_customers_count int64
	err := row.Scan(&new_customers_count)
	return new_customers_count, err
}

const getOrderStatusCounts = `-- name: GetOrderStatusCounts :many


SELECT
    status,
    COUNT(*) AS count
FROM
    orders
WHERE
    created_at BETWEEN $1 AND $2 -- $1 = start_date, $2 = end_date (optional, remove if counting all time)
GROUP BY
    status
`

type GetOrderStatusCountsParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

type GetOrderStatusCountsRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

// Exclude soft-deleted users
// --- Order Metrics ---
// Counts the number of orders in each status (pending, confirmed, shipped, delivered, cancelled).
func (q *Queries) GetOrderStatusCounts(ctx context.Context, arg GetOrderStatusCountsParams) ([]GetOrderStatusCountsRow, error) {
	rows, err := q.db.Query(ctx, getOrderStatusCounts, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderStatusCountsRow
	for rows.Next() {
		var i GetOrderStatusCountsRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByStatusWithinTimeRange = `-- name: GetOrdersByStatusWithinTimeRange :many
SELECT
    status,
    COUNT(*) AS count
FROM
    orders
WHERE
    created_at BETWEEN $1 AND $2 -- $1 = start_date, $2 = end_date (optional, remove if counting all time)
GROUP BY
    status
`

type GetOrdersByStatusWithinTimeRangeParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

type GetOrdersByStatusWithinTimeRangeRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

// $1 = start_date, $2 = end_date
// Note: This query is complex because order status updates modify the same row.
// A more robust approach might involve an order_status_history table or window functions.
// Simplified version assuming statuses are updated sequentially and we just compare timestamps.
// A better way might be to track status change events explicitly.
// For now, let's simplify the logic assuming we just want the difference between created_at and updated_at
// for 'shipped' or 'delivered' orders, IF created_at represents the time it became confirmed.
// This might not be accurate depending on how status transitions are handled.
// Let's revise:
// Assume 'confirmed' status sets confirmed_at, 'shipped' sets shipped_at, 'delivered' sets delivered_at.
// Add these timestamp fields to the orders table if they don't exist.
// ALTER TABLE orders ADD COLUMN confirmed_at TIMESTAMPTZ, shipped_at TIMESTAMPTZ, delivered_at TIMESTAMPTZ;
// Then update these timestamps in the service layer upon status changes.
// Query would then be:
// SELECT AVG(EXTRACT(EPOCH FROM (delivered_at - confirmed_at))) FROM orders WHERE status = 'delivered' AND ...;
// For now, acknowledging this complexity, we'll note it and move on, assuming status timestamps exist or are derivable.
// This query might need adjustment based on how status changes are tracked in the DB.
// Let's add a simpler one based on status counts for now.
// Counts orders by status within a time range.
// This is similar to GetOrderStatusCounts but with a time filter.
func (q *Queries) GetOrdersByStatusWithinTimeRange(ctx context.Context, arg GetOrdersByStatusWithinTimeRangeParams) ([]GetOrdersByStatusWithinTimeRangeRow, error) {
	rows, err := q.db.Query(ctx, getOrdersByStatusWithinTimeRange, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersByStatusWithinTimeRangeRow
	for rows.Next() {
		var i GetOrdersByStatusWithinTimeRangeRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductReviewStats = `-- name: GetProductReviewStats :one
SELECT
    avg_rating,
    num_ratings
FROM
    products
WHERE
    id = $1 AND deleted_at IS NULL
`

type GetProductReviewStatsRow struct {
	AvgRating  pgtype.Numeric `json:"avg_rating"`
	NumRatings *int32         `json:"num_ratings"`
}

// Retrieves average rating and number of ratings for a specific product.
// (This might already be covered by the existing product queries selecting avg_rating, num_ratings)
// But here's a dedicated query if needed:
func (q *Queries) GetProductReviewStats(ctx context.Context, id uuid.UUID) (GetProductReviewStatsRow, error) {
	row := q.db.QueryRow(ctx, getProductReviewStats, id)
	var i GetProductReviewStatsRow
	err := row.Scan(&i.AvgRating, &i.NumRatings)
	return i, err
}

const getSalesVolume = `-- name: GetSalesVolume :one

SELECT
    COUNT(*) AS total_orders
FROM
    orders
WHERE
    status = 'delivered'
    AND created_at BETWEEN $1 AND $2
`

type GetSalesVolumeParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

// $1 = start_date, $2 = end_date
// Counts the total number of delivered orders within a given time range.
func (q *Queries) GetSalesVolume(ctx context.Context, arg GetSalesVolumeParams) (int64, error) {
	row := q.db.QueryRow(ctx, getSalesVolume, arg.StartDate, arg.EndDate)
	var total_orders int64
	err := row.Scan(&total_orders)
	return total_orders, err
}

const getTopSellingCategories = `-- name: GetTopSellingCategories :many

SELECT
    c.id AS category_id,
    c.name AS category_name,
    SUM(oi.quantity) AS total_units_sold
FROM
    order_items oi
JOIN
    orders o ON oi.order_id = o.id
JOIN
    products p ON oi.product_id = p.id
JOIN
    categories c ON p.category_id = c.id
WHERE
    o.status = 'delivered'
    AND o.created_at BETWEEN $1 AND $2 -- $1 = start_date, $2 = end_date
GROUP BY
    c.id, c.name
ORDER BY
    total_units_sold DESC
LIMIT $3
`

type GetTopSellingCategoriesParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
	Limits    int32              `json:"limits"`
}

type GetTopSellingCategoriesRow struct {
	CategoryID     uuid.UUID `json:"category_id"`
	CategoryName   string    `json:"category_name"`
	TotalUnitsSold int64     `json:"total_units_sold"`
}

// $3 = number of top products to return (N)
// Retrieves the top N selling categories (by quantity sold) within a given time range.
func (q *Queries) GetTopSellingCategories(ctx context.Context, arg GetTopSellingCategoriesParams) ([]GetTopSellingCategoriesRow, error) {
	rows, err := q.db.Query(ctx, getTopSellingCategories, arg.StartDate, arg.EndDate, arg.Limits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSellingCategoriesRow
	for rows.Next() {
		var i GetTopSellingCategoriesRow
		if err := rows.Scan(&i.CategoryID, &i.CategoryName, &i.TotalUnitsSold); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopSellingProducts = `-- name: GetTopSellingProducts :many

SELECT
    p.id AS product_id,
    p.name AS product_name,
    SUM(oi.quantity) AS total_units_sold
FROM
    order_items oi
JOIN
    orders o ON oi.order_id = o.id
JOIN
    products p ON oi.product_id = p.id
WHERE
    o.status = 'delivered'
    AND o.created_at BETWEEN $1 AND $2 -- $1 = start_date, $2 = end_date
GROUP BY
    p.id, p.name
ORDER BY
    total_units_sold DESC
LIMIT $3
`

type GetTopSellingProductsParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
	Limits    int32              `json:"limits"`
}

type GetTopSellingProductsRow struct {
	ProductID      uuid.UUID `json:"product_id"`
	ProductName    string    `json:"product_name"`
	TotalUnitsSold int64     `json:"total_units_sold"`
}

// $1 = start_date, $2 = end_date
// Retrieves the top N selling products (by quantity sold) within a given time range.
func (q *Queries) GetTopSellingProducts(ctx context.Context, arg GetTopSellingProductsParams) ([]GetTopSellingProductsRow, error) {
	rows, err := q.db.Query(ctx, getTopSellingProducts, arg.StartDate, arg.EndDate, arg.Limits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSellingProductsRow
	for rows.Next() {
		var i GetTopSellingProductsRow
		if err := rows.Scan(&i.ProductID, &i.ProductName, &i.TotalUnitsSold); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalRevenue = `-- name: GetTotalRevenue :one

SELECT
    COALESCE(SUM(oi.quantity * oi.price_cents),0)::BIGINT AS total_revenue_cents
FROM
    orders o
JOIN
    order_items oi ON o.id = oi.order_id
WHERE
    o.status = 'delivered' -- Only delivered orders contribute to revenue
    AND o.created_at BETWEEN $1 AND $2
`

type GetTotalRevenueParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

// --- Sales Performance ---
// Calculates the total revenue from all delivered orders within a given time range.
func (q *Queries) GetTotalRevenue(ctx context.Context, arg GetTotalRevenueParams) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalRevenue, arg.StartDate, arg.EndDate)
	var total_revenue_cents int64
	err := row.Scan(&total_revenue_cents)
	return total_revenue_cents, err
}
