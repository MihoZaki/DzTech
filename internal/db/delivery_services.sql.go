// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: delivery_services.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createDeliveryService = `-- name: CreateDeliveryService :one
INSERT INTO delivery_services (
    name, description, base_cost_cents, estimated_days, is_active
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
`

type CreateDeliveryServiceParams struct {
	Name          string  `json:"name"`
	Description   *string `json:"description"`
	BaseCostCents int64   `json:"base_cost_cents"`
	EstimatedDays *int32  `json:"estimated_days"`
	IsActive      bool    `json:"is_active"`
}

func (q *Queries) CreateDeliveryService(ctx context.Context, arg CreateDeliveryServiceParams) (DeliveryService, error) {
	row := q.db.QueryRow(ctx, createDeliveryService,
		arg.Name,
		arg.Description,
		arg.BaseCostCents,
		arg.EstimatedDays,
		arg.IsActive,
	)
	var i DeliveryService
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BaseCostCents,
		&i.EstimatedDays,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDeliveryService = `-- name: DeleteDeliveryService :exec
DELETE FROM delivery_services WHERE id = $1
`

// Soft delete could be achieved by updating is_active to FALSE
// For hard delete:
func (q *Queries) DeleteDeliveryService(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDeliveryService, id)
	return err
}

const getActiveDeliveryServices = `-- name: GetActiveDeliveryServices :many
SELECT id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
FROM delivery_services
WHERE is_active = TRUE
ORDER BY name ASC
`

// Retrieves all delivery services that are currently active.
// Suitable for user-facing contexts like checkout.
func (q *Queries) GetActiveDeliveryServices(ctx context.Context) ([]DeliveryService, error) {
	rows, err := q.db.Query(ctx, getActiveDeliveryServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeliveryService
	for rows.Next() {
		var i DeliveryService
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.BaseCostCents,
			&i.EstimatedDays,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeliveryService = `-- name: GetDeliveryService :one
SELECT id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
FROM delivery_services
WHERE id = $1 AND is_active = $2
`

type GetDeliveryServiceParams struct {
	ID           uuid.UUID `json:"id"`
	ActiveFilter bool      `json:"active_filter"`
}

func (q *Queries) GetDeliveryService(ctx context.Context, arg GetDeliveryServiceParams) (DeliveryService, error) {
	row := q.db.QueryRow(ctx, getDeliveryService, arg.ID, arg.ActiveFilter)
	var i DeliveryService
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BaseCostCents,
		&i.EstimatedDays,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDeliveryServiceByID = `-- name: GetDeliveryServiceByID :one
SELECT id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
FROM delivery_services
WHERE id = $1
`

// Retrieves a delivery service by its ID, regardless of its active status.
// Suitable for admin operations.
func (q *Queries) GetDeliveryServiceByID(ctx context.Context, id uuid.UUID) (DeliveryService, error) {
	row := q.db.QueryRow(ctx, getDeliveryServiceByID, id)
	var i DeliveryService
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BaseCostCents,
		&i.EstimatedDays,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDeliveryServiceByName = `-- name: GetDeliveryServiceByName :one

SELECT id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
FROM delivery_services
WHERE name = $1 AND is_active = $2
`

type GetDeliveryServiceByNameParams struct {
	Name         string `json:"name"`
	ActiveFilter bool   `json:"active_filter"`
}

// Allow filtering by active status
func (q *Queries) GetDeliveryServiceByName(ctx context.Context, arg GetDeliveryServiceByNameParams) (DeliveryService, error) {
	row := q.db.QueryRow(ctx, getDeliveryServiceByName, arg.Name, arg.ActiveFilter)
	var i DeliveryService
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BaseCostCents,
		&i.EstimatedDays,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllDeliveryServices = `-- name: ListAllDeliveryServices :many
SELECT id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
FROM delivery_services
WHERE is_active = $1 -- Filter by active status
ORDER BY name ASC
LIMIT $3 OFFSET $2
`

type ListAllDeliveryServicesParams struct {
	ActiveFilter bool  `json:"active_filter"`
	PageOffset   int32 `json:"page_offset"`
	PageLimit    int32 `json:"page_limit"`
}

// Retrieves delivery services, optionally filtered by active status.
// Suitable for admin operations.
func (q *Queries) ListAllDeliveryServices(ctx context.Context, arg ListAllDeliveryServicesParams) ([]DeliveryService, error) {
	rows, err := q.db.Query(ctx, listAllDeliveryServices, arg.ActiveFilter, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeliveryService
	for rows.Next() {
		var i DeliveryService
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.BaseCostCents,
			&i.EstimatedDays,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDeliveryService = `-- name: UpdateDeliveryService :one

UPDATE delivery_services
SET
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    base_cost_cents = COALESCE($3, base_cost_cents),
    estimated_days = COALESCE($4, estimated_days),
    is_active = COALESCE($5, is_active),
    updated_at = NOW()
WHERE id = $6
RETURNING id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
`

type UpdateDeliveryServiceParams struct {
	Name          *string   `json:"name"`
	Description   *string   `json:"description"`
	BaseCostCents *int64    `json:"base_cost_cents"`
	EstimatedDays *int32    `json:"estimated_days"`
	IsActive      *bool     `json:"is_active"`
	ID            uuid.UUID `json:"id"`
}

// Allow filtering by active status
func (q *Queries) UpdateDeliveryService(ctx context.Context, arg UpdateDeliveryServiceParams) (DeliveryService, error) {
	row := q.db.QueryRow(ctx, updateDeliveryService,
		arg.Name,
		arg.Description,
		arg.BaseCostCents,
		arg.EstimatedDays,
		arg.IsActive,
		arg.ID,
	)
	var i DeliveryService
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BaseCostCents,
		&i.EstimatedDays,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
