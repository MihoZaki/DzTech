// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAllProducts = `-- name: CountAllProducts :one
SELECT COUNT(*) FROM products WHERE deleted_at IS NULL
`

func (q *Queries) CountAllProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM products WHERE deleted_at IS NULL
  AND ($1::TEXT = '' OR to_tsvector('english', name || ' ' || COALESCE(short_description, '')) @@ plainto_tsquery('english', $1))
  AND ($2::UUID IS NULL OR category_id = $2)
  AND ($3::TEXT = '' OR brand ILIKE '%' || $3 || '%')
  AND ($4::BIGINT IS NULL OR price_cents >= $4)
  AND ($5::BIGINT IS NULL OR price_cents <= $5)
  AND ($6::BOOLEAN IS NULL OR ($6 = true AND stock_quantity > 0) OR ($6 = false))
`

type CountProductsParams struct {
	Column1 string    `json:"column_1"`
	Column2 uuid.UUID `json:"column_2"`
	Column3 string    `json:"column_3"`
	Column4 int64     `json:"column_4"`
	Column5 int64     `json:"column_5"`
	Column6 bool      `json:"column_6"`
}

func (q *Queries) CountProducts(ctx context.Context, arg CountProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	CategoryID       uuid.UUID          `json:"category_id"`
	Name             string             `json:"name"`
	Slug             string             `json:"slug"`
	Description      pgtype.Text        `json:"description"`
	ShortDescription pgtype.Text        `json:"short_description"`
	PriceCents       int64              `json:"price_cents"`
	StockQuantity    int32              `json:"stock_quantity"`
	Status           string             `json:"status"`
	Brand            string             `json:"brand"`
	ImageUrls        []byte             `json:"image_urls"`
	SpecHighlights   []byte             `json:"spec_highlights"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.CategoryID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.ShortDescription,
		arg.PriceCents,
		arg.StockQuantity,
		arg.Status,
		arg.Brand,
		arg.ImageUrls,
		arg.SpecHighlights,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
UPDATE products
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const getCategory = `-- name: GetCategory :one
SELECT id, name, slug, type, parent_id, created_at
FROM categories
WHERE id = $1
`

func (q *Queries) GetCategory(ctx context.Context, id uuid.UUID) (Category, error) {
	row := q.db.QueryRow(ctx, getCategory, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Type,
		&i.ParentID,
		&i.CreatedAt,
	)
	return i, err
}

const getCategoryBySlug = `-- name: GetCategoryBySlug :one
SELECT id, name, slug, type, parent_id, created_at
FROM categories
WHERE slug = $1
`

func (q *Queries) GetCategoryBySlug(ctx context.Context, slug string) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryBySlug, slug)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Type,
		&i.ParentID,
		&i.CreatedAt,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetProduct(ctx context.Context, id uuid.UUID) (Product, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductBySlug = `-- name: GetProductBySlug :one
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE slug = $1 AND deleted_at IS NULL
`

func (q *Queries) GetProductBySlug(ctx context.Context, slug string) (Product, error) {
	row := q.db.QueryRow(ctx, getProductBySlug, slug)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listCategories = `-- name: ListCategories :many
SELECT id, name, slug, type, parent_id, created_at
FROM categories
ORDER BY name
`

func (q *Queries) ListCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.Query(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Type,
			&i.ParentID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListProductsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ShortDescription,
			&i.PriceCents,
			&i.StockQuantity,
			&i.Status,
			&i.Brand,
			&i.ImageUrls,
			&i.SpecHighlights,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByCategory = `-- name: ListProductsByCategory :many
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE category_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListProductsByCategoryParams struct {
	CategoryID uuid.UUID `json:"category_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

func (q *Queries) ListProductsByCategory(ctx context.Context, arg ListProductsByCategoryParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProductsByCategory, arg.CategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ShortDescription,
			&i.PriceCents,
			&i.StockQuantity,
			&i.Status,
			&i.Brand,
			&i.ImageUrls,
			&i.SpecHighlights,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProducts = `-- name: SearchProducts :many
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE deleted_at IS NULL
  AND ($1::TEXT = '' OR to_tsvector('english', name || ' ' || COALESCE(short_description, '')) @@ plainto_tsquery('english', $1))
  AND ($2::UUID IS NULL OR category_id = $2)
  AND ($3::TEXT = '' OR brand ILIKE '%' || $3 || '%')
  AND ($4::BIGINT IS NULL OR price_cents >= $4)
  AND ($5::BIGINT IS NULL OR price_cents <= $5)
  AND ($6::BOOLEAN IS NULL OR ($6 = true AND stock_quantity > 0) OR ($6 = false))
ORDER BY created_at DESC
LIMIT $7 OFFSET $8
`

type SearchProductsParams struct {
	Column1 string    `json:"column_1"`
	Column2 uuid.UUID `json:"column_2"`
	Column3 string    `json:"column_3"`
	Column4 int64     `json:"column_4"`
	Column5 int64     `json:"column_5"`
	Column6 bool      `json:"column_6"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, searchProducts,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ShortDescription,
			&i.PriceCents,
			&i.StockQuantity,
			&i.Status,
			&i.Brand,
			&i.ImageUrls,
			&i.SpecHighlights,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET
    category_id = COALESCE($2, category_id),
    name = COALESCE($3, name),
    slug = COALESCE($4, slug),
    description = COALESCE($5, description),
    short_description = COALESCE($6, short_description),
    price_cents = COALESCE($7, price_cents),
    stock_quantity = COALESCE($8, stock_quantity),
    status = COALESCE($9, status),
    brand = COALESCE($10, brand),
    image_urls = COALESCE($11, image_urls),
    spec_highlights = COALESCE($12, spec_highlights),
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at, deleted_at
`

type UpdateProductParams struct {
	ID               uuid.UUID   `json:"id"`
	CategoryID       uuid.UUID   `json:"category_id"`
	Name             string      `json:"name"`
	Slug             string      `json:"slug"`
	Description      pgtype.Text `json:"description"`
	ShortDescription pgtype.Text `json:"short_description"`
	PriceCents       int64       `json:"price_cents"`
	StockQuantity    int32       `json:"stock_quantity"`
	Status           string      `json:"status"`
	Brand            string      `json:"brand"`
	ImageUrls        []byte      `json:"image_urls"`
	SpecHighlights   []byte      `json:"spec_highlights"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ID,
		arg.CategoryID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.ShortDescription,
		arg.PriceCents,
		arg.StockQuantity,
		arg.Status,
		arg.Brand,
		arg.ImageUrls,
		arg.SpecHighlights,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
