// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkSlugExists = `-- name: CheckSlugExists :one
SELECT EXISTS(SELECT 1 FROM products WHERE slug = $1 AND deleted_at IS NULL) AS exists
`

// Checks if a product slug already exists (excluding soft-deleted products).
func (q *Queries) CheckSlugExists(ctx context.Context, slug string) (bool, error) {
	row := q.db.QueryRow(ctx, checkSlugExists, slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countAllProducts = `-- name: CountAllProducts :one
SELECT COUNT(*) FROM products WHERE deleted_at IS NULL
`

func (q *Queries) CountAllProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM products p
LEFT JOIN v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id
WHERE p.deleted_at IS NULL
AND ($1::TEXT = '' OR p.name ILIKE '%' || $1 || '%' OR COALESCE(p.short_description, '') ILIKE '%' || $1 || '%' OR to_tsvector('english', p.name || ' ' || COALESCE(p.short_description, '')) @@ plainto_tsquery('english', $1) OR p.spec_highlights::TEXT ILIKE '%' || $1 || '%')    -- Spec highlight filter: Check if apply_spec_filter is true, then match the value for the given key
  -- Apply spec_filter condition only if apply_spec_filter is true
  AND (NOT $2::BOOLEAN OR ($3::TEXT != '' AND p.spec_highlights ->> $3 ILIKE '%' || $4 || '%'))
  AND ($5::UUID = '00000000-0000-0000-0000-000000000000' OR p.category_id = $5)
  AND ($6::TEXT = '' OR p.brand ILIKE '%' || $6 || '%')
  AND ($7::BIGINT = 0 OR p.price_cents >= $7)
  AND ($8::BIGINT = 0 OR p.price_cents <= $8)
  AND (($9::BOOLEAN = false AND $9 IS NOT NULL) OR ($9 = true AND p.stock_quantity > 0) OR ($9 = false AND p.stock_quantity <= 0))
  -- Add the same discount filter condition as in SearchProductsWithDiscounts
  AND ($10::BOOLEAN = false OR vpcd.has_active_discount = TRUE)
`

type CountProductsParams struct {
	Query                 string    `json:"query"`
	ApplySpecFilter       bool      `json:"apply_spec_filter"`
	SpecFilterKey         string    `json:"spec_filter_key"`
	SpecFilterValue       *string   `json:"spec_filter_value"`
	CategoryID            uuid.UUID `json:"category_id"`
	Brand                 string    `json:"brand"`
	MinPrice              int64     `json:"min_price"`
	MaxPrice              int64     `json:"max_price"`
	InStockOnly           bool      `json:"in_stock_only"`
	IncludeDiscountedOnly bool      `json:"include_discounted_only"`
}

func (q *Queries) CountProducts(ctx context.Context, arg CountProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts,
		arg.Query,
		arg.ApplySpecFilter,
		arg.SpecFilterKey,
		arg.SpecFilterValue,
		arg.CategoryID,
		arg.Brand,
		arg.MinPrice,
		arg.MaxPrice,
		arg.InStockOnly,
		arg.IncludeDiscountedOnly,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at
) VALUES (
    $1, 
    $2, 
    $3, 
    $4, 
    $5, 
    $6, 
    $7, 
    $8, 
    $9, 
    $10, 
    $11, 
    NOW(), -- created_at
    NOW()  -- updated_at
) 
RETURNING  id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	CategoryID       uuid.UUID `json:"category_id"`
	Name             string    `json:"name"`
	Slug             string    `json:"slug"`
	Description      *string   `json:"description"`
	ShortDescription *string   `json:"short_description"`
	PriceCents       int64     `json:"price_cents"`
	StockQuantity    int32     `json:"stock_quantity"`
	Status           string    `json:"status"`
	Brand            string    `json:"brand"`
	ImageUrls        []byte    `json:"image_urls"`
	SpecHighlights   []byte    `json:"spec_highlights"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.CategoryID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.ShortDescription,
		arg.PriceCents,
		arg.StockQuantity,
		arg.Status,
		arg.Brand,
		arg.ImageUrls,
		arg.SpecHighlights,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.AvgRating,
		&i.NumRatings,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
UPDATE products
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, productID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProduct, productID)
	return err
}

const getCategory = `-- name: GetCategory :one
SELECT id, name, slug, type, parent_id, created_at
FROM categories
WHERE id = $1
`

func (q *Queries) GetCategory(ctx context.Context, categoryID uuid.UUID) (Category, error) {
	row := q.db.QueryRow(ctx, getCategory, categoryID)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Type,
		&i.ParentID,
		&i.CreatedAt,
	)
	return i, err
}

const getCategoryBySlug = `-- name: GetCategoryBySlug :one
SELECT id, name, slug, type, parent_id, created_at
FROM categories
WHERE slug = $1
`

func (q *Queries) GetCategoryBySlug(ctx context.Context, slug string) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryBySlug, slug)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Type,
		&i.ParentID,
		&i.CreatedAt,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetProduct(ctx context.Context, productID uuid.UUID) (Product, error) {
	row := q.db.QueryRow(ctx, getProduct, productID)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.AvgRating,
		&i.NumRatings,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductBySlug = `-- name: GetProductBySlug :one
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE slug = $1 AND deleted_at IS NULL
`

func (q *Queries) GetProductBySlug(ctx context.Context, slug string) (Product, error) {
	row := q.db.QueryRow(ctx, getProductBySlug, slug)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.AvgRating,
		&i.NumRatings,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listCategories = `-- name: ListCategories :many
SELECT id, name, slug, type, parent_id, created_at
FROM categories
ORDER BY name
`

func (q *Queries) ListCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.Query(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Type,
			&i.ParentID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

type ListProductsParams struct {
	PageOffset int32 `json:"page_offset"`
	PageLimit  int32 `json:"page_limit"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProducts, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ShortDescription,
			&i.PriceCents,
			&i.StockQuantity,
			&i.Status,
			&i.Brand,
			&i.AvgRating,
			&i.NumRatings,
			&i.ImageUrls,
			&i.SpecHighlights,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByCategory = `-- name: ListProductsByCategory :many
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE category_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type ListProductsByCategoryParams struct {
	CategoryID uuid.UUID `json:"category_id"`
	PageOffset int32     `json:"page_offset"`
	PageLimit  int32     `json:"page_limit"`
}

func (q *Queries) ListProductsByCategory(ctx context.Context, arg ListProductsByCategoryParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProductsByCategory, arg.CategoryID, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ShortDescription,
			&i.PriceCents,
			&i.StockQuantity,
			&i.Status,
			&i.Brand,
			&i.AvgRating,
			&i.NumRatings,
			&i.ImageUrls,
			&i.SpecHighlights,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsWithCategory = `-- name: ListProductsWithCategory :many
SELECT 
    p.id, p.category_id, p.name, p.slug, p.description, p.short_description, p.price_cents, p.stock_quantity, p.status, p.brand, p.avg_rating, p.num_ratings, p.image_urls, p.spec_highlights, p.created_at, p.updated_at, p.deleted_at,
    c.name as category_name,
    c.slug as category_slug,
    c.type as category_type
FROM products p
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.deleted_at IS NULL
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $1
`

type ListProductsWithCategoryParams struct {
	PageOffset int32 `json:"page_offset"`
	PageLimit  int32 `json:"page_limit"`
}

type ListProductsWithCategoryRow struct {
	Product      Product `json:"product"`
	CategoryName *string `json:"category_name"`
	CategorySlug *string `json:"category_slug"`
	CategoryType *string `json:"category_type"`
}

func (q *Queries) ListProductsWithCategory(ctx context.Context, arg ListProductsWithCategoryParams) ([]ListProductsWithCategoryRow, error) {
	rows, err := q.db.Query(ctx, listProductsWithCategory, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsWithCategoryRow
	for rows.Next() {
		var i ListProductsWithCategoryRow
		if err := rows.Scan(
			&i.Product.ID,
			&i.Product.CategoryID,
			&i.Product.Name,
			&i.Product.Slug,
			&i.Product.Description,
			&i.Product.ShortDescription,
			&i.Product.PriceCents,
			&i.Product.StockQuantity,
			&i.Product.Status,
			&i.Product.Brand,
			&i.Product.AvgRating,
			&i.Product.NumRatings,
			&i.Product.ImageUrls,
			&i.Product.SpecHighlights,
			&i.Product.CreatedAt,
			&i.Product.UpdatedAt,
			&i.Product.DeletedAt,
			&i.CategoryName,
			&i.CategorySlug,
			&i.CategoryType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsWithCategoryDetail = `-- name: ListProductsWithCategoryDetail :many
SELECT 
    p.id, p.category_id, p.name, p.slug, p.description, p.short_description, p.price_cents, p.stock_quantity, p.status, p.brand, p.avg_rating, p.num_ratings, p.image_urls, p.spec_highlights, p.created_at, p.updated_at, p.deleted_at,
    c.id, c.name, c.slug, c.type, c.parent_id, c.created_at
FROM products p
JOIN categories c ON p.category_id = c.id
WHERE p.category_id = $1 AND p.deleted_at IS NULL
ORDER BY p.created_at DESC
LIMIT $3 OFFSET $2
`

type ListProductsWithCategoryDetailParams struct {
	CategoryID uuid.UUID `json:"category_id"`
	PageOffset int32     `json:"page_offset"`
	PageLimit  int32     `json:"page_limit"`
}

type ListProductsWithCategoryDetailRow struct {
	Product  Product  `json:"product"`
	Category Category `json:"category"`
}

func (q *Queries) ListProductsWithCategoryDetail(ctx context.Context, arg ListProductsWithCategoryDetailParams) ([]ListProductsWithCategoryDetailRow, error) {
	rows, err := q.db.Query(ctx, listProductsWithCategoryDetail, arg.CategoryID, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsWithCategoryDetailRow
	for rows.Next() {
		var i ListProductsWithCategoryDetailRow
		if err := rows.Scan(
			&i.Product.ID,
			&i.Product.CategoryID,
			&i.Product.Name,
			&i.Product.Slug,
			&i.Product.Description,
			&i.Product.ShortDescription,
			&i.Product.PriceCents,
			&i.Product.StockQuantity,
			&i.Product.Status,
			&i.Product.Brand,
			&i.Product.AvgRating,
			&i.Product.NumRatings,
			&i.Product.ImageUrls,
			&i.Product.SpecHighlights,
			&i.Product.CreatedAt,
			&i.Product.UpdatedAt,
			&i.Product.DeletedAt,
			&i.Category.ID,
			&i.Category.Name,
			&i.Category.Slug,
			&i.Category.Type,
			&i.Category.ParentID,
			&i.Category.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProductsWithCategory = `-- name: SearchProductsWithCategory :many
SELECT 
    p.id, p.category_id, p.name, p.slug, p.description, p.short_description, p.price_cents, p.stock_quantity, p.status, p.brand, p.avg_rating, p.num_ratings, p.image_urls, p.spec_highlights, p.created_at, p.updated_at, p.deleted_at,
    c.name as category_name,
    c.slug as category_slug,
    c.type as category_type
FROM products p
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.deleted_at IS NULL
  AND ($1::TEXT = '' OR p.name ILIKE '%' || $1 || '%' OR COALESCE(p.short_description, '') ILIKE '%' || $1 || '%' OR to_tsvector('english', p.name || ' ' || COALESCE(p.short_description, '')) @@ plainto_tsquery('english', $1))
  AND ($2::UUID = '00000000-0000-0000-0000-000000000000' OR p.category_id = $2)
  AND ($3::TEXT = '' OR p.brand ILIKE '%' || $3 || '%')
  AND ($4::BIGINT = 0 OR p.price_cents >= $4)
  AND ($5::BIGINT = 0 OR p.price_cents <= $5)
  AND (($6::BOOLEAN = false AND $6 IS NOT NULL) OR ($6 = true AND p.stock_quantity > 0) OR ($6 = false AND p.stock_quantity <= 0))
ORDER BY p.created_at DESC
LIMIT $8 OFFSET $7
`

type SearchProductsWithCategoryParams struct {
	Query       string    `json:"query"`
	CategoryID  uuid.UUID `json:"category_id"`
	Brand       string    `json:"brand"`
	MinPrice    int64     `json:"min_price"`
	MaxPrice    int64     `json:"max_price"`
	InStockOnly bool      `json:"in_stock_only"`
	PageOffset  int32     `json:"page_offset"`
	PageLimit   int32     `json:"page_limit"`
}

type SearchProductsWithCategoryRow struct {
	Product      Product `json:"product"`
	CategoryName *string `json:"category_name"`
	CategorySlug *string `json:"category_slug"`
	CategoryType *string `json:"category_type"`
}

func (q *Queries) SearchProductsWithCategory(ctx context.Context, arg SearchProductsWithCategoryParams) ([]SearchProductsWithCategoryRow, error) {
	rows, err := q.db.Query(ctx, searchProductsWithCategory,
		arg.Query,
		arg.CategoryID,
		arg.Brand,
		arg.MinPrice,
		arg.MaxPrice,
		arg.InStockOnly,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProductsWithCategoryRow
	for rows.Next() {
		var i SearchProductsWithCategoryRow
		if err := rows.Scan(
			&i.Product.ID,
			&i.Product.CategoryID,
			&i.Product.Name,
			&i.Product.Slug,
			&i.Product.Description,
			&i.Product.ShortDescription,
			&i.Product.PriceCents,
			&i.Product.StockQuantity,
			&i.Product.Status,
			&i.Product.Brand,
			&i.Product.AvgRating,
			&i.Product.NumRatings,
			&i.Product.ImageUrls,
			&i.Product.SpecHighlights,
			&i.Product.CreatedAt,
			&i.Product.UpdatedAt,
			&i.Product.DeletedAt,
			&i.CategoryName,
			&i.CategorySlug,
			&i.CategoryType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProductsWithDiscounts = `-- name: SearchProductsWithDiscounts :many
SELECT
    p.id,
    p.category_id,
    p.name,
    p.slug,
    p.description,
    p.short_description,
    p.price_cents AS original_price_cents,
    p.stock_quantity,
    p.status,
    p.brand,
    p.image_urls,
    p.spec_highlights,
    p.created_at,
    p.updated_at,
    p.deleted_at,
    p.avg_rating,
    p.num_ratings,
    vpcd.total_fixed_discount_cents::BIGINT,
    vpcd.combined_percentage_factor::FLOAT,
    COALESCE(vpcd.calculated_discounted_price_cents, p.price_cents) AS discounted_price_cents,
    COALESCE(vpcd.has_active_discount, FALSE) AS has_active_discount
FROM
    products p
LEFT JOIN
    v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id
WHERE
    p.deleted_at IS NULL
    -- Main text search filter (name, description)
    AND (
        $1::TEXT = '' 
        OR p.name ILIKE '%' || $1 || '%' 
        OR COALESCE(p.short_description, '') ILIKE '%' || $1 || '%' 
        OR to_tsvector('english', p.name || ' ' || COALESCE(p.short_description, '')) @@ plainto_tsquery('english', $1)
        OR p.spec_highlights::TEXT ILIKE '%' || $1 || '%'
    )
    -- Spec highlight filter: Check if apply_spec_filter is true, then match the value for the given key
    AND (NOT $2::BOOLEAN OR ($3::TEXT != '' AND p.spec_highlights ->> $3 ILIKE '%' || $4 || '%'))
    -- Category filter
    AND ($5::UUID = '00000000-0000-0000-0000-000000000000' OR p.category_id = $5)
    -- Brand filter
    AND ($6::TEXT = '' OR p.brand ILIKE '%' || $6 || '%')
    -- Price range filter
    AND ($7::BIGINT = 0 OR p.price_cents >= $7)
    AND ($8::BIGINT = 0 OR p.price_cents <= $8)
    -- Stock availability filter
    AND (
        ($9::BOOLEAN = false AND $9 IS NOT NULL)
        OR ($9 = true AND p.stock_quantity > 0)
        OR ($9 = false AND p.stock_quantity <= 0)
    )
    -- Discount filter
    AND ($10::BOOLEAN = false OR vpcd.has_active_discount = TRUE)
ORDER BY
    p.created_at DESC
LIMIT $12 OFFSET $11
`

type SearchProductsWithDiscountsParams struct {
	Query                 string    `json:"query"`
	ApplySpecFilter       bool      `json:"apply_spec_filter"`
	SpecFilterKey         string    `json:"spec_filter_key"`
	SpecFilterValue       *string   `json:"spec_filter_value"`
	CategoryID            uuid.UUID `json:"category_id"`
	Brand                 string    `json:"brand"`
	MinPrice              int64     `json:"min_price"`
	MaxPrice              int64     `json:"max_price"`
	InStockOnly           bool      `json:"in_stock_only"`
	IncludeDiscountedOnly bool      `json:"include_discounted_only"`
	PageOffset            int32     `json:"page_offset"`
	PageLimit             int32     `json:"page_limit"`
}

type SearchProductsWithDiscountsRow struct {
	ID                           uuid.UUID          `json:"id"`
	CategoryID                   uuid.UUID          `json:"category_id"`
	Name                         string             `json:"name"`
	Slug                         string             `json:"slug"`
	Description                  *string            `json:"description"`
	ShortDescription             *string            `json:"short_description"`
	OriginalPriceCents           int64              `json:"original_price_cents"`
	StockQuantity                int32              `json:"stock_quantity"`
	Status                       string             `json:"status"`
	Brand                        string             `json:"brand"`
	ImageUrls                    []byte             `json:"image_urls"`
	SpecHighlights               []byte             `json:"spec_highlights"`
	CreatedAt                    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                    pgtype.Timestamptz `json:"updated_at"`
	DeletedAt                    pgtype.Timestamptz `json:"deleted_at"`
	AvgRating                    pgtype.Numeric     `json:"avg_rating"`
	NumRatings                   *int32             `json:"num_ratings"`
	VpcdTotalFixedDiscountCents  int64              `json:"vpcd_total_fixed_discount_cents"`
	VpcdCombinedPercentageFactor float64            `json:"vpcd_combined_percentage_factor"`
	DiscountedPriceCents         int64              `json:"discounted_price_cents"`
	HasActiveDiscount            bool               `json:"has_active_discount"`
}

// Searches for products and includes pre-calculated discount information using the view.
// Includes a flexible spec highlight filter for partial matching within values.
func (q *Queries) SearchProductsWithDiscounts(ctx context.Context, arg SearchProductsWithDiscountsParams) ([]SearchProductsWithDiscountsRow, error) {
	rows, err := q.db.Query(ctx, searchProductsWithDiscounts,
		arg.Query,
		arg.ApplySpecFilter,
		arg.SpecFilterKey,
		arg.SpecFilterValue,
		arg.CategoryID,
		arg.Brand,
		arg.MinPrice,
		arg.MaxPrice,
		arg.InStockOnly,
		arg.IncludeDiscountedOnly,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProductsWithDiscountsRow
	for rows.Next() {
		var i SearchProductsWithDiscountsRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ShortDescription,
			&i.OriginalPriceCents,
			&i.StockQuantity,
			&i.Status,
			&i.Brand,
			&i.ImageUrls,
			&i.SpecHighlights,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.AvgRating,
			&i.NumRatings,
			&i.VpcdTotalFixedDiscountCents,
			&i.VpcdCombinedPercentageFactor,
			&i.DiscountedPriceCents,
			&i.HasActiveDiscount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET
    category_id = COALESCE($1, category_id),
    name = COALESCE($2, name),
    slug = COALESCE($3, slug),
    description = COALESCE($4, description),
    short_description = COALESCE($5, short_description),
    price_cents = COALESCE($6, price_cents),
    stock_quantity = COALESCE($7, stock_quantity),
    status = COALESCE($8, status),
    brand = COALESCE($9, brand),
    image_urls = COALESCE($10, image_urls),
    spec_highlights = COALESCE($11, spec_highlights),
    updated_at = NOW()
WHERE id = $12 AND deleted_at IS NULL
RETURNING  id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at
`

type UpdateProductParams struct {
	CategoryID       uuid.UUID `json:"category_id"`
	Name             string    `json:"name"`
	Slug             string    `json:"slug"`
	Description      *string   `json:"description"`
	ShortDescription *string   `json:"short_description"`
	PriceCents       int64     `json:"price_cents"`
	StockQuantity    int32     `json:"stock_quantity"`
	Status           string    `json:"status"`
	Brand            string    `json:"brand"`
	ImageUrls        []byte    `json:"image_urls"`
	SpecHighlights   []byte    `json:"spec_highlights"`
	ProductID        uuid.UUID `json:"product_id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.CategoryID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.ShortDescription,
		arg.PriceCents,
		arg.StockQuantity,
		arg.Status,
		arg.Brand,
		arg.ImageUrls,
		arg.SpecHighlights,
		arg.ProductID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.AvgRating,
		&i.NumRatings,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
