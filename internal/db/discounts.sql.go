// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: discounts.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const applyDiscountToCategory = `-- name: ApplyDiscountToCategory :exec
INSERT INTO category_discounts (category_id, discount_id)
VALUES ($1, $2)
`

type ApplyDiscountToCategoryParams struct {
	CategoryID uuid.UUID `json:"category_id"`
	DiscountID uuid.UUID `json:"discount_id"`
}

// Associates a discount with a specific category (simplified version, might need more checks).
func (q *Queries) ApplyDiscountToCategory(ctx context.Context, arg ApplyDiscountToCategoryParams) error {
	_, err := q.db.Exec(ctx, applyDiscountToCategory, arg.CategoryID, arg.DiscountID)
	return err
}

const applyDiscountToProduct = `-- name: ApplyDiscountToProduct :exec

INSERT INTO product_discounts (product_id, discount_id)
VALUES ($1, $2)
`

type ApplyDiscountToProductParams struct {
	ProductID  uuid.UUID `json:"product_id"`
	DiscountID uuid.UUID `json:"discount_id"`
}

// Include usage limit check
// Associates a discount with a specific product (simplified version, might need more checks).
func (q *Queries) ApplyDiscountToProduct(ctx context.Context, arg ApplyDiscountToProductParams) error {
	_, err := q.db.Exec(ctx, applyDiscountToProduct, arg.ProductID, arg.DiscountID)
	return err
}

const countDiscounts = `-- name: CountDiscounts :one
SELECT COUNT(*) FROM discounts
WHERE ($1::boolean IS NULL OR is_active = $1) -- Filter by active status if provided
  AND ($2::timestamptz IS NULL OR valid_from <= $2) -- Filter by valid from date if provided
  AND ($3::timestamptz IS NULL OR valid_until >= $3)
`

type CountDiscountsParams struct {
	IsActive  bool               `json:"is_active"`
	FromDate  pgtype.Timestamptz `json:"from_date"`
	UntilDate pgtype.Timestamptz `json:"until_date"`
}

// Counts discounts based on the same filters as ListDiscounts.
func (q *Queries) CountDiscounts(ctx context.Context, arg CountDiscountsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDiscounts, arg.IsActive, arg.FromDate, arg.UntilDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDiscount = `-- name: CreateDiscount :one
INSERT INTO discounts (
    code, description, discount_type, discount_value,
    min_order_value_cents, max_uses, valid_from, valid_until, is_active
) VALUES (
    $1, $2, $3, $4,
    $5, $6, $7, $8, $9
) RETURNING id, code, description, discount_type, discount_value, min_order_value_cents, max_uses, current_uses, valid_from, valid_until, is_active, created_at, updated_at
`

type CreateDiscountParams struct {
	Code               string             `json:"code"`
	Description        *string            `json:"description"`
	DiscountType       string             `json:"discount_type"`
	DiscountValue      int64              `json:"discount_value"`
	MinOrderValueCents *int64             `json:"min_order_value_cents"`
	MaxUses            *int32             `json:"max_uses"`
	ValidFrom          pgtype.Timestamptz `json:"valid_from"`
	ValidUntil         pgtype.Timestamptz `json:"valid_until"`
	IsActive           bool               `json:"is_active"`
}

// Inserts a new discount record.
func (q *Queries) CreateDiscount(ctx context.Context, arg CreateDiscountParams) (Discount, error) {
	row := q.db.QueryRow(ctx, createDiscount,
		arg.Code,
		arg.Description,
		arg.DiscountType,
		arg.DiscountValue,
		arg.MinOrderValueCents,
		arg.MaxUses,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.IsActive,
	)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.MinOrderValueCents,
		&i.MaxUses,
		&i.CurrentUses,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDiscount = `-- name: DeleteDiscount :exec
DELETE FROM discounts WHERE id = $1
`

// Deletes a discount record (and associated links via CASCADE).
func (q *Queries) DeleteDiscount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDiscount, id)
	return err
}

const getActiveDiscounts = `-- name: GetActiveDiscounts :many

SELECT
    d.id,
    d.code,
    d.description,
    d.discount_type,
    d.discount_value,
    d.min_order_value_cents,
    d.max_uses,
    d.current_uses,
    d.valid_from,
    d.valid_until,
    d.is_active,
    d.created_at,
    d.updated_at
FROM
    discounts d
WHERE
    d.is_active = TRUE AND NOW() BETWEEN d.valid_from AND d.valid_until
    AND (d.max_uses IS NULL OR d.current_uses < d.max_uses)
`

// Check usage limit
// Fetches all currently active discounts (within date range and usage limits).
func (q *Queries) GetActiveDiscounts(ctx context.Context) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getActiveDiscounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Discount
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValueCents,
			&i.MaxUses,
			&i.CurrentUses,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountByCode = `-- name: GetDiscountByCode :one
SELECT id, code, description, discount_type, discount_value, min_order_value_cents, max_uses, current_uses, valid_from, valid_until, is_active, created_at, updated_at FROM discounts WHERE code = $1 AND is_active = TRUE AND valid_from <= NOW() AND valid_until >= NOW()
`

// Fetches a discount by its unique code.
func (q *Queries) GetDiscountByCode(ctx context.Context, code string) (Discount, error) {
	row := q.db.QueryRow(ctx, getDiscountByCode, code)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.MinOrderValueCents,
		&i.MaxUses,
		&i.CurrentUses,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDiscountByID = `-- name: GetDiscountByID :one
SELECT id, code, description, discount_type, discount_value, min_order_value_cents, max_uses, current_uses, valid_from, valid_until, is_active, created_at, updated_at FROM discounts WHERE id = $1
`

// Fetches a discount by its ID.
func (q *Queries) GetDiscountByID(ctx context.Context, id uuid.UUID) (Discount, error) {
	row := q.db.QueryRow(ctx, getDiscountByID, id)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.MinOrderValueCents,
		&i.MaxUses,
		&i.CurrentUses,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDiscountsByCategoryID = `-- name: GetDiscountsByCategoryID :many
SELECT d.id, d.code, d.description, d.discount_type, d.discount_value, d.min_order_value_cents, d.max_uses, d.current_uses, d.valid_from, d.valid_until, d.is_active, d.created_at, d.updated_at FROM discounts d
JOIN category_discounts cd ON d.id = cd.discount_id
WHERE cd.category_id = $1
  AND d.is_active = TRUE
  AND d.valid_from <= NOW()
  AND d.valid_until >= NOW()
  AND (d.max_uses IS NULL OR d.current_uses < d.max_uses)
`

// Fetches active discounts applicable to a specific category.
func (q *Queries) GetDiscountsByCategoryID(ctx context.Context, categoryID uuid.UUID) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getDiscountsByCategoryID, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Discount
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValueCents,
			&i.MaxUses,
			&i.CurrentUses,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountsByProductID = `-- name: GetDiscountsByProductID :many
SELECT d.id, d.code, d.description, d.discount_type, d.discount_value, d.min_order_value_cents, d.max_uses, d.current_uses, d.valid_from, d.valid_until, d.is_active, d.created_at, d.updated_at FROM discounts d
JOIN product_discounts pd ON d.id = pd.discount_id
WHERE pd.product_id = $1
  AND d.is_active = TRUE
  AND d.valid_from <= NOW()
  AND d.valid_until >= NOW()
  AND (d.max_uses IS NULL OR d.current_uses < d.max_uses)
`

// Fetches active discounts applicable to a specific product.
func (q *Queries) GetDiscountsByProductID(ctx context.Context, productID uuid.UUID) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getDiscountsByProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Discount
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValueCents,
			&i.MaxUses,
			&i.CurrentUses,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementDiscountUsage = `-- name: IncrementDiscountUsage :exec

UPDATE discounts
SET current_uses = current_uses + 1, updated_at = NOW()
WHERE id = $1 AND (max_uses IS NULL OR current_uses < max_uses)
`

// Pagination using limit and offset
// Increments the current_uses count for a specific discount.
// This should ideally be called within a transaction when applying the discount.
func (q *Queries) IncrementDiscountUsage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementDiscountUsage, id)
	return err
}

const linkCategoryToDiscount = `-- name: LinkCategoryToDiscount :exec

INSERT INTO category_discounts (category_id, discount_id) VALUES ($1, $2)
`

type LinkCategoryToDiscountParams struct {
	CategoryID uuid.UUID `json:"category_id"`
	DiscountID uuid.UUID `json:"discount_id"`
}

// Check usage limit
// Associates a category with a discount.
func (q *Queries) LinkCategoryToDiscount(ctx context.Context, arg LinkCategoryToDiscountParams) error {
	_, err := q.db.Exec(ctx, linkCategoryToDiscount, arg.CategoryID, arg.DiscountID)
	return err
}

const linkProductToDiscount = `-- name: LinkProductToDiscount :exec


INSERT INTO product_discounts (product_id, discount_id) VALUES ($1, $2)
`

type LinkProductToDiscountParams struct {
	ProductID  uuid.UUID `json:"product_id"`
	DiscountID uuid.UUID `json:"discount_id"`
}

// Prevent exceeding max_uses
// --- Link/Unlink Queries ---
// Associates a product with a discount.
func (q *Queries) LinkProductToDiscount(ctx context.Context, arg LinkProductToDiscountParams) error {
	_, err := q.db.Exec(ctx, linkProductToDiscount, arg.ProductID, arg.DiscountID)
	return err
}

const listDiscounts = `-- name: ListDiscounts :many
SELECT id, code, description, discount_type, discount_value, min_order_value_cents, max_uses, current_uses, valid_from, valid_until, is_active, created_at, updated_at FROM discounts
WHERE ($1::boolean IS NULL OR is_active = $1) -- Filter by active status if provided
  AND ($2::timestamptz IS NULL OR valid_from <= $2) -- Filter by valid from date if provided
  AND ($3::timestamptz IS NULL OR valid_until >= $3) -- Filter by valid until date if provided
ORDER BY created_at DESC -- Or another default order
LIMIT $5 OFFSET $4
`

type ListDiscountsParams struct {
	IsActive   bool               `json:"is_active"`
	FromDate   pgtype.Timestamptz `json:"from_date"`
	UntilDate  pgtype.Timestamptz `json:"until_date"`
	PageOffset int32              `json:"page_offset"`
	PageLimit  int32              `json:"page_limit"`
}

// Fetches a list of discounts, potentially with filters and pagination.
func (q *Queries) ListDiscounts(ctx context.Context, arg ListDiscountsParams) ([]Discount, error) {
	rows, err := q.db.Query(ctx, listDiscounts,
		arg.IsActive,
		arg.FromDate,
		arg.UntilDate,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Discount
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValueCents,
			&i.MaxUses,
			&i.CurrentUses,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unlinkCategoryFromDiscount = `-- name: UnlinkCategoryFromDiscount :exec
DELETE FROM category_discounts WHERE category_id = $1 AND discount_id = $2
`

type UnlinkCategoryFromDiscountParams struct {
	CategoryID uuid.UUID `json:"category_id"`
	DiscountID uuid.UUID `json:"discount_id"`
}

// Removes association between a category and a discount.
func (q *Queries) UnlinkCategoryFromDiscount(ctx context.Context, arg UnlinkCategoryFromDiscountParams) error {
	_, err := q.db.Exec(ctx, unlinkCategoryFromDiscount, arg.CategoryID, arg.DiscountID)
	return err
}

const unlinkProductFromDiscount = `-- name: UnlinkProductFromDiscount :exec
DELETE FROM product_discounts WHERE product_id = $1 AND discount_id = $2
`

type UnlinkProductFromDiscountParams struct {
	ProductID  uuid.UUID `json:"product_id"`
	DiscountID uuid.UUID `json:"discount_id"`
}

// Removes association between a product and a discount.
func (q *Queries) UnlinkProductFromDiscount(ctx context.Context, arg UnlinkProductFromDiscountParams) error {
	_, err := q.db.Exec(ctx, unlinkProductFromDiscount, arg.ProductID, arg.DiscountID)
	return err
}

const updateDiscount = `-- name: UpdateDiscount :one
UPDATE discounts
SET code = $2,
    description = $3,
    discount_type = $4,
    discount_value = $5,
    min_order_value_cents = $6,
    max_uses = $7,
    valid_from = $8,
    valid_until = $9,
    is_active = $10,
    updated_at = NOW()
WHERE id = $1
RETURNING id, code, description, discount_type, discount_value, min_order_value_cents, max_uses, current_uses, valid_from, valid_until, is_active, created_at, updated_at
`

type UpdateDiscountParams struct {
	ID                 uuid.UUID          `json:"id"`
	Code               string             `json:"code"`
	Description        *string            `json:"description"`
	DiscountType       string             `json:"discount_type"`
	DiscountValue      int64              `json:"discount_value"`
	MinOrderValueCents *int64             `json:"min_order_value_cents"`
	MaxUses            *int32             `json:"max_uses"`
	ValidFrom          pgtype.Timestamptz `json:"valid_from"`
	ValidUntil         pgtype.Timestamptz `json:"valid_until"`
	IsActive           bool               `json:"is_active"`
}

// Updates an existing discount record.
func (q *Queries) UpdateDiscount(ctx context.Context, arg UpdateDiscountParams) (Discount, error) {
	row := q.db.QueryRow(ctx, updateDiscount,
		arg.ID,
		arg.Code,
		arg.Description,
		arg.DiscountType,
		arg.DiscountValue,
		arg.MinOrderValueCents,
		arg.MaxUses,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.IsActive,
	)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.MinOrderValueCents,
		&i.MaxUses,
		&i.CurrentUses,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
