// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: refresh_token.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createRefreshToken = `-- name: CreateRefreshToken :exec
INSERT INTO refresh_tokens (
    user_id, token_identifier, token_hash, expires_at
) VALUES (
    $1, $2, $3, $4
)
`

type CreateRefreshTokenParams struct {
	UserID          uuid.UUID          `json:"user_id"`
	TokenIdentifier string             `json:"token_identifier"`
	TokenHash       string             `json:"token_hash"`
	ExpiresAt       pgtype.Timestamptz `json:"expires_at"`
}

// Inserts a new refresh token identifier and its bcrypt hash into the database.
func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, createRefreshToken,
		arg.UserID,
		arg.TokenIdentifier,
		arg.TokenHash,
		arg.ExpiresAt,
	)
	return err
}

const deleteExpiredRefreshTokens = `-- name: DeleteExpiredRefreshTokens :exec
DELETE FROM refresh_tokens
WHERE expires_at <= NOW() AND revoked = FALSE
`

// Deletes refresh tokens that have expired and are not revoked.
// This can be run periodically as a cleanup job if needed.
// Note: Revoked tokens might be kept for audit purposes, so this only cleans up truly expired ones.
func (q *Queries) DeleteExpiredRefreshTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredRefreshTokens)
	return err
}

const getValidRefreshTokenRecord = `-- name: GetValidRefreshTokenRecord :one
SELECT id, user_id, token_identifier, token_hash, expires_at, revoked, created_at, updated_at
FROM refresh_tokens
WHERE token_identifier = $1 -- Lookup by the unique identifier string
  AND expires_at > NOW() -- Ensure it hasn't expired
  AND revoked = FALSE
`

// Finds a valid (non-expired, non-revoked) refresh token record by its identifier.
// The bcrypt hash verification happens in Go code.
func (q *Queries) GetValidRefreshTokenRecord(ctx context.Context, tokenIdentifier string) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, getValidRefreshTokenRecord, tokenIdentifier)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenIdentifier,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.Revoked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const revokeRefreshTokenByIdentifier = `-- name: RevokeRefreshTokenByIdentifier :exec

UPDATE refresh_tokens
SET revoked = TRUE, updated_at = NOW()
WHERE token_identifier = $1
`

// Ensure it hasn't been revoked
// Marks a specific refresh token as revoked using its identifier.
func (q *Queries) RevokeRefreshTokenByIdentifier(ctx context.Context, tokenIdentifier string) error {
	_, err := q.db.Exec(ctx, revokeRefreshTokenByIdentifier, tokenIdentifier)
	return err
}

const revokeRefreshTokensByUser = `-- name: RevokeRefreshTokensByUser :exec
UPDATE refresh_tokens
SET revoked = TRUE, updated_at = NOW()
WHERE user_id = $1 AND revoked = FALSE
`

// Revokes all active refresh tokens for a specific user.
// Useful for "logout all devices" or account compromise scenarios.
func (q *Queries) RevokeRefreshTokensByUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeRefreshTokensByUser, userID)
	return err
}
