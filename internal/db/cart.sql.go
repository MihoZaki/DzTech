// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cart.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addCartItemsBulk = `-- name: AddCartItemsBulk :execrows

INSERT INTO cart_items (cart_id, product_id, quantity, created_at, updated_at)
SELECT 
  $1, -- $1: The target cart ID
  input.product_id,
  input.quantity, -- Use the new requested quantity
  NOW(),
  NOW()
FROM (
  -- Prepare input data using UNNEST
  SELECT 
    UNNEST($2::uuid[]) as product_id, -- $2: Array of product IDs
    UNNEST($3::int[]) as quantity      -- $3: Array of corresponding quantities
) as input
INNER JOIN products p ON p.id = input.product_id
  AND p.stock_quantity >= input.quantity -- Ensure sufficient stock for the NEW quantity during INSERT
  AND p.status = 'active'
  AND p.deleted_at IS NULL
ON CONFLICT (cart_id, product_id)
DO UPDATE SET
  quantity = CASE
    -- If the existing row in cart_items was soft-deleted, check stock and set to NEW quantity
    WHEN cart_items.deleted_at IS NOT NULL THEN
      CASE
        -- Re-check stock against the NEW quantity being added via EXCLUDED (the values that would have been inserted)
        WHEN (SELECT stock_quantity FROM products WHERE id = EXCLUDED.product_id) >= EXCLUDED.quantity THEN
          EXCLUDED.quantity -- Set to the NEW quantity from the INSERT attempt (overwrites old soft-deleted quantity)
        ELSE
          -- If stock check fails for the new quantity, keep the old soft-deleted quantity.
          -- Alternatively, could raise an exception depending on desired behavior.
          cart_items.quantity
      END
    -- If the existing row was NOT soft-deleted, add the new quantity and check total against stock
    ELSE
      LEAST(
        cart_items.quantity + EXCLUDED.quantity, -- Add the new quantity
        (SELECT stock_quantity FROM products WHERE id = EXCLUDED.product_id) -- Cap at product's stock
      )
  END,
  -- Undelete the item if it was soft-deleted, otherwise leave its status unchanged
  deleted_at = CASE
    WHEN cart_items.deleted_at IS NOT NULL THEN NULL -- Undelete
    ELSE cart_items.deleted_at -- Keep as is
  END,
  updated_at = NOW()
`

type AddCartItemsBulkParams struct {
	CartID     uuid.UUID   `json:"cart_id"`
	ProductIds []uuid.UUID `json:"product_ids"`
	Quantities []int32     `json:"quantities"`
}

// Include deleted_at to see if undeletion happened
// Adds multiple items to a cart, handling upserts and soft deletes.
// Checks stock availability for each item during the insert/update process.
// Join with products table to validate existence, status, deletion, and stock for the INSERT
func (q *Queries) AddCartItemsBulk(ctx context.Context, arg AddCartItemsBulkParams) (int64, error) {
	result, err := q.db.Exec(ctx, addCartItemsBulk, arg.CartID, arg.ProductIds, arg.Quantities)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const clearCart = `-- name: ClearCart :exec
UPDATE cart_items
SET deleted_at = NOW()
WHERE cart_id = $1
`

func (q *Queries) ClearCart(ctx context.Context, cartID uuid.UUID) error {
	_, err := q.db.Exec(ctx, clearCart, cartID)
	return err
}

const createCartItem = `-- name: CreateCartItem :one
INSERT INTO cart_items (cart_id, product_id, quantity, created_at, updated_at)
SELECT
    $1, -- $1
    $2, -- $2
    $3, -- $3
    NOW(),
    NOW()
FROM products
WHERE id = $2 -- Check product exists
    AND stock_quantity >= $3 -- Ensure enough stock for the INSERT
    AND status = 'active'
    AND deleted_at IS NULL
ON CONFLICT (cart_id, product_id)
DO UPDATE SET
    quantity = CASE
        WHEN cart_items.deleted_at IS NOT NULL THEN
            -- If the existing row was soft-deleted, check stock for the NEW requested quantity
            CASE
                WHEN (SELECT stock_quantity FROM products WHERE id = $2) >= $3 THEN
                    $3 -- Set to the NEW requested quantity if stock allows
                ELSE
                    -- Keep old quantity if stock check fails here
                    cart_items.quantity
            END
        ELSE
            -- If the existing row was NOT soft-deleted, add the new quantity and check total against stock
            LEAST(
                cart_items.quantity + $3, -- Add new quantity
                (SELECT stock_quantity FROM products WHERE id = $2) -- Cap at stock
            )
    END,
    deleted_at = CASE
        WHEN cart_items.deleted_at IS NOT NULL THEN NULL -- Undelete if it was soft-deleted
        ELSE cart_items.deleted_at -- Keep deleted_at if it wasn't soft-deleted
    END,
    updated_at = NOW()
RETURNING
    id,
    cart_id,
    product_id,
    quantity,
    created_at,
    updated_at,
    deleted_at
`

type CreateCartItemParams struct {
	CartID    uuid.UUID `json:"cart_id"`
	ProductID uuid.UUID `json:"product_id"`
	Quantity  int32     `json:"quantity"`
}

// Cart Item Management
func (q *Queries) CreateCartItem(ctx context.Context, arg CreateCartItemParams) (CartItem, error) {
	row := q.db.QueryRow(ctx, createCartItem, arg.CartID, arg.ProductID, arg.Quantity)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.ProductID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createGuestCart = `-- name: CreateGuestCart :one
INSERT INTO carts (session_id, created_at, updated_at, deleted_at) -- Only session_id in the INSERT
VALUES ($1, NOW(), NOW(), NULL) -- Uses sqlc.arg(session_id)
RETURNING id, user_id, session_id, created_at, updated_at, deleted_at
`

func (q *Queries) CreateGuestCart(ctx context.Context, sessionID *string) (Cart, error) {
	row := q.db.QueryRow(ctx, createGuestCart, sessionID)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createUserCart = `-- name: CreateUserCart :one
INSERT INTO carts (user_id, created_at, updated_at, deleted_at) -- Only user_id in the INSERT
VALUES ($1, NOW(), NOW(), NULL) -- Uses sqlc.arg(user_id)
RETURNING id, user_id, session_id, created_at, updated_at, deleted_at
`

// Cart Management
func (q *Queries) CreateUserCart(ctx context.Context, userID uuid.UUID) (Cart, error) {
	row := q.db.QueryRow(ctx, createUserCart, userID)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteCart = `-- name: DeleteCart :exec
UPDATE carts
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteCart(ctx context.Context, cartID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCart, cartID)
	return err
}

const deleteCartItem = `-- name: DeleteCartItem :exec
UPDATE cart_items
SET deleted_at = NOW()
WHERE id = $1
`

// Cart Cleanup
func (q *Queries) DeleteCartItem(ctx context.Context, itemID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCartItem, itemID)
	return err
}

const getCartByID = `-- name: GetCartByID :one
SELECT
    id,
    user_id,
    session_id,
    created_at,
    updated_at
FROM carts
WHERE id = $1 AND deleted_at IS NULL
`

type GetCartByIDRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	SessionID *string            `json:"session_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCartByID(ctx context.Context, cartID uuid.UUID) (GetCartByIDRow, error) {
	row := q.db.QueryRow(ctx, getCartByID, cartID)
	var i GetCartByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartBySessionID = `-- name: GetCartBySessionID :one
SELECT
    id,
    user_id,
    session_id,
    created_at,
    updated_at
FROM carts
WHERE session_id = $1 AND deleted_at IS NULL
`

type GetCartBySessionIDRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	SessionID *string            `json:"session_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCartBySessionID(ctx context.Context, sessionID *string) (GetCartBySessionIDRow, error) {
	row := q.db.QueryRow(ctx, getCartBySessionID, sessionID)
	var i GetCartBySessionIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartByUserID = `-- name: GetCartByUserID :one
SELECT
    id,
    user_id,
    session_id,
    created_at,
    updated_at
FROM carts
WHERE user_id = $1 AND deleted_at IS NULL
`

type GetCartByUserIDRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	SessionID *string            `json:"session_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCartByUserID(ctx context.Context, userID uuid.UUID) (GetCartByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getCartByUserID, userID)
	var i GetCartByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartItemByCartAndProduct = `-- name: GetCartItemByCartAndProduct :one
SELECT
    id,
    cart_id,
    product_id,
    quantity,
    created_at,
    updated_at
FROM cart_items
WHERE cart_id = $1 AND product_id = $2
`

type GetCartItemByCartAndProductParams struct {
	CartID    uuid.UUID `json:"cart_id"`
	ProductID uuid.UUID `json:"product_id"`
}

type GetCartItemByCartAndProductRow struct {
	ID        uuid.UUID          `json:"id"`
	CartID    uuid.UUID          `json:"cart_id"`
	ProductID uuid.UUID          `json:"product_id"`
	Quantity  int32              `json:"quantity"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCartItemByCartAndProduct(ctx context.Context, arg GetCartItemByCartAndProductParams) (GetCartItemByCartAndProductRow, error) {
	row := q.db.QueryRow(ctx, getCartItemByCartAndProduct, arg.CartID, arg.ProductID)
	var i GetCartItemByCartAndProductRow
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.ProductID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartItemByID = `-- name: GetCartItemByID :one
SELECT
    id,
    cart_id,
    product_id,
    quantity,
    created_at,
    updated_at
FROM cart_items
WHERE id = $1
`

type GetCartItemByIDRow struct {
	ID        uuid.UUID          `json:"id"`
	CartID    uuid.UUID          `json:"cart_id"`
	ProductID uuid.UUID          `json:"product_id"`
	Quantity  int32              `json:"quantity"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCartItemByID(ctx context.Context, itemID uuid.UUID) (GetCartItemByIDRow, error) {
	row := q.db.QueryRow(ctx, getCartItemByID, itemID)
	var i GetCartItemByIDRow
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.ProductID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartItemsWithProductDetails = `-- name: GetCartItemsWithProductDetails :many
SELECT
    ci.id,
    ci.cart_id,
    ci.product_id,
    ci.quantity,
    ci.created_at,
    ci.updated_at,
    p.name as product_name,
    p.price_cents as product_price_cents,
    p.stock_quantity as product_stock_quantity,
    p.image_urls as product_image_urls,
    p.brand as product_brand
FROM cart_items ci
JOIN products p ON ci.product_id = p.id
WHERE ci.cart_id = $1
    AND p.deleted_at IS NULL
    AND p.status = 'active'
ORDER BY ci.created_at DESC
`

type GetCartItemsWithProductDetailsRow struct {
	ID                   uuid.UUID          `json:"id"`
	CartID               uuid.UUID          `json:"cart_id"`
	ProductID            uuid.UUID          `json:"product_id"`
	Quantity             int32              `json:"quantity"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	ProductName          string             `json:"product_name"`
	ProductPriceCents    int64              `json:"product_price_cents"`
	ProductStockQuantity int32              `json:"product_stock_quantity"`
	ProductImageUrls     []byte             `json:"product_image_urls"`
	ProductBrand         string             `json:"product_brand"`
}

// Enhanced Cart Data Retrieval
func (q *Queries) GetCartItemsWithProductDetails(ctx context.Context, cartID uuid.UUID) ([]GetCartItemsWithProductDetailsRow, error) {
	rows, err := q.db.Query(ctx, getCartItemsWithProductDetails, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCartItemsWithProductDetailsRow
	for rows.Next() {
		var i GetCartItemsWithProductDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.CartID,
			&i.ProductID,
			&i.Quantity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductPriceCents,
			&i.ProductStockQuantity,
			&i.ProductImageUrls,
			&i.ProductBrand,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCartStats = `-- name: GetCartStats :one
SELECT
    COUNT(ci.id) as total_items,
    SUM(ci.quantity) FILTER (WHERE p.id IS NOT NULL) as total_quantity,
    SUM(ci.quantity * p.price_cents) FILTER (WHERE p.id IS NOT NULL) as total_value
FROM carts c
LEFT JOIN cart_items ci ON c.id = ci.cart_id
LEFT JOIN products p ON ci.product_id = p.id
WHERE c.id = $1
    AND p.deleted_at IS NULL
    AND p.status = 'active'
`

type GetCartStatsRow struct {
	TotalItems    int64 `json:"total_items"`
	TotalQuantity int64 `json:"total_quantity"`
	TotalValue    int64 `json:"total_value"`
}

func (q *Queries) GetCartStats(ctx context.Context, cartID uuid.UUID) (GetCartStatsRow, error) {
	row := q.db.QueryRow(ctx, getCartStats, cartID)
	var i GetCartStatsRow
	err := row.Scan(&i.TotalItems, &i.TotalQuantity, &i.TotalValue)
	return i, err
}

const getCartWithItemsAndProducts = `-- name: GetCartWithItemsAndProducts :many
SELECT
    c.id as cart_id,
    c.user_id as cart_user_id,
    c.session_id as cart_session_id,
    c.created_at as cart_created_at,
    c.updated_at as cart_updated_at,
    ci.id as cart_item_id,
    ci.cart_id as cart_item_cart_id,
    ci.product_id as cart_item_product_id,
    ci.quantity as cart_item_quantity,
    ci.created_at as cart_item_created_at,
    ci.updated_at as cart_item_updated_at,
    p.name as product_name,
    p.price_cents as product_price_cents,
    p.stock_quantity as product_stock_quantity,
    p.image_urls as product_image_urls,
    p.brand as product_brand
FROM carts c
LEFT JOIN cart_items ci ON c.id = ci.cart_id
LEFT JOIN products p ON ci.product_id = p.id
WHERE c.id = $1
    AND ci.deleted_at is Null
    AND (p.deleted_at IS NULL OR p.id IS NULL)
ORDER BY ci.created_at DESC
`

type GetCartWithItemsAndProductsRow struct {
	CartID               uuid.UUID          `json:"cart_id"`
	CartUserID           uuid.UUID          `json:"cart_user_id"`
	CartSessionID        *string            `json:"cart_session_id"`
	CartCreatedAt        pgtype.Timestamptz `json:"cart_created_at"`
	CartUpdatedAt        pgtype.Timestamptz `json:"cart_updated_at"`
	CartItemID           uuid.UUID          `json:"cart_item_id"`
	CartItemCartID       uuid.UUID          `json:"cart_item_cart_id"`
	CartItemProductID    uuid.UUID          `json:"cart_item_product_id"`
	CartItemQuantity     *int32             `json:"cart_item_quantity"`
	CartItemCreatedAt    pgtype.Timestamptz `json:"cart_item_created_at"`
	CartItemUpdatedAt    pgtype.Timestamptz `json:"cart_item_updated_at"`
	ProductName          *string            `json:"product_name"`
	ProductPriceCents    *int64             `json:"product_price_cents"`
	ProductStockQuantity *int32             `json:"product_stock_quantity"`
	ProductImageUrls     []byte             `json:"product_image_urls"`
	ProductBrand         *string            `json:"product_brand"`
}

func (q *Queries) GetCartWithItemsAndProducts(ctx context.Context, cartID uuid.UUID) ([]GetCartWithItemsAndProductsRow, error) {
	rows, err := q.db.Query(ctx, getCartWithItemsAndProducts, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCartWithItemsAndProductsRow
	for rows.Next() {
		var i GetCartWithItemsAndProductsRow
		if err := rows.Scan(
			&i.CartID,
			&i.CartUserID,
			&i.CartSessionID,
			&i.CartCreatedAt,
			&i.CartUpdatedAt,
			&i.CartItemID,
			&i.CartItemCartID,
			&i.CartItemProductID,
			&i.CartItemQuantity,
			&i.CartItemCreatedAt,
			&i.CartItemUpdatedAt,
			&i.ProductName,
			&i.ProductPriceCents,
			&i.ProductStockQuantity,
			&i.ProductImageUrls,
			&i.ProductBrand,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCartItemQuantity = `-- name: UpdateCartItemQuantity :one
UPDATE cart_items ci
SET quantity = $1, updated_at = NOW()
FROM products p
WHERE ci.id = $2
    AND ci.product_id = p.id
    AND $1 > 0
    AND $1 <= p.stock_quantity  -- Stock validation
RETURNING
    ci.id,
    ci.cart_id,
    ci.product_id,
    ci.quantity,
    ci.created_at,
    ci.updated_at,
    p.name as product_name,
    p.price_cents as product_price_cents,
    p.stock_quantity as product_stock_quantity,
    p.image_urls as product_image_urls,
    p.brand as product_brand
`

type UpdateCartItemQuantityParams struct {
	NewQuantity int32     `json:"new_quantity"`
	ItemID      uuid.UUID `json:"item_id"`
}

type UpdateCartItemQuantityRow struct {
	ID                   uuid.UUID          `json:"id"`
	CartID               uuid.UUID          `json:"cart_id"`
	ProductID            uuid.UUID          `json:"product_id"`
	Quantity             int32              `json:"quantity"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	ProductName          string             `json:"product_name"`
	ProductPriceCents    int64              `json:"product_price_cents"`
	ProductStockQuantity int32              `json:"product_stock_quantity"`
	ProductImageUrls     []byte             `json:"product_image_urls"`
	ProductBrand         string             `json:"product_brand"`
}

func (q *Queries) UpdateCartItemQuantity(ctx context.Context, arg UpdateCartItemQuantityParams) (UpdateCartItemQuantityRow, error) {
	row := q.db.QueryRow(ctx, updateCartItemQuantity, arg.NewQuantity, arg.ItemID)
	var i UpdateCartItemQuantityRow
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.ProductID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductName,
		&i.ProductPriceCents,
		&i.ProductStockQuantity,
		&i.ProductImageUrls,
		&i.ProductBrand,
	)
	return i, err
}
