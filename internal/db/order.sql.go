// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: order.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelOrder = `-- name: CancelOrder :one

UPDATE orders
SET 
    status = 'cancelled',
    cancelled_at = NOW(),
    completed_at = COALESCE(completed_at, NOW()), -- Set completed_at if it wasn't already
    updated_at = NOW()
WHERE id = $1
RETURNING 
    id, user_id, user_full_name, status, total_amount_cents, payment_method,
    province, city, phone_number_1, phone_number_2,
    notes, delivery_service_id, 
    created_at, updated_at, completed_at, cancelled_at
`

// Order items consistently
// Updates the status of an order to 'cancelled' and sets the cancelled_at and completed_at timestamps.
// This is a soft cancellation.
func (q *Queries) CancelOrder(ctx context.Context, orderID uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, cancelOrder, orderID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserFullName,
		&i.Status,
		&i.TotalAmountCents,
		&i.PaymentMethod,
		&i.Province,
		&i.City,
		&i.PhoneNumber1,
		&i.PhoneNumber2,
		&i.Notes,
		&i.DeliveryServiceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    user_id, user_full_name, status, total_amount_cents, payment_method,
    province, city, phone_number_1, phone_number_2,
    notes, delivery_service_id
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9,
    $10, $11
)
RETURNING id, user_id, user_full_name, status, total_amount_cents, payment_method,
         province, city, phone_number_1, phone_number_2,
         notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
`

type CreateOrderParams struct {
	UserID            uuid.UUID `json:"user_id"`
	UserFullName      string    `json:"user_full_name"`
	Status            string    `json:"status"`
	TotalAmountCents  int64     `json:"total_amount_cents"`
	PaymentMethod     string    `json:"payment_method"`
	Province          string    `json:"province"`
	City              string    `json:"city"`
	PhoneNumber1      string    `json:"phone_number_1"`
	PhoneNumber2      *string   `json:"phone_number_2"`
	Notes             *string   `json:"notes"`
	DeliveryServiceID uuid.UUID `json:"delivery_service_id"`
}

// Creates a new order with denormalized address fields and returns its details.
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.UserID,
		arg.UserFullName,
		arg.Status,
		arg.TotalAmountCents,
		arg.PaymentMethod,
		arg.Province,
		arg.City,
		arg.PhoneNumber1,
		arg.PhoneNumber2,
		arg.Notes,
		arg.DeliveryServiceID,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserFullName,
		&i.Status,
		&i.TotalAmountCents,
		&i.PaymentMethod,
		&i.Province,
		&i.City,
		&i.PhoneNumber1,
		&i.PhoneNumber2,
		&i.Notes,
		&i.DeliveryServiceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}

const decrementStockIfSufficient = `-- name: DecrementStockIfSufficient :one
UPDATE products
SET stock_quantity = stock_quantity - $1
WHERE id = $2 AND stock_quantity >= $1 -- The crucial condition
RETURNING id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at, deleted_at
`

type DecrementStockIfSufficientParams struct {
	DecrementAmount int32     `json:"decrement_amount"`
	ProductID       uuid.UUID `json:"product_id"`
}

type DecrementStockIfSufficientRow struct {
	ID               uuid.UUID          `json:"id"`
	CategoryID       uuid.UUID          `json:"category_id"`
	Name             string             `json:"name"`
	Slug             string             `json:"slug"`
	Description      *string            `json:"description"`
	ShortDescription *string            `json:"short_description"`
	PriceCents       int64              `json:"price_cents"`
	StockQuantity    int32              `json:"stock_quantity"`
	Status           string             `json:"status"`
	Brand            string             `json:"brand"`
	ImageUrls        []byte             `json:"image_urls"`
	SpecHighlights   []byte             `json:"spec_highlights"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
}

// Attempts to decrement the stock_quantity for a product by a given amount.
// Succeeds only if the resulting stock_quantity would be >= 0.
// Returns the updated product row if successful, or an error if insufficient stock.
// Note: The RETURNING clause might not be strictly necessary if we only care about RowsAffected.
// If RETURNING is omitted, the querier function will likely return sql.Result.
// Let's include RETURNING to get the updated stock if needed for debugging/logging.
func (q *Queries) DecrementStockIfSufficient(ctx context.Context, arg DecrementStockIfSufficientParams) (DecrementStockIfSufficientRow, error) {
	row := q.db.QueryRow(ctx, decrementStockIfSufficient, arg.DecrementAmount, arg.ProductID)
	var i DecrementStockIfSufficientRow
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrder = `-- name: GetOrder :one

SELECT 
    id, user_id, user_full_name, status, total_amount_cents, payment_method,
    province, city, phone_number_1, phone_number_2,
    notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
FROM orders
WHERE id = $1
`

// Array of quantities
// Retrieves an order by its ID with denormalized address fields.
func (q *Queries) GetOrder(ctx context.Context, orderID uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, orderID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserFullName,
		&i.Status,
		&i.TotalAmountCents,
		&i.PaymentMethod,
		&i.Province,
		&i.City,
		&i.PhoneNumber1,
		&i.PhoneNumber2,
		&i.Notes,
		&i.DeliveryServiceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}

const getOrderItemsByOrderID = `-- name: GetOrderItemsByOrderID :many
SELECT 
    id, order_id, product_id, product_name, price_cents, quantity, subtotal_cents, created_at, updated_at
FROM order_items
WHERE order_id = $1
ORDER BY created_at ASC
`

// Retrieves all items for a specific order ID.
func (q *Queries) GetOrderItemsByOrderID(ctx context.Context, orderID uuid.UUID) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, getOrderItemsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderItem
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.ProductName,
			&i.PriceCents,
			&i.Quantity,
			&i.SubtotalCents,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderWithItems = `-- name: GetOrderWithItems :many
SELECT 
    o.id, o.user_id, o.user_full_name, o.status, o.total_amount_cents, o.payment_method,
    o.province, o.city, o.phone_number_1, o.phone_number_2,
    o.notes, o.delivery_service_id, o.created_at, o.updated_at, o.completed_at, o.cancelled_at,
    oi.id AS item_id, oi.order_id AS item_order_id, oi.product_id AS item_product_id,
    oi.product_name AS item_product_name, oi.price_cents AS item_price_cents,
    oi.quantity AS item_quantity, oi.subtotal_cents AS item_subtotal_cents,
    oi.created_at AS item_created_at, oi.updated_at AS item_updated_at
FROM orders o
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE o.id = $1
ORDER BY oi.created_at ASC
`

type GetOrderWithItemsRow struct {
	ID                uuid.UUID          `json:"id"`
	UserID            uuid.UUID          `json:"user_id"`
	UserFullName      string             `json:"user_full_name"`
	Status            string             `json:"status"`
	TotalAmountCents  int64              `json:"total_amount_cents"`
	PaymentMethod     string             `json:"payment_method"`
	Province          string             `json:"province"`
	City              string             `json:"city"`
	PhoneNumber1      string             `json:"phone_number_1"`
	PhoneNumber2      *string            `json:"phone_number_2"`
	Notes             *string            `json:"notes"`
	DeliveryServiceID uuid.UUID          `json:"delivery_service_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	CompletedAt       pgtype.Timestamptz `json:"completed_at"`
	CancelledAt       pgtype.Timestamptz `json:"cancelled_at"`
	ItemID            uuid.UUID          `json:"item_id"`
	ItemOrderID       uuid.UUID          `json:"item_order_id"`
	ItemProductID     uuid.UUID          `json:"item_product_id"`
	ItemProductName   *string            `json:"item_product_name"`
	ItemPriceCents    *int64             `json:"item_price_cents"`
	ItemQuantity      *int32             `json:"item_quantity"`
	ItemSubtotalCents *int64             `json:"item_subtotal_cents"`
	ItemCreatedAt     pgtype.Timestamptz `json:"item_created_at"`
	ItemUpdatedAt     pgtype.Timestamptz `json:"item_updated_at"`
}

// Retrieves an order by its ID along with all its items, including denormalized address fields.
// This query uses a join and might return multiple rows if there are items.
// The service layer needs to aggregate these rows into a single Order object with a slice of OrderItems.
func (q *Queries) GetOrderWithItems(ctx context.Context, orderID uuid.UUID) ([]GetOrderWithItemsRow, error) {
	rows, err := q.db.Query(ctx, getOrderWithItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderWithItemsRow
	for rows.Next() {
		var i GetOrderWithItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserFullName,
			&i.Status,
			&i.TotalAmountCents,
			&i.PaymentMethod,
			&i.Province,
			&i.City,
			&i.PhoneNumber1,
			&i.PhoneNumber2,
			&i.Notes,
			&i.DeliveryServiceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.ItemID,
			&i.ItemOrderID,
			&i.ItemProductID,
			&i.ItemProductName,
			&i.ItemPriceCents,
			&i.ItemQuantity,
			&i.ItemSubtotalCents,
			&i.ItemCreatedAt,
			&i.ItemUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementStock = `-- name: IncrementStock :one
UPDATE products
SET stock_quantity = stock_quantity + $1
WHERE id = $2
RETURNING id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at, deleted_at
`

type IncrementStockParams struct {
	IncrementAmount int32     `json:"increment_amount"`
	ProductID       uuid.UUID `json:"product_id"`
}

type IncrementStockRow struct {
	ID               uuid.UUID          `json:"id"`
	CategoryID       uuid.UUID          `json:"category_id"`
	Name             string             `json:"name"`
	Slug             string             `json:"slug"`
	Description      *string            `json:"description"`
	ShortDescription *string            `json:"short_description"`
	PriceCents       int64              `json:"price_cents"`
	StockQuantity    int32              `json:"stock_quantity"`
	Status           string             `json:"status"`
	Brand            string             `json:"brand"`
	ImageUrls        []byte             `json:"image_urls"`
	SpecHighlights   []byte             `json:"spec_highlights"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
}

// Increments the stock_quantity for a product by a given amount.
// Suitable for releasing stock back when cancelling an order.
func (q *Queries) IncrementStock(ctx context.Context, arg IncrementStockParams) (IncrementStockRow, error) {
	row := q.db.QueryRow(ctx, incrementStock, arg.IncrementAmount, arg.ProductID)
	var i IncrementStockRow
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const insertOrderItemsBulk = `-- name: InsertOrderItemsBulk :exec
INSERT INTO order_items (order_id, product_id, product_name, price_cents, quantity)
SELECT
    $1 AS order_id, -- The single order ID for all items
    unnest($2::UUID[]) AS product_id, -- Array of product IDs
    unnest($3::TEXT[]) AS product_name, -- Array of product names (denormalized)
    unnest($4::BIGINT[]) AS price_cents, -- Array of final prices (including discounts)
    unnest($5::INTEGER[]) AS quantity
`

type InsertOrderItemsBulkParams struct {
	OrderID      uuid.UUID   `json:"order_id"`
	ProductIds   []uuid.UUID `json:"product_ids"`
	ProductNames []string    `json:"product_names"`
	PricesCents  []int64     `json:"prices_cents"`
	Quantities   []int32     `json:"quantities"`
}

// Inserts multiple order items efficiently in a single query.
// Requires arrays of equal length for product_ids, quantities, names, and prices_cents.
func (q *Queries) InsertOrderItemsBulk(ctx context.Context, arg InsertOrderItemsBulkParams) error {
	_, err := q.db.Exec(ctx, insertOrderItemsBulk,
		arg.OrderID,
		arg.ProductIds,
		arg.ProductNames,
		arg.PricesCents,
		arg.Quantities,
	)
	return err
}

const insertOrderItemsFromCart = `-- name: InsertOrderItemsFromCart :exec
INSERT INTO order_items (order_id, product_id, product_name, price_cents, quantity, created_at)
SELECT
    $1 AS order_id, -- The single order ID for all items
    ci.product_id,
    p.name AS product_name, -- Get the name from the products table
    COALESCE(vpcd.calculated_discounted_price_cents, p.price_cents) AS price_cents, -- Use the final price from the cart or fallback to original
    ci.quantity,
    NOW() -- Set the created_at timestamp for the order item
FROM
    cart_items ci
JOIN
    products p ON ci.product_id = p.id -- Join to get product name
LEFT JOIN
    v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id -- Join with the discount view to get final price
WHERE
    ci.cart_id = $2 -- Fetch items from the specific cart
    AND ci.deleted_at IS NULL
`

type InsertOrderItemsFromCartParams struct {
	OrderID uuid.UUID `json:"order_id"`
	CartID  uuid.UUID `json:"cart_id"`
}

// Inserts order items into the order_items table by copying them from the user's current cart.
// This ensures the item details (product, name, price, quantity) reflect the exact state of the cart at order creation time.
// It fetches the final price (including discounts) from the cart_items joined with the calculated discount view.
func (q *Queries) InsertOrderItemsFromCart(ctx context.Context, arg InsertOrderItemsFromCartParams) error {
	_, err := q.db.Exec(ctx, insertOrderItemsFromCart, arg.OrderID, arg.CartID)
	return err
}

const listAllOrders = `-- name: ListAllOrders :many

SELECT 
    id, user_id, user_full_name, status, total_amount_cents, payment_method,
    province, city, phone_number_1, phone_number_2,
    notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
FROM orders
WHERE ($1::UUID = '00000000-0000-0000-0000-000000000000'::UUID OR user_id = $1) -- Filter by user_id if provided
  AND ($2::TEXT = '' OR status = $2) -- Filter by status if provided
ORDER BY created_at DESC
LIMIT $4 OFFSET $3
`

type ListAllOrdersParams struct {
	FilterUserID uuid.UUID `json:"filter_user_id"`
	FilterStatus string    `json:"filter_status"`
	PageOffset   int32     `json:"page_offset"`
	PageLimit    int32     `json:"page_limit"`
}

// Page limit and offset
// Retrieves a paginated list of all orders with denormalized address fields, optionally filtered by status or user_id.
// Intended for admin use. Includes cancelled orders.
// If filter_user_id is the zero UUID ('00000000-0000-0000-0000-000000000000'), it retrieves orders for all users.
// If filter_status is an empty string (‚Äù), it retrieves orders of all statuses.
func (q *Queries) ListAllOrders(ctx context.Context, arg ListAllOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listAllOrders,
		arg.FilterUserID,
		arg.FilterStatus,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserFullName,
			&i.Status,
			&i.TotalAmountCents,
			&i.PaymentMethod,
			&i.Province,
			&i.City,
			&i.PhoneNumber1,
			&i.PhoneNumber2,
			&i.Notes,
			&i.DeliveryServiceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOrders = `-- name: ListUserOrders :many

SELECT 
    id, user_id, user_full_name, status, total_amount_cents, payment_method,
    province, city, phone_number_1, phone_number_2,
    notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
FROM orders
WHERE user_id = $1
  AND ($2::TEXT = '' OR status = $2) -- Filter by status if provided
  -- Explicitly exclude cancelled orders for user list
  AND cancelled_at IS NULL 
ORDER BY created_at DESC
LIMIT $4 OFFSET $3
`

type ListUserOrdersParams struct {
	UserID       uuid.UUID `json:"user_id"`
	FilterStatus string    `json:"filter_status"`
	PageOffset   int32     `json:"page_offset"`
	PageLimit    int32     `json:"page_limit"`
}

// Order items consistently
// Retrieves a paginated list of orders for a specific user with denormalized address fields, optionally filtered by status.
// Excludes cancelled orders by default. Admins should use ListAllOrders.
func (q *Queries) ListUserOrders(ctx context.Context, arg ListUserOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listUserOrders,
		arg.UserID,
		arg.FilterStatus,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserFullName,
			&i.Status,
			&i.TotalAmountCents,
			&i.PaymentMethod,
			&i.Province,
			&i.City,
			&i.PhoneNumber1,
			&i.PhoneNumber2,
			&i.Notes,
			&i.DeliveryServiceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :one

UPDATE orders
SET
    notes = COALESCE($1, notes), -- Use narg for potentially nil values
    updated_at = NOW()
WHERE id = $2
RETURNING id, user_id, user_full_name, status, total_amount_cents, payment_method,
         province, city, phone_number_1, phone_number_2,
         notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
`

type UpdateOrderParams struct {
	Notes   *string   `json:"notes"`
	OrderID uuid.UUID `json:"order_id"`
}

// Page limit and offset
// Updates other details of an order (notes, timestamps).
// Address fields are denormalized and set during creation.
func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrder, arg.Notes, arg.OrderID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserFullName,
		&i.Status,
		&i.TotalAmountCents,
		&i.PaymentMethod,
		&i.Province,
		&i.City,
		&i.PhoneNumber1,
		&i.PhoneNumber2,
		&i.Notes,
		&i.DeliveryServiceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders
SET status = $1::TEXT ,
    updated_at = NOW(),
    completed_at = CASE
        WHEN $1 IN ('delivered', 'cancelled') AND completed_at IS NULL THEN NOW()
        ELSE completed_at -- Don't overwrite if already set
    END,
    cancelled_at = CASE
        WHEN $1 = 'cancelled' AND cancelled_at IS NULL THEN NOW()
        ELSE cancelled_at -- Don't overwrite if already set
    END
WHERE id = $2
RETURNING id, user_id, user_full_name, status, total_amount_cents, payment_method,
         province, city, phone_number_1, phone_number_2,
         notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
`

type UpdateOrderStatusParams struct {
	Status  string    `json:"status"`
	OrderID uuid.UUID `json:"order_id"`
}

// Updates the status of an order and manages completion/cancellation timestamps.
func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderStatus, arg.Status, arg.OrderID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserFullName,
		&i.Status,
		&i.TotalAmountCents,
		&i.PaymentMethod,
		&i.Province,
		&i.City,
		&i.PhoneNumber1,
		&i.PhoneNumber2,
		&i.Notes,
		&i.DeliveryServiceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}
