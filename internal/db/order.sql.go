// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: order.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelOrder = `-- name: CancelOrder :one
UPDATE orders
SET 
    status = 'cancelled',
    cancelled_at = NOW(),
    completed_at = COALESCE(completed_at, NOW()), -- Set completed_at if it wasn't already
    updated_at = NOW()
WHERE id = $1
RETURNING 
    id, user_id, status, total_amount_cents, payment_method, shipping_address, billing_address, notes, delivery_service_id, 
    created_at, updated_at, completed_at, cancelled_at
`

// Updates the status of an order to 'cancelled' and sets the cancelled_at timestamp.
// This is a soft deletion conceptually.
func (q *Queries) CancelOrder(ctx context.Context, orderID uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, cancelOrder, orderID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalAmountCents,
		&i.PaymentMethod,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.Notes,
		&i.DeliveryServiceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    user_id, status, total_amount_cents, payment_method, shipping_address, billing_address, notes, delivery_service_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, user_id, status, total_amount_cents, payment_method, shipping_address, billing_address, notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
`

type CreateOrderParams struct {
	UserID            uuid.UUID `json:"user_id"`
	Status            string    `json:"status"`
	TotalAmountCents  int64     `json:"total_amount_cents"`
	PaymentMethod     string    `json:"payment_method"`
	ShippingAddress   []byte    `json:"shipping_address"`
	BillingAddress    []byte    `json:"billing_address"`
	Notes             *string   `json:"notes"`
	DeliveryServiceID uuid.UUID `json:"delivery_service_id"`
}

// Creates a new order and returns its details.
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.UserID,
		arg.Status,
		arg.TotalAmountCents,
		arg.PaymentMethod,
		arg.ShippingAddress,
		arg.BillingAddress,
		arg.Notes,
		arg.DeliveryServiceID,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalAmountCents,
		&i.PaymentMethod,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.Notes,
		&i.DeliveryServiceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (
    order_id, product_id, product_name, price_cents, quantity
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, order_id, product_id, product_name, price_cents, quantity, subtotal_cents, created_at, updated_at
`

type CreateOrderItemParams struct {
	OrderID     uuid.UUID `json:"order_id"`
	ProductID   uuid.UUID `json:"product_id"`
	ProductName string    `json:"product_name"`
	PriceCents  int64     `json:"price_cents"`
	Quantity    int32     `json:"quantity"`
}

// Creates a new order item and returns its details.
func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.ProductName,
		arg.PriceCents,
		arg.Quantity,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.ProductName,
		&i.PriceCents,
		&i.Quantity,
		&i.SubtotalCents,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementStockIfSufficient = `-- name: DecrementStockIfSufficient :one
UPDATE products
SET stock_quantity = stock_quantity - $1
WHERE id = $2 AND stock_quantity >= $1 -- The crucial condition
RETURNING id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at, deleted_at
`

type DecrementStockIfSufficientParams struct {
	DecrementAmount int32     `json:"decrement_amount"`
	ProductID       uuid.UUID `json:"product_id"`
}

// Attempts to decrement the stock_quantity for a product by a given amount.
// Succeeds only if the resulting stock_quantity would be >= 0.
// Returns the updated product row if successful, or an error if insufficient stock.
// Note: The RETURNING clause might not be strictly necessary if we only care about RowsAffected.
// If RETURNING is omitted, the querier function will likely return sql.Result.
// Let's include RETURNING to get the updated stock if needed for debugging/logging.
func (q *Queries) DecrementStockIfSufficient(ctx context.Context, arg DecrementStockIfSufficientParams) (Product, error) {
	row := q.db.QueryRow(ctx, decrementStockIfSufficient, arg.DecrementAmount, arg.ProductID)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrder = `-- name: GetOrder :one
SELECT 
    id, user_id, status, total_amount_cents, payment_method, shipping_address, billing_address, notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
FROM orders
WHERE id = $1
`

// Retrieves an order by its ID.
func (q *Queries) GetOrder(ctx context.Context, orderID uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, orderID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalAmountCents,
		&i.PaymentMethod,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.Notes,
		&i.DeliveryServiceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}

const getOrderByIDWithItems = `-- name: GetOrderByIDWithItems :many
SELECT 
    o.id, o.user_id, o.status, o.total_amount_cents, o.payment_method, o.shipping_address, o.billing_address, o.notes, o.delivery_service_id, o.created_at, o.updated_at, o.completed_at, o.cancelled_at,
    oi.id AS item_id, oi.order_id AS item_order_id, oi.product_id AS item_product_id, oi.product_name AS item_product_name, oi.price_cents AS item_price_cents, oi.quantity AS item_quantity, oi.subtotal_cents AS item_subtotal_cents, oi.created_at AS item_created_at, oi.updated_at AS item_updated_at
FROM orders o
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE o.id = $1
`

type GetOrderByIDWithItemsRow struct {
	ID                uuid.UUID          `json:"id"`
	UserID            uuid.UUID          `json:"user_id"`
	Status            string             `json:"status"`
	TotalAmountCents  int64              `json:"total_amount_cents"`
	PaymentMethod     string             `json:"payment_method"`
	ShippingAddress   []byte             `json:"shipping_address"`
	BillingAddress    []byte             `json:"billing_address"`
	Notes             *string            `json:"notes"`
	DeliveryServiceID uuid.UUID          `json:"delivery_service_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	CompletedAt       pgtype.Timestamptz `json:"completed_at"`
	CancelledAt       pgtype.Timestamptz `json:"cancelled_at"`
	ItemID            uuid.UUID          `json:"item_id"`
	ItemOrderID       uuid.UUID          `json:"item_order_id"`
	ItemProductID     uuid.UUID          `json:"item_product_id"`
	ItemProductName   *string            `json:"item_product_name"`
	ItemPriceCents    *int64             `json:"item_price_cents"`
	ItemQuantity      *int32             `json:"item_quantity"`
	ItemSubtotalCents *int64             `json:"item_subtotal_cents"`
	ItemCreatedAt     pgtype.Timestamptz `json:"item_created_at"`
	ItemUpdatedAt     pgtype.Timestamptz `json:"item_updated_at"`
}

// Retrieves an order by its ID along with all its items.
// This query uses a join and might return multiple rows if there are items.
// The service layer needs to aggregate these rows into a single Order object with a slice of OrderItems.
func (q *Queries) GetOrderByIDWithItems(ctx context.Context, orderID uuid.UUID) ([]GetOrderByIDWithItemsRow, error) {
	rows, err := q.db.Query(ctx, getOrderByIDWithItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderByIDWithItemsRow
	for rows.Next() {
		var i GetOrderByIDWithItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.TotalAmountCents,
			&i.PaymentMethod,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.Notes,
			&i.DeliveryServiceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.ItemID,
			&i.ItemOrderID,
			&i.ItemProductID,
			&i.ItemProductName,
			&i.ItemPriceCents,
			&i.ItemQuantity,
			&i.ItemSubtotalCents,
			&i.ItemCreatedAt,
			&i.ItemUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItemsByOrderID = `-- name: GetOrderItemsByOrderID :many
SELECT 
    id, order_id, product_id, product_name, price_cents, quantity, subtotal_cents, created_at, updated_at
FROM order_items
WHERE order_id = $1
ORDER BY created_at
`

// Retrieves all items for a specific order ID.
func (q *Queries) GetOrderItemsByOrderID(ctx context.Context, orderID uuid.UUID) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, getOrderItemsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderItem
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.ProductName,
			&i.PriceCents,
			&i.Quantity,
			&i.SubtotalCents,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementStock = `-- name: IncrementStock :one
UPDATE products
SET stock_quantity = stock_quantity + $1
WHERE id = $2
RETURNING id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at, deleted_at
`

type IncrementStockParams struct {
	IncrementAmount int32     `json:"increment_amount"`
	ProductID       uuid.UUID `json:"product_id"`
}

// Increments the stock_quantity for a product by a given amount.
// Suitable for releasing stock back when cancelling an order.
func (q *Queries) IncrementStock(ctx context.Context, arg IncrementStockParams) (Product, error) {
	row := q.db.QueryRow(ctx, incrementStock, arg.IncrementAmount, arg.ProductID)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listAllOrders = `-- name: ListAllOrders :many
SELECT 
    o.id, o.user_id, o.status, o.total_amount_cents, o.payment_method, o.shipping_address, o.billing_address, o.notes, o.delivery_service_id, o.created_at, o.updated_at, o.completed_at, o.cancelled_at
FROM orders o
WHERE ($1::UUID = '00000000-0000-0000-0000-000000000000' OR o.user_id = $1)
  AND ($2::TEXT = '' OR o.status = $2)
ORDER BY o.created_at DESC
LIMIT $4 OFFSET $3
`

type ListAllOrdersParams struct {
	FilterUserID uuid.UUID `json:"filter_user_id"`
	FilterStatus string    `json:"filter_status"`
	PageOffset   int32     `json:"page_offset"`
	PageLimit    int32     `json:"page_limit"`
}

// Retrieves a paginated list of all orders, optionally filtered by status or user_id.
// Intended for admin use. Includes cancelled orders.
// If filter_user_id is the zero UUID ('00000000-0000-0000-0000-000000000000'), it retrieves orders for all users.
// If filter_status is an empty string (‚Äù), it retrieves orders of all statuses.
func (q *Queries) ListAllOrders(ctx context.Context, arg ListAllOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listAllOrders,
		arg.FilterUserID,
		arg.FilterStatus,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.TotalAmountCents,
			&i.PaymentMethod,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.Notes,
			&i.DeliveryServiceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOrders = `-- name: ListUserOrders :many
SELECT 
    o.id, o.user_id, o.status, o.total_amount_cents, o.payment_method, o.shipping_address, o.billing_address, o.notes, o.delivery_service_id, o.created_at, o.updated_at, o.completed_at, o.cancelled_at
FROM orders o
WHERE o.user_id = $1
  AND ($2::TEXT = '' OR o.status = $2)
  -- Explicitly exclude cancelled orders for user list
  AND o.cancelled_at IS NULL 
ORDER BY o.created_at DESC
LIMIT $4 OFFSET $3
`

type ListUserOrdersParams struct {
	UserID       uuid.UUID `json:"user_id"`
	FilterStatus string    `json:"filter_status"`
	PageOffset   int32     `json:"page_offset"`
	PageLimit    int32     `json:"page_limit"`
}

// Retrieves a paginated list of orders for a specific user, optionally filtered by status.
// Excludes cancelled orders by default. Admins should use ListAllOrders.
func (q *Queries) ListUserOrders(ctx context.Context, arg ListUserOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listUserOrders,
		arg.UserID,
		arg.FilterStatus,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.TotalAmountCents,
			&i.PaymentMethod,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.Notes,
			&i.DeliveryServiceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders
SET
    notes = COALESCE($1, notes),
    updated_at = NOW()
WHERE id = $2
RETURNING id, user_id, status, total_amount_cents, payment_method, shipping_address, billing_address, notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
`

type UpdateOrderParams struct {
	Notes   *string   `json:"notes"`
	OrderID uuid.UUID `json:"order_id"`
}

// Updates other details of an order (notes, addresses - if allowed).
// Example updating notes and timestamps
func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrder, arg.Notes, arg.OrderID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalAmountCents,
		&i.PaymentMethod,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.Notes,
		&i.DeliveryServiceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders
SET status = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, user_id, status, total_amount_cents, payment_method, shipping_address, billing_address, notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
`

type UpdateOrderStatusParams struct {
	Status  string    `json:"status"`
	OrderID uuid.UUID `json:"order_id"`
}

// Updates the status of an order.
func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderStatus, arg.Status, arg.OrderID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalAmountCents,
		&i.PaymentMethod,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.Notes,
		&i.DeliveryServiceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}
