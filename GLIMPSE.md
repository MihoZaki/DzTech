Directory Structure:
└── Dockerfile
└── Readme.md
├── cmd/
  ├── server/
    └── main.go
├── dashboard/
  └── Dockerfile
  └── README.md
  └── eslint.config.js
  └── index.html
  └── package-lock.json
  └── package.json
  └── postcss.config.js
  ├── public/
    └── vite.svg
  ├── src/
    └── App.css
    └── App.jsx
    ├── assets/
      └── react.svg
    ├── components/
      └── AdminHeader.jsx
      └── FileUploadField.jsx
      └── SideBar.jsx
    └── index.css
    ├── layouts/
      └── AdminLayout.jsx
    └── main.jsx
    ├── pages/
      └── AdminDashboard.jsx
      └── NotFound.jsx
      └── Settings.jsx
      ├── auth/
        └── AuthPage.jsx
        └── LoginPage.jsx
        └── SigupPage.jsx
      ├── categories/
        └── AddCategory.jsx
        └── CategoriesList.jsx
        └── EditCategory.jsx
      ├── customers/
        └── CustomerList.jsx
      ├── delivery/
        └── AddDeliveryService.jsx
        └── DeliveryServicesList.jsx
        └── EditDeliveryService.jsx
      ├── discounts/
        └── AddDiscount.jsx
        └── DiscountsList.jsx
        └── EditDiscount.jsx
      ├── orders/
        └── OrderDetails.jsx
        └── OrdersList.jsx
      ├── products/
        └── AddProduct.jsx
        └── EditProduct.jsx
        └── ProductView.jsx
        └── ProductsList.jsx
    ├── services/
      └── api.js
    ├── stores/
      └── authStore.js
  └── tailwind.config.js
  └── vite.config.js
├── db/
  └── database.go
  └── migrate.go
└── devbox.json
└── docker-compose.yml
├── internal/
  ├── config/
    └── config.go
  ├── db/
    └── analytics.sql.go
    └── calculate_discounts.sql.go
    └── cart.sql.go
    └── db.go
    └── delivery_services.sql.go
    └── discounts.sql.go
    └── models.go
    └── multi_discounts.sql.go
    └── order.sql.go
    └── products.sql.go
    └── products_view.sql.go
    └── profile.sql.go
    └── querier.go
    ├── queries/
      └── analytics.sql
      └── calculate_discounts.sql
      └── cart.sql
      └── delivery_services.sql
      └── discounts.sql
      └── multi_discounts.sql
      └── order.sql
      └── products.sql
      └── products_view.sql
      └── profile.sql
      └── refresh_token.sql
      └── review.sql
      └── user.sql
    └── refresh_token.sql.go
    └── review.sql.go
    └── user.sql.go
  ├── handlers/
    └── admin_user_handler.go
    └── analytics.go
    └── auth.go
    └── cart.go
    └── category.go
    └── delivery_options.go
    └── delivery_service.go
    └── discount.go
    └── helper.go
    └── order.go
    └── product.go
    └── profile.go
    └── review.go
  ├── middleware/
    └── middleware.go
  ├── models/
    └── admin_user.go
    └── analytics.go
    └── auth.go
    └── cart.go
    └── category.go
    └── context.go
    └── delivery_service.go
    └── discount.go
    └── order.go
    └── product.go
    └── review.go
    └── user.go
    └── user_profile.go
    └── validation.go
  ├── router/
    └── router.go
  ├── server/
    └── server.go
  ├── services/
    └── admin_user_service.go
    └── analytics_service.go
    └── auth_service.go
    └── cart_service.go
    └── category_service.go
    └── delivery_service.go
    └── discount_service.go
    └── email_service.go
    └── errors.go
    └── order_service.go
    └── product_service.go
    └── review_service.go
    └── user_service.go
  ├── storage/
    └── storage.go
  ├── utils/
    └── errors.go
    └── roundup.go
    └── slug.go
└── justfile
├── migrations/
  └── 00001_init_db.sql
  └── 00002_create_users_table.sql
  └── 00003_create_products_and_categories_tables.sql
  └── 00004_create_cart_table.sql
  └── 00005_create_delivery_service_table.sql
  └── 00006_create_order_table.sql
  └── 00007_create_refresh_token_table.sql
  └── 00008_insert_test_data.sql
  └── 00009_create_discount_table.sql
  └── 00010_create_review_table.sql
  └── 00011_create_views_table.sql
  └── 00012_create_password_reset_token_table.sql
  └── 00013_create_admin_user.sql
└── nginx.conf
├── shared/
  └── types.go
  └── types.ts
└── sqlc.yaml
├── website/
  └── Dockerfile
  └── README.md
  └── eslint.config.js
  └── index.html
  └── package-lock.json
  └── package.json
  └── postcss.config.js
  ├── public/
    └── vite.svg
  ├── src/
    └── App.css
    └── App.jsx
    ├── components/
      └── CartModel.jsx
      └── FilterPanel.jsx
      └── Footer.jsx
      └── NavBar.jsx
      └── ProductCard.jsx
      └── ThemeSwitcher.jsx
    ├── contexts/
      └── AuthContext.jsx
      └── CartContext.jsx
    └── index.css
    └── main.jsx
    ├── pages/
      └── Account.jsx
      └── AccountSettings.jsx
      └── Auth.jsx
      └── BuildPC.jsx
      └── Cart.jsx
      └── Checkout.jsx
      └── Home.jsx
      └── MyOrders.jsx
      └── OrderDetails.jsx
      └── ProductDetail.jsx
      └── Products.jsx
    ├── services/
      └── api.js
    ├── stores/
      └── useStore.jsx
  └── tailwind.config.js
  └── vite.config.js

File Contents:

File: sqlc.yaml
================================================
version: "2"
sql:
  - engine: "postgresql"
    queries: "./internal/db/queries/"
    schema: "./migrations/"
    gen:
      go:
        package: "db"
        out: "./internal/db"
        sql_package: "pgx/v5"
        emit_json_tags: true
        emit_prepared_queries: false
        emit_pointers_for_null_types: true
        emit_interface: true
        emit_exact_table_names: false
        overrides:
        # Force ALL UUID types to use uuid.UUID
        - db_type: "uuid"
          go_type:
            import: "github.com/google/uuid"
            type: "UUID"
        - db_type: "uuid"
          nullable: true
          go_type:
            import: "github.com/google/uuid"
            type: "UUID"  # Still use UUID, handle nullability in the service layer
        - db_type: "uuid[]"
          go_type:
            import: "github.com/google/uuid"
            type: "[]UUID"


File: migrations/00001_init_db.sql
================================================
-- +goose Up
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE IF NOT EXISTS schema_migrations (
    version BIGINT PRIMARY KEY,
    is_applied BOOLEAN NOT NULL DEFAULT TRUE,
    applied_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- +goose Down
DROP TABLE IF EXISTS schema_migrations;


File: migrations/00010_create_review_table.sql
================================================
-- +goose Up
CREATE TABLE reviews (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5), -- Star rating (1 to 5)
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    deleted_at TIMESTAMP WITH TIME ZONE -- For soft deletes (optional, affects avg/num calculation)
);

-- Ensure a user can only rate a specific product once
CREATE UNIQUE INDEX idx_reviews_user_product_unique ON reviews(user_id, product_id) WHERE deleted_at IS NULL;

-- Indexes for common queries
CREATE INDEX idx_reviews_product_id ON reviews(product_id);
CREATE INDEX idx_reviews_user_id ON reviews(user_id);
CREATE INDEX idx_reviews_rating ON reviews(rating);
CREATE INDEX idx_reviews_created_at ON reviews(created_at);

-- +goose Down
DROP TABLE IF EXISTS reviews;


File: website/public/vite.svg
================================================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

File: dashboard/src/services/api.js
================================================
import axios from "axios";
import { toast } from "sonner";

const API_BASE_URL = import.meta.env.VITE_API_URL ||
  "http://localhost:8080/api";

const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    "Content-Type": "application/json",
  },
  withCredentials: true,
});

// Request Interceptor: Attach Access Token (EXCEPT for login, logout, and refresh endpoints)
apiClient.interceptors.request.use(
  (config) => {
    if (
      config.url.endsWith("/v1/auth/login") ||
      config.url.endsWith("/v1/auth/refresh") ||
      config.url.endsWith("/v1/auth/logout")
    ) {
      console.log(
        "[API Interceptor] Skipping access token header for:",
        config.url,
      );
      return config;
    }

    const token = localStorage.getItem("access_token");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    } else {
      console.log(
        "[API Interceptor] No access token found for request:",
        config.url,
      );
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  },
);

// Response Interceptor: Handle 401 and Attempt Refresh
let isRefreshing = false;
let failedQueue = [];

const processQueue = (error, token = null) => {
  failedQueue.forEach((prom) => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token);
    }
  });
  failedQueue = [];
};

apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // Check if the error is a 401 UNAUTHORIZED
    if (error.response?.status === 401) {
      if (
        originalRequest.url.endsWith("/v1/auth/login") ||
        originalRequest.url.endsWith("/v1/auth/logout") ||
        originalRequest.url.endsWith("/v1/auth/refresh") ||
        originalRequest._retry // Prevent loops if _retry is incorrectly set before reaching here for non-auth requests
      ) {
        console.log(
          "[API Interceptor] 401 on login/refresh/logout or retry attempt. Rejecting original request.",
          originalRequest.url,
        );
        return Promise.reject(error);
      }

      // Proceed with refresh logic only for non-auth requests
      if (isRefreshing) {
        // If a refresh is already in progress, queue this request
        console.log(
          "[API Interceptor] Queuing request while refresh is in progress:",
          originalRequest.url,
        );
        return new Promise((resolve, reject) => {
          failedQueue.push({ resolve, reject });
        })
          .then((token) => {
            originalRequest.headers.Authorization = `Bearer ${token}`;
            console.log(
              "[API Interceptor] Retry queued request with new token:",
              originalRequest.url,
            );
            return apiClient(originalRequest);
          })
          .catch((err) => {
            console.log(
              "[API Interceptor] Queued request failed after refresh attempt:",
              originalRequest.url,
            );
            return Promise.reject(err);
          });
      }

      originalRequest._retry = true;
      isRefreshing = true;
      console.log("[API Interceptor] Starting token refresh process...");

      try {
        console.log("[API Interceptor] Calling refresh endpoint...");

        const refreshResponse = await apiClient.post("/v1/auth/refresh");
        const newAccessToken = refreshResponse.data?.access_token;

        if (!newAccessToken) {
          throw new Error(
            `Refresh response missing 'access_token'. Got: ${
              JSON.stringify(refreshResponse.data)
            }`,
          );
        }

        console.log(
          "[API Interceptor] New access token received.",
        );

        // Update the access token in localStorage
        localStorage.setItem("access_token", newAccessToken);

        // Process queued requests with the new token
        console.log(
          "[API Interceptor] Processing queued requests with new token...",
        );
        processQueue(null, newAccessToken);

        // Retry the original request that failed with 401
        originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;
        isRefreshing = false;
        console.log(
          "[API Interceptor] Retrying original request after refresh.",
        );
        return apiClient(originalRequest);
      } catch (refreshError) {
        console.error("[API Interceptor] Refresh failed:", refreshError);
        console.error(
          "[API Interceptor] Status:",
          refreshError.response?.status,
        );
        console.error("[API Interceptor] Data:", refreshError.response?.data);

        // The refresh endpoint returned an error (likely 401 because refresh token is invalid/expired)
        // Clear tokens and logout user
        localStorage.removeItem("access_token");
        localStorage.removeItem("user");
        console.log("[API Interceptor] Tokens cleared after refresh failure.");

        // Process queued requests with the refresh error, rejecting them
        processQueue(refreshError, null);
        isRefreshing = false; // Ensure the flag is reset even after failure

        // Optionally redirect to login page globally here if needed
        window.location.href = "/auth/login";
        // Or show a toast
        toast.error("Session expired. Please log in again.");

        return Promise.reject(refreshError);
      }
    }

    // If the error is not a 401, or if it was a 401 but handled above, reject the promise
    return Promise.reject(error);
  },
);

// --- Auth API Functions ---
export const login = (email, password) =>
  apiClient.post("/v1/auth/login", { email, password });
export const logout = () => apiClient.post("/v1/auth/logout");

// --- Admin API Functions ---
// Product Crud
//
// Fetch all products
export const fetchProducts = (page = 1, limit = 20) => {
  const params = { page, limit };
  return apiClient.get("/v1/admin/products", { params });
};
// Search Product with filters
export const searchProducts = (q, page = 1, limit = 20, filters = {}) => {
  const params = {
    q,
    page,
    limit,
    ...filters,
  };
  Object.keys(params).forEach((key) => {
    if (params[key] === undefined || params[key] === "") {
      delete params[key];
    }
  });

  return apiClient.get("/v1/products/search", { params }); // Use the search endpoint
};
// Fetch Products by ID
export const fetchProductById = (id) =>
  apiClient.get(`/v1/admin/products/${id}`);
// Create Product
export const createProduct = (formData) =>
  apiClient.post("/v1/admin/products", formData, {
    headers: {
      "Content-Type": "multipart/form-data",
    },
  });
// Update Product
export const updateProductDetailsAndImages = (id, formData) =>
  apiClient.patch(`/v1/admin/products/${id}`, formData, {
    headers: {
      "Content-Type": "multipart/form-data",
    },
  });
// Delete Product by ID
export const deleteProduct = (id) =>
  apiClient.delete(`/v1/admin/products/${id}`);

/**
 * Create a new delivery service.
 * @param {Object} deliveryServiceData - The delivery service data to create.
 * @param {string} deliveryServiceData.name
 * @param {string} deliveryServiceData.description
 * @param {number} deliveryServiceData.base_cost_cents
 * @param {number} deliveryServiceData.estimated_days
 * @param {boolean} deliveryServiceData.is_active
 */
export const createDeliveryService = (deliveryServiceData) => {
  return apiClient.post("/v1/admin/delivery-services", deliveryServiceData);
};

/**
 * Fetch a specific delivery service by ID.
 * @param {string} id - The UUID of the delivery service.
 */
export const fetchDeliveryServiceById = (id) => {
  return apiClient.get(`/v1/admin/delivery-services/${id}`);
};

/**
 * Fetch the list of delivery services.
 * @param {Object} [params] - Optional query parameters.
 * @param {boolean} [params.active_only] - Filter for active services only.
 * @param {number} [params.page] - Page number.
 * @param {number} [params.limit] - Items per page.
 */
export const fetchDeliveryServices = (params = {}) => {
  return apiClient.get("/v1/admin/delivery-services", { params });
};

/**
 * Update an existing delivery service.
 * @param {string} id - The UUID of the delivery service to update.
 * @param {Object} deliveryServiceData - The data to update (partial allowed).
 */
export const updateDeliveryService = (id, deliveryServiceData) => {
  return apiClient.patch(
    `/v1/admin/delivery-services/${id}`,
    deliveryServiceData,
  );
};

/**
 * Delete a specific delivery service by ID.
 * @param {string} id - The UUID of the delivery service to delete.
 */
export const deleteDeliveryService = (id) => {
  return apiClient.delete(`/v1/admin/delivery-services/${id}`);
};

// ---  User Management API Functions ---

/**
 * Fetch the list of users.
 * @param {Object} [params] - Optional query parameters.
 * @param {boolean} [params.active_only] - Filter for active users only.
 * @param {number} [params.page] - Page number.
 * @param {number} [params.limit] - Items per page.
 */
export const fetchUsers = (params = {}) => {
  return apiClient.get("/v1/admin/users", { params });
};

/**
 * Fetch details of a specific user by ID.
 * @param {string} id - The UUID of the user.
 */
export const fetchUserById = (id) => {
  return apiClient.get(`/v1/admin/users/${id}`);
};

/**
 * Activate a user account (soft-delete reversal).
 * @param {string} userId - The UUID of the user to activate.
 */
export const activateUser = (userId) => {
  return apiClient.post(`/v1/admin/users/${userId}/activate`);
};

/**
 * Deactivate a user account (soft-delete).
 * @param {string} userId - The UUID of the user to deactivate.
 */
export const deactivateUser = (userId) => {
  return apiClient.post(`/v1/admin/users/${userId}/deactivate`);
};
/**
 * Update the authenticated user's profile information (name, email).
 * @param {Object} profileData - The profile data to update.
 * @param {string} [profileData.full_name] - The new full name.
 * @param {string} [profileData.email] - The new email address.
 */
export const updateUserProfile = (profileData) => {
  return apiClient.put("/v1/user/profile", profileData);
};

/**
 * Change the authenticated user's password.
 * @param {Object} passwordData - The password change data.
 * @param {string} passwordData.current_password - The user's current password.
 * @param {string} passwordData.new_password - The new password.
 * @param {string} passwordData.confirm_password - Confirmation of the new password.
 */
export const changeUserPassword = (passwordData) => {
  return apiClient.put("/v1/user/password/change", passwordData);
};

// --- Discounts ---
// Existing functions:
/**
 * Fetch the list of discounts.
 * @param {Object} [params] - Optional query parameters.
 * @param {boolean} [params.is_active] - Filter by active status (e.g., true/false).
 * @param {number} [params.page] - Page number.
 * @param {number} [params.limit] - Items per page.
 */
export const fetchDiscounts = (params = {}) => {
  return apiClient.get("/v1/admin/discounts", { params });
};
export const fetchActiveDiscounts = () =>
  apiClient.get("/v1/admin/discounts", {
    params: {
      is_active: true,
    },
  });
export const fetchProductDiscounts = (productId) =>
  apiClient.get(`/v1/admin/discounts/product/${productId}`);

/**
 * Create a new discount.
 * @param {Object} discountData - The discount data to create.
 */
export const createDiscount = (discountData) => {
  return apiClient.post("/v1/admin/discounts", discountData);
};

/**
 * Fetch details of a specific discount by ID.
 * @param {string} id - The UUID of the discount.
 */
export const fetchDiscountById = (id) => {
  return apiClient.get(`/v1/admin/discounts/${id}`);
};

/**
 * Update an existing discount.
 * @param {string} id - The UUID of the discount to update.
 * @param {Object} discountData - The data to update (partial allowed).
 */
export const updateDiscount = (id, discountData) => {
  return apiClient.put(`/v1/admin/discounts/${id}`, discountData);
};

/**
 * Delete a specific discount by ID.
 * @param {string} id - The UUID of the discount to delete.
 */
export const deleteDiscount = (id) => {
  return apiClient.delete(`/v1/admin/discounts/${id}`);
};

/**
 * Link a discount to a specific product.
 * @param {string} discountId - The UUID of the discount.
 * @param {string} productId - The UUID of the product to link.
 */
export const linkProductDiscount = (discountId, productId) => {
  return apiClient.post(`/v1/admin/discounts/${discountId}/link/product`, {
    product_id: productId,
  });
};

/**
 * Unlink a discount from a specific product.
 * @param {string} discountId - The UUID of the discount.
 * @param {string} productId - The UUID of the product to unlink.
 */
export const unlinkProductDiscount = (discountId, productId) => {
  return apiClient.post(`/v1/admin/discounts/${discountId}/unlink/product`, {
    product_id: productId,
  });
};

/**
 * Fetch the list of all categories.
 */
export const fetchCategories = () => apiClient.get("/v1/admin/categories");

/**
 * Create a new product category.
 * @param {Object} categoryData - The category data to create.
 * @param {string} categoryData.name
 * @param {string} categoryData.type
 */
export const createCategory = (categoryData) => {
  return apiClient.post("/v1/admin/categories", categoryData);
};

/**
 * Fetch details of a specific category by ID.
 * @param {string} id - The UUID of the category.
 */
export const fetchCategoryById = (id) => {
  return apiClient.get(`/v1/admin/categories/${id}`);
};

/**
 * Update an existing product category.
 * @param {string} id - The UUID of the category to update.
 * @param {Object} categoryData - The data to update (partial allowed).
 */
export const updateCategory = (id, categoryData) => {
  return apiClient.put(`/v1/admin/categories/${id}`, categoryData);
};

/**
 * Delete a specific product category.
 * @param {string} id - The UUID of the category to delete.
 */
export const deleteCategory = (id) => {
  return apiClient.delete(`/v1/admin/categories/${id}`);
};

/**
 * Fetch the list of all orders.
 * @param {Object} [params] - Optional query parameters.
 * @param {string} [params.user_id] - Filter by user ID.
 * @param {string} [params.status] - Filter by order status.
 * @param {number} [params.page] - Page number.
 * @param {number} [params.limit] - Items per page.
 */
export const fetchOrders = (params = {}) => {
  return apiClient.get("/v1/admin/orders/all", { params });
};

/**
 * Fetch details of a specific order by ID.
 * @param {string} id - The UUID of the order.
 */
export const fetchOrderById = (id) => {
  return apiClient.get(`/v1/admin/orders/${id}`);
};

/**
 * Update the status of a specific order.
 * @param {string} orderId - The UUID of the order to update.
 * @param {Object} statusData - The status data to update.
 * @param {string} statusData.status - The new status (pending, confirmed, shipped, delivered, cancelled).
 */
export const updateOrderStatus = (orderId, statusData) => {
  return apiClient.put(`/v1/admin/orders/${orderId}/status`, statusData);
};

/**
 * Cancel a specific order.
 * @param {string} orderId - The UUID of the order to cancel.
 */
export const cancelOrder = (orderId) => {
  return apiClient.put(`/v1/admin/orders/${orderId}/cancel`);
};

// --- Analytics API Functions ---
/**
 * Get total revenue from delivered orders within a time range.
 * @param {Object} [params] - Optional query parameters.
 * @param {string} [params.start_date] - Start date in ISO 8601 format.
 * @param {string} [params.end_date] - End date in ISO 8601 format.
 */
export const fetchRevenueAnalytics = (params = {}) => {
  return apiClient.get("/v1/admin/analytics/revenue", { params });
};

/**
 * Get total number of delivered orders within a time range.
 * @param {Object} [params] - Optional query parameters.
 * @param {string} [params.start_date] - Start date in ISO 8601 format.
 * @param {string} [params.end_date] - End date in ISO 8601 format.
 */
export const fetchSalesVolumeAnalytics = (params = {}) => {
  return apiClient.get("/v1/admin/analytics/sales-volume", { params });
};

/**
 * Get average order value (AOV) for delivered orders within a time range.
 * @param {Object} [params] - Optional query parameters.
 * @param {string} [params.start_date] - Start date in ISO 8601 format.
 * @param {string} [params.end_date] - End date in ISO 8601 format.
 */
export const fetchAverageOrderValueAnalytics = (params = {}) => {
  return apiClient.get("/v1/admin/analytics/average-order-value", { params });
};

/**
 * Get top N selling products by quantity within a time range.
 * @param {Object} [params] - Optional query parameters.
 * @param {string} [params.start_date] - Start date in ISO 8601 format.
 * @param {string} [params.end_date] - End date in ISO 8601 format.
 * @param {number} [params.limit] - Number of top products to return.
 */
export const fetchTopProductsAnalytics = (params = {}) => {
  return apiClient.get("/v1/admin/analytics/top-products", { params });
};

/**
 * Get top N selling categories by quantity within a time range.
 * @param {Object} [params] - Optional query parameters.
 * @param {string} [params.start_date] - Start date in ISO 8601 format.
 * @param {string} [params.end_date] - End date in ISO 8601 format.
 * @param {number} [params.limit] - Number of top categories to return.
 */
export const fetchTopCategoriesAnalytics = (params = {}) => {
  return apiClient.get("/v1/admin/analytics/top-categories", { params });
};

/**
 * Get products with stock quantity below a specified threshold.
 * @param {Object} params - Query parameters.
 * @param {number} params.threshold - The minimum stock quantity threshold.
 */
export const fetchLowStockAnalytics = (params = {}) => {
  // Ensure threshold is provided and is a number
  if (typeof params.threshold !== "number" || params.threshold <= 0) {
    throw new Error(
      "Threshold parameter is required and must be a positive number.",
    );
  }
  return apiClient.get("/v1/admin/analytics/low-stock", { params });
};

/**
 * Get count of new customer registrations within a time range.
 * @param {Object} [params] - Optional query parameters.
 * @param {string} [params.start_date] - Start date in ISO 8601 format.
 * @param {string} [params.end_date] - End date in ISO 8601 format.
 */
export const fetchNewCustomersAnalytics = (params = {}) => {
  return apiClient.get("/v1/admin/analytics/new-customers", { params });
};

/**
 * Get count of orders for each status within a time range.
 * @param {Object} [params] - Optional query parameters.
 * @param {string} [params.start_date] - Start date in ISO 8601 format.
 * @param {string} [params.end_date] - End date in ISO 8601 format.
 */
export const fetchOrderStatusCountsAnalytics = (params = {}) => {
  return apiClient.get("/v1/admin/analytics/order-status-counts", { params });
};

export default apiClient;


File: dashboard/vite.config.js
================================================
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
  },
});


File: Readme.md
================================================
# MVP Plan for Tech Store (PC Parts, Laptops, and Custom Builds)

---

## **Core User Stories**

### **Customer:**

- [x] As a customer, I want to **browse products** (PC parts, laptops) so I can
      see what’s available.
- [x] As a customer, I want to **search for specific products** (e.g., "RTX
      4090," "Ryzen 9 7950X") so I can find what I need quickly.
- [x] As a customer, I want to **view detailed product specs** (e.g., clock
      speed, compatibility, benchmarks) so I can make an informed decision.
- [x] As a customer, I want to **add products to my cart** so I can purchase
      them later.
- [x] As a customer, I want to **add items to my cart while offline** and have
      them sync once I log in.
- [x] As a customer, I want to **read and leave product reviews** to gauge
      quality and share my experience.
- [x] As a customer, I want to **create custom PC builds** by selecting
      compatible components (CPU, GPU, motherboard, etc.).
- [x] As a customer, I want to **select a delivery service** so I can choose how
      my products are delivered.
- [x] As a customer, I want to **create an account (optional)** to finalize my
      order and access additional features.
- [x] As a customer, I want to **view my order history** so I can track
      purchases and reorder if needed.
- [x] As a customer, I want to **confirm my order** so I can complete my
      purchase.

---

### **Admin:**

- [x] As an admin, I want to **add new PC parts and laptops** so customers can
      buy them.
- [x] As an admin, I want to **edit product details** (e.g., specs, pricing,
      stock) so I can keep the information up to date.
- [x] As an admin, I want to **remove products** so I can manage inventory.
- [x] As an admin, I want to **add and update delivery services** and their
      details.
- [x] As an admin, I want to **moderate product reviews** to maintain quality
      and relevance.
- [x] As an admin, I want to **manage custom build compatibility rules** (e.g.,
      CPU socket must match motherboard).

---

## **Key Features for an MVP**

### **Product Discovery**

- [x] **Product Listing Page**: Browse and search for PC parts and laptops.
- [x] **Advanced Search Filters**: Filter by category, brand, price range, specs
      (e.g., "16GB RAM," "1TB SSD").

### **Product Details**

- [x] **Detailed Specs**: Full specifications, high-quality images,
      compatibility notes, and customer reviews.

### **Shopping Cart**

- [x] Add/remove products.
- [x] View total cost.
- [x] Offline mode support with sync on login.

### **Product Reviews**

- [x] Star ratings.

### **Custom PC Builds**

- [x] **Component Selector**: Choose CPU, GPU, motherboard, RAM, storage, PSU,
      and case.
- [x] **Compatibility Check**: Real-time validation (e.g., "This CPU is not
      compatible with the selected motherboard").
- [x] **Build Summary**: Preview the build, estimated performance, and total
      price.
- [x] **Save/Share Builds**: Save for later or share with friends for feedback.

### **User Accounts**

- [x] Optional account creation.
- [x] Required for order finalization, wishlist, and order history.

### **Delivery Service Selection**

- [x] Choose from available delivery options during checkout.
- [x] Admins can configure services (e.g., standard, express, pickup).

### **Order History**

- [x] View past orders, reorder, or track deliveries.

### **Admin Panel**

- [x] Add/edit/remove products.
- [x] Manage delivery services.


---

## **Single Success Metric**

- **Conversion Rate**: The percentage of visitors who complete a purchase
  (either a product or a custom build).


File: internal/models/category.go
================================================
package models

import (
	"time"

	"github.com/google/uuid"
)

type Category struct {
	ID        uuid.UUID  `json:"id"`
	Name      string     `json:"name"`
	Slug      string     `json:"slug"`
	Type      string     `json:"type"`
	ParentID  *uuid.UUID `json:"parent_id,omitempty"`
	CreatedAt time.Time  `json:"created_at"`
}

// CreateCategoryRequest holds data for creating a new category.
type CreateCategoryRequest struct {
	Name     string    `json:"name" validate:"required,max=255"`
	Type     string    `json:"type" validate:"required,max=100"`
	ParentID uuid.UUID `json:"parent_id,omitempty" validate:"omitempty,uuid"` // Must be a valid UUID if provided
}

// UpdateCategoryRequest holds data for updating an existing category.
type UpdateCategoryRequest struct {
	Name     *string   `json:"name,omitempty" validate:"omitempty,max=255"` // Pointers allow optional updates
	Type     *string   `json:"type,omitempty" validate:"omitempty,max=100"`
	ParentID uuid.UUID `json:"parent_id,omitempty" validate:"omitempty,uuid"`
}

func (r *CreateCategoryRequest) Validate() error {
	return Validate.Struct(r)
}

func (upr *UpdateCategoryRequest) Validate() error {
	return Validate.Struct(upr)
}


File: internal/models/admin_user.go
================================================
package models

import (
	"time"

	"github.com/google/uuid"
)

// AdminUserListItem represents a user entry in the admin user list/detail view.
type AdminUserListItem struct {
	ID               uuid.UUID  `json:"id"`
	Name             string     `json:"name"` // Derived from FullName
	Email            string     `json:"email"`
	RegistrationDate time.Time  `json:"registration_date"`         // From users.created_at
	LastOrderDate    *time.Time `json:"last_order_date,omitempty"` // From latest order's created_at
	OrderCount       int64      `json:"order_count"`               // Aggregated from orders
	ActivityStatus   string     `json:"activity_status"`           // "Active" or "Inactive"
}

// AdminUpdateUserRequest represents data to update a user's details/status.
type AdminUpdateUserRequest struct {
	IsActive *bool   `json:"is_active,omitempty"` // Admin can set active/inactive (via soft delete)
	IsAdmin  *bool   `json:"is_admin,omitempty"`  // Admin can promote/demote admin status
	FullName *string `json:"full_name,omitempty"` // Admin can potentially update name (be careful)
}

// AdminActivateUserRequest represents data for activating a user (currently empty, could add audit reason later).
type AdminActivateUserRequest struct {
}

// AdminDeactivateUserRequest represents data for deactivating a user (currently empty, could add audit reason later).
type AdminDeactivateUserRequest struct {
	// Potentially add fields like 'reason' for deactivation if needed
}


File: internal/handlers/analytics.go
================================================
package handlers

import (
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"strconv"
	"time"

	"github.com/MihoZaki/DzTech/internal/services"

	"github.com/go-chi/chi/v5"
)

// AnalyticsHandler handles HTTP requests for analytics endpoints.
type AnalyticsHandler struct {
	service *services.AnalyticsService
	logger  *slog.Logger
}

// NewAnalyticsHandler creates a new instance of AnalyticsHandler.
func NewAnalyticsHandler(service *services.AnalyticsService, logger *slog.Logger) *AnalyticsHandler {
	return &AnalyticsHandler{
		service: service,
		logger:  logger,
	}
}

// RegisterRoutes registers the analytics-related routes under the given router.
func (h *AnalyticsHandler) RegisterRoutes(r chi.Router) {
	// Sales Performance
	r.Get("/revenue", h.GetTotalRevenue)                  // GET /api/v1/admin/analytics/revenue?start_date=&end_date=
	r.Get("/sales-volume", h.GetSalesVolume)              // GET /api/v1/admin/analytics/sales-volume?start_date=&end_date=
	r.Get("/average-order-value", h.GetAverageOrderValue) // GET /api/v1/admin/analytics/average-order-value?start_date=&end_date=
	r.Get("/top-products", h.GetTopSellingProducts)       // GET /api/v1/admin/analytics/top-products?start_date=&end_date=&limit=
	r.Get("/top-categories", h.GetTopSellingCategories)   // GET /api/v1/admin/analytics/top-categories?start_date=&end_date=&limit=

	// Product Performance
	r.Get("/low-stock", h.GetLowStockProducts) // GET /api/v1/admin/analytics/low-stock?threshold=
	// Note: GetProductReviewStats might be better under product endpoints, not analytics

	// Customer Insights
	r.Get("/new-customers", h.GetNewCustomersCount) // GET /api/v1/admin/analytics/new-customers?start_date=&end_date=

	// Order Metrics
	r.Get("/order-status-counts", h.GetOrderStatusCounts) // GET /api/v1/admin/analytics/order-status-counts?start_date=&end_date=

	// Discount Effectiveness
	// r.Get("/discount-usage", h.GetDiscountUsage) // GET /api/v1/admin/analytics/discount-usage?start_date=&end_date=
}

func parseTimeParam(r *http.Request, paramName string, defaultTime time.Time) (*time.Time, error) {
	timeStr := r.URL.Query().Get(paramName)
	if timeStr == "" {
		return &defaultTime, nil // Or return nil, nil if optional and default is not acceptable
	}
	t, err := time.Parse(time.RFC3339, timeStr) // Expecting ISO 8601 format
	if err != nil {
		return nil, fmt.Errorf("invalid format for %s: %w", paramName, err)
	}
	return &t, nil
}

func parseLimitParam(r *http.Request, defaultValue int) (int, error) {
	limitStr := r.URL.Query().Get("limit")
	if limitStr == "" {
		return defaultValue, nil
	}
	limit, err := strconv.Atoi(limitStr)
	if err != nil || limit <= 0 {
		return 0, fmt.Errorf("invalid limit parameter: %w", err)
	}
	if limit > 100 { // Example maximum limit
		limit = 100
	}
	return limit, nil
}

func parseThresholdParam(r *http.Request) (int, error) {
	thresholdStr := r.URL.Query().Get("threshold")
	if thresholdStr == "" {
		return 0, fmt.Errorf("missing threshold parameter")
	}
	threshold, err := strconv.Atoi(thresholdStr)
	if err != nil || threshold <= 0 {
		return 0, fmt.Errorf("invalid threshold parameter: %w", err)
	}
	return threshold, nil
}

// --- Handler Methods ---

// GetTotalRevenue handles the request to get total revenue.
func (h *AnalyticsHandler) GetTotalRevenue(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters
	startDate, err := parseTimeParam(r, "start_date", time.Now().AddDate(0, -1, 0)) // Default to 1 month ago
	if err != nil {
		h.logger.Error("Invalid start_date parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}
	endDate, err := parseTimeParam(r, "end_date", time.Now()) // Default to now
	if err != nil {
		h.logger.Error("Invalid end_date parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}

	// Validate date range
	if !endDate.After(*startDate) {
		h.logger.Error("End date must be after start date", "start_date", startDate, "end_date", endDate)
		http.Error(w, `{"error": "Invalid Parameter", "message": "End date must be after start date"}`, http.StatusBadRequest)
		return
	}

	// Call the service
	response, err := h.service.GetTotalRevenue(r.Context(), *startDate, *endDate)
	if err != nil {
		h.logger.Error("Failed to get total revenue", "error", err, "start_date", startDate, "end_date", endDate)
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to retrieve total revenue"}`, http.StatusInternalServerError)
		return
	}

	// Send success response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(response); err != nil {
		h.logger.Error("Failed to encode GetTotalRevenue response", "error", err)
		// Error already written to client, just log
	}
}

// GetSalesVolume handles the request to get sales volume.
func (h *AnalyticsHandler) GetSalesVolume(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters
	startDate, err := parseTimeParam(r, "start_date", time.Now().AddDate(0, -1, 0)) // Default to 1 month ago
	if err != nil {
		h.logger.Error("Invalid start_date parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}
	endDate, err := parseTimeParam(r, "end_date", time.Now()) // Default to now
	if err != nil {
		h.logger.Error("Invalid end_date parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}

	// Validate date range
	if !endDate.After(*startDate) {
		h.logger.Error("End date must be after start date", "start_date", startDate, "end_date", endDate)
		http.Error(w, `{"error": "Invalid Parameter", "message": "End date must be after start date"}`, http.StatusBadRequest)
		return
	}

	// Call the service
	response, err := h.service.GetSalesVolume(r.Context(), *startDate, *endDate)
	if err != nil {
		h.logger.Error("Failed to get sales volume", "error", err, "start_date", startDate, "end_date", endDate)
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to retrieve sales volume"}`, http.StatusInternalServerError)
		return
	}

	// Send success response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(response); err != nil {
		h.logger.Error("Failed to encode GetSalesVolume response", "error", err)
	}
}

// GetAverageOrderValue handles the request to get average order value.
func (h *AnalyticsHandler) GetAverageOrderValue(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters
	startDate, err := parseTimeParam(r, "start_date", time.Now().AddDate(0, -1, 0)) // Default to 1 month ago
	if err != nil {
		h.logger.Error("Invalid start_date parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}
	endDate, err := parseTimeParam(r, "end_date", time.Now()) // Default to now
	if err != nil {
		h.logger.Error("Invalid end_date parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}

	// Validate date range
	if !endDate.After(*startDate) {
		h.logger.Error("End date must be after start date", "start_date", startDate, "end_date", endDate)
		http.Error(w, `{"error": "Invalid Parameter", "message": "End date must be after start date"}`, http.StatusBadRequest)
		return
	}

	// Call the service
	response, err := h.service.GetAverageOrderValue(r.Context(), *startDate, *endDate)
	if err != nil {
		h.logger.Error("Failed to get average order value", "error", err, "start_date", startDate, "end_date", endDate)
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to retrieve average order value"}`, http.StatusInternalServerError)
		return
	}

	// Send success response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(response); err != nil {
		h.logger.Error("Failed to encode GetAverageOrderValue response", "error", err)
	}
}

// GetTopSellingProducts handles the request to get top selling products.
func (h *AnalyticsHandler) GetTopSellingProducts(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters
	startDate, err := parseTimeParam(r, "start_date", time.Now().AddDate(0, -1, 0)) // Default to 1 month ago
	if err != nil {
		h.logger.Error("Invalid start_date parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}
	endDate, err := parseTimeParam(r, "end_date", time.Now()) // Default to now
	if err != nil {
		h.logger.Error("Invalid end_date parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}
	limit, err := parseLimitParam(r, 10) // Default to top 10
	if err != nil {
		h.logger.Error("Invalid limit parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}

	// Validate date range
	if !endDate.After(*startDate) {
		h.logger.Error("End date must be after start date", "start_date", startDate, "end_date", endDate)
		http.Error(w, `{"error": "Invalid Parameter", "message": "End date must be after start date"}`, http.StatusBadRequest)
		return
	}

	// Call the service
	response, err := h.service.GetTopSellingProducts(r.Context(), *startDate, *endDate, limit)
	if err != nil {
		h.logger.Error("Failed to get top selling products", "error", err, "start_date", startDate, "end_date", endDate, "limit", limit)
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to retrieve top selling products"}`, http.StatusInternalServerError)
		return
	}

	// Send success response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(response); err != nil {
		h.logger.Error("Failed to encode GetTopSellingProducts response", "error", err)
	}
}

// GetTopSellingCategories handles the request to get top selling categories.
func (h *AnalyticsHandler) GetTopSellingCategories(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters
	startDate, err := parseTimeParam(r, "start_date", time.Now().AddDate(0, -1, 0)) // Default to 1 month ago
	if err != nil {
		h.logger.Error("Invalid start_date parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}
	endDate, err := parseTimeParam(r, "end_date", time.Now()) // Default to now
	if err != nil {
		h.logger.Error("Invalid end_date parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}
	limit, err := parseLimitParam(r, 10) // Default to top 10
	if err != nil {
		h.logger.Error("Invalid limit parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}

	// Validate date range
	if !endDate.After(*startDate) {
		h.logger.Error("End date must be after start date", "start_date", startDate, "end_date", endDate)
		http.Error(w, `{"error": "Invalid Parameter", "message": "End date must be after start date"}`, http.StatusBadRequest)
		return
	}

	// Call the service
	response, err := h.service.GetTopSellingCategories(r.Context(), *startDate, *endDate, limit)
	if err != nil {
		h.logger.Error("Failed to get top selling categories", "error", err, "start_date", startDate, "end_date", endDate, "limit", limit)
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to retrieve top selling categories"}`, http.StatusInternalServerError)
		return
	}

	// Send success response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(response); err != nil {
		h.logger.Error("Failed to encode GetTopSellingCategories response", "error", err)
	}
}

// GetLowStockProducts handles the request to get low stock products.
func (h *AnalyticsHandler) GetLowStockProducts(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters
	threshold, err := parseThresholdParam(r)
	if err != nil {
		h.logger.Error("Invalid threshold parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}

	// Call the service
	response, err := h.service.GetLowStockProducts(r.Context(), threshold)
	if err != nil {
		h.logger.Error("Failed to get low stock products", "error", err, "threshold", threshold)
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to retrieve low stock products"}`, http.StatusInternalServerError)
		return
	}

	// Send success response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(response); err != nil {
		h.logger.Error("Failed to encode GetLowStockProducts response", "error", err)
	}
}

// GetNewCustomersCount handles the request to get new customer count.
func (h *AnalyticsHandler) GetNewCustomersCount(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters
	startDate, err := parseTimeParam(r, "start_date", time.Now().AddDate(0, -1, 0)) // Default to 1 month ago
	if err != nil {
		h.logger.Error("Invalid start_date parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}
	endDate, err := parseTimeParam(r, "end_date", time.Now()) // Default to now
	if err != nil {
		h.logger.Error("Invalid end_date parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}

	// Validate date range
	if !endDate.After(*startDate) {
		h.logger.Error("End date must be after start date", "start_date", startDate, "end_date", endDate)
		http.Error(w, `{"error": "Invalid Parameter", "message": "End date must be after start date"}`, http.StatusBadRequest)
		return
	}

	// Call the service
	response, err := h.service.GetNewCustomersCount(r.Context(), *startDate, *endDate)
	if err != nil {
		h.logger.Error("Failed to get new customers count", "error", err, "start_date", startDate, "end_date", endDate)
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to retrieve new customers count"}`, http.StatusInternalServerError)
		return
	}

	// Send success response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(response); err != nil {
		h.logger.Error("Failed to encode GetNewCustomersCount response", "error", err)
	}
}

// GetOrderStatusCounts handles the request to get order status counts.
func (h *AnalyticsHandler) GetOrderStatusCounts(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters
	startDate, err := parseTimeParam(r, "start_date", time.Now().AddDate(0, -1, 0)) // Default to 1 month ago
	if err != nil {
		h.logger.Error("Invalid start_date parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}
	endDate, err := parseTimeParam(r, "end_date", time.Now()) // Default to now
	if err != nil {
		h.logger.Error("Invalid end_date parameter", "error", err)
		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
		return
	}

	// Validate date range
	if !endDate.After(*startDate) {
		h.logger.Error("End date must be after start date", "start_date", startDate, "end_date", endDate)
		http.Error(w, `{"error": "Invalid Parameter", "message": "End date must be after start date"}`, http.StatusBadRequest)
		return
	}

	// Call the service
	response, err := h.service.GetOrderStatusCounts(r.Context(), *startDate, *endDate)
	if err != nil {
		h.logger.Error("Failed to get order status counts", "error", err, "start_date", startDate, "end_date", endDate)
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to retrieve order status counts"}`, http.StatusInternalServerError)
		return
	}

	// Send success response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(response); err != nil {
		h.logger.Error("Failed to encode GetOrderStatusCounts response", "error", err)
	}
}

// GetDiscountUsage handles the request to get discount usage.
// func (h *AnalyticsHandler) GetDiscountUsage(w http.ResponseWriter, r *http.Request) {
// 	// Parse query parameters
// 	startDate, err := parseTimeParam(r, "start_date", time.Now().AddDate(0, -1, 0)) // Default to 1 month ago
// 	if err != nil {
// 		h.logger.Error("Invalid start_date parameter", "error", err)
// 		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
// 		return
// 	}
// 	endDate, err := parseTimeParam(r, "end_date", time.Now()) // Default to now
// 	if err != nil {
// 		h.logger.Error("Invalid end_date parameter", "error", err)
// 		http.Error(w, fmt.Sprintf(`{"error": "Invalid Parameter", "message": "%v"}`, err.Error()), http.StatusBadRequest)
// 		return
// 	}

// 	// Validate date range
// 	if !endDate.After(*startDate) {
// 		h.logger.Error("End date must be after start date", "start_date", startDate, "end_date", endDate)
// 		http.Error(w, `{"error": "Invalid Parameter", "message": "End date must be after start date"}`, http.StatusBadRequest)
// 		return
// 	}

// 	// Call the service
// 	response, err := h.service.GetDiscountUsage(r.Context(), *startDate, *endDate)
// 	if err != nil {
// 		h.logger.Error("Failed to get discount usage", "error", err, "start_date", startDate, "end_date", endDate)
// 		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to retrieve discount usage"}`, http.StatusInternalServerError)
// 		return
// 	}

// 	// Send success response
// 	w.Header().Set("Content-Type", "application/json")
// 	w.WriteHeader(http.StatusOK)
// 	if err := json.NewEncoder(w).Encode(response); err != nil {
// 		h.logger.Error("Failed to encode GetDiscountUsage response", "error", err)
// 	}
// }


File: internal/handlers/profile.go
================================================
package handlers

import (
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"strings" // Add strings import for checking error messages

	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/MihoZaki/DzTech/internal/services"
	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
)

// ProfileHandler handles HTTP requests for user profile updates and password recovery.
type ProfileHandler struct {
	service *services.UserService
	// emailService *services.ConcreteEmailService // Pass the concrete type or interface if defined
	logger *slog.Logger
}

// NewProfileHandler creates a new instance of ProfileHandler.
func NewProfileHandler(service *services.UserService, logger *slog.Logger) *ProfileHandler {
	return &ProfileHandler{
		service: service,
		logger:  logger,
	}
}

// RegisterRoutes registers the profile and password-related routes under the given router.
// This should be mounted under the authenticated user routes (e.g., /api/v1/user).
func (h *ProfileHandler) RegisterRoutes(r chi.Router) {
	// Authenticated Profile Routes
	r.Put("/profile", h.UpdateProfile)          // PUT /api/v1/user/profile (authenticated)
	r.Put("/password/change", h.ChangePassword) // PUT /api/v1/user/password/change (authenticated)
}

// RegisterAuthRoutes registers the public password recovery routes under the given router.
// This should be mounted under the public auth routes (e.g., /api/v1/auth).
// func (h *ProfileHandler) RegisterAuthRoutes(r chi.Router) {
// 	r.Post("/forgot-password", h.ForgotPassword) // POST /api/v1/auth/forgot-password
// 	r.Post("/reset-password", h.ResetPassword)   // POST /api/v1/auth/reset-password
// }

// UpdateProfile handles the request to update user profile information.
func (h *ProfileHandler) UpdateProfile(w http.ResponseWriter, r *http.Request) {
	// 1. Extract UserID from JWT context (existing logic)
	var userIDVal *uuid.UUID
	if user, ok := models.GetUserFromContext(r.Context()); ok {
		h.logger.Debug("Authenticated user accessing profile", "user_id", user.ID)
		userIDVal = &user.ID
	}
	if userIDVal == nil {
		http.Error(w, "Unauthorized: missing user context", http.StatusUnauthorized)
		return
	}
	userID := *userIDVal

	// 2. Decode Request Body into UpdateProfileRequest
	var req models.UpdateProfileRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Error("Invalid JSON in UpdateProfile request", "error", err)
		http.Error(w, `{"error": "Invalid JSON", "message": "Request body contains invalid JSON"}`, http.StatusBadRequest)
		return
	}

	// 3. Validate the request struct
	if err := req.Validate(); err != nil {
		http.Error(w, "Validation error: "+err.Error(), http.StatusBadRequest)
		return
	}

	// 4. Call the Service Method
	profileResponse, err := h.service.UpdateProfile(r.Context(), userID, req)
	if err != nil {
		h.logger.Error("Failed to update profile", "error", err, "user_id", userID)
		// Consider more specific error messages based on the error type if needed
		// For now, use a generic internal error
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to update profile"}`, http.StatusInternalServerError)
		return
	}

	// 5. Send Success Response (200 OK)
	h.logger.Info("Profile updated successfully", "user_id", userID)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK) // 200 OK
	if err := json.NewEncoder(w).Encode(profileResponse); err != nil {
		// Log encoding error, but response headers might already be sent
		h.logger.Error("Failed to encode UpdateProfile response", "error", err)
	}
}

// ChangePassword handles the request to change the user's password.
func (h *ProfileHandler) ChangePassword(w http.ResponseWriter, r *http.Request) {
	// 1. Extract UserID from JWT context (existing logic)
	var userIDVal *uuid.UUID
	if user, ok := models.GetUserFromContext(r.Context()); ok {
		h.logger.Debug("Authenticated user changing password", "user_id", user.ID)
		userIDVal = &user.ID
	}
	if userIDVal == nil {
		http.Error(w, "Unauthorized: missing user context", http.StatusUnauthorized)
		return
	}
	userID := *userIDVal

	// 2. Decode Request Body into ChangePasswordRequest
	var req models.ChangePasswordRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Error("Invalid JSON in ChangePassword request", "error", err)
		http.Error(w, `{"error": "Invalid JSON", "message": "Request body contains invalid JSON"}`, http.StatusBadRequest)
		return
	}

	// 3. Validate the request struct
	if err := req.Validate(); err != nil {
		http.Error(w, "Validation error: "+err.Error(), http.StatusBadRequest)
		return
	}

	// 4. Call the Service Method
	err := h.service.ChangePassword(r.Context(), userID, req)
	if err != nil {
		h.logger.Error("Failed to change password", "error", err, "user_id", userID)
		// Provide more specific error messages based on the error *string* returned by the service
		var errorMsg string
		var statusCode int
		errStr := err.Error()
		if strings.Contains(errStr, "current password is incorrect") {
			errorMsg = "Current password is incorrect"
			statusCode = http.StatusUnauthorized
		} else if strings.Contains(errStr, "must be at least 8 characters long") {
			errorMsg = "New password must be at least 8 characters long"
			statusCode = http.StatusBadRequest
		} else if strings.Contains(errStr, "do not match") {
			errorMsg = "New password and confirmation do not match"
			statusCode = http.StatusBadRequest
		} else if strings.Contains(errStr, "user not found") {
			errorMsg = "User not found"
			statusCode = http.StatusNotFound
		} else {
			// Generic error for unexpected issues
			errorMsg = "Failed to change password"
			statusCode = http.StatusInternalServerError
		}
		http.Error(w, fmt.Sprintf(`{"error": "Bad Request", "message": "%s"}`, errorMsg), statusCode)
		return
	}

	// 5. Send Success Response (200 OK or 204 No Content)
	h.logger.Info("Password changed successfully", "user_id", userID)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK) // 200 OK or 204 No Content

	json.NewEncoder(w).Encode(models.PasswordChangeResponse{Message: "Password updated successfully"})
}

// // ForgotPassword handles the request to initiate password recovery.
// func (h *ProfileHandler) ForgotPassword(w http.ResponseWriter, r *http.Request) {
// 	// 1. Decode Request Body into ForgotPasswordRequest
// 	var req models.ForgotPasswordRequest
// 	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
// 		h.logger.Error("Invalid JSON in ForgotPassword request", "error", err)
// 		http.Error(w, `{"error": "Invalid JSON", "message": "Request body contains invalid JSON"}`, http.StatusBadRequest)
// 		return
// 	}

// 	// 2. Validate the request struct
// 	if err := req.Validate(); err != nil {
// 		http.Error(w, "Validation error: "+err.Error(), http.StatusBadRequest)
// 		return
// 	}

// 	// 3. Call the Service Method
// 	err := h.service.ForgotPassword(r.Context(), req)
// 	if err != nil {
// 		h.logger.Error("Failed to initiate password recovery", "error", err, "email", req.Email)
// 	}

// 	// 4. Send Generic Success Response (200 OK)
// 	// Regardless of whether the email exists or the email sending succeeded/failed,
// 	// return a generic message to the client to prevent enumeration attacks.
// 	h.logger.Info("Forgot password request processed", "email", req.Email)
// 	w.Header().Set("Content-Type", "application/json")
// 	w.WriteHeader(http.StatusOK) // 200 OK
// 	json.NewEncoder(w).Encode(models.ForgotPasswordResponse{Message: "If your email exists in our system, a password reset link has been sent."})
// }

// // ResetPassword handles the request to complete password recovery using a token.
// func (h *ProfileHandler) ResetPassword(w http.ResponseWriter, r *http.Request) {
// 	// 1. Decode Request Body into ResetPasswordRequest
// 	var req models.ResetPasswordRequest
// 	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
// 		h.logger.Error("Invalid JSON in ResetPassword request", "error", err)
// 		http.Error(w, `{"error": "Invalid JSON", "message": "Request body contains invalid JSON"}`, http.StatusBadRequest)
// 		return
// 	}

// 	// 2. Validate the request struct
// 	if err := req.Validate(); err != nil {
// 		http.Error(w, "Validation error: "+err.Error(), http.StatusBadRequest)
// 		return
// 	}

// 	// 3. Call the Service Method
// 	err := h.service.ResetPassword(r.Context(), req)
// 	if err != nil {
// 		h.logger.Error("Failed to reset password", "error", err, "token", req.Token)
// 		// Provide a specific error message for known errors returned by the service
// 		errStr := err.Error()
// 		if strings.Contains(errStr, "invalid or expired password reset token") {
// 			http.Error(w, `{"error": "Invalid or Expired Token", "message": "The password reset token is invalid or has expired."}`, http.StatusBadRequest)
// 			return
// 		}
// 		// For other errors (e.g., DB issues, hashing issues), return a generic error
// 		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to reset password"}`, http.StatusInternalServerError)
// 		return
// 	}

// 	// 4. Send Success Response (200 OK)
// 	h.logger.Info("Password reset successfully", "token_used", req.Token)
// 	w.Header().Set("Content-Type", "application/json")
// 	w.WriteHeader(http.StatusOK) // 200 OK
// 	json.NewEncoder(w).Encode(models.ResetPasswordResponse{Message: "Password reset successfully. Please log in."})
// }


File: internal/services/auth_service.go
================================================
package services

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"log/slog"
	"time"

	"github.com/MihoZaki/DzTech/internal/db"
	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

// AuthService handles authentication-related business logic, including JWT and refresh tokens.
type AuthService struct {
	querier     db.Querier
	userService *UserService
	cartService *CartService
	jwtSecret   []byte // Secret for access/refresh token signing
	logger      *slog.Logger
}

// NewAuthService creates a new instance of AuthService.
func NewAuthService(querier db.Querier, userService *UserService, cartService *CartService, jwtSecret string, logger *slog.Logger) *AuthService {
	return &AuthService{
		querier:     querier,
		userService: userService,
		cartService: cartService,
		jwtSecret:   []byte(jwtSecret),
		logger:      logger,
	}
}

// Login authenticates a user and returns access token, refresh token string, and user details.
func (s *AuthService) Login(ctx context.Context, email, password string, sessionID string) (*models.LoginResponse, string, error) {
	user, err := s.userService.Authenticate(ctx, email, password)
	if err != nil {
		return nil, "", err
	}
	err = s.querier.RevokeAllRefreshTokensByUserID(ctx, user.ID)
	if err != nil {
		s.logger.Error("Failed to revoke existing refresh tokens during login", "error", err, "user_id", user.ID)
	}
	accessToken, refreshTokenStr, err := s.generateTokens(ctx, user.ID, user.Email, user.IsAdmin)
	if err != nil {
		s.logger.Error("Failed to generate tokens during login", "error", err, "user_id", user.ID)
		return nil, "", fmt.Errorf("failed to generate tokens: %w", err)
	}
	if sessionID != "" {
		err = s.cartService.SyncGuestCartToUserCart(ctx, sessionID, user.ID) // Call the new method
		if err != nil {
			s.logger.Error("Failed to sync guest cart to user cart after login", "user_id", user.ID, "session_id", sessionID, "error", err)
		} else {
			s.logger.Info("Guest cart synced successfully after login", "user_id", user.ID, "session_id", sessionID)
		}
	}
	return &models.LoginResponse{
		Token: accessToken,
		User:  *user,
	}, refreshTokenStr, nil
}

// Register registers a new user and returns access token, refresh token string, and user details.
func (s *AuthService) Register(ctx context.Context, email, password, fullName string, sessionID string) (*models.LoginResponse, string, error) {
	userID, err := s.userService.Register(ctx, email, password, fullName)
	if err != nil {
		return nil, "", err
	}

	user, err := s.userService.GetByID(ctx, userID.String())
	if err != nil {
		s.logger.Error("Failed to fetch user details after registration", "error", err, "user_id", userID)
		return nil, "", fmt.Errorf("failed to fetch user details after registration: %w", err)
	}

	err = s.querier.RevokeAllRefreshTokensByUserID(ctx, user.ID)
	if err != nil {
		s.logger.Error("Failed to revoke existing refresh tokens during registration", "error", err, "user_id", user.ID)
	}
	accessToken, refreshTokenStr, err := s.generateTokens(ctx, user.ID, user.Email, user.IsAdmin)
	if err != nil {
		s.logger.Error("Failed to generate tokens during registration", "error", err, "user_id", user.ID)
		return nil, "", fmt.Errorf("failed to generate tokens: %w", err)
	}
	if sessionID != "" {
		err = s.cartService.SyncGuestCartToUserCart(ctx, sessionID, user.ID) // Call the new method
		if err != nil {
			s.logger.Error("Failed to sync guest cart to user cart after login", "user_id", user.ID, "session_id", sessionID, "error", err)
		} else {
			s.logger.Info("Guest cart synced successfully after login", "user_id", user.ID, "session_id", sessionID)
		}
	}

	return &models.LoginResponse{
		Token: accessToken,
		User:  *user,
	}, refreshTokenStr, nil
}

// Refresh exchanges a valid refresh token (received from cookie) for a new access token and refresh token.
func (s *AuthService) Refresh(ctx context.Context, refreshTokenStr string) (string, string, error) {
	s.logger.Debug("Refreshing token", "received_token_str_len", len(refreshTokenStr))

	// Hash the received token string for DB lookup comparison
	receivedTokenHash := s.hashToken(refreshTokenStr)

	// Parse the JWT to extract the JTI and verify its signature
	token, err := jwt.ParseWithClaims(refreshTokenStr, &jwt.RegisteredClaims{}, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return s.jwtSecret, nil
	})

	if err != nil || !token.Valid {
		s.logger.Warn("Invalid or malformed refresh token JWT during refresh", "error", err, "token_valid", token.Valid)
		return "", "", errors.New("invalid refresh token")
	}

	claims, ok := token.Claims.(*jwt.RegisteredClaims)
	if !ok {
		s.logger.Warn("Could not parse claims from refresh token JWT during refresh")
		return "", "", errors.New("invalid refresh token")
	}

	jti := claims.ID
	if jti == "" {
		s.logger.Warn("Missing JTI in refresh token JWT during refresh")
		return "", "", errors.New("invalid refresh token")
	}

	// Lookup DB record by JTI (this gets the stored hash)
	dbRefreshToken, err := s.querier.GetValidRefreshTokenRecord(ctx, jti)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			s.logger.Warn("Refresh token JTI not found in DB or is expired/revoked", "jti", jti)
			return "", "", errors.New("invalid or expired refresh token")
		}
		s.logger.Error("Failed to fetch refresh token record from DB", "error", err, "jti", jti)
		return "", "", fmt.Errorf("failed to validate refresh token: %w", err)
	}

	// Compare the *received token's hash* with the *stored hash*
	if receivedTokenHash != dbRefreshToken.TokenHash {
		s.logger.Warn("Refresh token hash verification failed", "jti", jti)
		return "", "", errors.New("invalid refresh token")
	}

	// --- IMMEDIATELY REVOKE THE OLD TOKEN (Token Rotation) ---
	err = s.querier.RevokeRefreshTokenByJTI(ctx, jti)
	if err != nil {
		s.logger.Warn("Could not revoke old refresh token during refresh (might be concurrent request)", "jti", jti, "error", err)
	}

	dbUser, err := s.querier.GetUser(ctx, dbRefreshToken.UserID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return "", "", errors.New("user associated with refresh token not found")
		}
		s.logger.Error("Failed to fetch user associated with refresh token", "error", err, "user_id", dbRefreshToken.UserID)
		return "", "", fmt.Errorf("failed to validate user for refresh: %w", err)
	}

	user := &models.User{
		ID:      dbUser.ID,
		Email:   dbUser.Email,
		IsAdmin: dbUser.IsAdmin,
	}

	newAccessToken, newRefreshTokenStr, err := s.generateTokens(ctx, user.ID, user.Email, user.IsAdmin)
	if err != nil {
		s.logger.Error("Failed to generate new tokens during refresh", "error", err, "user_id", user.ID)
		return "", "", fmt.Errorf("failed to generate new tokens: %w", err)
	}

	return newAccessToken, newRefreshTokenStr, nil
}

// Logout revokes the provided refresh token (received from cookie).
func (s *AuthService) Logout(ctx context.Context, refreshTokenStr string) error {
	s.logger.Debug("Logging out", "refresh_token_str_len", len(refreshTokenStr))

	// Parse the JWT to extract the JTI and verify its signature
	token, err := jwt.ParseWithClaims(refreshTokenStr, &jwt.RegisteredClaims{}, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return s.jwtSecret, nil
	})

	if err != nil || !token.Valid {
		s.logger.Warn("Invalid or malformed refresh token JWT during logout", "error", err, "token_valid", token.Valid)
		return errors.New("invalid refresh token")
	}

	claims, ok := token.Claims.(*jwt.RegisteredClaims)
	if !ok {
		s.logger.Warn("Could not parse claims from refresh token JWT during logout")
		return errors.New("invalid refresh token")
	}

	jti := claims.ID
	if jti == "" {
		s.logger.Warn("Missing JTI in refresh token JWT during logout")
		return errors.New("invalid refresh token")
	}

	// Attempt to revoke the token in the database using its JTI
	err = s.querier.RevokeRefreshTokenByJTI(ctx, jti)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			s.logger.Warn("Attempted to revoke non-existent or already revoked refresh token", "jti", jti)
			return nil // Treat as success for the client
		}
		s.logger.Error("Failed to revoke refresh token in DB", "error", err, "jti", jti)
		return fmt.Errorf("failed to revoke refresh token: %w", err)
	}

	s.logger.Info("Refresh token revoked successfully", "jti", jti)
	return nil
}

// generateTokens creates a new access token and refresh token pair.
// It stores the refresh token hash in the database using the token's JTI.
// The hash is SHA-256 of the *entire signed refresh token string*.
func (s *AuthService) generateTokens(ctx context.Context, userID uuid.UUID, email string, isAdmin bool) (accessToken, refreshTokenStr string, err error) {
	// Generate a unique JTI (JWT ID) - this will be the unique identifier for the DB record
	refreshTokenJTI := uuid.NewString()

	// Define expiry times
	accessTokenExpiry := time.Now().Add(15 * time.Minute)    // Short-lived
	refreshTokenExpiry := time.Now().Add(7 * 24 * time.Hour) // Long-lived (7 days)

	// Create the access token
	accessToken, err = s.createAccessToken(userID, email, isAdmin, accessTokenExpiry)
	if err != nil {
		return "", "", fmt.Errorf("failed to create access token: %w", err)
	}

	// Create the refresh token JWT containing the JTI and expiry
	refreshTokenClaims := jwt.RegisteredClaims{
		ID:        refreshTokenJTI,            // Use the generated JTI
		Subject:   userID.String(),            // Link to user
		Issuer:    "tech-store-backend",       // Optional: Identify the issuer
		Audience:  jwt.ClaimStrings{"client"}, // Optional: Intended audience
		ExpiresAt: &jwt.NumericDate{Time: refreshTokenExpiry},
	}
	refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshTokenClaims)
	refreshTokenStr, err = refreshToken.SignedString(s.jwtSecret) // Sign with the main app secret
	if err != nil {
		return "", "", fmt.Errorf("failed to sign refresh token: %w", err)
	}

	// Hash the *entire signed refresh token string* using SHA-256
	tokenHash := s.hashToken(refreshTokenStr)

	// Store the JTI (as identifier) and the SHA-256 hash of the *entire signed token string* in the database
	err = s.querier.CreateRefreshToken(ctx, db.CreateRefreshTokenParams{
		Jti:       refreshTokenJTI, // Store the JTI as the lookup key
		UserID:    userID,          // Link to the user
		TokenHash: tokenHash,       // Store the SHA-256 hash of the *entire signed token string*
		ExpiresAt: pgtype.Timestamptz{Time: refreshTokenExpiry, Valid: true},
	})
	if err != nil {
		s.logger.Error("Failed to store refresh token in DB", "error", err, "user_id", userID, "jti", refreshTokenJTI)
		return "", "", fmt.Errorf("failed to store refresh token: %w", err)
	}

	return accessToken, refreshTokenStr, nil
}

// hashToken creates a SHA-256 hash of the input string and returns it as a hex string.
func (s *AuthService) hashToken(token string) string {
	hasher := sha256.New()
	hasher.Write([]byte(token))
	return hex.EncodeToString(hasher.Sum(nil))
}

// createAccessToken generates the actual JWT access token string.
func (s *AuthService) createAccessToken(userID uuid.UUID, email string, isAdmin bool, expiry time.Time) (string, error) {
	claims := jwt.MapClaims{
		"user_id":  userID.String(),
		"email":    email,
		"is_admin": isAdmin,
		"exp":      expiry.Unix(),
		// Add other claims as needed
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString(s.jwtSecret)
}

// --- Error Definitions ---
var (
	ErrInvalidRefreshToken = errors.New("invalid or expired refresh token")
)


File: migrations/00006_create_order_table.sql
================================================
-- +goose Up
-- Create the 'orders' table
CREATE TABLE orders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL ,
    user_full_name VARCHAR(255) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'confirmed', 'shipped', 'delivered', 'cancelled')), -- Enum-like constraint
    total_amount_cents BIGINT NOT NULL DEFAULT 0, -- Total amount in cents
    payment_method VARCHAR(50) NOT NULL DEFAULT 'Cash on Delivery', -- Fixed for COD system
    -- payment_status VARCHAR(20) DEFAULT 'pending', -- Could add if needed later
    province VARCHAR(255) NOT NULL,
    city VARCHAR(255) NOT NULL, 
    phone_number_1 VARCHAR(255) NOT NULL,
    phone_number_2 VARCHAR(255),
    notes TEXT, -- Optional notes
    delivery_service_id UUID NOT NULL REFERENCES delivery_services(id), -- Link to delivery_services table
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    completed_at TIMESTAMP WITH TIME ZONE, -- When status becomes 'delivered' or 'cancelled' (was nullable)
    cancelled_at TIMESTAMP WITH TIME ZONE  -- When status is explicitly set to 'cancelled' (nullable)
);
 
-- Create the 'order_items' table
CREATE TABLE order_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE, -- Link to orders table
    product_id UUID NOT NULL REFERENCES products(id) ON DELETE RESTRICT, -- Link to products table, prevent deletion if ordered
    product_name VARCHAR(255) NOT NULL, -- Denormalized product name for historical accuracy
    price_cents BIGINT NOT NULL, -- Price at time of order
    quantity INTEGER NOT NULL DEFAULT 1 CHECK (quantity > 0), -- Quantity ordered
    subtotal_cents BIGINT GENERATED ALWAYS AS (price_cents * quantity) STORED, -- Computed subtotal
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for common queries
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
CREATE INDEX idx_order_items_product_id ON order_items(product_id);
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_created_at ON orders(created_at);
CREATE INDEX idx_orders_delivery_service_id ON orders(delivery_service_id); -- Add index for delivery service

-- +goose Down
DROP TABLE IF EXISTS order_items;
DROP TABLE IF EXISTS orders;


File: website/index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="src/assets/logo.jpg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>YC Informatique</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


File: website/src/components/FilterPanel.jsx
================================================
// src/components/FilterPanel.jsx
import React from "react";

const FilterPanel = (
  {
    filters,
    onFilterChange,
    onApplyFilters,
    onResetFilters,
    categories = [],
    loading = false,
  },
) => {
  return (
    <div className="bg-base-100 p-4 rounded-lg shadow-md border border-neutral-content">
      <h3 className="font-bold text-lg mb-4 ">Filters</h3>

      {/* Category Filter - Uses passed down categories */}
      <div className="mb-4">
        <label className="label">
          <span className="label-text ">Category</span>
        </label>
        <select
          className="select select-bordered w-full bg-base-100"
          value={filters.category}
          onChange={(e) => onFilterChange("category", e.target.value)}
        >
          <option value="" className="bg-base-100">
            All Categories
          </option>
          {categories.map((category) => (
            <option
              key={category.id} // Use category.id from the fetched data
              value={category.name} // Use category.name for the filter value (matches the filter logic in Products.jsx)
              className="bg-base-100"
            >
              {category.name}
            </option>
          ))}
        </select>
      </div>

      {/* Price Range Filter */}
      <div className="mb-4">
        <label className="label">
          <span className="label-text ">Price Range</span>
        </label>
        <div className="grid grid-cols-2 gap-2">
          <input
            type="number"
            placeholder="Min"
            className="input input-bordered bg-base-100  border-gray-600"
            value={filters.minPrice}
            onChange={(e) => onFilterChange("minPrice", e.target.value)}
          />
          <input
            type="number"
            placeholder="Max"
            className="input input-bordered bg-base-100  border-gray-600"
            value={filters.maxPrice}
            onChange={(e) => onFilterChange("maxPrice", e.target.value)}
          />
        </div>
      </div>

      {/* Brand Filter */}
      <div className="mb-4">
        <label className="label">
          <span className="label-text ">Brand</span>
        </label>
        <select
          className="select select-bordered w-full bg-base-100  border-gray-600"
          value={filters.brand}
          onChange={(e) => onFilterChange("brand", e.target.value)}
        >
          <option value="" className="bg-base-100">
            All Brands
          </option>
          <option value="Intel" className="bg-base-100">
            Intel
          </option>
          <option value="AMD" className="bg-base-100">
            AMD
          </option>
          <option value="NVIDIA" className="bg-base-100">
            NVIDIA
          </option>
          <option value="Samsung" className="bg-base-100">
            Samsung
          </option>
          <option value="Corsair" className="bg-base-100">
            Corsair
          </option>
        </select>
      </div>

      {/* Additional Filters */}
      <div className="mb-4">
        <label className="label cursor-pointer justify-start gap-2">
          <input
            type="checkbox"
            className="toggle toggle-primary"
            checked={filters.inStockOnly}
            onChange={(e) => onFilterChange("inStockOnly", e.target.checked)}
          />
          <span className="label-text">In Stock Only</span>
        </label>
      </div>

      <div className="mb-4">
        <label className="label cursor-pointer justify-start gap-2">
          <input
            type="checkbox"
            className="toggle toggle-primary"
            checked={filters.includeDiscountedOnly}
            onChange={(e) =>
              onFilterChange("includeDiscountedOnly", e.target.checked)}
          />
          <span className="label-text">Include Discounted Only</span>
        </label>
      </div>

      <div className="mb-4">
        <label className="label">
          <span className="label-text ">Spec Filter</span>
        </label>
        <input
          type="text"
          placeholder="Enter specifications..."
          className="input input-bordered w-full bg-base-100  border-gray-600"
          value={filters.specFilter}
          onChange={(e) => onFilterChange("specFilter", e.target.value)}
        />
      </div>

      <div className="grid grid-cols-2 gap-2 mb-2">
        <button
          className="btn btn-primary"
          onClick={onApplyFilters}
        >
          Apply Filters
        </button>
        <button
          className="btn btn-secondary btn-outline"
          onClick={onResetFilters}
        >
          Reset
        </button>
      </div>
    </div>
  );
};

export default FilterPanel;


File: website/src/pages/ProductDetail.jsx
================================================
import React, { useState } from "react";
import { Link, useParams } from "react-router-dom";
import { ArrowLeftIcon } from "@heroicons/react/24/outline";
import { useCart } from "../contexts/CartContext";
import { useAuth } from "../contexts/AuthContext"; 
import {
  fetchProductById,
  searchProducts,
  submitReview,
} from "../services/api"; // Import the API functions
import { toast } from "sonner"; // Import toast for error messages
import { StarIcon } from "@heroicons/react/24/solid"; // Import StarIcon for the rating display/form
import ProductCard from "../components/ProductCard"; // Import ProductCard
import { useQuery } from "@tanstack/react-query"; // Import useQuery

// Base URL for the backend API (adjust this for your deployment environment)
const BACKEND_BASE_URL = import.meta.env.VITE_BACKEND_BASE_URL ||
  "http://localhost:8080";

const ProductDetail = () => {
  const { id } = useParams();
  const [selectedImageIndex, setSelectedImageIndex] = useState(0); // Track the index of the selected image from the array
  const [quantity, setQuantity] = useState(1);
  const { user } = useAuth(); // Get the current user from auth context
  const [reviews, setReviews] = useState([]); // State to hold reviews
  const [newReviewRating, setNewReviewRating] = useState(0); // State for the new review's star rating
  const [isSubmittingReview, setIsSubmittingReview] = useState(false); // Loading state for review submission
  const [isAddingToCart, setIsAddingToCart] = useState(false); // Loading state for add to cart
  const { addToCart } = useCart(); // Use the context function directly

  // Function to construct full image URL
  const constructImageUrl = (imageUrl) => {
    if (!imageUrl) return "";

    // If it's already a full URL, return as is
    if (imageUrl.startsWith("http://") || imageUrl.startsWith("https://")) {
      return imageUrl;
    }

    // Otherwise, prepend the backend base URL
    return `${BACKEND_BASE_URL}${imageUrl}`;
  };

  // Fetch main product details using TanStack Query
  const {
    data: product,
    isLoading: isProductLoading,
    isError: isProductError,
    error: productError,
    refetch: refetchProduct,
  } = useQuery({
    queryKey: ["product", id],
    queryFn: () => fetchProductById(id),
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
    cacheTime: 10 * 60 * 1000, // Cache for 10 minutes
    enabled: !!id, // Only run query if id exists
    onError: (error) => {
      console.error(`Error fetching product with id ${id}:`, error);
      toast.error("Failed to load product details. Please try again later.");
    },
  });

  // Fetch related products using TanStack Query
  const {
    data: relatedProductsData,
    isLoading: isRelatedProductsLoading,
    isError: isRelatedProductsError,
    error: relatedProductsError,
  } = useQuery({
    queryKey: ["related-products", product?.category_id], // Use category_id from the main product
    queryFn: () =>
      searchProducts({
        category_id: product?.category_id,
        limit: 6,
        page: 1,
      }),
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
    cacheTime: 10 * 60 * 1000, // Cache for 10 minutes
    enabled: !!product?.category_id, // Only run query if the main product has loaded and has a category_id
    onError: (error) => {
      console.error("Error fetching related products:", error);
      toast.error("Failed to load related products. Please try again later.");
    },
  });

  // Process related products data
  const relatedProducts = React.useMemo(() => {
    if (!relatedProductsData?.data) return [];

    // Process related products to ensure image URLs are properly formatted
    return relatedProductsData.data
      .filter((p) => p.id !== id) // Filter out the current product
      .map((prod) => {
        if (prod.image_urls && prod.image_urls.length > 0) {
          prod.image_urls = prod.image_urls.map((url) =>
            constructImageUrl(url)
          );
        }
        return prod;
      });
  }, [relatedProductsData, id, constructImageUrl]);

  const handleAddToCart = async () => { // Make function async
    if (product) {
      setIsAddingToCart(true);
      try {
        // Prepare the product object to pass to the context function
        // The context function will handle the API call via TanStack Query
        const productToAdd = {
          ...product,
          quantity: quantity, // Use the selected quantity
          image: product.image_urls && product.image_urls.length > 0
            ? constructImageUrl(product.image_urls[0])
            : "", // Use the constructed image URL
          // The context will handle price calculation internally based on the product object
        };

        // Call the context function which uses TanStack Query
        await addToCart(productToAdd);

        toast.success(`"${product.name}" added to cart!`); // Show success toast using product.name
      } catch (error) {
        // Errors are now handled within the CartContext mutation
        // But we can still catch here if needed for UI-specific logic
        console.error("Failed to add item to cart:", error);
        toast.error("Failed to add item to cart. Please try again."); // Show error toast
      } finally {
        setIsAddingToCart(false);
      }
    }
  };

  // Handler for submitting a new review
  const handleReviewSubmit = async (e) => {
    e.preventDefault();
    if (!user) {
      toast.error("Please log in to submit a rating.");
      return;
    }
    if (newReviewRating <= 0) {
      toast.error("Please select a rating.");
      return;
    }

    setIsSubmittingReview(true);
    try {
      // Call the actual API to submit the review
      await submitReview(product.id, newReviewRating);
      toast.success("Rating submitted successfully!");

      // Refetch the product to get updated ratings
      const updatedProduct = await refetchProduct();
      const newProductData = updatedProduct.data;

      // Update local state if refetch was successful
      if (newProductData) {
        setReviews([]); // Reset reviews if needed, or handle as per your logic
      }

      // Reset the form
      setNewReviewRating(0);
    } catch (error) {
      console.error("Error submitting rating:", error);
      toast.error("Failed to submit rating. Please try again.");
    } finally {
      setIsSubmittingReview(false);
    }
  };

  // Calculate the current image source based on the selected index and the product's image_urls
  const currentImageSrc = React.useMemo(() => {
    if (
      !product || !product.image_urls || !product.image_urls[selectedImageIndex]
    ) {
      return ""; // Fallback to empty string if no images
    }
    return product.image_urls[selectedImageIndex];
  }, [product, selectedImageIndex]);

  // --- Determine Pricing Information ---
  const hasDiscount = product?.has_active_discount &&
    product?.discounted_price_cents !== undefined;
  const currentPrice = hasDiscount
    ? product?.discounted_price_cents / 100
    : product?.price_cents / 100; // Convert cents to dollars
  const originalPrice = hasDiscount ? product?.price_cents / 100 : null; // Convert cents to dollars
  const discountPercentage = hasDiscount
    ? product?.effective_discount_percentage
    : 0;
  // --- End of Determination ---

  // --- Determine Rating Information ---
  const hasRatings = product?.num_ratings && product.num_ratings > 0;
  const avgRating = hasRatings ? (product?.avg_rating || 0) : 0;
  const numRatings = product?.num_ratings || 0;
  // --- End of Determination ---

  if (isProductLoading) {
    return (
      <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
        <div className="skeleton h-96 w-full mb-6 bg-base-200"></div>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
          <div>
            <div className="skeleton h-8 w-3/4 mb-4 bg-base-200"></div>
            <div className="skeleton h-4 w-full mb-2 bg-base-200"></div>
            <div className="skeleton h-4 w-5/6 mb-6 bg-base-200"></div>
            <div className="skeleton h-12 w-full bg-base-200"></div>
          </div>
          <div>
            <div className="skeleton h-64 w-full bg-base-200"></div>
          </div>
        </div>
      </div>
    );
  }

  if (isProductError) {
    return (
      <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen flex items-center justify-center">
        <div className="text-center">
          <p className="text-xl mb-4 text-error">
            Error loading product:{" "}
            {productError.message || "An unknown error occurred"}
          </p>
          <button
            className="btn btn-primary"
            onClick={() => refetchProduct()} // Retry function
          >
            Retry
          </button>
          <Link to="/products" className="btn btn-accent btn-outline">
            Back to Products
          </Link>
        </div>
      </div>
    );
  }

  // If product is loaded but is null/empty (not found)
  if (!product) {
    return (
      <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
        <p className="text-center text-error">Product not found.</p>
        <Link to="/products" className="btn btn-primary">Back to Products</Link>
      </div>
    );
  }

  // Determine the list of images to display in the thumbnail gallery
  const imageGalleryList = product.image_urls || []; // Use image_urls array, fallback to empty array if none

  return (
    <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
      {/* Updated Link with btn-sm */}
      <Link to="/products" className="btn btn-accent btn-outline mb-6">
        <ArrowLeftIcon className="h-4 w-4 mr-2" />
        Back to Products
      </Link>

      <div className="divider"></div>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
        {/* Image Gallery */}
        <div>
          <div className="aspect-square mb-4 bg-base-100 rounded-lg p-4">
            <img
              src={currentImageSrc} // Use the image source determined by state/index
              alt={`${product.name} - Image ${selectedImageIndex + 1}`} // Provide better alt text using product.name
              className="w-full h-full object-contain rounded-lg"
            />
          </div>
          {/* Thumbnail Strip */}
          <div className="flex flex-wrap gap-2 mt-2 max-h-32 overflow-y-auto">
            {/* Added flex-wrap and scrollable container */}
            {imageGalleryList.map((imgUrl, index) => (
              <button
                key={index} // Use the array index as the key
                className={`w-16 h-16 border rounded ${
                  selectedImageIndex === index
                    ? "border-primary ring-2 ring-primary"
                    : "border-transparent"
                } bg-base-200 flex-shrink-0`} // Highlight selected image
                onClick={() => setSelectedImageIndex(index)} // Update selected index on click
                title={`View Image ${index + 1}`} // Tooltip for clarity
              >
                <img
                  src={imgUrl}
                  alt={`Thumbnail ${index + 1}`}
                  className="w-full h-full object-cover rounded pointer-events-none"
                />{" "}
                {/* pointer-events-none prevents interaction with img itself */}
              </button>
            ))}
          </div>
        </div>

        {/* Product Info */}
        <div>
          <h1 className="text-3xl font-bold mb-4">{product.name}</h1>{" "}
          {/* Use product.name */}
          <div className="flex items-center gap-2 mb-4">
            <span className="text-2xl font-bold text-primary">
              DA {currentPrice?.toFixed(2) ?? "0.00"}{" "}
              {/* Use currentPrice and convert to DA */}
            </span>
            {/* Show original price if there's a discount */}
            {hasDiscount && originalPrice && (
              <>
                <span className="line-through text-gray-500">
                  DA {originalPrice.toFixed(2)}
                </span>
                <span className="badge badge-success bg-green-600 text-white">
                  -{discountPercentage.toFixed(0)}%
                </span>
              </>
            )}
          </div>

          {/* Rating Display */}
          <div className="flex items-center gap-1 mb-4">
            <StarIcon className="h-4 w-4 text-yellow-400 fill-current" />
            <span className="text-sm">
              {hasRatings ? avgRating.toFixed(2) : "No ratings"} ({numRatings}
              {" "}
              reviews)
            </span>
          </div>

          {/* Short Description */}
          <p className="text-gray-600 mb-4">
            {product.description ||
              product.short_description || "No description available."}
          </p>

          {/* Old-style specs table */}
          <div className="mb-6">
            <table className="table table-zebra bg-base-100">
              <tbody>
                <tr>
                  <td>Category</td>
                  <td>{product.category}</td>
                </tr>
                <tr>
                  <td>Brand</td>
                  <td>{product.brand}</td>
                </tr>
                <tr>
                  <td>Stock Quantity</td>
                  <td
                    className={product.stock_quantity > 0
                      ? "text-success"
                      : "text-error"}
                  >
                    {product.stock_quantity > 0
                      ? `${product.stock_quantity} In Stock`
                      : "Out of Stock"}
                  </td>
                </tr>
                <tr>
                  <td>Avg Rating</td>
                  <td>
                    {hasRatings ? avgRating.toFixed(2) : "N/A"} ({numRatings}
                    {" "}
                    reviews)
                  </td>
                </tr>
              </tbody>
            </table>
          </div>

          {/* Add to Cart Section */}
          <div className="flex items-center gap-4 mb-6">
            <div className="flex items-center">
              <button
                className="btn btn-sm"
                onClick={() => setQuantity(Math.max(1, quantity - 1))}
                disabled={isAddingToCart} // Disable when adding to cart
              >
                -
              </button>
              <span className="mx-2">{quantity}</span>
              <button
                className="btn btn-sm"
                onClick={() => setQuantity(quantity + 1)}
                disabled={isAddingToCart} // Disable when adding to cart
              >
                +
              </button>
            </div>
            <button
              className="btn btn-primary flex-1"
              onClick={handleAddToCart}
              disabled={isAddingToCart} // Disable when adding to cart
            >
              {isAddingToCart
                ? (
                  <>
                    <span className="loading loading-spinner loading-xs mr-2">
                    </span>
                    Adding...
                  </>
                )
                : (
                  "Add to Cart"
                )}
            </button>
          </div>

          {/* Reviews Section (Stars Only, Repositioned) */}
          <div className="mb-8">
            <h3 className="text-lg font-bold mb-2">Rate this Product</h3>
            {user
              ? (
                <form onSubmit={handleReviewSubmit}>
                  <div className="flex space-x-1 mb-2">
                    {[1, 2, 3, 4, 5].map((star) => (
                      <button
                        key={star}
                        type="button"
                        className={`text-xl ${
                          star <= newReviewRating
                            ? "text-yellow-400 fill-current"
                            : "text-gray-300"
                        }`}
                        onClick={() => setNewReviewRating(star)}
                      >
                        <StarIcon className="h-6 w-6" />
                      </button>
                    ))}
                  </div>
                  <button
                    type="submit"
                    className="btn btn-sm btn-primary"
                    disabled={isSubmittingReview || newReviewRating <= 0}
                  >
                    {isSubmittingReview
                      ? (
                        <>
                          <span className="loading loading-spinner loading-xs mr-2">
                          </span>
                          Submitting...
                        </>
                      )
                      : (
                        "Submit Rating"
                      )}
                  </button>
                </form>
              )
              : (
                <p className="text-sm text-gray-500">
                  Log in to rate this product.
                </p>
              )}
          </div>

          <div className="divider"></div>
          <h2 className="text-2xl content-center font-bold mb-4">
            Specifications
          </h2>
          <div className="bg-base-100 p-4 rounded-box border border-base-200">
            <table className="table table-zebra">
              <tbody>
                {product.spec_highlights &&
                  Object.entries(product.spec_highlights).map((
                    [key, value],
                  ) => (
                    <tr key={key}>
                      <td className="font-semibold capitalize">
                        {key.replace(/_/g, " ")}
                      </td>{" "}
                      {/* Format key */}
                      <td>{value}</td>
                    </tr>
                  ))}
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <div className="divider"></div>
      {/* Related Products */}
      <div className="mt-12">
        <h2 className="text-2xl font-bold mb-6">Related Products</h2>
        {isRelatedProductsLoading
          ? (
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
              {[...Array(4)].map((_, i) => (
                <div key={i} className="card bg-base-100 shadow-xl">
                  <div className="skeleton h-48 w-full"></div>
                  <div className="card-body">
                    <div className="skeleton h-4 w-3/4 mb-2"></div>
                    <div className="skeleton h-4 w-full mb-2"></div>
                    <div className="skeleton h-4 w-1/2 mb-4"></div>
                    <div className="skeleton h-8 w-full"></div>
                  </div>
                </div>
              ))}
            </div>
          )
          : isRelatedProductsError
          ? (
            <div className="text-center py-8">
              <p className="text-error">Failed to load related products.</p>
              <button
                className="btn btn-sm mt-2"
                onClick={() => relatedProductsData.refetch()} // Retry function for related products
              >
                Retry
              </button>
            </div>
          )
          : relatedProducts.length > 0
          ? (
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
              {relatedProducts.map((relatedProduct) => (
                <ProductCard key={relatedProduct.id} product={relatedProduct} />
              ))}
            </div>
          )
          : (
            <p className="text-center text-gray-500">
              No related products found.
            </p>
          )}
      </div>
    </div>
  );
};

export default ProductDetail;


File: website/src/pages/Auth.jsx
================================================
import React, { useEffect, useState } from "react"; // Import useEffect
import { useAuth } from "../contexts/AuthContext";
import { useNavigate } from "react-router-dom"; // useNavigate is a hook, typically used inside components
import { toast } from "sonner";
import heroBackgroundImage from "../assets/heroBackgroundImage.png";

const AuthPage = () => {
  const [isLogin, setIsLogin] = useState(true); // Toggle between login and signup
  const [formData, setFormData] = useState({
    email: "",
    password: "",
    name: "",
  }); // Include name for signup
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const { login, register, user } = useAuth(); // Get register function as well
  const navigate = useNavigate(); // Get navigate function from hook

  useEffect(() => {
    if (user) {
      navigate("/"); // Perform navigation
    }
  }, [user, navigate]); // Dependency array: run effect if 'user' or 'navigate' changes

  const handleChange = (e) => {
    setFormData({ ...formData, [e.target.name]: e.target.value });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(""); // Clear previous errors
    setIsLoading(true);

    try {
      // Simple validation (add more as needed)
      if (!formData.email || !formData.password) {
        setError("Email and password are required.");
        setIsLoading(false);
        return;
      }

      if (!isLogin && !formData.name.trim()) {
        setError("Name is required for signup.");
        setIsLoading(false);
        return;
      }

      if (isLogin) {
        // Login attempt
        await login({
          email: formData.email,
          password: formData.password,
        });
        toast.success("Logged in successfully!");
      } else {
        // Registration attempt
        await register({
          email: formData.email,
          password: formData.password,
          full_name: formData.name.trim(),
        });
        toast.success("Account created successfully!");
      }

      // Navigate to appropriate page after successful auth
      // This navigate call is inside an event handler (handleSubmit), which is correct
      navigate("/account");
    } catch (error) {
      console.error(isLogin ? "Login" : "Registration", "error:", error);

      // Try to get error message from response
      let errorMessage = isLogin
        ? "Login failed. Please try again."
        : "Registration failed. Please try again.";

      if (error.response) {
        // Server responded with error status
        if (error.response.data && error.response.data.message) {
          errorMessage = error.response.data.message;
        } else if (error.response.status === 401) {
          errorMessage = "Invalid email or password.";
        } else if (error.response.status === 409) {
          errorMessage = "Email already exists. Please use a different email.";
        }
      } else if (error.request) {
        // Request was made but no response received
        errorMessage = "Network error. Please check your connection.";
      }

      setError(errorMessage);
      toast.error(errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  // Conditional rendering based on user state is fine in the render function
  // But navigation must happen in useEffect
  if (user) {
    // You can choose to return null here if you want the component to disappear immediately
    // after navigation is triggered, or just let the rest of the component render.
    // Often, the navigate() call itself is sufficient and the component will unmount
    // as the router switches to the new route.
    // For clarity, returning null is acceptable if you don't want any UI shown after nav.
    return null; // Don't render anything if user is already logged in and navigation is triggered
  }

  return (
    <div
      className="relative w-full px-4 py-8 min-h-screen flex items-center justify-center"
      style={{
        backgroundImage: `url(${heroBackgroundImage})`, // Use the imported variable
        backgroundSize: "cover",
        backgroundPosition: "center",
      }}
    >
      <div className="absolute w-full min-h-screen bg-base-300/50" />
      <div className="card bg-base-100 w-full max-w-md shadow-xl border border-base-200">
        <div className="card-body">
          <h2 className="card-title text-2xl mb-4">
            {isLogin ? "Login" : "Sign Up"}
          </h2>

          {error && <div className="alert alert-error mb-4">{error}</div>}

          <form onSubmit={handleSubmit}>
            {!isLogin && ( // Show name field only for signup
              <div className="form-control">
                <label className="label">
                  <span className="label-text">Full Name</span>
                </label>
                <input
                  type="text"
                  name="name"
                  placeholder="Enter your full name"
                  className="input input-bordered"
                  value={formData.name}
                  onChange={handleChange}
                  disabled={isLoading}
                />
              </div>
            )}
            <div className="form-control">
              <label className="label">
                <span className="label-text">Email</span>
              </label>
              <input
                type="email"
                name="email"
                placeholder="email@example.com"
                className="input input-bordered"
                value={formData.email}
                onChange={handleChange}
                disabled={isLoading}
              />
            </div>
            <div className="form-control mt-2">
              <label className="label">
                <span className="label-text">Password</span>
              </label>
              <input
                type="password"
                name="password"
                placeholder="Enter your password"
                className="input input-bordered"
                value={formData.password}
                onChange={handleChange}
                disabled={isLoading}
              />
            </div>
            <div className="form-control mt-6">
              <button
                type="submit"
                className={`btn btn-primary ${isLoading ? "loading" : ""}`}
                disabled={isLoading}
              >
                {isLoading
                  ? (
                    <>
                      <span className="loading loading-spinner loading-xs mr-2">
                      </span>
                      {isLogin ? "Logging in..." : "Signing up..."}
                    </>
                  )
                  : (
                    isLogin ? "Log In" : "Sign Up"
                  )}
              </button>
            </div>
          </form>

          <div className="divider my-4">OR</div>

          <div className="text-center">
            <p className="text-sm">
              {isLogin ? "Don't have an account?" : "Already have an account?"}
              {" "}
              <button
                onClick={() => setIsLogin(!isLogin)}
                className="link link-primary"
                disabled={isLoading}
              >
                {isLogin ? "Sign Up" : "Log In"}
              </button>
            </p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default AuthPage;


File: website/src/contexts/CartContext.jsx
================================================
import React, { createContext, useContext, useState } from "react";
import { useStore } from "../stores/useStore";
import {
  addItemToCart,
  clearUserCart,
  fetchUserCart,
  removeCartItem,
  updateCartItem,
} from "../services/api";
import { toast } from "sonner";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query"; // Import TanStack Query hooks

// Import the auth context to listen for changes
import { useAuth } from "../contexts/AuthContext";

const BACKEND_BASE_URL = import.meta.env.VITE_BACKEND_BASE_URL ||
  "http://localhost:8080";

const CartContext = createContext();

export const CartProvider = ({ children }) => {
  const queryClient = useQueryClient(); // Get the query client instance
  const { cart: localCart } = useStore(); // We might still use the local store for optimistic updates if desired
  const { user, isAuthenticated } = useAuth(); // Get auth context

  // Function to construct full image URL
  const constructImageUrl = (imageUrl) => {
    if (!imageUrl) return "";

    // If it's already a full URL, return as is
    if (imageUrl.startsWith("http://") || imageUrl.startsWith("https://")) {
      return imageUrl;
    }

    // Otherwise, prepend the backend base URL
    return `${BACKEND_BASE_URL}${imageUrl}`;
  };

  const cartQueryKey = isAuthenticated ? ["cart", user?.id] : ["cart", "guest"];

  // 1. QUERY TO FETCH CART DATA FROM THE API
  const {
    data: backendCartData = { items: [], total_amount_cents: 0 }, // Default value to prevent errors
    isLoading: isCartLoading,
    isError: isCartError,
    error: cartError,
    refetch: refetchCart,
  } = useQuery({
    queryKey: cartQueryKey, // Use the dynamic key
    queryFn: () => fetchUserCart(), // API function to fetch cart (relies on session cookie for guests)
    enabled: true, // Enable for both authed and unauthed now
    staleTime: 0, // Data becomes stale immediately, forcing refetch on invalidation
    cacheTime: 5 * 60 * 1000, // Cache for 5 minutes
    onError: (error) => {
      console.error("Error fetching cart:", error);
      // Optionally show a toast error here if it's a persistent issue
      // toast.error("Failed to load cart. Please try again.");
    },
  });

  // Process backend data for UI consumption (similar to syncCartWithBackend logic)
  const processedCart = React.useMemo(() => {
    if (!backendCartData.items || !Array.isArray(backendCartData.items)) {
      return [];
    }
    return backendCartData.items.map((cartItem) => {
      const product = cartItem.product;
      const unitPrice = product.final_price_cents / 100; // Use product's final price

      // Construct full image URL
      const fullImageUrl = product.image_urls && product.image_urls.length > 0
        ? constructImageUrl(product.image_urls[0])
        : "";

      return {
        id: product.id,
        name: product.name,
        price: unitPrice, // This is the final/discounted price
        original_price_cents: product.original_price_cents, // Preserve original price
        final_price_cents: product.final_price_cents, // Preserve final price
        image: fullImageUrl, // Use the constructed full image URL
        quantity: cartItem.quantity, // Use the quantity from backend
        cart_item_id: cartItem.id, // Store the backend cart item ID
        brand: product.brand,
        stock_quantity: product.stock_quantity,
        has_active_discount: product.has_active_discount,
      };
    });
  }, [backendCartData, constructImageUrl]);

  // Calculate totals based on processed cart data from the query
  const { subtotal, total } = React.useMemo(() => {
    let sub = 0;
    processedCart.forEach((item) => {
      const price = typeof item.price === "number"
        ? item.price
        : parseFloat(item.price);
      const quantity = typeof item.quantity === "number"
        ? item.quantity
        : parseInt(item.quantity);
      if (!isNaN(price) && !isNaN(quantity)) {
        sub += price * quantity;
      }
    });
    return { subtotal: sub, total: sub }; // Assuming total equals subtotal
  }, [processedCart]);

  // 2. MUTATION TO ADD AN ITEM TO THE CART
  const addCartItemMutation = useMutation({
    mutationFn: ({ productId, quantity }) => addItemToCart(productId, quantity),
    onSuccess: () => {
      // Invalidate and refetch the cart query to get the updated data from the backend
      // Use the current query key to invalidate the correct cache entry
      queryClient.invalidateQueries({ queryKey: cartQueryKey });
      toast.success("Item added to cart!"); // Show success toast
    },
    onError: (error) => {
      console.error("Error adding item to cart:", error);
      const errorMessage = error?.response?.data?.message || error.message ||
        "Failed to add item to cart. Please try again.";
      toast.error(errorMessage); // Show error toast
    },
  });

  // 3. MUTATION TO UPDATE ITEM QUANTITY IN THE CART
  const updateQuantityMutation = useMutation({
    mutationFn: ({ cartItemId, quantity }) =>
      updateCartItem(cartItemId, quantity),
    onSuccess: () => {
      // Invalidate and refetch the cart query to get the updated data from the backend
      queryClient.invalidateQueries({ queryKey: cartQueryKey });
      toast.success("Quantity updated!"); // Show success toast
    },
    onError: (error) => {
      console.error("Error updating quantity:", error);
      const errorMessage = error?.response?.data?.message || error.message ||
        "Failed to update quantity. Please try again.";
      toast.error(errorMessage); // Show error toast
    },
  });

  // 4. MUTATION TO REMOVE AN ITEM FROM THE CART
  const removeCartItemMutation = useMutation({
    mutationFn: (cartItemId) => removeCartItem(cartItemId),
    onSuccess: () => {
      // Invalidate and refetch the cart query to get the updated data from the backend
      queryClient.invalidateQueries({ queryKey: cartQueryKey });
      toast.success("Item removed from cart!"); // Show success toast
    },
    onError: (error) => {
      console.error("Error removing item from cart:", error);
      const errorMessage = error?.response?.data?.message || error.message ||
        "Failed to remove item from cart. Please try again.";
      toast.error(errorMessage); // Show error toast
    },
  });

  // 5. MUTATION TO CLEAR THE ENTIRE CART
  const clearCartMutation = useMutation({
    mutationFn: () => clearUserCart(),
    onSuccess: () => {
      // Invalidate and refetch the cart query to get the updated (empty) data from the backend
      queryClient.invalidateQueries({ queryKey: cartQueryKey });
      toast.success("Cart cleared!"); // Show success toast
    },
    onError: (error) => {
      console.error("Error clearing cart:", error);
      const errorMessage = error?.response?.data?.message || error.message ||
        "Failed to clear cart. Please try again.";
      toast.error(errorMessage); // Show error toast
    },
  });

  // Define functions that wrap the mutations for easier use in components
  const addToCart = async (product) => {
    addCartItemMutation.mutate({
      productId: product.id,
      quantity: product.quantity || 1,
    });
  };

  const updateQuantity = async (productId, newQuantity) => {
    // Find the cart_item_id associated with the product ID
    const cartItem = processedCart.find((item) => item.id === productId);
    if (cartItem) {
      updateQuantityMutation.mutate({
        cartItemId: cartItem.cart_item_id,
        quantity: newQuantity,
      });
    } else {
      console.error(
        `Cart item with product ID ${productId} not found for update.`,
      );
      toast.error("Item not found in cart for update.");
    }
  };

  const removeFromCart = async (productId) => {
    // Find the cart_item_id associated with the product ID
    const cartItem = processedCart.find((item) => item.id === productId);
    if (cartItem) {
      removeCartItemMutation.mutate(cartItem.cart_item_id);
    } else {
      console.error(
        `Cart item with product ID ${productId} not found for removal.`,
      );
      toast.error("Item not found in cart for removal.");
    }
  };

  const clearCart = async () => {
    clearCartMutation.mutate();
  };

  // Function to manually refresh the cart
  const refreshCart = () => {
    refetchCart();
  };

  // Construct the context value
  const contextValue = {
    cart: processedCart, // Use the cart data from the query
    addToCart,
    removeFromCart,
    updateQuantity,
    clearCart,
    refreshCart,
    subtotal,
    total,
    isLoading: isCartLoading, // Use loading state from the query
    isError: isCartError, // Expose error state if needed
    error: cartError, // Expose error details if needed
    // Expose mutation statuses if needed for granular control in UI
    isAddingItem: addCartItemMutation.isPending,
    isUpdatingQuantity: updateQuantityMutation.isPending,
    isRemovingItem: removeCartItemMutation.isPending,
    isClearingCart: clearCartMutation.isPending,
    isAuthenticated, // Expose auth status to components if needed for logic
  };

  return (
    <CartContext.Provider value={contextValue}>
      {children}
    </CartContext.Provider>
  );
};

export const useCart = () => {
  const context = useContext(CartContext);
  if (!context) throw new Error("useCart must be used within CartProvider");
  return context;
};


File: website/eslint.config.js
================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])


File: dashboard/public/vite.svg
================================================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

File: dashboard/src/components/FileUploadField.jsx
================================================
import React from "react";
import { useController } from "react-hook-form";
import { MinusIcon, PhotoIcon } from "@heroicons/react/24/outline";

const FileUploadField = (
  { name, control, rules, accept = "image/*", multiple = true },
) => {
  const {
    field: { onChange, value, onBlur },
    fieldState: { error },
  } = useController({
    name,
    control,
    rules,
    defaultValue: [],
  });

  const [localFiles, setLocalFiles] = React.useState(value || []);

  React.useEffect(() => {
    if (value && Array.isArray(value)) {
      setLocalFiles(value);
    } else {
      setLocalFiles([]);
    }
  }, [value]);

  const handleFileChange = (event) => {
    const newFiles = Array.from(event.target.files);
    if (newFiles.length === 0) return;

    const updatedLocalFiles = [...localFiles, ...newFiles];
    setLocalFiles(updatedLocalFiles);
    console.log("Files to be set:", updatedLocalFiles); // Debug log
    onChange(updatedLocalFiles);
  };

  const removeFile = (indexToRemove) => {
    const updatedLocalFiles = localFiles.filter((_, index) =>
      index !== indexToRemove
    );
    setLocalFiles(updatedLocalFiles);
    onChange(updatedLocalFiles);
  };

  const clearAllFiles = () => {
    setLocalFiles([]);
    onChange([]);
  };

  return (
    <div className="space-y-2">
      <label className="flex flex-col items-center justify-center w-full sm:w-64 h-48 border-2 border-dashed border-base-300 rounded-lg cursor-pointer bg-base-100 hover:bg-base-200">
        <PhotoIcon className="w-12 h-12 text-gray-400" />
        <span className="text-sm text-center mt-2">Click to Upload</span>
        <input
          type="file"
          multiple={multiple}
          accept={accept}
          className="hidden"
          onChange={handleFileChange}
          onBlur={onBlur}
        />
      </label>

      {localFiles.length > 0 && (
        <div className="flex-1 w-full">
          <div className="flex justify-between items-center mb-1">
            <p className="text-sm text-gray-500">
              Selected files ({localFiles.length}):
            </p>
            <button
              type="button"
              className="btn btn-xs btn-outline text-error"
              onClick={clearAllFiles}
            >
              Clear All
            </button>
          </div>
          <ul className="space-y-1">
            {localFiles.map((file, index) => (
              <li
                key={`${file.name}-${index}`}
                className="flex items-center justify-between bg-base-200 p-2 rounded text-sm"
              >
                <span className="truncate flex-1 mr-2">{file.name}</span>
                <button
                  type="button"
                  className="btn btn-xs btn-outline btn-error"
                  onClick={() => removeFile(index)}
                >
                  <MinusIcon className="w-3 h-3" />
                </button>
              </li>
            ))}
          </ul>
        </div>
      )}
      {error && <p className="text-red-500 text-xs">{error.message}</p>}
    </div>
  );
};

export default FileUploadField;


File: dashboard/src/pages/auth/AuthPage.jsx
================================================
import React from "react";
import { Navigate, Route, Routes } from "react-router-dom";
import LoginPage from "./LoginPage"; // Create this
import SignupPage from "./SigupPage"; // Create this

const AuthPage = () => {
  return (
    <div className="hero min-h-screen bg-base-200">
      <div className="hero-content flex-col">
        {/* Add your logo or branding here if needed */}
        <Routes>
          <Route path="/" element={<Navigate to="login" replace />} />
          <Route path="login" element={<LoginPage />} />
          <Route path="signup" element={<SignupPage />} />
        </Routes>
      </div>
    </div>
  );
};

export default AuthPage;


File: dashboard/src/pages/discounts/AddDiscount.jsx
================================================
// src/pages/discounts/AddDiscount.jsx
import React from "react";
import { Link, useNavigate } from "react-router-dom";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { createDiscount } from "../../services/api";
import { ArrowLeftIcon } from "@heroicons/react/24/outline";
import { toast } from "sonner";

// Define the Zod schema for validation based on DB/API schema
// Adjust regex for YYYY-MM-DDTHH:mm format (as provided by datetime-local)
const dateTimeLocalRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/;

const addDiscountSchema = z.object({
  code: z.string().min(1, { message: "Code is required." }),
  description: z.string().optional(), // Optional
  discount_type: z.enum(["percentage", "fixed"], { // Use 'fixed' as per DB schema
    errorMap: () => ({ message: "Invalid discount type." }),
  }),
  discount_value: z.number().min(0, {
    message: "Discount value must be zero or positive.",
  }), // Use number
  valid_from: z.string().regex(dateTimeLocalRegex, {
    message: "Invalid date format for Valid From (expected YYYY-MM-DDTHH:mm).",
  }),
  valid_until: z.string().regex(dateTimeLocalRegex, {
    message: "Invalid date format for Valid Until (expected YYYY-MM-DDTHH:mm).",
  }),
  is_active: z.boolean(), // Add back is_active
  // Removed: name, target_type, target_id, min_order_value_cents, max_uses (assuming not part of direct API call for create/update)
});

const AddDiscount = () => {
  const navigate = useNavigate();
  const queryClient = useQueryClient();

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm({
    resolver: zodResolver(addDiscountSchema),
    defaultValues: {
      code: "",
      description: "",
      discount_type: "percentage", // Default type
      discount_value: 0, // Default value
      valid_from: new Date().toISOString().slice(0, 16),
      valid_until: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
        .slice(0, 16),
      is_active: true, // Default to active
    },
  });

  const createDiscountMutation = useMutation({
    mutationFn: createDiscount,
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["discounts"] });
      toast.success("Discount created successfully!");
      navigate("/admin/discounts"); // Redirect back to the list
    },
    onError: (error) => {
      console.error("Create Error:", error);
      toast.error(
        `Failed to create discount: ${error.message || "Unknown error"}`,
      );
    },
  });

  const onSubmit = (data) => {
    console.log("Submitting Add Discount Data:", data);

    const validFromDate = new Date(data.valid_from).toISOString();
    const validUntilDate = new Date(data.valid_until).toISOString();
    // Prepare data for API call
    // discount_value is already a number if parsed correctly by react-hook-form
    // valid_from and valid_until are already strings in ISO format
    const submitData = {
      code: data.code.trim(), // Ensure no leading/trailing spaces
      description: data.description?.trim() || null, // Send null if empty string
      discount_type: data.discount_type,
      discount_value: data.discount_value, // Should be a number
      valid_from: validFromDate,
      valid_until: validUntilDate,
      is_active: data.is_active, // Include is_active
      // Do not include name, target_type, target_id, min_order_value_cents, max_uses
    };
    createDiscountMutation.mutate(submitData);
  };

  return (
    <div className="bg-neutral p-6 rounded-lg shadow-md max-w-4xl mx-auto">
      <Link to="/admin/discounts" className="btn btn-ghost btn-sm mb-6">
        <ArrowLeftIcon className="h-4 w-4 mr-2" />
        Back to Discounts
      </Link>

      <h2 className="text-xl font-bold mb-6">Add New Discount</h2>

      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div className="form-control">
            <label className="label">
              <span className="label-text">Code *</span>
            </label>
            <input
              type="text"
              className={`input input-bordered ${
                errors.code ? "input-error" : ""
              }`}
              placeholder="Enter discount code (e.g., SAVE10)..."
              {...register("code")}
            />
            {errors.code && (
              <label className="label">
                <span className="label-text-alt text-error">
                  {errors.code.message}
                </span>
              </label>
            )}
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Description</span>
            </label>
            <textarea
              className={`textarea textarea-bordered ${
                errors.description ? "textarea-error" : ""
              }`}
              placeholder="Enter discount description..."
              rows="2"
              {...register("description")}
            >
            </textarea>
            {errors.description && (
              <label className="label">
                <span className="label-text-alt text-error">
                  {errors.description.message}
                </span>
              </label>
            )}
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Discount Type *</span>
            </label>
            <select
              className={`select select-bordered ${
                errors.discount_type ? "select-error" : ""
              }`}
              {...register("discount_type")}
            >
              <option value="percentage">Percentage</option>
              <option value="fixed">Fixed Amount</option>
            </select>
            {errors.discount_type && (
              <label className="label">
                <span className="label-text-alt text-error">
                  {errors.discount_type.message}
                </span>
              </label>
            )}
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Discount Value *</span>
            </label>
            <input
              type="number"
              step="0.01" // Allow decimal values for percentages or fixed amounts in cents
              min="0"
              className={`input input-bordered ${
                errors.discount_value ? "input-error" : ""
              }`}
              placeholder="Enter discount value..."
              {...register("discount_value", { valueAsNumber: true })}
            />
            {errors.discount_value && (
              <label className="label">
                <span className="label-text-alt text-error">
                  {errors.discount_value.message}
                </span>
              </label>
            )}
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Valid From *</span>
            </label>
            <input
              type="datetime-local"
              className={`input input-bordered ${
                errors.valid_from ? "input-error" : ""
              }`}
              {...register("valid_from")}
            />
            {errors.valid_from && (
              <label className="label">
                <span className="label-text-alt text-error">
                  {errors.valid_from.message}
                </span>
              </label>
            )}
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Valid Until *</span>
            </label>
            <input
              type="datetime-local"
              className={`input input-bordered ${
                errors.valid_until ? "input-error" : ""
              }`}
              {...register("valid_until")}
            />
            {errors.valid_until && (
              <label className="label">
                <span className="label-text-alt text-error">
                  {errors.valid_until.message}
                </span>
              </label>
            )}
          </div>

          {/* Add is_active toggle */}
          <div className="form-control md:col-span-2">
            <label className="label cursor-pointer justify-between">
              <span className="label-text">Active *</span>
              <input
                type="checkbox"
                className="toggle toggle-primary"
                {...register("is_active")}
              />
            </label>
          </div>
        </div>

        <div className="form-control mt-6">
          <button
            type="submit"
            className="btn btn-primary"
            disabled={createDiscountMutation.isPending}
          >
            {createDiscountMutation.isPending
              ? (
                <>
                  <span className="loading loading-spinner loading-xs mr-2">
                  </span>{" "}
                  Creating...
                </>
              )
              : "Create Discount"}
          </button>
        </div>
      </form>
    </div>
  );
};

export default AddDiscount;


File: dashboard/src/pages/products/EditProduct.jsx
================================================
// src/pages/products/EditProduct.jsx
import React, { useEffect, useRef } from "react"; // Add useRef
import { useNavigate, useParams } from "react-router-dom";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useFieldArray, useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { toast } from "sonner";
import {
  ArrowLeftIcon,
  MinusIcon,
  PhotoIcon,
  PlusIcon,
} from "@heroicons/react/24/outline";
import FileUploadField from "../../components/FileUploadField";
// --- CORRECTED IMPORT ---
import {
  fetchProductById,
  updateProductDetailsAndImages, // Import the new function
} from "../../services/api";

// Define a schema for individual spec pairs
const specPairSchema = z.object({
  key: z.string().min(1, { message: "Key is required." }),
  value: z.string().min(1, { message: "Value is required." }),
});

// Schema for editing product details (excluding image file objects themselves, as they are handled separately for updates)
const editProductSchema = z.object({
  name: z.string().min(2, { message: "Name must be at least 2 characters." }),
  description: z.string().optional(),
  short_description: z.string().optional(),
  price_cents: z.number().int().positive({
    message: "Price (in cents) must be a positive integer.",
  }),
  stock_quantity: z.number().int().gte(0, {
    message: "Stock quantity cannot be negative.",
  }),
  status: z.enum(["active", "draft", "discontinued"], {
    message: "Status must be active, draft, or discontinued.",
  }),
  brand: z.string().min(1, { message: "Brand is required." }),
  category_id: z.string().uuid({
    message: "Category ID must be a valid UUID.",
  }),
  spec_highlights: z.array(specPairSchema).optional(), // Optional array of pairs
  images: z.array(z.instanceof(File)).optional(),
});

const EditProduct = () => {
  const { id: productId } = useParams();
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const fileUploadRef = useRef(); // Create ref for FileUploadField

  // In EditProduct.jsx, update the useQuery hook
  const {
    data: product,
    isLoading: productLoading,
    isError: productError,
    error: productFetchError,
    isFetching,
  } = useQuery({
    queryKey: ["product", productId],
    queryFn: () => fetchProductById(productId),
    select: (response) => {
      return response.data; // Keep the original return
    },
    enabled: !!productId,
  });
  // Define the update mutation for product details AND images using PATCH
  const updateProductMutation = useMutation({
    mutationFn: ({ id, formData }) =>
      updateProductDetailsAndImages(id, formData), // Use the new function
    onSuccess: (updatedData) => {
      console.log("Product updated successfully:", updatedData);
      toast.success("Product updated successfully!");
      queryClient.invalidateQueries({ queryKey: ["product", productId] });
      queryClient.invalidateQueries({ queryKey: ["products"] });
      navigate("/admin/products");
    },
    onError: (error) => {
      console.error("Update Product Error:", error);
      let errorMessage = "Failed to update product.";
      if (error.response?.data?.message) {
        errorMessage = error.response.data.message;
      } else if (error.message) {
        errorMessage = error.message;
      }
      toast.error(errorMessage);
    },
  });

  const {
    register,
    control,
    handleSubmit,
    formState: { errors },
    reset,
    setValue,
  } = useForm({
    resolver: zodResolver(editProductSchema),
    defaultValues: {
      name: "",
      description: "",
      short_description: "",
      price_cents: 0,
      stock_quantity: 0,
      status: "draft",
      brand: "",
      category_id: "",
      spec_highlights: [],
    },
  });

  const { fields, append, remove } = useFieldArray({
    control,
    name: "spec_highlights",
  });

  // Pre-populate the form when product data is loaded
  useEffect(() => {
    if (product) {
      console.log("Pre-populating form with product ", product);
      reset({
        name: product.name,
        description: product.description,
        short_description: product.short_description,
        price_cents: product.price_cents,
        stock_quantity: product.stock_quantity,
        status: product.status,
        brand: product.brand,
        category_id: product.category_id,
        spec_highlights: Object.entries(product.spec_highlights || {}).map((
          [key, value],
        ) => ({ key, value })),
      });
    }
  }, [product, reset]);

  const onSubmit = async (data) => {
    console.log("Submitting Edit Product Data (from RHF):", data); // Log the whole data object

    const formData = new FormData();

    // Append updated details fields to FormData
    Object.entries(data).forEach(([key, value]) => {
      // IMPORTANT: Exclude the file array field ('new_images') from this loop
      // as it needs special handling below.
      if (key !== "spec_highlights" && key !== "images") {
        formData.append(key, value);
      }
    });

    // Append spec_highlights as a JSON string to FormData
    if (data.spec_highlights && data.spec_highlights.length > 0) {
      const specHighlightsObj = data.spec_highlights.reduce((obj, pair) => {
        obj[pair.key] = pair.value;
        return obj;
      }, {});
      formData.append("spec_highlights", JSON.stringify(specHighlightsObj));
    }

    // --- GET NEW IMAGES FROM THE RHF DATA OBJECT ---
    const newImageFiles = data.images; // Get files directly from the RHF data object

    if (
      newImageFiles && Array.isArray(newImageFiles) && newImageFiles.length > 0
    ) {
      newImageFiles.forEach((file, index) => {
        // Append using the field name expected by the backend ('images')
        formData.append("images", file, file.name); // Append each file individually under the 'images' key
      });
    } else {
    }

    // Submit the combined FormData using the PATCH mutation
    updateProductMutation.mutate({ id: productId, formData });

    // No need for separate details/images promises as it's one request now
  };

  // --- STATE CHECKS AND RENDERING ---
  // Check if the ID was provided in the URL
  if (!productId) {
    return (
      <div className="alert alert-warning">
        <p>Error: Product ID not found in URL.</p>
        <button onClick={() => navigate(-1)} className="btn btn-sm mt-2">
          Go Back
        </button>
      </div>
    );
  }

  // Check loading state - this handles the initial fetch
  if (productLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  }

  // Check error state after loading attempt
  if (productError) {
    console.error("Error fetching product:", productFetchError); // Log the error object
    return (
      <div className="alert alert-error">
        <p>Error loading product: {productFetchError.message}</p>
        <button onClick={() => navigate(-1)} className="btn btn-sm mt-2">
          Go Back
        </button>
      </div>
    );
  }

  // If the query ran successfully but returned no data (e.g., 404 from server), product might be undefined
  // Check if product data exists after loading and error checks
  if (!product) {
    // This case might occur if the query succeeded (status 200) but returned an empty response,
    // or if the select function returned undefined.
    // More commonly, a 404 would trigger the error state above.
    // But let's handle it just in case.
    console.warn("Product data is undefined after successful fetch attempt.");
    return (
      <div className="alert alert-warning">
        <p>Product not found or data unavailable.</p>
        <button onClick={() => navigate(-1)} className="btn btn-sm mt-2">
          Go Back
        </button>
      </div>
    );
  }

  // Construct the backend base URL for displaying existing images
  const BACKEND_BASE_URL = import.meta.env.VITE_BACKEND_BASE_URL ||
    "http://localhost:8080";

  // Render the form once data is loaded
  return (
    <div className="bg-neutral p-6 rounded-lg shadow-md max-w-4xl mx-auto border border-secondary">
      <div className="flex items-center mb-6">
        <button onClick={() => navigate(-1)} className="btn btn-ghost btn-sm">
          <ArrowLeftIcon className="w-5 h-5" />
        </button>
        <h2 className="text-xl font-bold ml-2">
          Edit Product: {product?.name}
        </h2>
      </div>

      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
        {/* Name */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Name *</span>
          </label>
          <input
            type="text"
            className={`input input-bordered ${
              errors.name ? "input-error" : ""
            }`}
            {...register("name")}
          />
          {errors.name && (
            <p className="text-red-500 text-xs">{errors.name.message}</p>
          )}
        </div>

        {/* Description */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Description</span>
          </label>
          <textarea
            className={`textarea textarea-bordered ${
              errors.description ? "textarea-error" : ""
            }`}
            rows="3"
            {...register("description")}
          >
          </textarea>
          {errors.description && (
            <p className="text-red-500 text-xs">{errors.description.message}</p>
          )}
        </div>

        {/* Short Description */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Short Description</span>
          </label>
          <input
            type="text"
            className={`input input-bordered ${
              errors.short_description ? "input-error" : ""
            }`}
            {...register("short_description")}
          />
          {errors.short_description && (
            <p className="text-red-500 text-xs">
              {errors.short_description.message}
            </p>
          )}
        </div>

        {/* Price (in cents) */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Price (in cents) *</span>
          </label>
          <input
            type="number"
            min="0"
            className={`input input-bordered ${
              errors.price_cents ? "input-error" : ""
            }`}
            {...register("price_cents", { valueAsNumber: true })}
          />
          {errors.price_cents && (
            <p className="text-red-500 text-xs">{errors.price_cents.message}</p>
          )}
        </div>

        {/* Stock Quantity */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Stock Quantity *</span>
          </label>
          <input
            type="number"
            min="0"
            className={`input input-bordered ${
              errors.stock_quantity ? "input-error" : ""
            }`}
            {...register("stock_quantity", { valueAsNumber: true })}
          />
          {errors.stock_quantity && (
            <p className="text-red-500 text-xs">
              {errors.stock_quantity.message}
            </p>
          )}
        </div>

        {/* Status */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Status *</span>
          </label>
          <select
            className={`select select-bordered ${
              errors.status ? "select-error" : ""
            }`}
            {...register("status")}
          >
            <option value="active">Active</option>
            <option value="draft">Draft</option>
            <option value="discontinued">Discontinued</option>
          </select>
          {errors.status && (
            <p className="text-red-500 text-xs">{errors.status.message}</p>
          )}
        </div>

        {/* Brand */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Brand *</span>
          </label>
          <input
            type="text"
            className={`input input-bordered ${
              errors.brand ? "input-error" : ""
            }`}
            {...register("brand")}
          />
          {errors.brand && (
            <p className="text-red-500 text-xs">{errors.brand.message}</p>
          )}
        </div>

        {/* Category ID */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Category *</span>
          </label>
          <select
            className={`select select-bordered ${
              errors.category_id ? "select-error" : ""
            }`}
            {...register("category_id")}
          >
            <option value={product?.category_id}>
              {product?.category_name || "Loading..."}
            </option>
          </select>
          {errors.category_id && (
            <p className="text-red-500 text-xs">{errors.category_id.message}</p>
          )}
        </div>

        {/* Spec Highlights (Dynamic Form) */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Specification Highlights</span>
          </label>
          <div className="space-y-2">
            <button
              type="button"
              className="btn btn-xs btn-outline btn-secondary mb-2"
              onClick={() => append({ key: "", value: "" })}
            >
              <PlusIcon className="w-4 h-4 mr-1" /> Add Spec
            </button>
            {fields.map((field, index) => (
              <div key={field.id} className="flex gap-2 items-center">
                <input
                  type="text"
                  placeholder="Key (e.g., Processor)"
                  className={`input input-bordered input-sm flex-1 ${
                    errors.spec_highlights?.[index]?.key ? "input-error" : ""
                  }`}
                  {...register(`spec_highlights.${index}.key`)}
                />
                <input
                  type="text"
                  placeholder="Value (e.g., Intel i7)"
                  className={`input input-bordered input-sm flex-1 ${
                    errors.spec_highlights?.[index]?.value ? "input-error" : ""
                  }`}
                  {...register(`spec_highlights.${index}.value`)}
                />
                <button
                  type="button"
                  className="btn btn-xs btn-outline btn-error"
                  onClick={() =>
                    remove(index)}
                >
                  <MinusIcon className="w-4 h-4" />
                </button>
              </div>
            ))}
            {errors.spec_highlights && (
              <p className="text-red-500 text-xs">
                At least one spec is required and keys/values cannot be blank.
              </p>
            )}
          </div>
        </div>

        {/* Existing Images Display */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Current Images</span>
          </label>
          <div className="bg-base-200 p-4 rounded">
            {product?.image_urls && product.image_urls.length > 0
              ? (
                <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2">
                  {/* Grid for thumbnails */}
                  {product.image_urls.map((url, idx) => {
                    const fullUrl = `${BACKEND_BASE_URL}${url}`;
                    return (
                      <div key={idx} className="avatar">
                        <div className="mask mask-squircle w-16 h-16">
                          {/* Smaller thumbnail size */}
                          <img
                            src={fullUrl}
                            alt={`Current product image ${idx + 1}`}
                            className="object-cover w-full h-full" // Cover the avatar area
                            onError={(e) => {
                              e.target.src =
                                "https://placehold.co/60x60?text=Err  "; // Fallback on error
                            }}
                          />
                        </div>
                      </div>
                    );
                  })}
                </div>
              )
              : (
                <p className="text-sm text-gray-500 italic">
                  No images currently uploaded.
                </p>
              )}
          </div>
        </div>

        {/* Image Replacement Field */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">
              Replace Images (Multiple allowed)
            </span>
          </label>
          <FileUploadField
            name="images"
            control={control}
            accept="image/*"
            multiple={true}
          />
          <p className="text-sm text-gray-500 mt-1">
            Select new images to replace the current set.
          </p>
        </div>

        {/* Submit Buttons */}
        <div className="form-control mt-6">
          <div className="flex gap-2">
            <button
              type="submit"
              className="btn btn-primary flex-1"
              disabled={updateProductMutation.isPending} // Disable based on the single mutation
            >
              {updateProductMutation.isPending
                ? (
                  <>
                    <span className="loading loading-spinner loading-xs mr-2">
                    </span>{" "}
                    Saving...
                  </>
                )
                : "Save Changes"}
            </button>
            <button
              type="button"
              className="btn btn-ghost"
              onClick={() => navigate(-1)} // Go back without saving
            >
              Cancel
            </button>
          </div>
        </div>
      </form>
    </div>
  );
};

export default EditProduct;


File: dashboard/src/pages/categories/EditCategory.jsx
================================================
import React from "react";
import { Link, useNavigate, useParams } from "react-router-dom";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { fetchCategoryById, updateCategory } from "../../services/api";
import { ArrowLeftIcon } from "@heroicons/react/24/outline";
import { toast } from "sonner";

const editCategorySchema = z.object({
  name: z.string().min(1, { message: "Name is required." }),
  type: z.string().min(1, { message: "Type is required." }),
});

const EditCategory = () => {
  const { id: categoryId } = useParams();
  const navigate = useNavigate();
  const queryClient = useQueryClient();

  const {
    data: category,
    isLoading: categoryLoading,
    isError: categoryError,
    error: categoryFetchError,
  } = useQuery({
    queryKey: ["category", categoryId],
    queryFn: () => fetchCategoryById(categoryId),
    select: (response) => response.data.data,
    enabled: !!categoryId,
  });

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset, // Use reset to populate form with fetched data
  } = useForm({
    resolver: zodResolver(editCategorySchema),
    defaultValues: {
      name: "",
      type: "",
    },
  });

  // Prefill form when data is loaded
  React.useEffect(() => {
    if (category) {
      reset({
        name: category.name,
        type: category.type,
      });
    }
  }, [category, reset]);

  const updateCategoryMutation = useMutation({
    mutationFn: ({ id, data }) => updateCategory(id, data), // Adjust mutation function signature
    onSuccess: (data, variables) => { // Use variables to get the ID
      queryClient.invalidateQueries({ queryKey: ["category", variables.id] });
      queryClient.invalidateQueries({ queryKey: ["categories"] });
      toast.success("Category updated successfully!");
      navigate("/admin/categories"); // Redirect back to the list
    },
    onError: (error) => {
      console.error("Update Error:", error);
      toast.error(
        `Failed to update category: ${error.message || "Unknown error"}`,
      );
    },
  });

  const onSubmit = (data) => {
    console.log("Submitting Edit Category Data:", data);
    updateCategoryMutation.mutate({ id: categoryId, data }); // Pass id and data object
  };

  if (categoryLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  }

  if (categoryError) {
    return (
      <div className="alert alert-error">
        Error loading category: {categoryFetchError.message}
        <Link to="/admin/categories" className="btn btn-sm ml-4">
          Go Back to List
        </Link>
      </div>
    );
  }

  if (!category) {
    return (
      <div className="alert alert-warning">
        Category not found.
        <Link to="/admin/categories" className="btn btn-sm ml-4">
          Go Back to List
        </Link>
      </div>
    );
  }

  return (
    <div className="bg-neutral p-6 rounded-lg shadow-md max-w-2xl mx-auto">
      <Link to="/admin/categories" className="btn btn-ghost btn-sm mb-6">
        <ArrowLeftIcon className="h-4 w-4 mr-2" />
        Back to Categories
      </Link>

      <h2 className="text-xl font-bold mb-6">Edit Category: {category.name}</h2>

      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
        <div className="form-control">
          <label className="label">
            <span className="label-text">Name *</span>
          </label>
          <input
            type="text"
            className={`input input-bordered ${
              errors.name ? "input-error" : ""
            }`}
            placeholder="Enter category name..."
            {...register("name")}
          />
          {errors.name && (
            <label className="label">
              <span className="label-text-alt text-error">
                {errors.name.message}
              </span>
            </label>
          )}
        </div>

        <div className="form-control">
          <label className="label">
            <span className="label-text">Type *</span>
          </label>
          <input
            type="text"
            className={`input input-bordered ${
              errors.type ? "input-error" : ""
            }`}
            placeholder="Enter category type..."
            {...register("type")}
          />
          {errors.type && (
            <label className="label">
              <span className="label-text-alt text-error">
                {errors.type.message}
              </span>
            </label>
          )}
        </div>

        <div className="form-control mt-6">
          <div className="flex gap-2">
            <button
              type="submit"
              className="btn btn-primary flex-1"
              disabled={updateCategoryMutation.isPending}
            >
              {updateCategoryMutation.isPending
                ? (
                  <>
                    <span className="loading loading-spinner loading-xs mr-2">
                    </span>{" "}
                    Saving...
                  </>
                )
                : "Save Changes"}
            </button>
            <button
              type="button"
              className="btn btn-ghost"
              onClick={() => navigate(-1)} // Go back
            >
              Cancel
            </button>
          </div>
        </div>
      </form>
    </div>
  );
};

export default EditCategory;


File: dashboard/src/assets/react.svg
================================================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

File: cmd/server/main.go
================================================
package main

import (
	"log/slog"
	"os"

	"github.com/MihoZaki/DzTech/internal/config"
	"github.com/MihoZaki/DzTech/internal/server"
)

func main() {
	// Configure structured logging
handler := slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
		Level: slog.LevelDebug, // Or get from config/env var
	})
	logger := slog.New(handler)
	slog.SetDefault(logger) // Set the global logger

	// Load configuration
	cfg := config.LoadConfig()

	// Create and start server
	srv := server.New(cfg)

	if err := srv.Start(); err != nil {
		slog.Error("Server failed to start", "error", err)
		os.Exit(1)
	}
}


File: internal/router/router.go
================================================
package router

import (
	"log/slog"
	"net/http"

	"github.com/MihoZaki/DzTech/db"
	"github.com/MihoZaki/DzTech/internal/config"
	db_queries "github.com/MihoZaki/DzTech/internal/db" // SQLC generated code
	"github.com/MihoZaki/DzTech/internal/handlers"
	"github.com/MihoZaki/DzTech/internal/middleware"
	"github.com/MihoZaki/DzTech/internal/services"
	"github.com/MihoZaki/DzTech/internal/storage"
	"github.com/go-chi/chi/v5"
	"github.com/redis/go-redis/v9"
)

func New(cfg *config.Config, redisClient *redis.Client) http.Handler {

	r := chi.NewRouter()

	// Apply middleware
	middleware.ApplyMiddleware(r)

	// Health check endpoint
	r.Get("/health", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("OK"))
	})
	// Get the database pool from the db package
	pool := db.GetPool()
	if pool == nil {
		slog.Error("Database pool is not initialized")
		panic("database pool is not initialized")
	}

	// --- Initialize Storage Client ---
	localStoragePath := "./uploads"
	localPublicPath := "/uploads"
	allowedTypes := []string{"image/jpeg", "image/png", "image/gif", "image/webp"}
	maxFileSize := int64(10 * 1024 * 1024) // 10MB

	storer := storage.NewLocalStorage(localStoragePath, localPublicPath, allowedTypes, maxFileSize)
	r.Handle(localPublicPath+"/*", http.StripPrefix(localPublicPath, http.FileServer(http.Dir(localStoragePath))))

	// Initialize database querier
	querier := db_queries.New(pool)

	// Initialize services
	userService := services.NewUserService(querier) // Initialize services (add redisClient if needed in constructor)
	productService := services.NewProductService(querier, storer, redisClient, slog.Default())
	cartService := services.NewCartService(querier, productService, slog.Default())
	orderService := services.NewOrderService(querier, pool, cartService, redisClient, productService, slog.Default())
	authService := services.NewAuthService(querier, userService, cartService, cfg.JWTSecret, slog.Default())
	deliveryService := services.NewDeliveryServiceService(querier, slog.Default())
	adminUserService := services.NewAdminUserService(querier, slog.Default())
	reviewService := services.NewReviewService(querier, pool, slog.Default())
	discountService := services.NewDiscountService(querier, redisClient, slog.Default())
	categoryService := services.NewCategoryService(querier, redisClient, slog.Default())
	analyticsService := services.NewAnalyticsService(querier, redisClient, slog.Default())

	// Initialize handlers
	authHandler := handlers.NewAuthHandler(authService)
	productHandler := handlers.NewProductHandler(productService)
	adminProductHandler := handlers.NewProductHandler(productService)
	adminOrderHandler := handlers.NewOrderHandler(orderService, slog.Default())
	adminDeliveryHandler := handlers.NewDeliveryServiceHandler(deliveryService, slog.Default())
	cartHandler := handlers.NewCartHandler(cartService, productService, slog.Default())
	orderHandler := handlers.NewOrderHandler(orderService, slog.Default())
	deliveryOptionsHandler := handlers.NewDeliveryOptionsHandler(deliveryService, slog.Default())
	adminUserHandler := handlers.NewAdminUserHandler(adminUserService, slog.Default())
	reviewHandler := handlers.NewReviewHandler(reviewService, slog.Default())
	discountHandler := handlers.NewDiscountHandler(discountService, slog.Default())
	categoryHandler := handlers.NewCategoryHandler(categoryService, slog.Default())
	analyticsHandler := handlers.NewAnalyticsHandler(analyticsService, slog.Default())
	profileHandler := handlers.NewProfileHandler(userService, slog.Default())

	// Create sub-routers
	authRouter := chi.NewRouter()
	authHandler.RegisterRoutes(authRouter)
	// Register password recovery routes on the auth router (public)
	// profileHandler.RegisterAuthRoutes(authRouter) // Adds /forgot-password, /reset-password under /api/v1/auth

	analyticsRouter := chi.NewRouter()
	analyticsHandler.RegisterRoutes(analyticsRouter)

	productRouter := chi.NewRouter()
	productRouter.Get("/", productHandler.ListAllProducts)
	productRouter.Get("/{id}", productHandler.GetProduct)
	productRouter.Get("/search", productHandler.SearchProducts)
	productRouter.Get("/categories", productHandler.ListCategories)
	productRouter.Get("/categories/{id}", productHandler.GetCategory)

	guestRouter := chi.NewRouter()
	orderHandler.RegisterGuestRoutes(guestRouter)

	adminRouter := chi.NewRouter()
	adminRouter.Use(middleware.JWTMiddleware(cfg))
	adminRouter.Use(middleware.RequireAdmin)
	adminRouter.Route("/products", func(r chi.Router) {
		adminProductHandler.RegisterRoutes(r)
	})
	adminRouter.Route("/orders", func(r chi.Router) {
		adminOrderHandler.RegisterAdminRoutes(r)
	})
	adminRouter.Route("/delivery-services", func(r chi.Router) {
		adminDeliveryHandler.RegisterRoutes(r)
	})
	adminRouter.Route("/users", func(r chi.Router) {
		adminUserHandler.RegisterRoutes(r)
	})
	adminRouter.Route("/discounts", func(r chi.Router) {
		discountHandler.RegisterRoutes(r)
	})
	adminRouter.Route("/categories", func(r chi.Router) {
		categoryHandler.RegisterRoutes(r)
	})
	adminRouter.Route("/analytics", func(r chi.Router) {
		analyticsHandler.RegisterRoutes(r)
	})

	// Create user-specific sub-router (protected)
	userRouter := chi.NewRouter()
	userRouter.Use(middleware.JWTMiddleware(cfg)) // Apply JWT middleware to user routes
	profileHandler.RegisterRoutes(userRouter)

	cartRouter := chi.NewRouter()
	cartRouter.Use(middleware.JWTMiddleware(cfg))
	cartHandler.RegisterRoutes(cartRouter)

	orderRouter := chi.NewRouter()
	orderRouter.Use(middleware.JWTMiddleware(cfg))
	orderHandler.RegisterUserRoutes(orderRouter)

	deliveryOptionsRouter := chi.NewRouter()
	deliveryOptionsRouter.Use(middleware.JWTMiddleware(cfg))
	deliveryOptionsHandler.RegisterRoutes(deliveryOptionsRouter)

	reviewRouter := chi.NewRouter()
	reviewRouter.Use(middleware.JWTMiddleware(cfg))
	reviewHandler.RegisterRoutes(reviewRouter)

	// Mount sub-routers
	r.Mount("/api/v1/auth", authRouter)
	r.Mount("/api/v1/products", productRouter)
	r.Mount("/api/v1/admin", adminRouter)
	r.Mount("/api/v1/user", userRouter)
	r.Mount("/api/v1/cart", cartRouter)
	r.Mount("/api/v1/orders", orderRouter)
	r.Mount("/api/v1/delivery-options", deliveryOptionsRouter)
	r.Mount("/api/v1/reviews", reviewRouter)
	r.Mount("/api/v1/checkout", guestRouter)

	slog.Info("Router initialized")
	return r
}


File: internal/db/cart.sql.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cart.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addCartItemsBulk = `-- name: AddCartItemsBulk :execrows

INSERT INTO cart_items (cart_id, product_id, quantity, created_at, updated_at)
SELECT 
  $1, -- $1: The target cart ID
  input.product_id,
  input.quantity, -- Use the new requested quantity
  NOW(),
  NOW()
FROM (
  -- Prepare input data using UNNEST
  SELECT 
    UNNEST($2::uuid[]) as product_id, -- $2: Array of product IDs
    UNNEST($3::int[]) as quantity      -- $3: Array of corresponding quantities
) as input
INNER JOIN products p ON p.id = input.product_id
  AND p.stock_quantity >= input.quantity -- Ensure sufficient stock for the NEW quantity during INSERT
  AND p.status = 'active'
  AND p.deleted_at IS NULL
ON CONFLICT (cart_id, product_id)
DO UPDATE SET
  quantity = CASE
    -- If the existing row in cart_items was soft-deleted, check stock and set to NEW quantity
    WHEN cart_items.deleted_at IS NOT NULL THEN
      CASE
        -- Re-check stock against the NEW quantity being added via EXCLUDED (the values that would have been inserted)
        WHEN (SELECT stock_quantity FROM products WHERE id = EXCLUDED.product_id) >= EXCLUDED.quantity THEN
          EXCLUDED.quantity -- Set to the NEW quantity from the INSERT attempt (overwrites old soft-deleted quantity)
        ELSE
          -- If stock check fails for the new quantity, keep the old soft-deleted quantity.
          -- Alternatively, could raise an exception depending on desired behavior.
          cart_items.quantity
      END
    -- If the existing row was NOT soft-deleted, add the new quantity and check total against stock
    ELSE
      LEAST(
        cart_items.quantity + EXCLUDED.quantity, -- Add the new quantity
        (SELECT stock_quantity FROM products WHERE id = EXCLUDED.product_id) -- Cap at product's stock
      )
  END,
  -- Undelete the item if it was soft-deleted, otherwise leave its status unchanged
  deleted_at = CASE
    WHEN cart_items.deleted_at IS NOT NULL THEN NULL -- Undelete
    ELSE cart_items.deleted_at -- Keep as is
  END,
  updated_at = NOW()
`

type AddCartItemsBulkParams struct {
	CartID     uuid.UUID   `json:"cart_id"`
	ProductIds []uuid.UUID `json:"product_ids"`
	Quantities []int32     `json:"quantities"`
}

// Include deleted_at to see if undeletion happened
// Adds multiple items to a cart, handling upserts and soft deletes.
// Checks stock availability for each item during the insert/update process.
// Join with products table to validate existence, status, deletion, and stock for the INSERT
func (q *Queries) AddCartItemsBulk(ctx context.Context, arg AddCartItemsBulkParams) (int64, error) {
	result, err := q.db.Exec(ctx, addCartItemsBulk, arg.CartID, arg.ProductIds, arg.Quantities)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const clearCart = `-- name: ClearCart :exec
UPDATE cart_items
SET deleted_at = NOW()
WHERE cart_id = $1
`

func (q *Queries) ClearCart(ctx context.Context, cartID uuid.UUID) error {
	_, err := q.db.Exec(ctx, clearCart, cartID)
	return err
}

const createCartItem = `-- name: CreateCartItem :one
INSERT INTO cart_items (cart_id, product_id, quantity, created_at, updated_at)
SELECT
    $1, -- $1
    $2, -- $2
    $3, -- $3
    NOW(),
    NOW()
FROM products
WHERE id = $2 -- Check product exists
    AND stock_quantity >= $3 -- Ensure enough stock for the INSERT
    AND status = 'active'
    AND deleted_at IS NULL
ON CONFLICT (cart_id, product_id)
DO UPDATE SET
    quantity = CASE
        WHEN cart_items.deleted_at IS NOT NULL THEN
            -- If the existing row was soft-deleted, check stock for the NEW requested quantity
            CASE
                WHEN (SELECT stock_quantity FROM products WHERE id = $2) >= $3 THEN
                    $3 -- Set to the NEW requested quantity if stock allows
                ELSE
                    -- Keep old quantity if stock check fails here
                    cart_items.quantity
            END
        ELSE
            -- If the existing row was NOT soft-deleted, add the new quantity and check total against stock
            LEAST(
                cart_items.quantity + $3, -- Add new quantity
                (SELECT stock_quantity FROM products WHERE id = $2) -- Cap at stock
            )
    END,
    deleted_at = CASE
        WHEN cart_items.deleted_at IS NOT NULL THEN NULL -- Undelete if it was soft-deleted
        ELSE cart_items.deleted_at -- Keep deleted_at if it wasn't soft-deleted
    END,
    updated_at = NOW()
RETURNING
    id,
    cart_id,
    product_id,
    quantity,
    created_at,
    updated_at,
    deleted_at
`

type CreateCartItemParams struct {
	CartID    uuid.UUID `json:"cart_id"`
	ProductID uuid.UUID `json:"product_id"`
	Quantity  int32     `json:"quantity"`
}

// Cart Item Management
func (q *Queries) CreateCartItem(ctx context.Context, arg CreateCartItemParams) (CartItem, error) {
	row := q.db.QueryRow(ctx, createCartItem, arg.CartID, arg.ProductID, arg.Quantity)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.ProductID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createGuestCart = `-- name: CreateGuestCart :one
INSERT INTO carts (session_id, created_at, updated_at, deleted_at) -- Only session_id in the INSERT
VALUES ($1, NOW(), NOW(), NULL) -- Uses sqlc.arg(session_id)
RETURNING id, user_id, session_id, created_at, updated_at, deleted_at
`

func (q *Queries) CreateGuestCart(ctx context.Context, sessionID *string) (Cart, error) {
	row := q.db.QueryRow(ctx, createGuestCart, sessionID)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createUserCart = `-- name: CreateUserCart :one
INSERT INTO carts (user_id, created_at, updated_at, deleted_at) -- Only user_id in the INSERT
VALUES ($1, NOW(), NOW(), NULL) -- Uses sqlc.arg(user_id)
RETURNING id, user_id, session_id, created_at, updated_at, deleted_at
`

// Cart Management
func (q *Queries) CreateUserCart(ctx context.Context, userID uuid.UUID) (Cart, error) {
	row := q.db.QueryRow(ctx, createUserCart, userID)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteCart = `-- name: DeleteCart :exec
UPDATE carts
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteCart(ctx context.Context, cartID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCart, cartID)
	return err
}

const deleteCartItem = `-- name: DeleteCartItem :exec
UPDATE cart_items
SET deleted_at = NOW()
WHERE id = $1
`

// Cart Cleanup
func (q *Queries) DeleteCartItem(ctx context.Context, itemID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCartItem, itemID)
	return err
}

const getCartByID = `-- name: GetCartByID :one
SELECT
    id,
    user_id,
    session_id,
    created_at,
    updated_at
FROM carts
WHERE id = $1 AND deleted_at IS NULL
`

type GetCartByIDRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	SessionID *string            `json:"session_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCartByID(ctx context.Context, cartID uuid.UUID) (GetCartByIDRow, error) {
	row := q.db.QueryRow(ctx, getCartByID, cartID)
	var i GetCartByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartBySessionID = `-- name: GetCartBySessionID :one
SELECT
    id,
    user_id,
    session_id,
    created_at,
    updated_at
FROM carts
WHERE session_id = $1 AND deleted_at IS NULL
`

type GetCartBySessionIDRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	SessionID *string            `json:"session_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCartBySessionID(ctx context.Context, sessionID *string) (GetCartBySessionIDRow, error) {
	row := q.db.QueryRow(ctx, getCartBySessionID, sessionID)
	var i GetCartBySessionIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartByUserID = `-- name: GetCartByUserID :one
SELECT
    id,
    user_id,
    session_id,
    created_at,
    updated_at
FROM carts
WHERE user_id = $1 AND deleted_at IS NULL
`

type GetCartByUserIDRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	SessionID *string            `json:"session_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCartByUserID(ctx context.Context, userID uuid.UUID) (GetCartByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getCartByUserID, userID)
	var i GetCartByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartItemByCartAndProduct = `-- name: GetCartItemByCartAndProduct :one
SELECT
    id,
    cart_id,
    product_id,
    quantity,
    created_at,
    updated_at
FROM cart_items
WHERE cart_id = $1 AND product_id = $2
`

type GetCartItemByCartAndProductParams struct {
	CartID    uuid.UUID `json:"cart_id"`
	ProductID uuid.UUID `json:"product_id"`
}

type GetCartItemByCartAndProductRow struct {
	ID        uuid.UUID          `json:"id"`
	CartID    uuid.UUID          `json:"cart_id"`
	ProductID uuid.UUID          `json:"product_id"`
	Quantity  int32              `json:"quantity"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCartItemByCartAndProduct(ctx context.Context, arg GetCartItemByCartAndProductParams) (GetCartItemByCartAndProductRow, error) {
	row := q.db.QueryRow(ctx, getCartItemByCartAndProduct, arg.CartID, arg.ProductID)
	var i GetCartItemByCartAndProductRow
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.ProductID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartItemByID = `-- name: GetCartItemByID :one
SELECT
    id,
    cart_id,
    product_id,
    quantity,
    created_at,
    updated_at
FROM cart_items
WHERE id = $1
`

type GetCartItemByIDRow struct {
	ID        uuid.UUID          `json:"id"`
	CartID    uuid.UUID          `json:"cart_id"`
	ProductID uuid.UUID          `json:"product_id"`
	Quantity  int32              `json:"quantity"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCartItemByID(ctx context.Context, itemID uuid.UUID) (GetCartItemByIDRow, error) {
	row := q.db.QueryRow(ctx, getCartItemByID, itemID)
	var i GetCartItemByIDRow
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.ProductID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartItemsCount = `-- name: GetCartItemsCount :one

SELECT COUNT(*) AS num_cart_items
FROM cart_items
WHERE cart_id = $1 AND deleted_at IS NULL
`

// Update the timestamp
// Counts the number of active (non-deleted) items in a specific cart.
func (q *Queries) GetCartItemsCount(ctx context.Context, cartID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getCartItemsCount, cartID)
	var num_cart_items int64
	err := row.Scan(&num_cart_items)
	return num_cart_items, err
}

const getCartItemsWithProductDetails = `-- name: GetCartItemsWithProductDetails :many
SELECT
    ci.id,
    ci.cart_id,
    ci.product_id,
    ci.quantity,
    ci.created_at,
    ci.updated_at,
    p.name as product_name,
    p.price_cents as product_price_cents,
    p.stock_quantity as product_stock_quantity,
    p.image_urls as product_image_urls,
    p.brand as product_brand
FROM cart_items ci
JOIN products p ON ci.product_id = p.id
WHERE ci.cart_id = $1
    AND p.deleted_at IS NULL
    AND p.status = 'active'
ORDER BY ci.created_at DESC
`

type GetCartItemsWithProductDetailsRow struct {
	ID                   uuid.UUID          `json:"id"`
	CartID               uuid.UUID          `json:"cart_id"`
	ProductID            uuid.UUID          `json:"product_id"`
	Quantity             int32              `json:"quantity"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	ProductName          string             `json:"product_name"`
	ProductPriceCents    int64              `json:"product_price_cents"`
	ProductStockQuantity int32              `json:"product_stock_quantity"`
	ProductImageUrls     []byte             `json:"product_image_urls"`
	ProductBrand         string             `json:"product_brand"`
}

// Enhanced Cart Data Retrieval
func (q *Queries) GetCartItemsWithProductDetails(ctx context.Context, cartID uuid.UUID) ([]GetCartItemsWithProductDetailsRow, error) {
	rows, err := q.db.Query(ctx, getCartItemsWithProductDetails, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCartItemsWithProductDetailsRow
	for rows.Next() {
		var i GetCartItemsWithProductDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.CartID,
			&i.ProductID,
			&i.Quantity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductPriceCents,
			&i.ProductStockQuantity,
			&i.ProductImageUrls,
			&i.ProductBrand,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCartStats = `-- name: GetCartStats :one
SELECT
    COUNT(ci.id) as total_items,
    SUM(ci.quantity) FILTER (WHERE p.id IS NOT NULL) as total_quantity,
    SUM(ci.quantity * p.price_cents) FILTER (WHERE p.id IS NOT NULL) as total_value
FROM carts c
LEFT JOIN cart_items ci ON c.id = ci.cart_id
LEFT JOIN products p ON ci.product_id = p.id
WHERE c.id = $1
    AND p.deleted_at IS NULL
    AND p.status = 'active'
`

type GetCartStatsRow struct {
	TotalItems    int64 `json:"total_items"`
	TotalQuantity int64 `json:"total_quantity"`
	TotalValue    int64 `json:"total_value"`
}

func (q *Queries) GetCartStats(ctx context.Context, cartID uuid.UUID) (GetCartStatsRow, error) {
	row := q.db.QueryRow(ctx, getCartStats, cartID)
	var i GetCartStatsRow
	err := row.Scan(&i.TotalItems, &i.TotalQuantity, &i.TotalValue)
	return i, err
}

const getCartWithItemsAndProducts = `-- name: GetCartWithItemsAndProducts :many
SELECT
    c.id as cart_id,
    c.user_id as cart_user_id,
    c.session_id as cart_session_id,
    c.created_at as cart_created_at,
    c.updated_at as cart_updated_at,
    ci.id as cart_item_id,
    ci.cart_id as cart_item_cart_id,
    ci.product_id as cart_item_product_id,
    ci.quantity as cart_item_quantity,
    ci.created_at as cart_item_created_at,
    ci.updated_at as cart_item_updated_at,
    p.name as product_name,
    p.price_cents as product_price_cents,
    p.stock_quantity as product_stock_quantity,
    p.image_urls as product_image_urls,
    p.brand as product_brand
FROM carts c
LEFT JOIN cart_items ci ON c.id = ci.cart_id
LEFT JOIN products p ON ci.product_id = p.id
WHERE c.id = $1
    AND ci.deleted_at is Null
    AND (p.deleted_at IS NULL OR p.id IS NULL)
ORDER BY ci.created_at DESC
`

type GetCartWithItemsAndProductsRow struct {
	CartID               uuid.UUID          `json:"cart_id"`
	CartUserID           uuid.UUID          `json:"cart_user_id"`
	CartSessionID        *string            `json:"cart_session_id"`
	CartCreatedAt        pgtype.Timestamptz `json:"cart_created_at"`
	CartUpdatedAt        pgtype.Timestamptz `json:"cart_updated_at"`
	CartItemID           uuid.UUID          `json:"cart_item_id"`
	CartItemCartID       uuid.UUID          `json:"cart_item_cart_id"`
	CartItemProductID    uuid.UUID          `json:"cart_item_product_id"`
	CartItemQuantity     *int32             `json:"cart_item_quantity"`
	CartItemCreatedAt    pgtype.Timestamptz `json:"cart_item_created_at"`
	CartItemUpdatedAt    pgtype.Timestamptz `json:"cart_item_updated_at"`
	ProductName          *string            `json:"product_name"`
	ProductPriceCents    *int64             `json:"product_price_cents"`
	ProductStockQuantity *int32             `json:"product_stock_quantity"`
	ProductImageUrls     []byte             `json:"product_image_urls"`
	ProductBrand         *string            `json:"product_brand"`
}

func (q *Queries) GetCartWithItemsAndProducts(ctx context.Context, cartID uuid.UUID) ([]GetCartWithItemsAndProductsRow, error) {
	rows, err := q.db.Query(ctx, getCartWithItemsAndProducts, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCartWithItemsAndProductsRow
	for rows.Next() {
		var i GetCartWithItemsAndProductsRow
		if err := rows.Scan(
			&i.CartID,
			&i.CartUserID,
			&i.CartSessionID,
			&i.CartCreatedAt,
			&i.CartUpdatedAt,
			&i.CartItemID,
			&i.CartItemCartID,
			&i.CartItemProductID,
			&i.CartItemQuantity,
			&i.CartItemCreatedAt,
			&i.CartItemUpdatedAt,
			&i.ProductName,
			&i.ProductPriceCents,
			&i.ProductStockQuantity,
			&i.ProductImageUrls,
			&i.ProductBrand,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncGuestCartItemsToUserCart = `-- name: SyncGuestCartItemsToUserCart :exec
INSERT INTO cart_items (cart_id, product_id, quantity, created_at, updated_at)
SELECT
    $1, -- $1: The destination user's cart ID
    ci.product_id,
    ci.quantity, -- Quantity from the guest cart item
    NOW(), -- New created_at timestamp for the entry in the user's cart
    NOW()  -- New updated_at timestamp for the user's cart
FROM
    cart_items ci -- Primary table: items from the source guest cart
INNER JOIN products p ON p.id = ci.product_id -- Join with products table to validate and get stock info at INSERT time
    AND p.stock_quantity >= ci.quantity -- Ensure sufficient stock for the NEW quantity during INSERT
    AND p.status = 'active'
    AND p.deleted_at IS NULL
WHERE
    ci.cart_id = $2 -- Filter items from the specific guest cart
    AND ci.deleted_at IS NULL -- Only sync items not marked as deleted in the guest cart
ON CONFLICT (cart_id, product_id)
DO UPDATE SET
    -- In the UPDATE part (conflict resolution), handle merging with existing items in the user's cart
    quantity = CASE
        -- Scenario: The item exists in the user's cart but was soft-deleted.
        WHEN cart_items.deleted_at IS NOT NULL THEN
            CASE
                -- Re-check stock against the quantity being added from the guest cart (EXCLUDED.quantity).
                WHEN (SELECT stock_quantity FROM products WHERE id = EXCLUDED.product_id) >= EXCLUDED.quantity THEN
                    EXCLUDED.quantity -- Set to the guest cart's quantity (overwrites old soft-deleted quantity)
                ELSE
                    -- If stock check fails for the guest quantity, keep the old soft-deleted quantity.
                    cart_items.quantity
            END
        -- Scenario: The item exists in the user's cart and is NOT soft-deleted.
        ELSE
            -- Add the guest cart's quantity to the user's existing quantity.
            -- Use LEAST to cap the total at the product's available stock.
            LEAST(
                cart_items.quantity + EXCLUDED.quantity, -- Add guest quantity to existing quantity
                (SELECT stock_quantity FROM products WHERE id = EXCLUDED.product_id) -- Cap at product's stock
            )
    END,
    -- Handle the soft-delete state during the update.
    -- If the item was soft-deleted in the user's cart, undelete it.
    deleted_at = CASE
        WHEN cart_items.deleted_at IS NOT NULL THEN NULL -- Undelete if it was soft-deleted
        ELSE cart_items.deleted_at -- Keep existing state (likely NULL)
    END,
    updated_at = NOW()
`

type SyncGuestCartItemsToUserCartParams struct {
	TargetUserCartID  uuid.UUID `json:"target_user_cart_id"`
	SourceGuestCartID uuid.UUID `json:"source_guest_cart_id"`
}

// Merges items from a guest cart into a user's cart using upsert logic.
// Handles quantity updates, stock checks, and soft-delete state transitions (undeletion).
// This query performs the core merge operation efficiently in a single statement.
func (q *Queries) SyncGuestCartItemsToUserCart(ctx context.Context, arg SyncGuestCartItemsToUserCartParams) error {
	_, err := q.db.Exec(ctx, syncGuestCartItemsToUserCart, arg.TargetUserCartID, arg.SourceGuestCartID)
	return err
}

const updateCartItemQuantity = `-- name: UpdateCartItemQuantity :one
UPDATE cart_items ci
SET quantity = $1, updated_at = NOW()
FROM products p
WHERE ci.id = $2
    AND ci.product_id = p.id
    AND $1 > 0
    AND $1 <= p.stock_quantity  -- Stock validation
RETURNING
    ci.id,
    ci.cart_id,
    ci.product_id,
    ci.quantity,
    ci.created_at,
    ci.updated_at,
    p.name as product_name,
    p.price_cents as product_price_cents,
    p.stock_quantity as product_stock_quantity,
    p.image_urls as product_image_urls,
    p.brand as product_brand
`

type UpdateCartItemQuantityParams struct {
	NewQuantity int32     `json:"new_quantity"`
	ItemID      uuid.UUID `json:"item_id"`
}

type UpdateCartItemQuantityRow struct {
	ID                   uuid.UUID          `json:"id"`
	CartID               uuid.UUID          `json:"cart_id"`
	ProductID            uuid.UUID          `json:"product_id"`
	Quantity             int32              `json:"quantity"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	ProductName          string             `json:"product_name"`
	ProductPriceCents    int64              `json:"product_price_cents"`
	ProductStockQuantity int32              `json:"product_stock_quantity"`
	ProductImageUrls     []byte             `json:"product_image_urls"`
	ProductBrand         string             `json:"product_brand"`
}

func (q *Queries) UpdateCartItemQuantity(ctx context.Context, arg UpdateCartItemQuantityParams) (UpdateCartItemQuantityRow, error) {
	row := q.db.QueryRow(ctx, updateCartItemQuantity, arg.NewQuantity, arg.ItemID)
	var i UpdateCartItemQuantityRow
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.ProductID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductName,
		&i.ProductPriceCents,
		&i.ProductStockQuantity,
		&i.ProductImageUrls,
		&i.ProductBrand,
	)
	return i, err
}


File: internal/db/analytics.sql.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getAverageFulfillmentTime = `-- name: GetAverageFulfillmentTime :one
SELECT
    AVG(EXTRACT(EPOCH FROM (o_shipped_or_delivered.updated_at - o_confirmed.updated_at))) AS avg_seconds
FROM
    orders o_confirmed
JOIN
    orders o_shipped_or_delivered ON o_confirmed.id = o_shipped_or_delivered.id
WHERE
    o_confirmed.status = 'confirmed'
    AND (o_shipped_or_delivered.status = 'shipped' OR o_shipped_or_delivered.status = 'delivered')
    AND o_confirmed.created_at BETWEEN $1 AND $2
`

type GetAverageFulfillmentTimeParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

// Calculates the average time between order confirmation and shipment/delivery completion.
// Assumes 'confirmed' status is the start and 'shipped' or 'delivered' is the end.
func (q *Queries) GetAverageFulfillmentTime(ctx context.Context, arg GetAverageFulfillmentTimeParams) (float64, error) {
	row := q.db.QueryRow(ctx, getAverageFulfillmentTime, arg.StartDate, arg.EndDate)
	var avg_seconds float64
	err := row.Scan(&avg_seconds)
	return avg_seconds, err
}

const getAverageOrderValue = `-- name: GetAverageOrderValue :one

SELECT
    AVG(o.total_amount_cents) AS aov_cents
FROM
    orders o
WHERE
    o.status = 'delivered'
    AND o.created_at BETWEEN $1 AND $2
`

type GetAverageOrderValueParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

// @start_date = start_date, @start_date = end_date
// Calculates the average order value (AOV) for delivered orders within a given time range.
func (q *Queries) GetAverageOrderValue(ctx context.Context, arg GetAverageOrderValueParams) (float64, error) {
	row := q.db.QueryRow(ctx, getAverageOrderValue, arg.StartDate, arg.EndDate)
	var aov_cents float64
	err := row.Scan(&aov_cents)
	return aov_cents, err
}

const getDiscountUsage = `-- name: GetDiscountUsage :many

SELECT
    d.code AS discount_code,
    d.discount_type,
    d.discount_value,
    COUNT(o.id) AS usage_count,
    SUM(o.total_amount_cents) AS total_revenue_with_discount
FROM
    orders o
JOIN
    discounts d ON o.applied_discount_code = d.code -- Assuming orders table stores the code used
WHERE
    o.status = 'delivered'
    AND o.created_at BETWEEN $1 AND $2 -- $1 = start_date, $2 = end_date
GROUP BY
    d.code, d.discount_type, d.discount_value
`

type GetDiscountUsageParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

type GetDiscountUsageRow struct {
	DiscountCode             string `json:"discount_code"`
	DiscountType             string `json:"discount_type"`
	DiscountValue            int64  `json:"discount_value"`
	UsageCount               int64  `json:"usage_count"`
	TotalRevenueWithDiscount int64  `json:"total_revenue_with_discount"`
}

// --- Discount Effectiveness ---
// Retrieves usage count and revenue attributed to specific discount codes within a time range.
func (q *Queries) GetDiscountUsage(ctx context.Context, arg GetDiscountUsageParams) ([]GetDiscountUsageRow, error) {
	rows, err := q.db.Query(ctx, getDiscountUsage, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDiscountUsageRow
	for rows.Next() {
		var i GetDiscountUsageRow
		if err := rows.Scan(
			&i.DiscountCode,
			&i.DiscountType,
			&i.DiscountValue,
			&i.UsageCount,
			&i.TotalRevenueWithDiscount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLowStockProducts = `-- name: GetLowStockProducts :many


SELECT
    id AS product_id,
    name AS product_name,
    stock_quantity
FROM
    products
WHERE
    stock_quantity < $1 -- $1 = threshold quantity
    AND deleted_at IS NULL
ORDER BY
    stock_quantity ASC
`

type GetLowStockProductsRow struct {
	ProductID     uuid.UUID `json:"product_id"`
	ProductName   string    `json:"product_name"`
	StockQuantity int32     `json:"stock_quantity"`
}

// $3 = number of top products to return (N)
// --- Product Performance ---
// Retrieves products with stock quantity below a specified threshold.
func (q *Queries) GetLowStockProducts(ctx context.Context, stockQuantity int32) ([]GetLowStockProductsRow, error) {
	rows, err := q.db.Query(ctx, getLowStockProducts, stockQuantity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLowStockProductsRow
	for rows.Next() {
		var i GetLowStockProductsRow
		if err := rows.Scan(&i.ProductID, &i.ProductName, &i.StockQuantity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewCustomersCount = `-- name: GetNewCustomersCount :one

SELECT
    COUNT(*) AS new_customers_count
FROM
    users
WHERE
    created_at BETWEEN $1 AND $2-- $1 = start_date, $2 = end_date
    AND deleted_at IS NULL
`

type GetNewCustomersCountParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

// --- Customer Insights ---
// Counts the number of new customers registered within a given time range.
func (q *Queries) GetNewCustomersCount(ctx context.Context, arg GetNewCustomersCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getNewCustomersCount, arg.StartDate, arg.EndDate)
	var new_customers_count int64
	err := row.Scan(&new_customers_count)
	return new_customers_count, err
}

const getOrderStatusCounts = `-- name: GetOrderStatusCounts :many


SELECT
    status,
    COUNT(*) AS count
FROM
    orders
WHERE
    created_at BETWEEN $1 AND $2 -- $1 = start_date, $2 = end_date (optional, remove if counting all time)
GROUP BY
    status
`

type GetOrderStatusCountsParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

type GetOrderStatusCountsRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

// Exclude soft-deleted users
// --- Order Metrics ---
// Counts the number of orders in each status (pending, confirmed, shipped, delivered, cancelled).
func (q *Queries) GetOrderStatusCounts(ctx context.Context, arg GetOrderStatusCountsParams) ([]GetOrderStatusCountsRow, error) {
	rows, err := q.db.Query(ctx, getOrderStatusCounts, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderStatusCountsRow
	for rows.Next() {
		var i GetOrderStatusCountsRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByStatusWithinTimeRange = `-- name: GetOrdersByStatusWithinTimeRange :many
SELECT
    status,
    COUNT(*) AS count
FROM
    orders
WHERE
    created_at BETWEEN $1 AND $2 -- $1 = start_date, $2 = end_date (optional, remove if counting all time)
GROUP BY
    status
`

type GetOrdersByStatusWithinTimeRangeParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

type GetOrdersByStatusWithinTimeRangeRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

// $1 = start_date, $2 = end_date
// Note: This query is complex because order status updates modify the same row.
// A more robust approach might involve an order_status_history table or window functions.
// Simplified version assuming statuses are updated sequentially and we just compare timestamps.
// A better way might be to track status change events explicitly.
// For now, let's simplify the logic assuming we just want the difference between created_at and updated_at
// for 'shipped' or 'delivered' orders, IF created_at represents the time it became confirmed.
// This might not be accurate depending on how status transitions are handled.
// Let's revise:
// Assume 'confirmed' status sets confirmed_at, 'shipped' sets shipped_at, 'delivered' sets delivered_at.
// Add these timestamp fields to the orders table if they don't exist.
// ALTER TABLE orders ADD COLUMN confirmed_at TIMESTAMPTZ, shipped_at TIMESTAMPTZ, delivered_at TIMESTAMPTZ;
// Then update these timestamps in the service layer upon status changes.
// Query would then be:
// SELECT AVG(EXTRACT(EPOCH FROM (delivered_at - confirmed_at))) FROM orders WHERE status = 'delivered' AND ...;
// For now, acknowledging this complexity, we'll note it and move on, assuming status timestamps exist or are derivable.
// This query might need adjustment based on how status changes are tracked in the DB.
// Let's add a simpler one based on status counts for now.
// Counts orders by status within a time range.
// This is similar to GetOrderStatusCounts but with a time filter.
func (q *Queries) GetOrdersByStatusWithinTimeRange(ctx context.Context, arg GetOrdersByStatusWithinTimeRangeParams) ([]GetOrdersByStatusWithinTimeRangeRow, error) {
	rows, err := q.db.Query(ctx, getOrdersByStatusWithinTimeRange, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersByStatusWithinTimeRangeRow
	for rows.Next() {
		var i GetOrdersByStatusWithinTimeRangeRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductReviewStats = `-- name: GetProductReviewStats :one
SELECT
    avg_rating,
    num_ratings
FROM
    products
WHERE
    id = $1 AND deleted_at IS NULL
`

type GetProductReviewStatsRow struct {
	AvgRating  pgtype.Numeric `json:"avg_rating"`
	NumRatings *int32         `json:"num_ratings"`
}

// Retrieves average rating and number of ratings for a specific product.
// (This might already be covered by the existing product queries selecting avg_rating, num_ratings)
// But here's a dedicated query if needed:
func (q *Queries) GetProductReviewStats(ctx context.Context, id uuid.UUID) (GetProductReviewStatsRow, error) {
	row := q.db.QueryRow(ctx, getProductReviewStats, id)
	var i GetProductReviewStatsRow
	err := row.Scan(&i.AvgRating, &i.NumRatings)
	return i, err
}

const getSalesVolume = `-- name: GetSalesVolume :one

SELECT
    COUNT(*) AS total_orders
FROM
    orders
WHERE
    status = 'delivered'
    AND created_at BETWEEN $1 AND $2
`

type GetSalesVolumeParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

// $1 = start_date, $2 = end_date
// Counts the total number of delivered orders within a given time range.
func (q *Queries) GetSalesVolume(ctx context.Context, arg GetSalesVolumeParams) (int64, error) {
	row := q.db.QueryRow(ctx, getSalesVolume, arg.StartDate, arg.EndDate)
	var total_orders int64
	err := row.Scan(&total_orders)
	return total_orders, err
}

const getTopSellingCategories = `-- name: GetTopSellingCategories :many

SELECT
    c.id AS category_id,
    c.name AS category_name,
    SUM(oi.quantity) AS total_units_sold
FROM
    order_items oi
JOIN
    orders o ON oi.order_id = o.id
JOIN
    products p ON oi.product_id = p.id
JOIN
    categories c ON p.category_id = c.id
WHERE
    o.status = 'delivered'
    AND o.created_at BETWEEN $1 AND $2 -- $1 = start_date, $2 = end_date
GROUP BY
    c.id, c.name
ORDER BY
    total_units_sold DESC
LIMIT $3
`

type GetTopSellingCategoriesParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
	Limits    int32              `json:"limits"`
}

type GetTopSellingCategoriesRow struct {
	CategoryID     uuid.UUID `json:"category_id"`
	CategoryName   string    `json:"category_name"`
	TotalUnitsSold int64     `json:"total_units_sold"`
}

// $3 = number of top products to return (N)
// Retrieves the top N selling categories (by quantity sold) within a given time range.
func (q *Queries) GetTopSellingCategories(ctx context.Context, arg GetTopSellingCategoriesParams) ([]GetTopSellingCategoriesRow, error) {
	rows, err := q.db.Query(ctx, getTopSellingCategories, arg.StartDate, arg.EndDate, arg.Limits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSellingCategoriesRow
	for rows.Next() {
		var i GetTopSellingCategoriesRow
		if err := rows.Scan(&i.CategoryID, &i.CategoryName, &i.TotalUnitsSold); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopSellingProducts = `-- name: GetTopSellingProducts :many

SELECT
    p.id AS product_id,
    p.name AS product_name,
    SUM(oi.quantity) AS total_units_sold
FROM
    order_items oi
JOIN
    orders o ON oi.order_id = o.id
JOIN
    products p ON oi.product_id = p.id
WHERE
    o.status = 'delivered'
    AND o.created_at BETWEEN $1 AND $2 -- $1 = start_date, $2 = end_date
GROUP BY
    p.id, p.name
ORDER BY
    total_units_sold DESC
LIMIT $3
`

type GetTopSellingProductsParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
	Limits    int32              `json:"limits"`
}

type GetTopSellingProductsRow struct {
	ProductID      uuid.UUID `json:"product_id"`
	ProductName    string    `json:"product_name"`
	TotalUnitsSold int64     `json:"total_units_sold"`
}

// $1 = start_date, $2 = end_date
// Retrieves the top N selling products (by quantity sold) within a given time range.
func (q *Queries) GetTopSellingProducts(ctx context.Context, arg GetTopSellingProductsParams) ([]GetTopSellingProductsRow, error) {
	rows, err := q.db.Query(ctx, getTopSellingProducts, arg.StartDate, arg.EndDate, arg.Limits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSellingProductsRow
	for rows.Next() {
		var i GetTopSellingProductsRow
		if err := rows.Scan(&i.ProductID, &i.ProductName, &i.TotalUnitsSold); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalRevenue = `-- name: GetTotalRevenue :one

SELECT
    COALESCE(SUM(oi.quantity * oi.price_cents),0)::BIGINT AS total_revenue_cents
FROM
    orders o
JOIN
    order_items oi ON o.id = oi.order_id
WHERE
    o.status = 'delivered' -- Only delivered orders contribute to revenue
    AND o.created_at BETWEEN $1 AND $2
`

type GetTotalRevenueParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

// --- Sales Performance ---
// Calculates the total revenue from all delivered orders within a given time range.
func (q *Queries) GetTotalRevenue(ctx context.Context, arg GetTotalRevenueParams) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalRevenue, arg.StartDate, arg.EndDate)
	var total_revenue_cents int64
	err := row.Scan(&total_revenue_cents)
	return total_revenue_cents, err
}


File: internal/db/queries/review.sql
================================================
-- name: CreateReview :one
-- Inserts a new review and returns its details.
-- NOTE: This query alone does not update the product's avg_rating/num_ratings.
INSERT INTO reviews (
    user_id, product_id, rating
) VALUES (
    $1, $2, $3
)
RETURNING id, user_id, product_id, rating, created_at, updated_at;

-- name: GetReviewByUserAndProduct :one
-- Retrieves a review by a specific user for a specific product.
SELECT id, user_id, product_id, rating, created_at, updated_at
FROM reviews
WHERE user_id = $1 AND product_id = $2 AND deleted_at IS NULL;

-- name: GetReviewByIDAndUser :one
-- Retrieves a specific review by its ID and verifies the user owns it.
SELECT id, user_id, product_id, rating, created_at, updated_at
FROM reviews
WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL;

-- name: GetReviewsByProductID :many
-- Retrieves all reviews for a specific product, including the reviewer's name, potentially paginated.
SELECT 
    r.id,
    r.user_id,
    r.product_id,
    r.rating,
    r.created_at,
    r.updated_at,
    u.full_name AS reviewer_name 
FROM reviews r
JOIN users u ON r.user_id = u.id -- INNER JOIN to link review to user
WHERE r.product_id = sqlc.arg(product_id) AND r.deleted_at IS NULL
ORDER BY r.created_at DESC -- Or rating DESC, etc.
LIMIT sqlc.arg(page_limit) OFFSET sqlc.arg(page_offset);


-- name: GetReviewsByUserID :many
-- Retrieves all reviews submitted by a specific user, including the product name, potentially paginated.
SELECT 
    r.id,
    r.user_id,
    r.product_id,
    r.rating,
    r.created_at,
    r.updated_at,
    p.name AS product_name -- Join with products table to get the name
FROM reviews r
JOIN products p ON r.product_id = p.id -- INNER JOIN to link review to product
WHERE r.user_id = sqlc.arg(user_id) AND r.deleted_at IS NULL
ORDER BY r.created_at DESC
LIMIT sqlc.arg(page_limit) OFFSET sqlc.arg(page_offset);

-- name: UpdateReview :one
-- Updates the rating of an existing review.
-- NOTE: This query alone does not update the product's avg_rating/num_ratings.
UPDATE reviews
SET rating = $1, updated_at = NOW()
WHERE id = $2 AND user_id = $3 -- Ensure user owns the review
RETURNING id, user_id, product_id, rating, created_at, updated_at;

-- name: DeleteReview :one
-- Soft deletes a review by setting deleted_at.
-- NOTE: This query alone does not update the product's avg_rating/num_ratings.
UPDATE reviews
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = $1 AND user_id = $2 -- Ensure user owns the review
RETURNING id, user_id, product_id, rating, created_at, updated_at;

-- name: CalculateReviewStatsForProduct :one
-- Calculates the average rating and count of non-deleted reviews for a specific product.
-- Used to update the products table.
SELECT
    AVG(r.rating)::NUMERIC(3,2) AS avg_rating,
    COUNT(r.rating)::INTEGER AS num_ratings
FROM reviews r
WHERE r.product_id = sqlc.arg(product_id) AND r.deleted_at IS NULL;

-- name: UpdateProductReviewStats :exec
-- Updates the avg_rating and num_ratings fields in the products table for a specific product.
UPDATE products
SET
    avg_rating = sqlc.arg(avg_rating),
    num_ratings = sqlc.arg(num_ratings),
    updated_at = NOW() -- Optionally update the product's general updated_at too
WHERE id = sqlc.arg(product_id);


File: internal/db/queries/products.sql
================================================
-- name: GetProduct :one
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE id = sqlc.arg(product_id) AND deleted_at IS NULL;

-- name: GetProductBySlug :one
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE slug = sqlc.arg(slug) AND deleted_at IS NULL;

-- name: CheckSlugExists :one
-- Checks if a product slug already exists (excluding soft-deleted products).
SELECT EXISTS(SELECT 1 FROM products WHERE slug = $1 AND deleted_at IS NULL) AS exists;

-- name: ListProducts :many
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT sqlc.arg(page_limit) OFFSET sqlc.arg(page_offset);

-- name: ListProductsWithCategory :many
SELECT 
    sqlc.embed(p),
    c.name as category_name,
    c.slug as category_slug,
    c.type as category_type
FROM products p
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.deleted_at IS NULL
ORDER BY p.created_at DESC
LIMIT sqlc.arg(page_limit) OFFSET sqlc.arg(page_offset);

-- name: ListProductsByCategory :many
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE category_id = sqlc.arg(category_id) AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT sqlc.arg(page_limit) OFFSET sqlc.arg(page_offset);

-- name: ListProductsWithCategoryDetail :many
SELECT 
    sqlc.embed(p),
    sqlc.embed(c)
FROM products p
JOIN categories c ON p.category_id = c.id
WHERE p.category_id = sqlc.arg(category_id) AND p.deleted_at IS NULL
ORDER BY p.created_at DESC
LIMIT sqlc.arg(page_limit) OFFSET sqlc.arg(page_offset);


-- name: SearchProductsWithDiscounts :many
-- Searches for products and includes pre-calculated discount information using the view.
-- Includes a flexible spec highlight filter for partial matching within values.
SELECT
    p.id,
    p.category_id,
    c.name AS category_name,
    p.name,
    p.slug,
    p.description,
    p.short_description,
    p.price_cents AS original_price_cents,
    p.stock_quantity,
    p.status,
    p.brand,
    p.image_urls,
    p.spec_highlights,
    p.created_at,
    p.updated_at,
    p.deleted_at,
    p.avg_rating,
    p.num_ratings,
    vpcd.total_fixed_discount_cents::BIGINT,
    vpcd.combined_percentage_factor::FLOAT,
    COALESCE(vpcd.calculated_discounted_price_cents, p.price_cents) AS discounted_price_cents,
    -- Use the has_active_discount boolean directly from the view
    COALESCE(vpcd.has_active_discount, FALSE) AS has_active_discount
FROM
    products p
INNER JOIN categories c ON p.category_id = c.id -- Join with categories table
LEFT JOIN
    v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id
WHERE
    p.deleted_at IS NULL
    -- Main text search filter (name, description)
    AND (
        sqlc.arg(query)::TEXT = '' 
        OR p.name ILIKE '%' || sqlc.arg(query) || '%' 
        OR COALESCE(p.short_description, '') ILIKE '%' || sqlc.arg(query) || '%' 
        OR to_tsvector('english', p.name || ' ' || COALESCE(p.short_description, '')) @@ plainto_tsquery('english', sqlc.arg(query))
        OR p.spec_highlights::TEXT ILIKE '%' || sqlc.arg(query) || '%'
    )
    -- Spec highlight filter: Check if apply_spec_filter is true, then match the value for the given key
    AND (NOT sqlc.arg(apply_spec_filter)::BOOLEAN OR (sqlc.arg(spec_filter_key)::TEXT != '' AND p.spec_highlights ->> sqlc.arg(spec_filter_key) ILIKE '%' || sqlc.arg(spec_filter_value) || '%'))
    -- Category filter
    AND (sqlc.arg(category_id)::UUID = '00000000-0000-0000-0000-000000000000' OR p.category_id = sqlc.arg(category_id))
    -- Brand filter
    AND (sqlc.arg(brand)::TEXT = '' OR p.brand ILIKE '%' || sqlc.arg(brand) || '%')
    -- Price range filter
    AND (sqlc.arg(min_price)::BIGINT = 0 OR p.price_cents >= sqlc.arg(min_price))
    AND (sqlc.arg(max_price)::BIGINT = 0 OR p.price_cents <= sqlc.arg(max_price))
    -- Stock availability filter
    AND (
        (sqlc.arg(in_stock_only)::BOOLEAN = false AND sqlc.arg(in_stock_only) IS NOT NULL)
        OR (sqlc.arg(in_stock_only) = true AND p.stock_quantity > 0)
        OR (sqlc.arg(in_stock_only) = false AND p.stock_quantity <= 0)
    )
    -- Discount filter
    AND (sqlc.arg(include_discounted_only)::BOOLEAN = false OR vpcd.has_active_discount = TRUE)
ORDER BY
    p.created_at DESC
LIMIT sqlc.arg(page_limit) OFFSET sqlc.arg(page_offset);
-- name: SearchProductsWithCategory :many
SELECT 
    sqlc.embed(p),
    c.name as category_name,
    c.slug as category_slug,
    c.type as category_type
FROM products p
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.deleted_at IS NULL
  AND (sqlc.arg(query)::TEXT = '' OR p.name ILIKE '%' || sqlc.arg(query) || '%' OR COALESCE(p.short_description, '') ILIKE '%' || sqlc.arg(query) || '%' OR to_tsvector('english', p.name || ' ' || COALESCE(p.short_description, '')) @@ plainto_tsquery('english', sqlc.arg(query)))
  AND (sqlc.arg(category_id)::UUID = '00000000-0000-0000-0000-000000000000' OR p.category_id = sqlc.arg(category_id))
  AND (sqlc.arg(brand)::TEXT = '' OR p.brand ILIKE '%' || sqlc.arg(brand) || '%')
  AND (sqlc.arg(min_price)::BIGINT = 0 OR p.price_cents >= sqlc.arg(min_price))
  AND (sqlc.arg(max_price)::BIGINT = 0 OR p.price_cents <= sqlc.arg(max_price))
  AND ((sqlc.arg(in_stock_only)::BOOLEAN = false AND sqlc.arg(in_stock_only) IS NOT NULL) OR (sqlc.arg(in_stock_only) = true AND p.stock_quantity > 0) OR (sqlc.arg(in_stock_only) = false AND p.stock_quantity <= 0))
ORDER BY p.created_at DESC
LIMIT sqlc.arg(page_limit) OFFSET sqlc.arg(page_offset);


-- name: CreateProduct :one
INSERT INTO products (
    category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at
) VALUES (
    sqlc.arg(category_id), 
    sqlc.arg(name), 
    sqlc.arg(slug), 
    sqlc.arg(description), 
    sqlc.arg(short_description), 
    sqlc.arg(price_cents), 
    sqlc.arg(stock_quantity), 
    sqlc.arg(status), 
    sqlc.arg(brand), 
    sqlc.arg(image_urls), 
    sqlc.arg(spec_highlights), 
    NOW(), -- created_at
    NOW()  -- updated_at
) 
RETURNING  id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at;

-- name: UpdateProduct :one
UPDATE products
SET
    category_id = COALESCE(sqlc.arg(category_id), category_id),
    name = COALESCE(sqlc.arg(name), name),
    slug = COALESCE(sqlc.arg(slug), slug),
    description = COALESCE(sqlc.arg(description), description),
    short_description = COALESCE(sqlc.arg(short_description), short_description),
    price_cents = COALESCE(sqlc.arg(price_cents), price_cents),
    stock_quantity = COALESCE(sqlc.arg(stock_quantity), stock_quantity),
    status = COALESCE(sqlc.arg(status), status),
    brand = COALESCE(sqlc.arg(brand), brand),
    image_urls = COALESCE(sqlc.arg(image_urls), image_urls),
    spec_highlights = COALESCE(sqlc.arg(spec_highlights), spec_highlights),
    updated_at = NOW()
WHERE id = sqlc.arg(product_id) AND deleted_at IS NULL
RETURNING  id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at;

-- name: DeleteProduct :exec
UPDATE products
SET deleted_at = NOW()
WHERE id = sqlc.arg(product_id);


-- name: CountProducts :one
SELECT COUNT(*) FROM products p
LEFT JOIN v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id
WHERE p.deleted_at IS NULL
    -- Main text search filter (name, description)
    AND (
        sqlc.arg(query)::TEXT = '' 
        OR p.name ILIKE '%' || sqlc.arg(query) || '%' 
        OR COALESCE(p.short_description, '') ILIKE '%' || sqlc.arg(query) || '%' 
        OR to_tsvector('english', p.name || ' ' || COALESCE(p.short_description, '')) @@ plainto_tsquery('english', sqlc.arg(query))
        OR p.spec_highlights::TEXT ILIKE '%' || sqlc.arg(query) || '%'
    )
    -- Spec highlight filter: Check if apply_spec_filter is true, then match the value for the given key
    AND (NOT sqlc.arg(apply_spec_filter)::BOOLEAN OR (sqlc.arg(spec_filter_key)::TEXT != '' AND p.spec_highlights ->> sqlc.arg(spec_filter_key) ILIKE '%' || sqlc.arg(spec_filter_value) || '%'))
    -- Category filter
    AND (sqlc.arg(category_id)::UUID = '00000000-0000-0000-0000-000000000000' OR p.category_id = sqlc.arg(category_id))
    -- Brand filter
    AND (sqlc.arg(brand)::TEXT = '' OR p.brand ILIKE '%' || sqlc.arg(brand) || '%')
    -- Price range filter
    AND (sqlc.arg(min_price)::BIGINT = 0 OR p.price_cents >= sqlc.arg(min_price))
    AND (sqlc.arg(max_price)::BIGINT = 0 OR p.price_cents <= sqlc.arg(max_price))
    -- Stock availability filter
    AND (
        (sqlc.arg(in_stock_only)::BOOLEAN = false AND sqlc.arg(in_stock_only) IS NOT NULL)
        OR (sqlc.arg(in_stock_only) = true AND p.stock_quantity > 0)
        OR (sqlc.arg(in_stock_only) = false AND p.stock_quantity <= 0)
    )
    -- Discount filter
    AND (sqlc.arg(include_discounted_only)::BOOLEAN = false OR vpcd.has_active_discount = TRUE);

-- name: CountAllProducts :one
SELECT COUNT(*) FROM products WHERE deleted_at IS NULL;

-- name: CreateCategory :one
INSERT INTO categories (
    name, slug, type
) VALUES (
    $1, $2, $3
) RETURNING id, name, slug, type, parent_id, created_at ;

-- name: GetCategory :one
SELECT id, name, slug, type, parent_id, created_at 
FROM categories
WHERE id = $1 ;

-- name: GetCategoryBySlug :one
SELECT id, name, slug, type, parent_id, created_at 
FROM categories
WHERE slug = $1 ;

-- name: ListCategories :many
SELECT id, name, slug, type, parent_id, created_at 
FROM categories
ORDER BY created_at DESC
LIMIT $1 OFFSET $2;

-- name: UpdateCategory :one
UPDATE categories
SET
    name = COALESCE($2, name),
    slug = COALESCE($3, slug),
    type = COALESCE($4, type)
WHERE id = $1 
RETURNING id, name, slug, type, parent_id, created_at ;

-- name: DeleteCategory :exec
DELETE FROM categories WHERE id = $1;
 
-- name: CountCategories :one
SELECT COUNT(*) FROM categories ;

-- name: CheckCategorySlugExists :one
SELECT EXISTS(
    SELECT 1 FROM categories
    WHERE slug = $1 
) AS exists;


File: internal/models/validation.go
================================================
package models

import "github.com/go-playground/validator/v10"

// Global validator instance for the models package
var Validate *validator.Validate

type Validator interface {
	Validate() error
}

func init() {
	Validate = validator.New()
}


File: internal/models/user.go
================================================
package models

import (
	"time"

	"github.com/google/uuid"
)

type User struct {
	ID        uuid.UUID  `json:"id"`
	Email     string     `json:"email"`
	Password  string     `json:"-" validate:"required"`
	FullName  string     `json:"full_name"`
	IsAdmin   bool       `json:"is_admin"`
	CreatedAt time.Time  `json:"created_at"`
	UpdatedAt time.Time  `json:"updated_at"`
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
}

type UserLogin struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required,min=6"`
}

type UserRegister struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required,min=6"`
	FullName string `json:"full_name" validate:"max=100"`
}


func (ur *UserRegister) Validate() error {
	return Validate.Struct(ur)
}

func (ul *UserLogin) Validate() error {
	return Validate.Struct(ul)
}


File: internal/handlers/delivery_service.go
================================================
package handlers

import (
	"encoding/json"
	"errors"
	"log/slog"
	"net/http"
	"strconv"

	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/MihoZaki/DzTech/internal/services"
	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
)

// DeliveryServiceHandler manages HTTP requests for delivery service-related operations.
type DeliveryServiceHandler struct {
	service *services.DeliveryServiceService
	logger  *slog.Logger
}

// NewDeliveryServiceHandler creates a new instance of DeliveryServiceHandler.
func NewDeliveryServiceHandler(service *services.DeliveryServiceService, logger *slog.Logger) *DeliveryServiceHandler {
	return &DeliveryServiceHandler{
		service: service,
		logger:  logger,
	}
}

// RegisterRoutes registers the delivery service-related routes with the provided Chi router.
// Assumes the router 'r' has admin middleware applied (e.g., JWT + RequireAdmin).
func (h *DeliveryServiceHandler) RegisterRoutes(r chi.Router) {
	r.Post("/", h.CreateDeliveryService)       // POST /api/v1/admin/delivery-services
	r.Get("/{id}", h.GetDeliveryService)       // GET /api/v1/admin/delivery-services/{id} (gets any status)
	r.Get("/", h.ListAllDeliveryServices)      // GET /api/v1/admin/delivery-services?page=&limit=&active_only= (admin sees all)
	r.Patch("/{id}", h.UpdateDeliveryService)  // PATCH /api/v1/admin/delivery-services/{id}
	r.Delete("/{id}", h.DeleteDeliveryService) // DELETE /api/v1/admin/delivery-services/{id}
}

// CreateDeliveryService handles creating a new delivery service.
func (h *DeliveryServiceHandler) CreateDeliveryService(w http.ResponseWriter, r *http.Request) {
	var req models.CreateDeliveryServiceRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid JSON in request body: "+err.Error(), http.StatusBadRequest)
		return
	}

	if err := req.Validate(); err != nil {
		http.Error(w, "Validation error: "+err.Error(), http.StatusBadRequest)
		return
	}

	deliveryService, err := h.service.CreateDeliveryService(r.Context(), req)
	if err != nil {
		// Log the error server-side
		h.logger.Error("Failed to create delivery service", "error", err, "name", req.Name)
		// Check for specific DB errors like unique_violation if needed
		http.Error(w, "Failed to create delivery service", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated) // 201 Created
	if err := json.NewEncoder(w).Encode(deliveryService); err != nil {
		// Log encoding error, but response headers might already be sent
		h.logger.Error("Failed to encode CreateDeliveryService response", "error", err)
	}
}

// GetDeliveryService handles retrieving a specific delivery service by its ID (admin: gets any status).
func (h *DeliveryServiceHandler) GetDeliveryService(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		http.Error(w, "Invalid delivery service ID format", http.StatusBadRequest)
		return
	}

	// Use the new method that ignores the active status for admin retrieval
	deliveryService, err := h.service.GetDeliveryServiceByID(r.Context(), id)
	if err != nil {
		if errors.Is(err, services.ErrDeliveryServiceNotFound) {
			http.Error(w, "Delivery service not found", http.StatusNotFound)
			return
		}
		h.logger.Error("Failed to get delivery service by ID (admin)", "error", err, "id", id)
		http.Error(w, "Failed to retrieve delivery service", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK) // 200 OK
	if err := json.NewEncoder(w).Encode(deliveryService); err != nil {
		h.logger.Error("Failed to encode GetDeliveryService response", "error", err)
	}
}

// ListAllDeliveryServices handles listing delivery services (admin: sees all statuses).
func (h *DeliveryServiceHandler) ListAllDeliveryServices(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters for pagination and filtering
	activeOnlyStr := r.URL.Query().Get("active_only")
	activeOnly := activeOnlyStr == "true" // Default to false if not provided or not "true"
	pageStr := r.URL.Query().Get("page")
	limitStr := r.URL.Query().Get("limit")

	page := 1 // Default page
	if pageStr != "" {
		if p, err := strconv.Atoi(pageStr); err == nil && p > 0 {
			page = p
		} // else, keep default
	}

	limit := 20 // Default limit
	if limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 {
			limit = l
		} // else, keep default
	}

	offset := (page - 1) * limit

	// Use the admin-specific list method
	deliveryServices, err := h.service.ListAllDeliveryServices(r.Context(), activeOnly, limit, offset)
	if err != nil {
		h.logger.Error("Failed to list delivery services (admin)", "error", err, "active_only", activeOnly, "page", page, "limit", limit)
		http.Error(w, "Failed to retrieve delivery services", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK) // 200 OK
	if err := json.NewEncoder(w).Encode(deliveryServices); err != nil {
		h.logger.Error("Failed to encode ListAllDeliveryServices response", "error", err)
	}
}

// UpdateDeliveryService handles updating an existing delivery service.
func (h *DeliveryServiceHandler) UpdateDeliveryService(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		http.Error(w, "Invalid delivery service ID format", http.StatusBadRequest)
		return
	}

	var req models.UpdateDeliveryServiceRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid JSON in request body: "+err.Error(), http.StatusBadRequest)
		return
	}

	// Validate the partial request struct (optional, if using validator tags)
	// Note: Validator might need special handling for partial updates (e.g., omitempty rules)
	if err := req.Validate(); err != nil {
		http.Error(w, "Validation error: "+err.Error(), http.StatusBadRequest)
		return
	}

	updatedDeliveryService, err := h.service.UpdateDeliveryService(r.Context(), id, req)
	if err != nil {
		if errors.Is(err, services.ErrDeliveryServiceNotFound) {
			http.Error(w, "Delivery service not found", http.StatusNotFound)
			return
		}
		h.logger.Error("Failed to update delivery service", "error", err, "id", id)
		http.Error(w, "Failed to update delivery service", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK) // 200 OK
	if err := json.NewEncoder(w).Encode(updatedDeliveryService); err != nil {
		h.logger.Error("Failed to encode UpdateDeliveryService response", "error", err)
	}
}

// DeleteDeliveryService handles deleting a delivery service.
func (h *DeliveryServiceHandler) DeleteDeliveryService(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		http.Error(w, "Invalid delivery service ID format", http.StatusBadRequest)
		return
	}

	err = h.service.DeleteDeliveryService(r.Context(), id)
	if err != nil {
		if errors.Is(err, services.ErrDeliveryServiceNotFound) {
			// Technically, if it's already gone, is it an error? Maybe return 204 No Content?
			// For consistency with Update, let's return 404 if not found *before* the delete attempt.
			// If the delete query itself fails (e.g., foreign key constraint), it returns 500.
			// If the delete query succeeds but affected 0 rows (despite finding it earlier), might need specific handling.
			// Let's stick to the pattern used in Update.
			http.Error(w, "Delivery service not found", http.StatusNotFound)
			return
		}
		h.logger.Error("Failed to delete delivery service", "error", err, "id", id)
		http.Error(w, "Failed to delete delivery service", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusNoContent) // 204 No Content on successful delete
}


File: internal/handlers/discount.go
================================================
package handlers

import (
	"encoding/json"
	"errors"
	"log/slog"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/MihoZaki/DzTech/internal/services"
	"github.com/go-chi/chi/v5"
	"github.com/go-playground/validator/v10"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

// DiscountHandler handles HTTP requests for discount management.
type DiscountHandler struct {
	service *services.DiscountService
	logger  *slog.Logger
}

// NewDiscountHandler creates a new instance of DiscountHandler.
func NewDiscountHandler(service *services.DiscountService, logger *slog.Logger) *DiscountHandler {
	return &DiscountHandler{
		service: service,
		logger:  logger,
	}
}

// RegisterRoutes registers discount-related routes with the provided router.
// This function assumes the router already has admin authorization middleware applied.
func (h *DiscountHandler) RegisterRoutes(r chi.Router) {
	r.Post("/", h.CreateDiscount)
	r.Get("/{id}", h.GetDiscount)
	r.Put("/{id}", h.UpdateDiscount)
	r.Delete("/{id}", h.DeleteDiscount)
	r.Get("/", h.ListDiscounts)
	r.Get("/product/{product_id}", h.GetDiscountsByProductID)

	r.Route("/{discount_id}/link", func(r chi.Router) {
		r.Post("/product", h.LinkDiscountToProduct)
	})
	r.Route("/{discount_id}/unlink", func(r chi.Router) {
		r.Post("/product", h.UnlinkDiscountFromProduct)
	})
}

// CreateDiscount handles the creation of a new discount.
func (h *DiscountHandler) CreateDiscount(w http.ResponseWriter, r *http.Request) {
	var req models.CreateDiscountRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Error("Invalid JSON in CreateDiscount request", "error", err)
		http.Error(w, `{"error": "Invalid JSON", "message": "Request body contains invalid JSON"}`, http.StatusBadRequest)
		return
	}

	if err := req.Validate(); err != nil {
		h.logger.Error("Validation failed for CreateDiscount request", "error", err)
		fieldErrors := make(map[string]string)
		if validationErrors, ok := err.(validator.ValidationErrors); ok {
			for _, err := range validationErrors {
				fieldErrors[err.Field()] = formatValidationError(err)
			}
		}
		// Send validation error response
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusUnprocessableEntity)
		json.NewEncoder(w).Encode(map[string]interface{}{
			"error":   "Validation Failed",
			"message": "The request data is invalid.",
			"details": fieldErrors,
		})
		return
	}

	createdDiscount, err := h.service.CreateDiscount(r.Context(), req)
	if err != nil {
		h.logger.Error("Failed to create discount", "error", err)
		if strings.Contains(err.Error(), "already exists") {
			http.Error(w, `{"error": "Discount Code Conflict", "message": "`+err.Error()+`"}`, http.StatusConflict)
			return
		}
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to create discount"}`, http.StatusInternalServerError)
		return
	}

	h.logger.Info("Discount created successfully", "discount_id", createdDiscount.ID)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(createdDiscount)
}

// GetDiscount handles retrieving a specific discount by ID.
func (h *DiscountHandler) GetDiscount(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		h.logger.Error("Invalid discount ID in GetDiscount request", "id", idStr, "error", err)
		http.Error(w, `{"error": "Invalid Discount ID", "message": "Discount ID must be a valid UUID"}`, http.StatusBadRequest)
		return
	}

	discount, err := h.service.GetDiscount(r.Context(), id)
	if err != nil {
		h.logger.Error("Failed to get discount", "id", id, "error", err)
		if errors.Is(err, pgx.ErrNoRows) || err.Error() == "discount not found" {
			http.Error(w, `{"error": "Discount Not Found", "message": "The requested discount does not exist"}`, http.StatusNotFound)
			return
		}
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to retrieve discount"}`, http.StatusInternalServerError)
		return
	}

	h.logger.Info("Discount retrieved successfully", "discount_id", discount.ID)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(discount)
}

func (h *DiscountHandler) GetDiscountsByProductID(w http.ResponseWriter, r *http.Request) {
	productIDStr := chi.URLParam(r, "product_id")
	productID, err := uuid.Parse(productIDStr)
	if err != nil {
		h.logger.Error("Invalid product ID parameter in GetDiscountsByProductID request", "value", productIDStr, "error", err)
		http.Error(w, `{"error": "Invalid Parameter", "message": "Parameter 'product_id' must be a valid UUID"}`, http.StatusBadRequest)
		return
	}

	discounts, err := h.service.GetDiscountsByProductID(r.Context(), productID)
	if err != nil {
		h.logger.Error("Failed to get discounts for product", "product_id", productID, "error", err)
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to retrieve discounts for product"}`, http.StatusInternalServerError)
		return
	}

	h.logger.Info("Discounts retrieved successfully for product", "product_id", productID, "count", len(discounts))
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(discounts) // Encode the slice directly
}

// UpdateDiscount handles updating an existing discount by ID.
func (h *DiscountHandler) UpdateDiscount(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		h.logger.Error("Invalid discount ID in UpdateDiscount request", "id", idStr, "error", err)
		http.Error(w, `{"error": "Invalid Discount ID", "message": "Discount ID must be a valid UUID"}`, http.StatusBadRequest)
		return
	}

	var req models.UpdateDiscountRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Error("Invalid JSON in UpdateDiscount request", "error", err)
		http.Error(w, `{"error": "Invalid JSON", "message": "Request body contains invalid JSON"}`, http.StatusBadRequest)
		return
	}

	// Validation for UpdateDiscountRequest might be trickier due to conditional fields.
	// You might need custom validation logic here or ensure the service handles it robustly.
	// For now, let's assume basic struct validation works where applicable.
	if err := req.Validate(); err != nil {
		h.logger.Error("Validation failed for UpdateDiscount request", "error", err)
		fieldErrors := make(map[string]string)
		if validationErrors, ok := err.(validator.ValidationErrors); ok {
			for _, err := range validationErrors {
				fieldErrors[err.Field()] = formatValidationError(err)
			}
		}
		// Send validation error response
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusUnprocessableEntity)
		json.NewEncoder(w).Encode(map[string]interface{}{
			"error":   "Validation Failed",
			"message": "The request data is invalid.",
			"details": fieldErrors,
		})
		return
	}

	updatedDiscount, err := h.service.UpdateDiscount(r.Context(), id, req)
	if err != nil {
		h.logger.Error("Failed to update discount", "id", id, "error", err)
		if errors.Is(err, pgx.ErrNoRows) || err.Error() == "discount not found" {
			http.Error(w, `{"error": "Discount Not Found", "message": "The requested discount does not exist"}`, http.StatusNotFound)
			return
		}
		if strings.Contains(err.Error(), "already exists") {
			http.Error(w, `{"error": "Discount Code Conflict", "message": "`+err.Error()+`"}`, http.StatusConflict)
			return
		}
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to update discount"}`, http.StatusInternalServerError)
		return
	}

	h.logger.Info("Discount updated successfully", "discount_id", updatedDiscount.ID)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(updatedDiscount)
}

// DeleteDiscount handles deleting a discount by ID.
func (h *DiscountHandler) DeleteDiscount(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		h.logger.Error("Invalid discount ID in DeleteDiscount request", "id", idStr, "error", err)
		http.Error(w, `{"error": "Invalid Discount ID", "message": "Discount ID must be a valid UUID"}`, http.StatusBadRequest)
		return
	}

	err = h.service.DeleteDiscount(r.Context(), id)
	if err != nil {
		h.logger.Error("Failed to delete discount", "id", id, "error", err)
		if errors.Is(err, pgx.ErrNoRows) || err.Error() == "discount not found" {
			http.Error(w, `{"error": "Discount Not Found", "message": "The requested discount does not exist"}`, http.StatusNotFound)
			return
		}
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to delete discount"}`, http.StatusInternalServerError)
		return
	}

	h.logger.Info("Discount deleted successfully", "discount_id", id)
	w.WriteHeader(http.StatusNoContent) // 204 No Content
}

// ListDiscounts handles retrieving a paginated list of discounts based on filters.
func (h *DiscountHandler) ListDiscounts(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters
	query := r.URL.Query()
	var isActive *bool
	if isActiveStr := query.Get("is_active"); isActiveStr != "" {
		isActiveVal, err := strconv.ParseBool(isActiveStr)
		if err != nil {
			h.logger.Error("Invalid is_active parameter in ListDiscounts request", "value", isActiveStr, "error", err)
			http.Error(w, `{"error": "Invalid Parameter", "message": "Parameter 'is_active' must be a valid boolean (true/false)"}`, http.StatusBadRequest)
			return
		}
		isActive = &isActiveVal
	}

	// --- Parse new date filter parameters ---
	var validFrom, validUntil *time.Time
	if validFromStr := query.Get("valid_from"); validFromStr != "" {
		parsedTime, err := time.Parse(time.RFC3339, validFromStr) // Or another layout if needed, e.g. time.RFC3339Nano
		if err != nil {
			h.logger.Error("Invalid valid_from parameter in ListDiscounts request", "value", validFromStr, "error", err)
			http.Error(w, `{"error": "Invalid Parameter", "message": "Parameter 'valid_from' must be a valid RFC3339 timestamp"}`, http.StatusBadRequest)
			return
		}
		validFrom = &parsedTime
	}

	if validUntilStr := query.Get("valid_until"); validUntilStr != "" {
		parsedTime, err := time.Parse(time.RFC3339, validUntilStr) // Or another layout if needed
		if err != nil {
			h.logger.Error("Invalid valid_until parameter in ListDiscounts request", "value", validUntilStr, "error", err)
			http.Error(w, `{"error": "Invalid Parameter", "message": "Parameter 'valid_until' must be a valid RFC3339 timestamp"}`, http.StatusBadRequest)
			return
		}
		validUntil = &parsedTime
	}
	// ---

	pageStr := query.Get("page")
	page, err := strconv.Atoi(pageStr)
	if err != nil || page < 1 {
		page = 1 // Default to page 1
	}

	limitStr := query.Get("limit")
	limit, err := strconv.Atoi(limitStr)
	if err != nil || limit < 1 {
		limit = 20 // Default to 20 per page
	}
	if limit > 100 {
		limit = 100 // Enforce maximum limit
	}

	req := models.ListDiscountsRequest{
		IsActive:   isActive,
		ValidFrom:  validFrom,  // Add parsed date filters
		ValidUntil: validUntil, // Add parsed date filters
		Page:       page,
		Limit:      limit,
	}

	listResponse, err := h.service.ListDiscounts(r.Context(), req)
	if err != nil {
		h.logger.Error("Failed to list discounts", "request", req, "error", err)
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to retrieve discount list"}`, http.StatusInternalServerError)
		return
	}

	h.logger.Info("Discount list retrieved successfully", "page", req.Page, "limit", req.Limit, "total", listResponse.Total)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(listResponse)
}

// LinkDiscountToProduct handles associating a discount with a product.
func (h *DiscountHandler) LinkDiscountToProduct(w http.ResponseWriter, r *http.Request) {
	discountIDStr := chi.URLParam(r, "discount_id")
	discountID, err := uuid.Parse(discountIDStr)
	if err != nil {
		h.logger.Error("Invalid discount ID in LinkDiscountToProduct request", "discount_id", discountIDStr, "error", err)
		http.Error(w, `{"error": "Invalid Discount ID", "message": "Discount ID must be a valid UUID"}`, http.StatusBadRequest)
		return
	}

	var req models.LinkDiscountRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Error("Invalid JSON in LinkDiscountToProduct request", "error", err)
		http.Error(w, `{"error": "Invalid JSON", "message": "Request body contains invalid JSON"}`, http.StatusBadRequest)
		return
	}

	if err := req.Validate(); err != nil {
		h.logger.Error("Validation failed for LinkDiscountToProduct request", "error", err)
		fieldErrors := make(map[string]string)
		if validationErrors, ok := err.(validator.ValidationErrors); ok {
			for _, err := range validationErrors {
				fieldErrors[err.Field()] = formatValidationError(err)
			}
		}
		// Send validation error response
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusUnprocessableEntity)
		json.NewEncoder(w).Encode(map[string]interface{}{
			"error":   "Validation Failed",
			"message": "The request data is invalid.",
			"details": fieldErrors,
		})
		return
	}

	err = h.service.LinkDiscountToProduct(r.Context(), discountID, req.ProductID)
	if err != nil {
		h.logger.Error("Failed to link discount to product", "discount_id", discountID, "product_id", req.ProductID, "error", err)
		if strings.Contains(err.Error(), "already linked to product") {

			http.Error(w, `{"error": "Conflict", "message": "The discount is already linked to the specified product"}`, http.StatusConflict)
			return
		}
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to link discount to product"}`, http.StatusInternalServerError)
		return
	}

	h.logger.Info("Discount linked to product successfully", "discount_id", discountID, "product_id", req.ProductID)
	w.WriteHeader(http.StatusOK) // 200 OK or 204 No Content
}

// UnlinkDiscountFromProduct handles removing the association between a discount and a product.
func (h *DiscountHandler) UnlinkDiscountFromProduct(w http.ResponseWriter, r *http.Request) {
	discountIDStr := chi.URLParam(r, "discount_id")
	discountID, err := uuid.Parse(discountIDStr)
	if err != nil {
		h.logger.Error("Invalid discount ID in UnlinkDiscountFromProduct request", "discount_id", discountIDStr, "error", err)
		http.Error(w, `{"error": "Invalid Discount ID", "message": "Discount ID must be a valid UUID"}`, http.StatusBadRequest)
		return
	}

	var req models.UnlinkDiscountRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Error("Invalid JSON in UnlinkDiscountFromProduct request", "error", err)
		http.Error(w, `{"error": "Invalid JSON", "message": "Request body contains invalid JSON"}`, http.StatusBadRequest)
		return
	}

	if err := req.Validate(); err != nil {
		h.logger.Error("Validation failed for UnlinkDiscountFromProduct request", "error", err)
		fieldErrors := make(map[string]string)
		if validationErrors, ok := err.(validator.ValidationErrors); ok {
			for _, err := range validationErrors {
				fieldErrors[err.Field()] = formatValidationError(err)
			}
		}
		// Send validation error response
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusUnprocessableEntity)
		json.NewEncoder(w).Encode(map[string]interface{}{
			"error":   "Validation Failed",
			"message": "The request data is invalid.",
			"details": fieldErrors,
		})
		return
	}

	err = h.service.UnlinkDiscountFromProduct(r.Context(), discountID, req.ProductID)
	if err != nil {
		h.logger.Error("Failed to unlink discount from product", "discount_id", discountID, "product_id", req.ProductID, "error", err)
		http.Error(w, `{"error": "Internal Server Error", "message": "Failed to unlink discount from product"}`, http.StatusInternalServerError)
		return
	}

	h.logger.Info("Discount unlinked from product successfully", "discount_id", discountID, "product_id", req.ProductID)
	w.WriteHeader(http.StatusOK) // 200 OK or 204 No Content
}


File: internal/utils/slug.go
================================================
package utils

import (
	"github.com/gosimple/slug"
)

// GenerateSlug creates a URL-friendly slug from an input string.
// It converts the input to lowercase, replaces spaces with hyphens,
// removes special characters, etc.
// Example: "AMD Ryzen 9 7950X" -> "amd-ryzen-9-7950x"
func GenerateSlug(input string) string {
	return slug.Make(input)
}


File: internal/services/review_service.go
================================================
package services

import (
	"context"
	"errors"
	"fmt"
	"log/slog"

	"github.com/MihoZaki/DzTech/internal/db"
	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgxpool"
)

// ReviewService handles business logic for reviews.
type ReviewService struct {
	querier db.Querier
	pool    *pgxpool.Pool // Need for transactions
	logger  *slog.Logger
}

func NewReviewService(querier db.Querier, pool *pgxpool.Pool, logger *slog.Logger) *ReviewService {
	return &ReviewService{
		querier: querier,
		pool:    pool,
		logger:  logger,
	}
}

// CreateReview creates a new review for a product by a user and updates product stats.
func (s *ReviewService) CreateReview(ctx context.Context, userID uuid.UUID, req models.CreateReviewRequest) (*models.Review, error) {
	queries, ok := s.querier.(*db.Queries)
	if !ok {
		return nil, errors.New("querier type assertion to *db.Queries failed, cannot create transactional querier")
	}
	tx, err := s.pool.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction for review creation: %w", err)
	}
	defer func() {
		if err := tx.Rollback(ctx); err != nil && !errors.Is(err, pgx.ErrTxClosed) {
			s.logger.Error("Error during review creation transaction rollback", "error", err)
		}
	}()

	txQuerier := queries.WithTx(tx)

	dbReview, err := txQuerier.CreateReview(ctx, db.CreateReviewParams{
		UserID:    userID,
		ProductID: req.ProductID,
		Rating:    int32(req.Rating),
	})
	if err != nil {

		var pgErr *pgconn.PgError
		if errors.As(err, &pgErr) {
			if pgErr.Code == "23505" { // PostgreSQL unique violation error code
				return nil, fmt.Errorf("user has already reviewed this product")
			}
		}

		return nil, fmt.Errorf("failed to create review in transaction: %w", err)
	}

	// This happens within the same transaction to ensure consistency
	err = s.updateProductReviewStats(ctx, txQuerier, req.ProductID)
	if err != nil {
		return nil, fmt.Errorf("failed to update product review stats in transaction: %w", err)
	}

	if err = tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit review creation transaction: %w", err)
	}

	apiReview := &models.Review{
		ID:        dbReview.ID,
		UserID:    dbReview.UserID,
		ProductID: dbReview.ProductID,
		Rating:    int(dbReview.Rating),
		CreatedAt: dbReview.CreatedAt.Time,
		UpdatedAt: dbReview.UpdatedAt.Time,
	}

	return apiReview, nil
}

func (s *ReviewService) updateProductReviewStats(ctx context.Context, querier db.Querier, productID uuid.UUID) error {
	stats, err := querier.CalculateReviewStatsForProduct(ctx, productID)
	if err != nil {
		return fmt.Errorf("failed to calculate review stats for product %s: %w", productID, err)
	}

	// The CalculateReviewStatsForProductRow fields are:
	// - AvgRating pgtype.Numeric (can be NULL if no reviews)
	// - NumRatings int32 (will be 0 if no reviews)
	//
	// The UpdateProductReviewStatsParams fields are
	// - AvgRating pgtype.Numeric (matches)
	// - NumRatings *int32 (mismatch if products.num_ratings is NOT NULL, but COUNT always returns int32)
	// - ProductID uuid.UUID (matches)

	updateParams := db.UpdateProductReviewStatsParams{
		AvgRating:  stats.AvgRating,
		NumRatings: &stats.NumRatings,
		ProductID:  productID,
	}

	err = querier.UpdateProductReviewStats(ctx, updateParams)
	if err != nil {
		return fmt.Errorf("failed to update review stats in products table for product %s: %w", productID, err)
	}

	s.logger.Debug("Updated review stats for product",
		"product_id", productID,
		"new_avg_rating", stats.AvgRating,
		"new_avg_rating_valid", stats.AvgRating.Valid,
		"new_num_ratings", stats.NumRatings)

	return nil
}

// UpdateReview updates an existing review by the user and recalculates product stats.
func (s *ReviewService) UpdateReview(ctx context.Context, reviewID uuid.UUID, userID uuid.UUID, req models.UpdateReviewRequest) (*models.Review, error) {
	queries, ok := s.querier.(*db.Queries)
	if !ok {
		return nil, errors.New("querier type assertion to *db.Queries failed, cannot create transactional querier")
	}

	tx, err := s.pool.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction for review update: %w", err)
	}
	defer func() {
		if err := tx.Rollback(ctx); err != nil && !errors.Is(err, pgx.ErrTxClosed) {
			s.logger.Error("Error during review update transaction rollback", "error", err)
		}
	}()

	txQuerier := queries.WithTx(tx)

	fetchedReview, err := txQuerier.GetReviewByIDAndUser(ctx, db.GetReviewByIDAndUserParams{
		ID:     reviewID,
		UserID: userID,
	})
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, fmt.Errorf("review not found or does not belong to user")
		}
		return nil, fmt.Errorf("failed to fetch review for update: %w", err)
	}

	dbReview, err := txQuerier.UpdateReview(ctx, db.UpdateReviewParams{
		Rating: int32(req.Rating),
		ID:     reviewID,
		UserID: userID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update review in transaction: %w", err)
	}

	err = s.updateProductReviewStats(ctx, txQuerier, fetchedReview.ProductID)
	if err != nil {
		return nil, fmt.Errorf("failed to update product review stats in transaction: %w", err)
	}

	if err = tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit review update transaction: %w", err)
	}
	apiReview := &models.Review{
		ID:        dbReview.ID,
		UserID:    dbReview.UserID,
		ProductID: dbReview.ProductID,
		Rating:    int(dbReview.Rating),
		CreatedAt: dbReview.CreatedAt.Time,
		UpdatedAt: dbReview.UpdatedAt.Time,
	}

	return apiReview, nil
}

// DeleteReview deletes an existing review by the user and recalculates product stats.
func (s *ReviewService) DeleteReview(ctx context.Context, reviewID uuid.UUID, userID uuid.UUID) error {

	queries, ok := s.querier.(*db.Queries)
	if !ok {
		return errors.New("querier type assertion to *db.Queries failed, cannot create transactional querier")
	}

	tx, err := s.pool.Begin(ctx)
	if err != nil {
		return fmt.Errorf("failed to begin transaction for review deletion: %w", err)
	}

	defer func() {
		if err := tx.Rollback(ctx); err != nil && !errors.Is(err, pgx.ErrTxClosed) {
			s.logger.Error("Error during review deletion transaction rollback", "error", err)
		}
	}()

	txQuerier := queries.WithTx(tx)

	reviewToDelete, err := txQuerier.GetReviewByIDAndUser(ctx, db.GetReviewByIDAndUserParams{
		ID:     reviewID,
		UserID: userID,
	})
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {

			return fmt.Errorf("review not found or does not belong to user")
		}

		return fmt.Errorf("failed to fetch review for deletion: %w", err)
	}

	_, err = txQuerier.DeleteReview(ctx, db.DeleteReviewParams{
		ID:     reviewID,
		UserID: userID,
	})
	if err != nil {
		return fmt.Errorf("failed to delete review in transaction: %w", err)
	}

	err = s.updateProductReviewStats(ctx, txQuerier, reviewToDelete.ProductID)
	if err != nil {
		return fmt.Errorf("failed to update product review stats in transaction: %w", err)
	}

	if err = tx.Commit(ctx); err != nil {
		return fmt.Errorf("failed to commit review deletion transaction: %w", err)
	}

	return nil
}

// GetReviewsByProductID fetches reviews for a specific product.
func (s *ReviewService) GetReviewsByProductID(ctx context.Context, productID uuid.UUID, page, limit int) (*models.GetReviewsByProductResponse, error) {
	if limit <= 0 {
		limit = 20 // Default limit
	}
	if page <= 0 {
		page = 1 // Default page
	}
	offset := (page - 1) * limit

	dbReviews, err := s.querier.GetReviewsByProductID(ctx, db.GetReviewsByProductIDParams{
		ProductID:  productID,
		PageOffset: int32(offset),
		PageLimit:  int32(limit),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch reviews for product: %w", err)
	}

	reviewListItems := make([]models.ReviewListItem, len(dbReviews))
	for i, r := range dbReviews {
		reviewListItems[i] = models.ReviewListItem{
			ID:           r.ID,
			UserID:       r.UserID,
			ReviewerName: *r.ReviewerName,
			ProductID:    r.ProductID,
			Rating:       int(r.Rating),
			CreatedAt:    r.CreatedAt.Time,
			UpdatedAt:    r.UpdatedAt.Time,
		}
	}

	return &models.GetReviewsByProductResponse{
		Reviews: reviewListItems,
		Page:    page,
		Limit:   limit,
	}, nil
}

// GetReviewsByUserID fetches reviews submitted by a specific user.
// This method does not update product stats, just reads reviews.
func (s *ReviewService) GetReviewsByUserID(ctx context.Context, userID uuid.UUID, page, limit int) (*models.GetReviewsByUserResponse, error) {
	if limit <= 0 {
		limit = 20
	}
	if page <= 0 {
		page = 1
	}
	offset := (page - 1) * limit

	dbReviews, err := s.querier.GetReviewsByUserID(ctx, db.GetReviewsByUserIDParams{
		UserID:     userID,
		PageOffset: int32(offset),
		PageLimit:  int32(limit),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch reviews by user: %w", err)
	}

	reviewByUserListItems := make([]models.ReviewByUserListItem, len(dbReviews))
	for i, r := range dbReviews {
		reviewByUserListItems[i] = models.ReviewByUserListItem{
			ID:          r.ID,
			UserID:      r.UserID,
			ProductID:   r.ProductID,
			ProductName: r.ProductName,
			Rating:      int(r.Rating),
			CreatedAt:   r.CreatedAt.Time,
			UpdatedAt:   r.UpdatedAt.Time,
		}
	}

	return &models.GetReviewsByUserResponse{
		Reviews: reviewByUserListItems,
		Page:    page,
		Limit:   limit,
	}, nil
}


File: internal/services/cart_service.go
================================================
package services

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"strings"
	"time"

	"github.com/MihoZaki/DzTech/internal/db"
	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/MihoZaki/DzTech/internal/utils"
	"github.com/google/uuid"

	"github.com/jackc/pgx/v5"
)

type CartService struct {
	querier    db.Querier
	productSvc *ProductService // Need product details for cart items
	logger     *slog.Logger
}

func NewCartService(querier db.Querier, productSvc *ProductService, logger *slog.Logger) *CartService {
	return &CartService{
		querier:    querier,
		productSvc: productSvc,
		logger:     logger,
	}
}

// GetCartForContext retrieves the cart for the given user ID or session ID.
// It ensures the cart exists, fetching or creating it as necessary.
// It calculates enhanced totals: original value, discounted value, and savings.
func (s *CartService) GetCartForContext(ctx context.Context, userID *uuid.UUID, sessionID string) (*models.CartSummary, error) {
	if userID == nil && sessionID == "" {
		return nil, fmt.Errorf("either userID or sessionID must be provided")
	}

	var cartID uuid.UUID
	var cartUserID uuid.UUID
	var cartSessionID *string
	var cartCreatedAt, cartUpdatedAt time.Time

	// Determine if user is authenticated or a guest
	if userID != nil {
		dbCart, err := s.getOrCreateUserCart(ctx, *userID)
		if err != nil {
			s.logger.Error("Error getting/creating user cart", "error", err, "user_id", *userID)
			return nil, err
		}
		cartID = dbCart.ID
		cartUserID = dbCart.UserID
		cartSessionID = dbCart.SessionID
		cartCreatedAt = dbCart.CreatedAt.Time
		cartUpdatedAt = dbCart.UpdatedAt.Time
	} else {
		dbCart, err := s.getOrCreateGuestCart(ctx, sessionID)
		if err != nil {
			s.logger.Error("Error getting/creating guest cart", "error", err, "session_id", sessionID)
			return nil, err
		}
		cartID = dbCart.ID
		cartUserID = dbCart.UserID       // Will be nil for guest carts
		cartSessionID = dbCart.SessionID // Will be &sessionID for guest carts
		cartCreatedAt = dbCart.CreatedAt.Time
		cartUpdatedAt = dbCart.UpdatedAt.Time
	}

	dbItemsWithProductAndDiscounts, err := s.querier.GetCartWithItemsAndProductsWithDiscounts(ctx, cartID)
	if err != nil && !errors.Is(err, pgx.ErrNoRows) {
		s.logger.Error("Error fetching cart items with product details and discounts", "error", err, "cart_id", cartID)
		return nil, fmt.Errorf("failed to retrieve cart items with discounts: %w", err)
	}

	if len(dbItemsWithProductAndDiscounts) == 0 {
		// Return an empty summary if the cart exists but has no items
		return &models.CartSummary{
			ID:         cartID,
			UserID:     cartUserID,
			SessionID:  cartSessionID,
			CreatedAt:  cartCreatedAt,
			UpdatedAt:  cartUpdatedAt,
			Items:      []models.CartItemSummary{},
			TotalItems: 0,
			TotalQty:   0,
			// --- Initialize New Totals for Empty Cart ---
			TotalOriginalValueCents:   0,
			TotalDiscountedValueCents: 0,
			TotalSavingsCents:         0,
			// ---
		}, nil
	}

	// Calculate totals and build the summary model
	var totalItems, totalQuantity int
	var totalOriginalValueCents int64   // New field: Sum of (original_price * quantity)
	var totalDiscountedValueCents int64 // New field: Sum of (final_price * quantity)
	// var totalValueCents int64 // Old field, now represented by totalDiscountedValueCents
	items := make([]models.CartItemSummary, 0, len(dbItemsWithProductAndDiscounts)) // Pre-allocate slice

	// Use a map to track distinct product IDs for TotalItems count
	distinctProducts := make(map[uuid.UUID]bool)

	for _, itemRow := range dbItemsWithProductAndDiscounts {
		if itemRow.ProductName != nil {
			qty := int(*itemRow.ItemQuantity)                 // Quantity is a pointer because of emit_pointers_for_null_types
			originalPriceCents := *itemRow.OriginalPriceCents // Original price from the query (p.price_cents)
			finalPriceCents := itemRow.FinalPriceCents        // Final price from the query (vpcd.calculated_discounted_price_cents or fallback)

			// --- Calculate Item Subtotals ---
			itemOriginalSubtotalCents := originalPriceCents * int64(qty)
			itemFinalSubtotalCents := finalPriceCents * int64(qty)
			// ---

			// --- Accumulate Totals ---
			totalOriginalValueCents += itemOriginalSubtotalCents
			totalDiscountedValueCents += itemFinalSubtotalCents
			// totalValueCents += itemFinalSubtotalCents // Old calculation, now redundant
			// ---

			productID := itemRow.ItemProductID
			if !distinctProducts[productID] {
				totalItems++
				distinctProducts[productID] = true
			}
			totalQuantity += qty

			// Decode the image URLs JSONB array from []byte to []string
			var imageUrls []string
			if itemRow.ProductImageUrls != nil { // Check if JSONB column is not NULL
				err := json.Unmarshal(itemRow.ProductImageUrls, &imageUrls)
				if err != nil {
					s.logger.Warn("Failed to decode image URLs for product in cart", "product_id", itemRow.ItemProductID, "error", err)
					// Set an empty slice on error
					imageUrls = []string{}
				}
			} else {
				imageUrls = []string{} // Default to empty slice if image_urls is null in DB
			}

			productLite := &models.ProductLite{
				ID:                 itemRow.ItemProductID,         // Use ID from the joined query result
				Name:               *itemRow.ProductName,          // Use Name from the joined query result
				OriginalPriceCents: *itemRow.OriginalPriceCents,   // Include original price
				FinalPriceCents:    finalPriceCents,               // Use the final discounted price
				StockQuantity:      *itemRow.ProductStockQuantity, // Use Stock from the joined query result
				ImageUrls:          imageUrls,                     // Now properly decoded
				Brand:              *itemRow.ProductBrand,         // Use Brand from the joined query result
				HasActiveDiscount:  itemRow.HasActiveDiscount,     // Use the flag from the view
			}

			itemSummary := models.CartItemSummary{
				ID:       itemRow.ItemID,     // Use ID from the joined query result
				CartID:   itemRow.ItemCartID, // Use CartID from the joined query result
				Product:  productLite,        // Use the updated ProductLite
				Quantity: qty,                // Use quantity from the joined query result
			}
			items = append(items, itemSummary)
		} else {
			s.logger.Debug("Skipping cart item with missing/deleted product", "item_id", itemRow.ItemID, "product_id", itemRow.ItemProductID)
		}
	}

	totalOriginalValueCentsRounded := utils.RoundToDinarCents(totalOriginalValueCents)
	totalDiscountedValueCentsRounded := utils.RoundToDinarCents(totalDiscountedValueCents)
	// --- Calculate Final Savings ---
	totalSavingsCents := totalOriginalValueCentsRounded - totalDiscountedValueCentsRounded
	// ---
	return &models.CartSummary{
		ID:                        cartID,
		UserID:                    cartUserID,
		SessionID:                 cartSessionID,
		CreatedAt:                 cartCreatedAt,
		UpdatedAt:                 cartUpdatedAt,
		Items:                     items,
		TotalItems:                totalItems,
		TotalQty:                  totalQuantity,
		TotalOriginalValueCents:   totalOriginalValueCentsRounded,
		TotalDiscountedValueCents: totalDiscountedValueCentsRounded,
		TotalSavingsCents:         totalSavingsCents,
		// ---
		// Optionally, remove TotalValue or set it to the discounted value for backward compatibility if needed elsewhere.
		// TotalValue: totalDiscountedValueCents, // If TotalValue field is kept in the model
	}, nil
}

// getOrCreateUserCart fetches the cart for a user, creating one if it doesn't exist.
// Returns the database row struct (GetCartByUserIDRow).
func (s *CartService) getOrCreateUserCart(ctx context.Context, userID uuid.UUID) (db.Cart, error) {
	cart, err := s.querier.GetCartByUserID(ctx, userID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			// Cart doesn't exist, create one using the specific query for users
			newCart, err := s.querier.CreateUserCart(ctx, userID) // Pass userID directly as argument
			if err != nil {
				return db.Cart{}, fmt.Errorf("failed to create cart for user %s: %w", userID, err)
			}
			s.logger.Debug("Created new cart for user", "user_id", userID, "cart_id", newCart.ID)
			return newCart, nil // Return the struct returned by CreateUserCart
		}
		return db.Cart{}, fmt.Errorf("failed to get cart for user %s: %w", userID, err)
	}
	// Return the existing cart row, cast appropriately if necessary

	return db.Cart{
		ID:        cart.ID,
		UserID:    cart.UserID,    // Should be the userID passed in
		SessionID: cart.SessionID, // Should be nil/NULL
		CreatedAt: cart.CreatedAt,
		UpdatedAt: cart.UpdatedAt,
	}, nil
}

// getOrCreateGuestCart fetches the cart for a session, creating one if it doesn't exist.
// Uses the new CreateGuestCart query.
// Returns the database row struct (Cart, which is the struct used for the RETURNING clause).
func (s *CartService) getOrCreateGuestCart(ctx context.Context, sessionID string) (db.Cart, error) {
	cart, err := s.querier.GetCartBySessionID(ctx, &sessionID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			// Cart doesn't exist, create one using the specific query for guests
			newCart, err := s.querier.CreateGuestCart(ctx, &sessionID) // Pass sessionID as a pointer to string
			if err != nil {
				return db.Cart{}, fmt.Errorf("failed to create cart for session %s: %w", sessionID, err)
			}
			s.logger.Debug("Created new cart for session", "session_id", sessionID, "cart_id", newCart.ID)
			return newCart, nil // Return the struct returned by CreateGuestCart
		}
		return db.Cart{}, fmt.Errorf("failed to get cart for session %s: %w", sessionID, err)
	}
	// Return the existing cart row, mapped appropriately.
	// Assuming GetCartBySessionIDRow fields can be mapped to db.Cart.
	// GetCartBySessionID returns GetCartBySessionIDRow.
	return db.Cart{
		ID:        cart.ID,
		UserID:    cart.UserID,    // Should be nil/NULL
		SessionID: cart.SessionID, // Should be &sessionID
		CreatedAt: cart.CreatedAt,
		UpdatedAt: cart.UpdatedAt,
	}, nil
}

// AddItemToCart adds an item to the specified user's or guest's cart.
// If the item already exists in the cart, it updates the quantity.
func (s *CartService) AddItemToCart(ctx context.Context, userID *uuid.UUID, sessionID string, productID uuid.UUID, quantity int) (*db.CartItem, error) {
	if quantity <= 0 {
		return nil, fmt.Errorf("quantity must be greater than 0")
	}
	// Validate product exists and get its details (including stock)
	product, err := s.productSvc.GetProduct(ctx, productID) // We don't strictly need the returned product struct here for existence check if the DB query handles it robustly
	if err != nil {
		return nil, fmt.Errorf("failed to validate product %s: %w", productID, err)
	}

	if product.StockQuantity < quantity {
		return nil, fmt.Errorf("requested quantity %d exceeds available stock %d for product %s", quantity, product.StockQuantity, productID)
	}
	// Determine the cart ID based on user or session
	var cartID uuid.UUID
	if userID != nil {
		userCart, err := s.getOrCreateUserCart(ctx, *userID)
		if err != nil {
			return nil, fmt.Errorf("failed to get user cart: %w", err)
		}
		cartID = userCart.ID
	} else {
		guestCart, err := s.getOrCreateGuestCart(ctx, sessionID)
		if err != nil {
			return nil, fmt.Errorf("failed to get guest cart: %w", err)
		}
		cartID = guestCart.ID
	}

	// Attempt to create or update the cart item using the SQL query
	// The query CreateCartItem handles ON CONFLICT (cart_id, product_id) DO UPDATE SET quantity = ...
	// and also enforces stock limits during the update.
	params := db.CreateCartItemParams{
		CartID:    cartID,
		ProductID: productID,
		Quantity:  int32(quantity),
	}
	// The CreateCartItem query is designed to handle the upsert and stock check atomically.
	updatedOrCreatedItem, err := s.querier.CreateCartItem(ctx, params)
	if err != nil {
		// The DB query should handle stock violations during the INSERT/UPDATE.
		// Depending on how strictly the DB constraint is defined, this might manifest differently.
		// For now, let the error propagate. The handler can decide how to respond.
		s.logger.Info("the update failure is due to", "dbErr", err)
		return nil, fmt.Errorf("failed to add item to cart: %w", err)
	}

	return &updatedOrCreatedItem, nil
}

// AddBulkItems adds multiple items to the user's or guest's cart efficiently in a single database call.
// It performs upserts and checks stock availability for all items in the batch atomically in the DB.
// It determines the cart based on userID (authenticated) or sessionID (guest).
func (s *CartService) AddBulkItems(ctx context.Context, userID *uuid.UUID, sessionID string, items []models.BulkAddItemRequest_Item) error {
	if len(items) == 0 {
		return fmt.Errorf("cannot add empty item list to cart")
	}

	// Determine the cart ID based on user or session (mirroring AddItemToCart logic)
	var cartID uuid.UUID
	if userID != nil {
		userCart, err := s.getOrCreateUserCart(ctx, *userID)
		if err != nil {
			return fmt.Errorf("failed to get user cart: %w", err)
		}
		cartID = userCart.ID
	} else if sessionID != "" {
		guestCart, err := s.getOrCreateGuestCart(ctx, sessionID)
		if err != nil {
			return fmt.Errorf("failed to get guest cart: %w", err)
		}
		cartID = guestCart.ID
	} else {
		return fmt.Errorf("either userID or sessionID must be provided to add items to cart")
	}

	// Validate items before preparing DB parameters
	for _, item := range items {
		if item.Quantity <= 0 {
			return fmt.Errorf("quantity for product %s must be greater than 0", item.ProductID)
		}
	}

	productIDs := make([]uuid.UUID, len(items))
	quantities := make([]int32, len(items))

	for i, item := range items {
		productIDs[i] = item.ProductID
		quantities[i] = int32(item.Quantity)
	}

	params := db.AddCartItemsBulkParams{
		CartID:     cartID, // Use the fetched or created cart ID
		ProductIds: productIDs,
		Quantities: quantities,
	}
	rowsAffected, err := s.querier.AddCartItemsBulk(ctx, params)
	requestedItemsCount := int64(len(items))
	if err != nil {
		s.logger.Error("Failed to add bulk items to cart in DB", "error", err, "user_id", userID, "session_id", sessionID, "items", items)
		return fmt.Errorf("failed to add items to cart: %w", err)
	}

	if rowsAffected != requestedItemsCount {
		s.logger.Warn("Bulk add: not all items were added to cart", "user_id", userID, "session_id", sessionID, "requested", requestedItemsCount, "added", rowsAffected)
		return fmt.Errorf("some items could not be added to the cart (e.g., invalid product ID, insufficient stock, inactive product)")
	}
	s.logger.Debug("Successfully added bulk items to cart", "user_id", userID, "session_id", sessionID, "num_items", len(items))
	return nil
}

// UpdateItemQuantityInCart updates the quantity of an item in the specified user's or guest's cart.
func (s *CartService) UpdateItemQuantityInCart(ctx context.Context, userID *uuid.UUID, sessionID string, itemID uuid.UUID, newQuantity int) (*db.UpdateCartItemQuantityRow, error) {
	if newQuantity <= 0 {
		return nil, fmt.Errorf("quantity must be greater than 0")
	}

	// Fetch the existing cart item to get its CartID and ProductID
	existingItem, err := s.querier.GetCartItemByID(ctx, itemID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, fmt.Errorf("cart item with ID %s not found", itemID)
		}
		return nil, fmt.Errorf("failed to fetch cart item %s: %w", itemID, err)
	}

	// Verify the item belongs to the correct cart (associated with the given userID or sessionID).
	// This is crucial for security: a user shouldn't be able to update an item in another user's or guest's cart.
	// We need to determine the expected cart ID based on userID/sessionID.
	var expectedCartID uuid.UUID
	if userID != nil {
		userCart, err := s.getOrCreateUserCart(ctx, *userID) // Use getOrCreate to ensure cart exists/get ID
		if err != nil {
			return nil, fmt.Errorf("failed to get user cart: %w", err)
		}
		expectedCartID = userCart.ID
	} else {
		guestCart, err := s.getOrCreateGuestCart(ctx, sessionID) // Use getOrCreate to ensure cart exists/get ID
		if err != nil {
			return nil, fmt.Errorf("failed to get guest cart: %w", err)
		}
		expectedCartID = guestCart.ID
	}

	// Check if the item's CartID matches the expected CartID derived from the user/session context.
	if existingItem.CartID != expectedCartID {
		return nil, fmt.Errorf("access denied: cart item %s does not belong to the specified cart", itemID)
	}

	// Call the query to update the quantity, which includes stock validation.
	params := db.UpdateCartItemQuantityParams{
		NewQuantity: int32(newQuantity),
		ItemID:      itemID,
	}
	updatedItem, err := s.querier.UpdateCartItemQuantity(ctx, params)
	if err != nil {
		// Check for stock violation errors propagated from the DB query
		if strings.Contains(strings.ToLower(err.Error()), "stock") || strings.Contains(strings.ToLower(err.Error()), "check") {
			return nil, fmt.Errorf("failed to update quantity: %w", err) // Propagate DB error or customize message
		}
		return nil, fmt.Errorf("failed to update item quantity: %w", err)
	}

	return &updatedItem, nil
}

// RemoveItemFromCart removes a specific item from the user's or guest's cart.
func (s *CartService) RemoveItemFromCart(ctx context.Context, userID *uuid.UUID, sessionID string, itemID uuid.UUID) error {

	existingItem, err := s.querier.GetCartItemByID(ctx, itemID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return fmt.Errorf("cart item with ID %s not found", itemID)
		}
		return fmt.Errorf("failed to fetch cart item %s: %w", itemID, err)
	}

	// Verify the item belongs to the correct cart (associated with the given userID or sessionID).
	// This is crucial for security: a user shouldn't be able to delete an item from another user's or guest's cart.
	// We need to determine the expected cart ID based on userID/sessionID.
	var expectedCartID uuid.UUID
	if userID != nil {
		userCart, err := s.getOrCreateUserCart(ctx, *userID) // Use getOrCreate to ensure cart exists/get ID
		if err != nil {
			return fmt.Errorf("failed to get user cart: %w", err)
		}
		expectedCartID = userCart.ID
	} else {
		guestCart, err := s.getOrCreateGuestCart(ctx, sessionID) // Use getOrCreate to ensure cart exists/get ID
		if err != nil {
			return fmt.Errorf("failed to get guest cart: %w", err)
		}
		expectedCartID = guestCart.ID
	}

	// Check if the item's CartID matches the expected CartID derived from the user/session context.
	if existingItem.CartID != expectedCartID {
		return fmt.Errorf("access denied: cart item %s does not belong to the specified cart", itemID)
	}

	// Call the query to soft-delete the item.
	err = s.querier.DeleteCartItem(ctx, itemID)
	if err != nil {
		slog.Debug("Deletion fail", "item_id", itemID, "cart_id", expectedCartID)
		return fmt.Errorf("failed to remove item %s from cart: %w", itemID, err)
	}
	slog.Debug("Deletion success", "item_id", itemID, "cart_id", expectedCartID)
	return nil
}

// ClearCart removes all items from the specified user's or guest's cart by soft-deleting them.
func (s *CartService) ClearCart(ctx context.Context, userID *uuid.UUID, sessionID string) error {
	// Determine the cart ID based on user or session
	var cartID uuid.UUID
	if userID != nil {
		userCart, err := s.getOrCreateUserCart(ctx, *userID)
		if err != nil {
			return fmt.Errorf("failed to get user cart: %w", err)
		}
		cartID = userCart.ID
	} else {
		guestCart, err := s.getOrCreateGuestCart(ctx, sessionID)
		if err != nil {
			return fmt.Errorf("failed to get guest cart: %w", err)
		}
		cartID = guestCart.ID
	}

	// Call the query to soft-delete all items in the cart.
	err := s.querier.ClearCart(ctx, cartID)
	if err != nil {
		return fmt.Errorf("failed to clear cart %s: %w", cartID, err)
	}

	return nil
}

// SyncGuestCartToUserCart merges items from a guest cart into a user's authenticated cart.
// It fetches the guest cart by sessionID, the user cart by userID, transfers items efficiently using a DB query,
// and clears the guest cart upon successful transfer.
func (s *CartService) SyncGuestCartToUserCart(ctx context.Context, guestSessionID string, userID uuid.UUID) error {
	if guestSessionID == "" {
		return fmt.Errorf("guest session ID cannot be empty for cart sync")
	}

	// --- Fetch or Ensure User Cart Header Exists ---
	var userCart db.GetCartByUserIDRow                            // Declare the variable to hold the user cart header info
	userCartResult, err := s.querier.GetCartByUserID(ctx, userID) // Use the existing query
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			// User cart doesn't exist, create one using the specific query for users
			newUserCart, err := s.querier.CreateUserCart(ctx, userID) // Pass userID directly as argument
			if err != nil {
				return fmt.Errorf("failed to create cart for user %s during sync: %w", userID, err)
			}
			s.logger.Debug("Created new cart for user during sync", "user_id", userID, "cart_id", newUserCart.ID)

			// Assign the fields from the newly created cart (db.CreateUserCartRow) to the userCart variable (db.GetCartByUserIDRow)
			// This explicitly converts the struct types.
			userCart = db.GetCartByUserIDRow{
				ID:        newUserCart.ID,
				UserID:    newUserCart.UserID,
				SessionID: newUserCart.SessionID,
				CreatedAt: newUserCart.CreatedAt,
				UpdatedAt: newUserCart.UpdatedAt,
			}
		} else {
			return fmt.Errorf("failed to get user cart for user %s during sync: %w", userID, err)
		}
	} else {
		userCart = userCartResult
	}

	// --- Fetch Guest Cart Header ---
	guestCart, err := s.querier.GetCartBySessionID(ctx, &guestSessionID)
	if err != nil {
		// If the guest cart doesn't exist, nothing to sync. This is not an error for the login flow.
		if errors.Is(err, pgx.ErrNoRows) {
			s.logger.Debug("No guest cart found for session during sync", "session_id", guestSessionID)
			return nil
		}
		return fmt.Errorf("failed to get guest cart for session %s during sync: %w", guestSessionID, err)
	}
	// --- End Fetch Guest Cart Header ---

	// --- Check Guest Cart Items Count ---
	guestCartItemCount, err := s.querier.GetCartItemsCount(ctx, guestCart.ID) // You might need this simple count query
	if err != nil {
		return fmt.Errorf("failed to count items in guest cart %s during sync: %w", guestCart.ID, err)
	}
	if guestCartItemCount == 0 {
		s.logger.Debug("Guest cart is empty, nothing to sync", "session_id", guestSessionID, "guest_cart_id", guestCart.ID)
		return nil // Nothing to sync
	}
	// --- End Check Guest Cart Items Count ---

	// --- Perform the Sync using the new query ---
	params := db.SyncGuestCartItemsToUserCartParams{
		TargetUserCartID:  userCart.ID,  // Destination cart (ID from userCart variable)
		SourceGuestCartID: guestCart.ID, // Source cart
	}
	err = s.querier.SyncGuestCartItemsToUserCart(ctx, params)
	if err != nil {
		// Log error and return it - this is a critical failure in the sync process.
		s.logger.Error("Failed to sync guest cart items to user cart in DB", "user_id", userID, "guest_session_id", guestSessionID, "source_cart_id", guestCart.ID, "target_cart_id", userCart.ID, "error", err)
		return fmt.Errorf("failed to sync cart items: %w", err)
	}
	s.logger.Info("Guest cart items synced to user cart", "user_id", userID, "guest_session_id", guestSessionID, "source_cart_id", guestCart.ID, "target_cart_id", userCart.ID)
	// --- End Sync Query ---

	// --- Clear Guest Cart (after successful sync query) ---
	err = s.ClearCart(ctx, nil, guestSessionID) // Pass nil userID, sessionID to target the guest cart
	if err != nil {
		// Log error but don't fail the login/registration flow if clearing fails
		s.logger.Error("Failed to clear guest cart after sync", "session_id", guestSessionID, "guest_cart_id", guestCart.ID, "error", err)
		// Optionally, you could return the error here if clearing is critical.
		// For now, proceed assuming items were transferred.
	} else {
		s.logger.Debug("Successfully cleared guest cart after sync", "session_id", guestSessionID, "guest_cart_id", guestCart.ID)
	}
	// --- End Clear Guest Cart ---

	s.logger.Info("Cart sync completed successfully", "session_id", guestSessionID, "user_id", userID)
	return nil
}


File: migrations/00002_create_users_table.sql
================================================
-- +goose Up
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash BYTEA,
    full_name VARCHAR(255),
    is_admin BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

CREATE INDEX idx_users_email ON users(email) WHERE deleted_at IS NULL;

-- +goose Down
DROP TABLE IF EXISTS users;


File: migrations/00009_create_discount_table.sql
================================================
-- +goose Up
-- Create discounts table
CREATE TABLE discounts (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    code VARCHAR(50) UNIQUE NOT NULL,
    description TEXT,
    discount_type VARCHAR(10) NOT NULL CHECK (discount_type IN ('percentage', 'fixed')),
    discount_value BIGINT NOT NULL CHECK (discount_value >= 0),
    min_order_value_cents BIGINT DEFAULT 0 CHECK (min_order_value_cents >= 0),
    max_uses INT DEFAULT NULL,
    current_uses INT DEFAULT 0,
    valid_from TIMESTAMPTZ NOT NULL,
    valid_until TIMESTAMPTZ NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create product_discounts table
CREATE TABLE product_discounts (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    discount_id UUID NOT NULL REFERENCES discounts(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (product_id, discount_id)
);

-- Create category_discounts table
CREATE TABLE category_discounts (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    category_id UUID NOT NULL REFERENCES categories(id) ON DELETE CASCADE,
    discount_id UUID NOT NULL REFERENCES discounts(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (category_id, discount_id)
);

-- Indexes for discounts table
CREATE INDEX idx_discounts_code ON discounts(code);
CREATE INDEX idx_discounts_is_active ON discounts(is_active);
CREATE INDEX idx_discounts_valid_from ON discounts(valid_from);
CREATE INDEX idx_discounts_valid_until ON discounts(valid_until);
CREATE INDEX idx_discounts_active_period ON discounts(is_active, valid_from, valid_until);

-- Indexes for product_discounts table
CREATE INDEX idx_product_discounts_product_id ON product_discounts(product_id);
CREATE INDEX idx_product_discounts_discount_id ON product_discounts(discount_id);

-- Indexes for category_discounts table
CREATE INDEX idx_category_discounts_category_id ON category_discounts(category_id);
CREATE INDEX idx_category_discounts_discount_id ON category_discounts(discount_id);
-- +goose Down
-- +goose StatementBegin
DROP TABLE IF EXISTS discounts;
-- +goose StatementEnd


File: website/README.md
================================================
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.


File: website/src/stores/useStore.jsx
================================================
// Updated useStore.jsx
import { create } from "zustand";

export const useStore = create((set, get) => ({
  cart: [],
  buildPcComponents: {},

  // Cart actions
  addToCart: (product) =>
    set((state) => {
      const existingItem = state.cart.find((item) => item.id === product.id);
      if (existingItem) {
        return {
          cart: state.cart.map((item) =>
            item.id === product.id
              ? { ...item, quantity: item.quantity + 1 }
              : item
          ),
        };
      }
      return { cart: [...state.cart, { ...product, quantity: 1 }] };
    }),

  removeFromCart: (productId) =>
    set((state) => ({
      cart: state.cart.filter((item) => item.id !== productId),
    })),

  updateQuantity: (productId, quantity) =>
    set((state) => ({
      cart: state.cart.map((item) =>
        item.id === productId ? { ...item, quantity } : item
      ),
    })),

  clearCart: () => set({ cart: [] }),

  // New function to set cart directly from backend data
  setCartFromBackend: (cartItems) => set({ cart: cartItems }),

  // Build PC actions
  setPcComponent: (category, component) =>
    set((state) => ({
      buildPcComponents: {
        ...state.buildPcComponents,
        [category]: component,
      },
    })),

  clearBuildPcComponents: () => set({ buildPcComponents: {} }),
}));


File: website/src/components/ThemeSwitcher.jsx
================================================
import { MoonIcon, SunIcon } from "@heroicons/react/24/outline";
import React, { useEffect, useState } from "react";

const ThemeSwitcher = () => {
  // Determine initial theme based on localStorage or default to light ('fantasy')
  const getInitialTheme = () => {
    const savedTheme = localStorage.getItem("theme");
    if (savedTheme) {
      // Validate saved theme exists in our list (optional but good practice)
      const availableThemes = ["fantasy", "night"];
      if (availableThemes.includes(savedTheme)) {
        return savedTheme;
      }
    }
    // Default to light theme ('fantasy')
    return "fantasy";
  };

  const [currentTheme, setCurrentTheme] = useState(getInitialTheme);

  // Apply theme on component mount and when currentTheme changes
  useEffect(() => {
    document.documentElement.setAttribute("data-theme", currentTheme);
    // Save the theme to localStorage whenever it changes
    localStorage.setItem("theme", currentTheme);
  }, [currentTheme]);

  const toggleTheme = () => {
    const newTheme = currentTheme === "fantasy" ? "night" : "fantasy";
    setCurrentTheme(newTheme);
    // The useEffect will handle saving to localStorage and applying the attribute
  };

  return (
    <button
      onClick={toggleTheme}
      className={`flex flex-row px-3 items-center gap-2 transition`} // Changed to flex-row, added gap-2 for spacing
    >
      <div>
        {currentTheme === "fantasy"
          ? <MoonIcon className="h-6 w-6" />
          : <SunIcon className="h-6 w-6" />}
      </div>
      <p className="text-sm">
        {currentTheme === "fantasy" ? "Dark Mode" : "Light Mode"}
      </p>
    </button>
  );
};

export default ThemeSwitcher;


File: website/src/pages/Checkout.jsx
================================================
import React, { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import { useCart } from "../contexts/CartContext";
import { useAuth } from "../contexts/AuthContext"; // Import useAuth to check authentication status
import {
  createOrder,
  fetchDeliveryOptions,
  placeGuestOrder,
} from "../services/api"; // Import the API functions
import { toast } from "sonner"; // Import toast for notifications

const Checkout = () => {
  const { cart, subtotal, clearCart } = useCart(); // Get cart data and clearCart function
  const { user, isAuthenticated } = useAuth(); // Get user and authentication status
  const navigate = useNavigate();

  // State for form inputs
  const [formData, setFormData] = useState({
    // Shipping Address
    firstName: "",
    lastName: "",
    phone: "",
    wilaya: "", // Separate Wilaya (Province)
    city: "", // Separate City
    streetAddress: "", // Street Address

    // Other Checkout Details
    deliveryServiceId: "", // Maps to API's delivery_service_id
    paymentMethod: "Cash on Delivery", // Default payment method
    notes: "", // Maps to API's notes field
  });

  const [errors, setErrors] = useState({}); // State to store validation errors
  const [loading, setLoading] = useState(false); // State for loading during API call
  const [apiError, setApiError] = useState(""); // State for API errors
  const [deliveryOptions, setDeliveryOptions] = useState([]); // State to hold fetched delivery options
  const [deliveryOptionsLoading, setDeliveryOptionsLoading] = useState(true); // Loading state for delivery options
  const [deliveryOptionsError, setDeliveryOptionsError] = useState(""); // Error state for delivery options

  // Fetch delivery options when component mounts
  useEffect(() => {
    const loadDeliveryOptions = async () => {
      setDeliveryOptionsLoading(true);
      setDeliveryOptionsError("");
      try {
        const options = await fetchDeliveryOptions();
        setDeliveryOptions(options);
        // Optionally, set a default delivery option if available
        // if (options.length > 0) {
        //   setFormData(prev => ({...prev, deliveryServiceId: options[0].id}));
        // }
      } catch (err) {
        console.error("Error fetching delivery options:", err);
        setDeliveryOptionsError(
          "Failed to load delivery options. Please try again later.",
        );
        toast.error("Failed to load delivery options.");
      } finally {
        setDeliveryOptionsLoading(false);
      }
    };

    loadDeliveryOptions();
  }, []); // Empty dependency array means this runs once on mount

  // Calculate total including delivery cost
  const selectedDeliveryOption = deliveryOptions.find((option) =>
    option.id === formData.deliveryServiceId
  );
  const deliveryCostCents = selectedDeliveryOption
    ? selectedDeliveryOption.base_cost_cents
    : 0;
  const deliveryCostDZD = deliveryCostCents / 100; // Convert cents to DZD
  const totalCents = subtotal * 100 + deliveryCostCents; // Calculate total in cents
  const totalDZD = totalCents / 100; // Convert total cents to DZD

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
    // Clear error for the field being edited
    if (errors[name]) {
      setErrors((prev) => ({ ...prev, [name]: "" }));
    }
    // Clear general API error when user starts editing
    if (apiError) {
      setApiError("");
    }
  };

  const validateForm = () => {
    const newErrors = {};

    if (!formData.firstName.trim()) {
      newErrors.firstName = "First name is required.";
    }
    if (!formData.lastName.trim()) {
      newErrors.lastName = "Last name is required.";
    }
    if (!formData.phone.trim()) {
      newErrors.phone = "Phone number is required.";
    } else if (!/^\+?[0-9\s\-\(\)]+$/.test(formData.phone)) { // Basic phone format validation
      newErrors.phone = "Please enter a valid phone number.";
    }
    if (!formData.wilaya.trim()) {
      newErrors.wilaya = "Wilaya is required.";
    }
    if (!formData.city.trim()) {
      newErrors.city = "City is required.";
    }
    if (!formData.deliveryServiceId.trim()) {
      newErrors.deliveryServiceId = "Delivery service is required.";
    }
    if (!formData.streetAddress.trim()) {
      newErrors.streetAddress = "Street address is required.";
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!validateForm()) {
      return; // Stop if client-side validation fails
    }

    setLoading(true); // Set loading state
    setApiError(""); // Clear any previous API errors

    try {
      // Prepare the payload object according to the API specification
      const payload = {
        shipping_address: {
          full_name: `${formData.firstName.trim()} ${formData.lastName.trim()}`,
          phone_number_1: formData.phone.trim(),
          phone_number_2: "", // Optional, could add a second phone field later
          province: formData.wilaya.trim(),
          city: formData.city.trim(),
          address: formData.streetAddress.trim(), // Use the separate address field
        },
        delivery_service_id: formData.deliveryServiceId.trim(), // Use the selected ID
        payment_method: formData.paymentMethod, // Use the selected/default method
        notes: formData.notes.trim(), // Use the notes field
      };

      console.log("Sending checkout payload:", payload); // Debugging

      let response;
      if (isAuthenticated) {
        // Call the authenticated checkout API function
        response = await createOrder(payload);
        console.log("Authenticated order placed successfully:", response); // Debugging
      } else {
        // Call the guest checkout API function
        response = await placeGuestOrder(payload);
        console.log("Guest order placed successfully:", response); // Debugging
      }

      toast.success(`Order ${response.order.id} placed successfully!`);

      // On successful order placement:
      clearCart(); // Clear the cart
      // Navigate to home page after successful order
      navigate("/");
    } catch (error) {
      console.error("Error placing order:", error);
      // Try to get a user-friendly message from the backend response
      const errorMessage = error?.response?.data?.message || error.message ||
        "Failed to place order. Please try again.";
      setApiError(errorMessage);
      toast.error(errorMessage); // Show error toast
    } finally {
      setLoading(false); // Reset loading state
    }
  };

  if (cart.length === 0) {
    return (
      <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen flex items-center justify-center">
        <div className="text-center">
          <p className="text-xl mb-4">Your cart is empty.</p>
          <button
            className="btn btn-primary"
            onClick={() => navigate("/products")} // Go back to products
          >
            Continue Shopping
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
      <h1 className="text-3xl font-bold mb-8">Checkout</h1>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        {/* Order Summary */}
        <div className="bg-base-100 p-6 rounded-lg shadow-lg border border-base-200">
          <h2 className="text-xl font-bold mb-4">Order Summary</h2>
          <div className="space-y-4 max-h-96 overflow-y-auto">
            {cart.map((item) => (
              <div
                key={item.id}
                className="flex items-center gap-4 pb-4 border-b border-base-300"
              >
                <img
                  src={item.image}
                  alt={item.name || item.title} // Prefer 'name' if available, fallback to 'title'
                  className="w-16 h-16 object-contain bg-inherit p-2 rounded"
                />
                <div className="flex-1">
                  <h3 className="font-semibold">{item.name || item.title}</h3>
                  <p className="text-primary font-bold">DZD {item.price}</p>
                  <p className="text-gray-500">Qty: {item.quantity}</p>
                </div>
                <p className="font-bold">
                  DZD {(item.price * item.quantity).toFixed(2)}
                </p>
              </div>
            ))}
          </div>
          <div className="divider my-4"></div>
          <div className="space-y-2">
            <div className="flex justify-between">
              <span>Subtotal:</span>
              <span>DZD {subtotal.toFixed(2)}</span>
            </div>
            <div className="flex justify-between">
              <span>Delivery:</span>
              <span>
                {selectedDeliveryOption
                  ? (
                    <>
                      DZD {deliveryCostDZD.toFixed(2)}{" "}
                      ({selectedDeliveryOption.name})
                    </>
                  )
                  : (
                    "N/A"
                  )}
              </span>
            </div>
            <div className="flex justify-between font-bold text-lg">
              <span>Total:</span>
              <span className="text-primary">DZD {totalDZD.toFixed(2)}</span>
            </div>
          </div>
        </div>

        {/* Checkout Form */}
        <div className="bg-base-100 p-6 rounded-lg shadow-lg border border-base-200">
          <h2 className="text-xl font-bold mb-4">Shipping Information</h2>

          {/* Display API Error */}
          {apiError && (
            <div className="alert alert-error mb-4">
              <p>{apiError}</p>
            </div>
          )}

          <form onSubmit={handleSubmit}>
            {/* Required Fields */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
              <div>
                <label className="label">
                  <span className="label-text">First name *</span>
                </label>
                <input
                  type="text"
                  name="firstName"
                  value={formData.firstName}
                  onChange={handleInputChange}
                  className={`input input-bordered w-full ${
                    errors.firstName ? "input-error" : ""
                  }`}
                  placeholder="John"
                  disabled={loading} // Disable during loading
                />
                {errors.firstName && (
                  <label className="label">
                    <span className="label-text-alt text-error">
                      {errors.firstName}
                    </span>
                  </label>
                )}
              </div>
              <div>
                <label className="label">
                  <span className="label-text">Last name *</span>
                </label>
                <input
                  type="text"
                  name="lastName"
                  value={formData.lastName}
                  onChange={handleInputChange}
                  className={`input input-bordered w-full ${
                    errors.lastName ? "input-error" : ""
                  }`}
                  placeholder="Doe"
                  disabled={loading} // Disable during loading
                />
                {errors.lastName && (
                  <label className="label">
                    <span className="label-text-alt text-error">
                      {errors.lastName}
                    </span>
                  </label>
                )}
              </div>
            </div>

            <div className="mb-4">
              <label className="label">
                <span className="label-text">Phone * (e.g., +213...)</span>
              </label>
              <input
                type="tel"
                name="phone"
                value={formData.phone}
                onChange={handleInputChange}
                className={`input input-bordered w-full ${
                  errors.phone ? "input-error" : ""
                }`}
                placeholder="+2136XXXXXXXX"
                disabled={loading} // Disable during loading
              />
              {errors.phone && (
                <label className="label">
                  <span className="label-text-alt text-error">
                    {errors.phone}
                  </span>
                </label>
              )}
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
              <div>
                <label className="label">
                  <span className="label-text">Wilaya (Province) *</span>
                </label>
                <input
                  type="text"
                  name="wilaya"
                  value={formData.wilaya}
                  onChange={handleInputChange}
                  className={`input input-bordered w-full ${
                    errors.wilaya ? "input-error" : ""
                  }`}
                  placeholder="e.g., Algiers"
                  disabled={loading} // Disable during loading
                />
                {errors.wilaya && (
                  <label className="label">
                    <span className="label-text-alt text-error">
                      {errors.wilaya}
                    </span>
                  </label>
                )}
              </div>
              <div>
                <label className="label">
                  <span className="label-text">City *</span>
                </label>
                <input
                  type="text"
                  name="city"
                  value={formData.city}
                  onChange={handleInputChange}
                  className={`input input-bordered w-full ${
                    errors.city ? "input-error" : ""
                  }`}
                  placeholder="e.g., Bab Ezzouar"
                  disabled={loading} // Disable during loading
                />
                {errors.city && (
                  <label className="label">
                    <span className="label-text-alt text-error">
                      {errors.city}
                    </span>
                  </label>
                )}
              </div>
            </div>

            <div className="mb-4">
              <label className="label">
                <span className="label-text">Street Address (Optional)</span>
              </label>
              <input
                type="text"
                name="streetAddress"
                value={formData.streetAddress}
                onChange={handleInputChange}
                className="input input-bordered w-full"
                placeholder="e.g., 123 Main Street, Apt 4B"
                disabled={loading} // Disable during loading
              />
              {/* No error state for optional field unless made mandatory */}
            </div>

            <div className="mb-4">
              <label className="label">
                <span className="label-text">Delivery Service *</span>
              </label>
              {deliveryOptionsLoading
                ? (
                  <div className="flex items-center justify-center p-4">
                    <span className="loading loading-spinner loading-lg"></span>
                  </div>
                )
                : deliveryOptionsError
                ? (
                  <div className="alert alert-error">
                    <p>{deliveryOptionsError}</p>
                  </div>
                )
                : (
                  <select
                    name="deliveryServiceId"
                    value={formData.deliveryServiceId}
                    onChange={handleInputChange}
                    className={`select select-bordered w-full ${
                      errors.deliveryServiceId ? "select-error" : ""
                    }`}
                    disabled={loading || deliveryOptions.length === 0} // Disable during loading or if no options
                  >
                    <option value="" disabled>
                      Select a service
                    </option>
                    {deliveryOptions
                      .filter((option) => option.is_active) // Only show active options
                      .map((option) => (
                        <option key={option.id} value={option.id}>
                          {option.name} - DZD{" "}
                          {(option.base_cost_cents / 100).toFixed(2)} (
                          {option.estimated_days} days)
                        </option>
                      ))}
                  </select>
                )}
              {errors.deliveryServiceId && (
                <label className="label">
                  <span className="label-text-alt text-error">
                    {errors.deliveryServiceId}
                  </span>
                </label>
              )}
            </div>

            {/* Display selected delivery option details */}
            {selectedDeliveryOption && !deliveryOptionsLoading && (
              <div className="mb-4 p-4 bg-base-200 rounded-box border border-base-300">
                <h3 className="font-bold mb-1">Selected Delivery:</h3>
                <p className="text-sm">{selectedDeliveryOption.name}</p>
                <p className="text-sm">
                  Cost: DZD {deliveryCostDZD.toFixed(2)}
                </p>
                <p className="text-sm">
                  Estimated Days: {selectedDeliveryOption.estimated_days}
                </p>
                <p className="text-sm mt-1 italic">
                  {selectedDeliveryOption.description}
                </p>
              </div>
            )}

            {/* Notes/Instructions */}
            <div className="mb-4">
              <label className="label">
                <span className="label-text">Order Notes (Optional)</span>
              </label>
              <textarea
                name="notes"
                value={formData.notes}
                onChange={handleInputChange}
                className="textarea textarea-bordered w-full"
                placeholder="Delivery instructions, gift note, etc..."
                rows="3"
                disabled={loading} // Disable during loading
              >
              </textarea>
            </div>

            <button
              type="submit"
              className="btn btn-primary w-full"
              disabled={loading} // Disable button during API call
            >
              {loading
                ? (
                  <>
                    <span className="loading loading-spinner loading-xs mr-2">
                    </span>
                    Placing Order...
                  </>
                )
                : (
                  "Place Order"
                )}
            </button>
          </form>
        </div>
      </div>
    </div>
  );
};

export default Checkout;


File: website/src/services/api.js
================================================
// src/services/api.js
import axios from "axios";
import { toast } from "sonner";

// Base URL for the API (adjust this for your deployment environment)
const API_BASE_URL = import.meta.env.VITE_API_URL ||
  "http://localhost:8080/api";

// Create an Axios instance with defaults
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000, // Timeout after 30 seconds (increased from 10s)
  headers: {
    "Content-Type": "application/json",
  },
  withCredentials: true,
});

// --- Request Interceptor: Attach Access Token (EXCEPT for auth endpoints) ---
apiClient.interceptors.request.use(
  (config) => {
    // Don't attach the access token to login, logout, or refresh endpoints
    if (
      config.url.endsWith("/v1/auth/login") ||
      config.url.endsWith("/v1/auth/refresh") ||
      config.url.endsWith("/v1/auth/logout")
    ) {
      console.log(
        "[API Interceptor] Skipping access token header for:",
        config.url,
      );
      return config;
    }

    const token = localStorage.getItem("access_token");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    } else {
      console.log(
        "[API Interceptor] No access token found for request:",
        config.url,
      );
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  },
);

// --- Response Interceptor: Handle 401 and Attempt Refresh ---
let isRefreshing = false;
let failedQueue = [];

const processQueue = (error, token = null) => {
  failedQueue.forEach((prom) => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token);
    }
  });
  failedQueue = [];
};

apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // Check if the error is a 401 UNAUTHORIZED
    if (error.response?.status === 401) {
      if (
        originalRequest.url.endsWith("/v1/auth/login") ||
        originalRequest.url.endsWith("/v1/auth/logout") ||
        originalRequest.url.endsWith("/v1/auth/refresh") ||
        originalRequest._retry
      ) {
        console.log(
          "[API Interceptor] 401 on auth endpoint or retry attempt. Rejecting original request.",
          originalRequest.url,
        );
        return Promise.reject(error);
      }

      // Proceed with refresh logic only for non-auth requests
      if (isRefreshing) {
        // If a refresh is already in progress, queue this request
        return new Promise((resolve, reject) => {
          failedQueue.push({ resolve, reject });
        })
          .then((token) => {
            originalRequest.headers.Authorization = `Bearer ${token}`;
            return apiClient(originalRequest);
          })
          .catch((err) => {
            return Promise.reject(err);
          });
      }

      originalRequest._retry = true; // Mark this request as retried
      isRefreshing = true;

      try {
        console.log("[API Interceptor] Calling refresh endpoint...");
        // Attempt to refresh the token (cookies should be sent due to withCredentials: true)
        const refreshResponse = await apiClient.post("/v1/auth/refresh");
        const newAccessToken = refreshResponse.data?.access_token; // Extract from {  { access_token: ... } }

        if (!newAccessToken) {
          throw new Error(
            `Refresh response missing 'access_token'. Got: ${
              JSON.stringify(refreshResponse.data)
            }`,
          );
        }

        console.log(
          "[API Interceptor] New access token received.",
        );

        // Update the access token in localStorage
        localStorage.setItem("access_token", newAccessToken);

        // Process queued requests with the new token
        processQueue(null, newAccessToken);

        // Retry the original request that failed with 401
        originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;
        isRefreshing = false;
        console.log(
          "[API Interceptor] Retrying original request after refresh.",
        );
        return apiClient(originalRequest);
      } catch (refreshError) {
        console.error("[API Interceptor] Refresh failed:", refreshError);
        // Clear tokens and logout user if refresh fails
        localStorage.removeItem("access_token");
        localStorage.removeItem("user");
        processQueue(refreshError, null);
        isRefreshing = false;

        // Optionally redirect to login page globally here if needed
        // window.location.href = '/auth/login';
        // Or show a toast
        toast.error("Session expired. Please log in again.");

        // Reject the original request with the refresh error
        return Promise.reject(refreshError);
      }
    }

    // If the error is not a 401, or if it was a 401 but handled above, reject the promise
    return Promise.reject(error);
  },
);

// --- Authentication Endpoints ---
/**
 * Registers a new user.
 * @param {Object} userData - The user's registration data (email, password, full_name).
 * @returns {Promise<Object>} The response data containing the new user info.
 */
export const registerUser = async (userData) => {
  try {
    const response = await apiClient.post("/v1/auth/register", userData);
    return response.data; // Returns { success: true,  { id, email, full_name, ... } }
  } catch (error) {
    console.error("Error registering user:", error);
    throw error; // Re-throw to be handled by caller
  }
};

/**
 * Logs in a user and returns an access token.
 * @param {Object} credentials - The user's login credentials (email, password).
 * @returns {Promise<Object>} The response data containing access token and user info.
 */
export const loginUser = async (credentials) => {
  try {
    const response = await apiClient.post("/v1/auth/login", credentials);
    return response.data; // Returns { success: true,  { access_token, user: { id, email, full_name, ... } } }
  } catch (error) {
    console.error("Error logging in:", error);
    throw error;
  }
};

/**
 * Logs out the user by revoking the refresh token (assumes refresh token is handled via cookies).
 * @returns {Promise<void>} Resolves on successful logout.
 */
export const logoutUser = async () => {
  try {
    // Logout is a POST request, refresh token is sent via cookie
    await apiClient.post("/v1/auth/logout");
    // Response is 204 No Content, no data to return
  } catch (error) {
    console.error("Error logging out:", error);
    throw error;
  }
};

// --- Public Products Endpoints ---
/**
 * Fetches a paginated list of products.
 * @param {number} page - Page number (1-indexed).
 * @param {number} limit - Number of products per page.
 * @returns {Promise<Object>} The response data containing products array, pagination info, etc.
 */
export const fetchProducts = async (page = 1, limit = 20) => {
  try {
    const response = await apiClient.get("/v1/products", {
      params: {
        page,
        limit,
      },
    });
    // The API returns {  [...], page, limit, total, total_pages }
    // Return the *entire* response object. The component will destructure it.
    return response.data;
  } catch (error) {
    console.error("Error fetching products:", error);
    throw error;
  }
};

/**
 * Fetches details of a specific product by its ID.
 * @param {string} id - The UUID of the product.
 * @returns {Promise<Object>} The response data containing the product details.
 */
export const fetchProductById = async (id) => {
  try {
    const response = await apiClient.get(`/v1/products/${id}`);
    // The API returns the product object directly
    return response.data;
  } catch (error) {
    console.error(`Error fetching product with id ${id}:`, error);
    throw error;
  }
};

/**
 * Searches for products based on various criteria.
 * @param {Object} searchParams - Object containing search parameters (query, category_id, brand, min_price, max_price, in_stock_only, include_discounted_only, page, limit, spec_filter).
 * @returns {Promise<Object>} The response data containing matching products array, pagination info, etc.
 */
export const searchProducts = async (searchParams = {}) => {
  try {
    // Default parameters
    const params = {
      page: 1,
      limit: 20,
      ...searchParams, // Spread the provided search parameters
    };

    // Convert boolean parameters to strings as expected by the API
    if (params.in_stock_only !== undefined) {
      params.in_stock_only = String(params.in_stock_only).toLowerCase();
    }
    if (params.include_discounted_only !== undefined) {
      params.include_discounted_only = String(params.include_discounted_only)
        .toLowerCase();
    }

    const response = await apiClient.get("/v1/products/search", { params });
    return response.data;
  } catch (error) {
    console.error("Error searching products:", error);
    throw error;
  }
};

/**
 * Fetches all product categories.
 * @returns {Promise<Array>} An array of category objects.
 */
export const fetchCategories = async () => {
  try {
    const response = await apiClient.get("/v1/products/categories");
    // The API returns the array of categories directly
    return response.data;
  } catch (error) {
    console.error("Error fetching categories:", error);
    throw error;
  }
};

/**
 * Fetches details of a specific category by its ID.
 * @param {string} id - The UUID of the category.
 * @returns {Promise<Object>} The response data containing the category details.
 */
export const fetchCategoryById = async (id) => {
  try {
    const response = await apiClient.get(`/v1/products/categories/${id}`);
    // The API returns the category object directly
    return response.data;
  } catch (error) {
    console.error(`Error fetching category with id ${id}:`, error);
    throw error;
  }
};

// --- Checkout Endpoints ---

/**
 * Places an order for a guest user using their session cart.
 * @param {Object} orderData - The order details including shipping address and payment method.
 * @returns {Promise<Object>} The response data containing the created order and items.
 */
export const placeGuestOrder = async (orderData) => {
  try {
    // Note: The session ID is handled automatically via the 'withCredentials: true' and cookies
    const response = await apiClient.post("/v1/checkout/guest", orderData);
    return response.data; // Returns { order: { ... }, items: [...] }
  } catch (error) {
    console.error("Error placing guest order:", error);
    throw error;
  }
};

// --- User Cart Endpoints (Require Authorization Token) ---
// Note: The interceptor handles adding the Authorization header automatically if token exists in localStorage
/**
 * Adds multiple items to the user's cart in a single request.
 * @param {Array<{product_id: string, quantity: number}>} items - Array of items to add.
 * @returns {Promise<Object>} The response data containing the updated cart summary.
 */
export const bulkAddToCart = async (items) => {
  try {
    const response = await apiClient.post("/v1/cart/add-bulk", {
      items: items,
    });
    return response.data; // Returns { message: "...", cart_summary: { ... } }
  } catch (error) {
    console.error("Error adding items to cart in bulk:", error);
    throw error;
  }
};

/**
 * Fetches the current user's cart.
 * @returns {Promise<Object>} The response data containing the cart details.
 */
export const fetchUserCart = async () => {
  // Token is automatically added by interceptor if present
  try {
    const response = await apiClient.get("/v1/cart");
    return response.data; // Returns the cart object
  } catch (error) {
    console.error("Error fetching user cart:", error);
    throw error;
  }
};

/**
 * Adds an item to the current user's cart.
 * @param {string} productId - The UUID of the product to add.
 * @param {number} quantity - The quantity to add.
 * @returns {Promise<Object>} The response data containing the added cart item details.
 */
export const addItemToCart = async (productId, quantity) => {
  // Token is automatically added by interceptor if present
  try {
    const response = await apiClient.post("/v1/cart/items", {
      product_id: productId,
      quantity: quantity,
    });
    return response.data; // Returns the added/updated cart item object
  } catch (error) {
    console.error("Error adding item to cart:", error);
    throw error;
  }
};

/**
 * Updates the quantity of an item in the current user's cart.
 * @param {string} itemId - The UUID of the cart item to update.
 * @param {number} quantity - The new quantity.
 * @returns {Promise<Object>} The response data containing the updated cart item details.
 */
export const updateCartItem = async (itemId, quantity) => {
  // Token is automatically added by interceptor if present
  try {
    const response = await apiClient.patch(`/v1/cart/items/${itemId}`, {
      quantity: quantity,
    });
    return response.data; // Returns the updated cart item object
  } catch (error) {
    console.error("Error updating cart item:", error);
    throw error;
  }
};

/**
 * Removes an item from the current user's cart.
 * @param {string} itemId - The UUID of the cart item to remove.
 * @returns {Promise<void>} Resolves on successful removal.
 */
export const removeCartItem = async (itemId) => {
  // Token is automatically added by interceptor if present
  try {
    await apiClient.delete(`/v1/cart/items/${itemId}`);
    // Response is 204 No Content, no data to return
  } catch (error) {
    console.error("Error removing item from cart:", error);
    throw error;
  }
};

/**
 * Clears the current user's cart.
 * @returns {Promise<void>} Resolves on successful clearing.
 */
export const clearUserCart = async () => {
  // Token is automatically added by interceptor if present
  try {
    await apiClient.delete("/v1/cart");
    // Response is 204 No Content, no data to return
  } catch (error) {
    console.error("Error clearing cart:", error);
    throw error;
  }
};

// --- User Orders Endpoints (Require Authorization Token) ---
/**
 * Creates a new order from the user's cart.
 * @param {Object} orderData - The order details (delivery_service_id, shipping_address, notes).
 * @returns {Promise<Object>} The response data containing the created order details.
 */
export const createOrder = async (orderData) => {
  // Token is automatically added by interceptor if present
  try {
    const response = await apiClient.post("/v1/orders", orderData);
    return response.data; // Returns the created order object
  } catch (error) {
    console.error("Error creating order:", error);
    throw error;
  }
};

/**
 * Fetches details of a specific order belonging to the user.
 * @param {string} orderId - The UUID of the order.
 * @returns {Promise<Object>} The response data containing the order details.
 */
export const fetchOrderById = async (orderId) => {
  // Token is automatically added by interceptor if present
  try {
    const response = await apiClient.get(`/v1/orders/${orderId}`);
    return response.data; // Returns the order object
  } catch (error) {
    console.error(`Error fetching order with id ${orderId}:`, error);
    throw error;
  }
};

/**
 * Fetches a paginated list of orders for the current user.
 * @param {number} page - Page number (1-indexed).
 * @param {number} limit - Number of orders per page.
 * @returns {Promise<Object>} The response data containing orders array, pagination info, etc.
 */
export const fetchUserOrders = async (page = 1, limit = 20) => {
  // Token is automatically added by interceptor if present
  try {
    const response = await apiClient.get("/v1/orders", {
      params: {
        page,
        limit,
      },
    });
    return response.data; // Returns {  [...], page, limit, total, total_pages }
  } catch (error) {
    console.error("Error fetching user orders:", error);
    throw error;
  }
};

// --- User Profile Endpoints (Require Authorization Token) ---
// Assuming these endpoints exist and follow the pattern seen in admin
// Check actual API docs for exact paths and payload structure if they differ from admin

/**
 * Updates the current user's profile information (name, email).
 * @param {Object} profileData - The profile data to update.
 * @returns {Promise<Object>} The response data containing the updated user details.
 */
export const updateUserProfile = async (profileData) => {
  // Token is automatically added by interceptor if present
  try {
    const response = await apiClient.put("/v1/user/profile", profileData); // Check actual path
    return response.data.data; // Assuming response is { success: true,  { ...updated_user_data... } }
  } catch (error) {
    console.error("Error updating user profile:", error);
    throw error;
  }
};

/**
 * Changes the current user's password.
 * @param {Object} passwordData - The password change data (current_password, new_password, confirm_password).
 * @returns {Promise<Object>} The response data confirming the password change.
 */
export const changeUserPassword = async (passwordData) => {
  // Token is automatically added by interceptor if present
  try {
    const response = await apiClient.put(
      "/v1/user/password/change",
      passwordData,
    ); // Check actual path
    return response.data; // Assuming response is { success: true, message: "Password changed successfully" }
  } catch (error) {
    console.error("Error changing user password:", error);
    throw error;
  }
};

// --- Delivery Options Endpoint (Require Authorization Token) ---
/**
 * Fetches the available delivery options for the user.
 * @returns {Promise<Array>} An array of delivery option objects.
 */
export const fetchDeliveryOptions = async () => {
  // Token is automatically added by interceptor if present
  try {
    const response = await apiClient.get("/v1/delivery-options");
    return response.data; // Returns the array of delivery options
  } catch (error) {
    console.error("Error fetching delivery options:", error);
    throw error;
  }
};

// --- Reviews Endpoint (Require Authorization Token) ---
/**
 * Submits a review for a product.
 * @param {string} productId - The UUID of the product.
 * @param {number} rating - The rating (1-5).
 * @returns {Promise<Object>} The response data containing the created review details.
 */
export const submitReview = async (productId, rating) => {
  // Token is automatically added by interceptor if present
  try {
    const response = await apiClient.post("/v1/reviews", {
      product_id: productId,
      rating: rating,
    });
    return response.data; // Returns the created review object
  } catch (error) {
    console.error("Error submitting review:", error);
    throw error;
  }
};

// --- Health Check Endpoint ---
/**
 * Checks the health of the API service.
 * @returns {Promise<Object>} The response data containing the health status.
 */
export const checkHealth = async () => {
  try {
    const response = await apiClient.get("/health");
    return response.data; // Returns { status: "ok", timestamp: "..." }
  } catch (error) {
    console.error("Error checking health:", error);
    throw error; // Might throw a 500 error response
  }
};

export default apiClient;


File: dashboard/src/layouts/AdminLayout.jsx
================================================
import React from "react";
import { Outlet } from "react-router-dom"; // Outlet is where child routes are rendered
import Sidebar from "../components/SideBar"; // We'll create this next
import AdminHeader from "../components/AdminHeader"; // We'll create this next

const AdminLayout = () => {
  return (
    <div className="drawer lg:drawer-open">
      {/* DaisyUI drawer for responsive sidebar */}
      <input id="sidebar-drawer" type="checkbox" className="drawer-toggle" />
      <div className="drawer-content flex flex-col">
        {/* Header */}
        <AdminHeader />

        {/* Main Content Area */}
        <main className="flex-1 p-4 md:p-6 bg-base-100">
          <Outlet />{" "}
          {/* Child routes like /admin/products, /admin/orders will render here */}
        </main>

        {/* Footer (optional) */}
        <footer className="p-4 text-center text-sm text-gray-500 border-t">
          © {new Date().getFullYear()} YC Informatique. All rights reserved.
        </footer>
      </div>
      <div className="drawer-side z-50">
        <label htmlFor="sidebar-drawer" className="drawer-overlay"></label>
        <Sidebar />
      </div>
    </div>
  );
};

export default AdminLayout;


File: dashboard/src/pages/NotFound.jsx
================================================
import React from "react";
import { Link } from "react-router-dom";

const NotFound = () => {
  return (
    <div className="hero min-h-screen bg-base-200">
      <div className="hero-content text-center">
        <div className="max-w-md">
          <h1 className="text-5xl font-bold">404</h1>
          <p className="py-6">
            Oops! The page you're looking for doesn't exist.
          </p>
          <Link to="/admin/dashboard" className="btn btn-primary">
            Go to Dashboard
          </Link>
        </div>
      </div>
    </div>
  );
};

export default NotFound;


File: dashboard/src/pages/orders/OrdersList.jsx
================================================
// src/pages/orders/OrdersList.jsx
import React, { useState } from "react";
import { Link } from "react-router-dom";
import { useQuery } from "@tanstack/react-query";
import { fetchOrders } from "../../services/api";
import { EyeIcon } from "@heroicons/react/24/outline";

const OrdersList = () => {
  // State for pagination
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage, setItemsPerPage] = useState(20);

  // State for filters
  const [filterStatus, setFilterStatus] = useState(""); // e.g., "", "pending", "confirmed", "shipped", "delivered", "cancelled"
  const [filterUserId, setFilterUserId] = useState(""); // State for user_id filter

  const buildQueryParams = () => {
    const params = {
      page: currentPage,
      limit: itemsPerPage,
    };
    // Add filter parameters if they exist
    if (filterStatus) {
      params.status = filterStatus;
    }
    if (filterUserId) {
      params.user_id = filterUserId; // Add user_id filter parameter
    }
    return params;
  };

  const {
    data,
    isLoading,
    isError,
    error,
    refetch,
  } = useQuery({
    queryKey: ["orders", currentPage, itemsPerPage, filterStatus, filterUserId], // Include user_id filter in key
    queryFn: () => fetchOrders(buildQueryParams()),
    select: (response) => {
      const { data, page, limit, total, total_pages } = response.data;
      return {
        orders: data,
        pagination: { page, limit, total, totalPages: total_pages },
      };
    },
  });

  const { orders = [], pagination } = data || {};

  // Handler for changing pages
  const goToPage = (newPage) => {
    if (pagination) {
      const { page: currentPageFromMeta, totalPages } = pagination;
      if (newPage >= 1 && (!totalPages || newPage <= totalPages)) {
        setCurrentPage(newPage);
      }
    } else {
      if (newPage >= 1) {
        setCurrentPage(newPage);
      }
    }
  };

  // Handler for changing items per page
  const handleItemsPerPageChange = (newLimit) => {
    setItemsPerPage(newLimit);
    setCurrentPage(1); // Reset to first page when limit changes
  };

  // Handler for status filter change
  const handleFilterStatusChange = (e) => {
    setFilterStatus(e.target.value);
    setCurrentPage(1); // Reset to first page when filter changes
  };

  const handleFilterByUserId = (userId) => {
    setFilterUserId(userId);
    setCurrentPage(1); // Reset to first page when filter changes
  };

  const handleClearUserIdFilter = () => {
    setFilterUserId("");
    setCurrentPage(1); // Reset to first page when clearing filter
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  }

  if (isError) {
    return (
      <div className="alert alert-error shadow-lg">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          className="stroke-current flex-shrink-0 h-6 w-6"
          fill="none"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="2"
            d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"
          />
        </svg>
        <span>Error: {error.message}</span>
        <button onClick={() => refetch()} className="btn btn-sm">Retry</button>
      </div>
    );
  }

  // Helper function to truncate UUID
  const truncateUuid = (uuid) => {
    if (!uuid || typeof uuid !== "string") return "N/A";
    return `${uuid.substring(0, 8)}...`;
  };

  return (
    <div className="bg-neutral p-6 rounded-lg shadow-md">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-xl font-bold">Orders</h2>
        {/* Add any potential global order actions here if needed, e.g., bulk export */}
      </div>

      {/* Filter Controls */}
      <div className="bg-base-100 p-4 rounded-box mb-4 flex flex-wrap gap-4">
        <div className="form-control">
          <label className="label">
            <span className="label-text">Status</span>
          </label>
          <select
            className="select select-bordered select-sm w-full max-w-xs"
            value={filterStatus}
            onChange={handleFilterStatusChange}
          >
            <option value="">All Statuses</option>
            <option value="pending">Pending</option>
            <option value="confirmed">Confirmed</option>
            <option value="shipped">Shipped</option>
            <option value="delivered">Delivered</option>
            <option value="cancelled">Cancelled</option>
          </select>
        </div>

        {filterUserId && (
          <div className="form-control flex flex-row items-center">
            <label className="label">
              <span className="label-text">User Filter:</span>
            </label>
            <div className="flex items-center gap-2">
              <span className="badge badge-info">
                {truncateUuid(filterUserId)}
              </span>
              <button
                className="btn btn-xs btn-outline"
                onClick={handleClearUserIdFilter}
              >
                Clear
              </button>
            </div>
          </div>
        )}
        {/* --- END NEW --- */}

        {/* Add more filters here if needed (e.g., date range) */}
      </div>

      {/* Pagination Controls Top */}
      {pagination && (
        <div className="flex flex-col sm:flex-row justify-between items-center mb-4 gap-2">
          <div className="text-sm">
            Showing {(pagination.page - 1) * pagination.limit + 1} -
            {Math.min(pagination.page * pagination.limit, pagination.total)} of
            {" "}
            {pagination.total} orders
          </div>
          <div className="join">
            <button
              className="join-item btn btn-xs"
              onClick={() => goToPage(pagination.page - 1)}
              disabled={pagination.page <= 1}
            >
              « Prev
            </button>
            <button className="join-item btn btn-xs">
              Page {pagination.page} of {pagination.totalPages}
            </button>
            <button
              className="join-item btn btn-xs"
              onClick={() => goToPage(pagination.page + 1)}
              disabled={pagination.page >= pagination.totalPages}
            >
              Next »
            </button>
          </div>
          <select
            className="select select-bordered select-xs w-24"
            value={itemsPerPage}
            onChange={(e) => handleItemsPerPageChange(Number(e.target.value))}
          >
            <option value={10}>10/page</option>
            <option value={20}>20/page</option>
            <option value={50}>50/page</option>
            <option value={100}>100/page</option>
          </select>
        </div>
      )}

      <div className="overflow-x-auto">
        <table className="table table-zebra w-full">
          <thead>
            <tr>
              <th>Order ID</th>
              <th>User ID</th>
              <th>User Name</th>
              <th>Phone Number</th>
              <th>Total (DZD)</th>
              <th>Status</th>
              <th>Date</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {orders.length > 0
              ? (
                orders.map((order) => {
                  const totalPriceDZD = order.total_amount_cents
                    ? (order.total_amount_cents / 100).toFixed(2)
                    : "Calculating...";

                  let statusClass = "badge-ghost";
                  if (order.status === "pending") {
                    statusClass = "badge-warning";
                  } else if (order.status === "confirmed") {
                    statusClass = "badge-info";
                  } else if (order.status === "shipped") {
                    statusClass = "badge-primary";
                  } else if (order.status === "delivered") {
                    statusClass = "badge-success";
                  } else if (order.status === "cancelled") {
                    statusClass = "badge-error";
                  }

                  return (
                    <tr key={order.id}>
                      <td title={order.id}>{truncateUuid(order.id)}</td>
                      <td>
                        <button
                          className="btn btn-xs btn-ghost"
                          onClick={() => handleFilterByUserId(order.user_id)}
                          title="Filter orders by this user"
                        >
                          {truncateUuid(order.user_id)}
                        </button>
                      </td>
                      <td>
                        {order.user_email || order.user_full_name || "N/A"}
                      </td>
                      <td>
                        {order.phone_number_1 || order.phone_number_2 || "N/A"}
                      </td>
                      <td>{totalPriceDZD}</td>
                      <td>
                        <span className={`badge ${statusClass}`}>
                          {order.status}
                        </span>
                      </td>
                      <td>{new Date(order.created_at).toLocaleString()}</td>
                      <td>
                        <Link
                          to={`/admin/orders/${order.id}`} // Navigate to details page
                          className="btn btn-xs btn-info"
                        >
                          <EyeIcon className="w-4 h-4" />
                        </Link>
                      </td>
                    </tr>
                  );
                })
              )
              : (
                <tr>
                  <td colSpan="7" className="text-center py-4">
                    No orders found.
                  </td>
                </tr>
              )}
          </tbody>
        </table>
      </div>

      {/* Pagination Controls Bottom */}
      {pagination && (
        <div className="flex flex-col sm:flex-row justify-between items-center mt-4 gap-2">
          <div className="text-sm">
            Showing {(pagination.page - 1) * pagination.limit + 1} -
            {Math.min(pagination.page * pagination.limit, pagination.total)} of
            {" "}
            {pagination.total} orders
          </div>
          <div className="join">
            <button
              className="join-item btn btn-xs"
              onClick={() => goToPage(pagination.page - 1)}
              disabled={pagination.page <= 1}
            >
              « Prev
            </button>
            <button className="join-item btn btn-xs">
              Page {pagination.page} of {pagination.totalPages}
            </button>
            <button
              className="join-item btn btn-xs"
              onClick={() => goToPage(pagination.page + 1)}
              disabled={pagination.page >= pagination.totalPages}
            >
              Next »
            </button>
          </div>
          <select
            className="select select-bordered select-xs w-24"
            value={itemsPerPage}
            onChange={(e) => handleItemsPerPageChange(Number(e.target.value))}
          >
            <option value={10}>10/page</option>
            <option value={20}>20/page</option>
            <option value={50}>50/page</option>
            <option value={100}>100/page</option>
          </select>
        </div>
      )}
    </div>
  );
};

export default OrdersList;


File: dashboard/src/pages/delivery/DeliveryServicesList.jsx
================================================
// src/pages/delivery/DeliveryServicesList.jsx
import React, { useState } from "react";
import { Link } from "react-router-dom";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import {
  deleteDeliveryService,
  fetchDeliveryServices,
} from "../../services/api";
import {
  PencilSquareIcon,
  PlusCircleIcon,
  TrashIcon,
} from "@heroicons/react/24/outline";
import { toast } from "sonner";

const DeliveryServicesList = () => {
  const queryClient = useQueryClient();

  const {
    data: deliveryServices,
    isLoading,
    isError,
    error,
    refetch,
  } = useQuery({
    queryKey: ["deliveryServices"], // Keep the key the same for caching consistency
    queryFn: () => fetchDeliveryServices({ active_only: true }), // Pass the required parameter
    select: (response) => response.data, // Adjust based on your API response structure
  });
  console.log(deliveryServices);

  const deleteMutation = useMutation({
    mutationFn: deleteDeliveryService,
    onSuccess: (data, deletedId) => {
      queryClient.invalidateQueries({ queryKey: ["deliveryServices"] });
      toast.success(`Delivery Service ID ${deletedId} deleted successfully.`);
    },
    onError: (error, deletedId) => {
      console.error("Delete Error:", error);
      toast.error(
        `Failed to delete delivery service ID ${deletedId}: ${
          error.message || "Unknown error"
        }`,
      );
    },
  });

  const handleDelete = (deliveryServiceId) => {
    if (
      window.confirm(
        `Are you sure you want to delete delivery service ID: ${deliveryServiceId}? This action cannot be undone.`,
      )
    ) {
      deleteMutation.mutate(deliveryServiceId);
    }
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  }

  if (isError) {
    return (
      <div className="alert alert-error shadow-lg">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          className="stroke-current flex-shrink-0 h-6 w-6"
          fill="none"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="2"
            d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"
          />
        </svg>
        <span>Error: {error.message}</span>
        <button onClick={() => refetch()} className="btn btn-sm">Retry</button>
      </div>
    );
  }

  // Helper function to truncate UUID
  const truncateUuid = (uuid) => {
    if (!uuid || typeof uuid !== "string") return "N/A";
    return `${uuid.substring(0, 8)}...`;
  };

  return (
    <div className="bg-neutral p-6 rounded-lg shadow-md">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-xl font-bold">Delivery Services</h2>
        <Link
          to="/admin/delivery/add"
          className="btn btn-accent flex items-center gap-2"
        >
          <PlusCircleIcon className="w-5 h-5" />
          Add Service
        </Link>
      </div>

      <div className="overflow-x-auto">
        <table className="table table-zebra w-full">
          <thead>
            <tr>
              <th>ID (Truncated)</th>
              <th>Name</th>
              <th>Description</th>
              <th>Base Cost (DZD)</th>
              <th>Est. Days</th>
              <th>Active</th>
              <th>Created At</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {deliveryServices && deliveryServices.length > 0
              ? (
                deliveryServices.map((service) => (
                  <tr key={service.id}>
                    <td title={service.id}>{truncateUuid(service.id)}</td>
                    <td>{service.name}</td>
                    <td>{service.description}</td>
                    <td>{(service.base_cost_cents / 100).toFixed(2)}</td>
                    <td>{service.estimated_days}</td>
                    <td>
                      <span
                        className={`badge ${
                          service.is_active ? "badge-success" : "badge-error"
                        }`}
                      >
                        {service.is_active ? "Yes" : "No"}
                      </span>
                    </td>
                    <td>{new Date(service.created_at).toLocaleString()}</td>
                    <td>
                      <div className="flex gap-2">
                        <Link
                          to={`/admin/delivery/${service.id}/edit`}
                          className="btn btn-xs btn-info"
                        >
                          <PencilSquareIcon className="w-4 h-4" />
                        </Link>
                        <button
                          className="btn btn-xs btn-error"
                          onClick={() => handleDelete(service.id)}
                          disabled={deleteMutation.isPending}
                        >
                          {deleteMutation.isPending &&
                              deleteMutation.variables === service.id
                            ? (
                              <span className="loading loading-spinner loading-xs">
                              </span>
                            )
                            : <TrashIcon className="w-4 h-4" />}
                        </button>
                      </div>
                    </td>
                  </tr>
                ))
              )
              : (
                <tr>
                  <td colSpan="8" className="text-center py-4">
                    No delivery services found.
                  </td>
                </tr>
              )}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default DeliveryServicesList;


File: dashboard/src/pages/categories/CategoriesList.jsx
================================================
import React, { useState } from "react";
import { Link } from "react-router-dom";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { deleteCategory, fetchCategories } from "../../services/api";
import {
  PencilSquareIcon,
  PlusCircleIcon,
  TrashIcon,
} from "@heroicons/react/24/outline";
import { toast } from "sonner";

const CategoriesList = () => {
  const queryClient = useQueryClient();

  const {
    data: categories,
    isLoading,
    isError,
    error,
    refetch,
  } = useQuery({
    queryKey: ["categories"],
    queryFn: fetchCategories,
    select: (response) => response.data.data.data,
  });

  const deleteMutation = useMutation({
    mutationFn: deleteCategory,
    onSuccess: (data, deletedId) => {
      queryClient.invalidateQueries({ queryKey: ["categories"] });
      toast.success(`Category ID ${deletedId} deleted successfully.`);
    },
    onError: (error, deletedId) => {
      console.error("Delete Error:", error);
      toast.error(
        `Failed to delete category ID ${deletedId}: ${
          error.message || "Unknown error"
        }`,
      );
    },
  });
  console.log(categories);
  const handleDelete = (categoryId) => {
    if (
      window.confirm(
        `Are you sure you want to delete category ID: ${categoryId}? This action cannot be undone.`,
      )
    ) {
      deleteMutation.mutate(categoryId);
    }
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  }

  if (isError) {
    return (
      <div className="alert alert-error shadow-lg">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          className="stroke-current flex-shrink-0 h-6 w-6"
          fill="none"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="2"
            d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"
          />
        </svg>
        <span>Error: {error.message}</span>
        <button onClick={() => refetch()} className="btn btn-sm">Retry</button>
      </div>
    );
  }

  // Helper function to truncate UUID
  const truncateUuid = (uuid) => {
    if (!uuid || typeof uuid !== "string") return "N/A";
    return `${uuid.substring(0, 8)}...`;
  };

  return (
    <div className="bg-neutral p-6 rounded-lg shadow-md">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-xl font-bold">Categories</h2>
        <Link
          to="/admin/categories/add"
          className="btn btn-accent flex items-center gap-2"
        >
          <PlusCircleIcon className="w-5 h-5" />
          Add Category
        </Link>
      </div>

      <div className="overflow-x-auto">
        <table className="table table-zebra w-full">
          <thead>
            <tr>
              <th>ID (Truncated)</th>
              <th>Name</th>
              <th>Slug</th>
              <th>Type</th>
              <th>Created At</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {categories && categories.length > 0
              ? (
                categories.map((category) => (
                  <tr key={category.id}>
                    <td title={category.id}>{truncateUuid(category.id)}</td>
                    <td>{category.name}</td>
                    <td className="font-mono">{category.slug}</td>
                    <td>{category.type}</td>
                    <td>{new Date(category.created_at).toLocaleString()}</td>
                    <td>
                      <div className="flex gap-2">
                        <Link
                          to={`/admin/categories/${category.id}/edit`}
                          className="btn btn-xs btn-info"
                        >
                          <PencilSquareIcon className="w-4 h-4" />
                        </Link>
                        <button
                          className="btn btn-xs btn-error"
                          onClick={() => handleDelete(category.id)}
                          disabled={deleteMutation.isPending}
                        >
                          {deleteMutation.isPending &&
                              deleteMutation.variables === category.id
                            ? (
                              <span className="loading loading-spinner loading-xs">
                              </span>
                            )
                            : <TrashIcon className="w-4 h-4" />}
                        </button>
                      </div>
                    </td>
                  </tr>
                ))
              )
              : (
                <tr>
                  <td colSpan="6" className="text-center py-4">
                    No categories found.
                  </td>
                </tr>
              )}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default CategoriesList;


File: dashboard/src/App.jsx
================================================
// src/App.jsx
import React from "react";
import { Navigate, Route, Routes } from "react-router-dom";
import AdminLayout from "./layouts/AdminLayout";
import AdminDashboard from "./pages/AdminDashboard";
import AuthPage from "./pages/auth/AuthPage";
import NotFound from "./pages/NotFound";
import ProductsList from "./pages/products/ProductsList";
import AddProduct from "./pages/products/AddProduct";
import EditProduct from "./pages/products/EditProduct";
import ProductView from "./pages/products/ProductView";
import CategoriesList from "./pages/categories/CategoriesList";
import AddCategory from "./pages/categories/AddCategory";
import EditCategory from "./pages/categories/EditCategory";
import OrdersList from "./pages/orders/OrdersList";
import OrderDetails from "./pages/orders/OrderDetails";
import DeliveryServicesList from "./pages/delivery/DeliveryServicesList";
import AddDeliveryService from "./pages/delivery/AddDeliveryService";
import EditDeliveryService from "./pages/delivery/EditDeliveryService";
import CustomersList from "./pages/customers/CustomerList";
import DiscountsList from "./pages/discounts/DiscountsList";
import AddDiscount from "./pages/discounts/AddDiscount";
import EditDiscount from "./pages/discounts/EditDiscount";
import Settings from "./pages/Settings"; // Import the new Settings component

function App() {
  return (
    <div className="min-h-screen bg-base-100">
      <Routes>
        <Route path="/auth/*" element={<AuthPage />} />

        <Route
          path="/admin"
          element={<Navigate to="/admin/dashboard" replace />}
        />
        <Route path="/admin/*" element={<AdminLayout />}>
          <Route index element={<AdminDashboard />} />
          <Route path="dashboard" element={<AdminDashboard />} />
          <Route path="products" element={<ProductsList />} />
          <Route path="products/add" element={<AddProduct />} />
          <Route path="products/:id" element={<ProductView />} />
          <Route path="products/:id/edit" element={<EditProduct />} />
          <Route path="orders" element={<OrdersList />} />
          <Route path="orders/:id" element={<OrderDetails />} />
          <Route path="categories" element={<CategoriesList />} />
          <Route path="categories/add" element={<AddCategory />} />
          <Route path="categories/:id/edit" element={<EditCategory />} />
          <Route path="delivery" element={<DeliveryServicesList />} />
          <Route path="delivery/add" element={<AddDeliveryService />} />
          <Route path="delivery/:id/edit" element={<EditDeliveryService />} />
          <Route path="customers" element={<CustomersList />} />
          <Route path="discounts" element={<DiscountsList />} />
          <Route path="discounts/add" element={<AddDiscount />} />
          <Route path="discounts/:id/edit" element={<EditDiscount />} />
          <Route path="settings" element={<Settings />} />
        </Route>

        <Route path="*" element={<NotFound />} />
      </Routes>
    </div>
  );
}

export default App;


File: shared/types.go
================================================
package shared

type User struct {
	ID        string `json:"id"`
	Email     string `json:"email"`
	FullName  string `json:"full_name"`
	IsAdmin   bool   `json:"is_admin"`
	CreatedAt string `json:"created_at"`
	UpdatedAt string `json:"updated_at"`
}

type LoginRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type RegisterRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
	FullName string `json:"full_name"`
}

type AuthResponse struct {
	Token string `json:"token"`
	User  User   `json:"user"`
}

type ErrorResponse struct {
	Type     string                 `json:"type"`
	Title    string                 `json:"title"`
	Status   int                    `json:"status"`
	Detail   string                 `json:"detail"`
	Instance string                 `json:"instance,omitempty"`
	Errors   map[string]interface{} `json:"errors,omitempty"`
}

type Pagination struct {
	Page      int `json:"page"`
	PerPage   int `json:"per_page"`
	Total     int `json:"total"`
	TotalPage int `json:"total_page"`
}

type Product struct {
	ID               string                 `json:"id"`
	Name             string                 `json:"name"`
	Slug             string                 `json:"slug"`
	Description      string                 `json:"description"`
	ShortDescription string                 `json:"short_description"`
	PriceCents       int64                  `json:"price_cents"`
	StockQuantity    int                    `json:"stock_quantity"`
	Status           string                 `json:"status"`
	Brand            string                 `json:"brand"`
	ImageUrls        []string               `json:"image_urls"`
	SpecHighlights   map[string]interface{} `json:"spec_highlights"`
	CategoryID       string                 `json:"category_id"`
	CreatedAt        string                 `json:"created_at"`
	UpdatedAt        string                 `json:"updated_at"`
}

type Category struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Slug     string `json:"slug"`
	Type     string `json:"type"`
	ParentID string `json:"parent_id,omitempty"`
}


File: justfile
================================================
# Load .env file
set dotenv-load := true

# Justfile - Backend Helper Commands
default:
  @just --list

[group('migration')]
[doc('Migrate the database up one time')]
migrate-up:
  goose -dir migrations up

[group('migration')]
[doc('Migrate the database down one time')]
migrate-down:
  goose -dir migrations down

[group('migration')]
[doc('Return the migration status')]
migrate-status:
  goose -dir migrations status

[group('migration')]
[doc('Create a new migration based on the argument provided')]
migrate-create name:
  echo "Creating migration: {{name}}"
  goose -s -dir migrations create {{name}} sql

[group('database')]
[doc('Create tech_store_dev Datebase')]
db-create:
  createdb tech_store_dev

[group('database')]
[doc('Drop tech_store_dev Database')]
db-drop:
  dropdb tech_store_dev

[group('development')]
[doc('Start the server (Default Port: 8080)')]
dev:
  go run cmd/server/main.go

[group('development')]
[doc('Run the seed script')]
seed:
  go run scripts/seed.go

[group('development')]
[doc('Run all the tests')]
test:
  go test ./...

[group('development')]
[doc('Build the backend API')]
build:
  go build -o bin/server cmd/server/main.go

[group('development')]
[doc('Run the database migration & Start the server')]
serve:
  just migrate-up
  just dev

[group('development')]
[doc('Reset the entire database')]
reset:
  just db-drop
  just db-create
  just migrate-up


File: internal/db/calculate_discounts.sql.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: calculate_discounts.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getCartWithItemsAndProductsWithDiscounts = `-- name: GetCartWithItemsAndProductsWithDiscounts :many


SELECT
    c.id AS cart_id,
    c.user_id,
    c.session_id,
    c.created_at,
    c.updated_at,
    -- Cart Items
    ci.id AS item_id,
    ci.cart_id AS item_cart_id,
    ci.product_id AS item_product_id,
    ci.quantity AS item_quantity,
    ci.created_at AS item_created_at,
    ci.updated_at AS item_updated_at,
    -- Product Details (with discount calculation from the view)
    p.id AS product_id,
    p.name AS product_name,
    p.price_cents AS original_price_cents,
    p.stock_quantity AS product_stock_quantity,
    p.image_urls AS product_image_urls,
    p.brand AS product_brand,
    -- Use the pre-calculated discounted price from the view
    COALESCE(vpcd.calculated_discounted_price_cents, p.price_cents, 0)::BIGINT AS final_price_cents, -- This is the price *per unit* after discount
    -- Use the has_active_discount boolean directly from the view
    COALESCE(vpcd.has_active_discount, FALSE) AS has_active_discount,
    -- Include the breakdown fields for potential use in the cart context
 COALESCE(vpcd.total_fixed_discount_cents, 0)::BIGINT AS vpcd_total_fixed_discount_cents, -- Fallback to 0
    COALESCE(vpcd.combined_percentage_factor, 1.0)::FLOAT AS vpcd_combined_percentage_factor -- Fallback to 1.0 (no discount factor)
FROM
    carts c
LEFT JOIN
    cart_items ci ON c.id = ci.cart_id AND ci.deleted_at IS NULL
LEFT JOIN
    products p ON ci.product_id = p.id AND p.deleted_at IS NULL
LEFT JOIN
    v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id -- Join with the view
WHERE
    c.id = $1 AND c.deleted_at IS NULL
ORDER BY
    ci.created_at ASC
`

type GetCartWithItemsAndProductsWithDiscountsRow struct {
	CartID                       uuid.UUID          `json:"cart_id"`
	UserID                       uuid.UUID          `json:"user_id"`
	SessionID                    *string            `json:"session_id"`
	CreatedAt                    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                    pgtype.Timestamptz `json:"updated_at"`
	ItemID                       uuid.UUID          `json:"item_id"`
	ItemCartID                   uuid.UUID          `json:"item_cart_id"`
	ItemProductID                uuid.UUID          `json:"item_product_id"`
	ItemQuantity                 *int32             `json:"item_quantity"`
	ItemCreatedAt                pgtype.Timestamptz `json:"item_created_at"`
	ItemUpdatedAt                pgtype.Timestamptz `json:"item_updated_at"`
	ProductID                    uuid.UUID          `json:"product_id"`
	ProductName                  *string            `json:"product_name"`
	OriginalPriceCents           *int64             `json:"original_price_cents"`
	ProductStockQuantity         *int32             `json:"product_stock_quantity"`
	ProductImageUrls             []byte             `json:"product_image_urls"`
	ProductBrand                 *string            `json:"product_brand"`
	FinalPriceCents              int64              `json:"final_price_cents"`
	HasActiveDiscount            bool               `json:"has_active_discount"`
	VpcdTotalFixedDiscountCents  int64              `json:"vpcd_total_fixed_discount_cents"`
	VpcdCombinedPercentageFactor float64            `json:"vpcd_combined_percentage_factor"`
}

// $1 = page_limit, $2 = page_offset
// Assuming this returns one cart object with many items
func (q *Queries) GetCartWithItemsAndProductsWithDiscounts(ctx context.Context, id uuid.UUID) ([]GetCartWithItemsAndProductsWithDiscountsRow, error) {
	rows, err := q.db.Query(ctx, getCartWithItemsAndProductsWithDiscounts, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCartWithItemsAndProductsWithDiscountsRow
	for rows.Next() {
		var i GetCartWithItemsAndProductsWithDiscountsRow
		if err := rows.Scan(
			&i.CartID,
			&i.UserID,
			&i.SessionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ItemID,
			&i.ItemCartID,
			&i.ItemProductID,
			&i.ItemQuantity,
			&i.ItemCreatedAt,
			&i.ItemUpdatedAt,
			&i.ProductID,
			&i.ProductName,
			&i.OriginalPriceCents,
			&i.ProductStockQuantity,
			&i.ProductImageUrls,
			&i.ProductBrand,
			&i.FinalPriceCents,
			&i.HasActiveDiscount,
			&i.VpcdTotalFixedDiscountCents,
			&i.VpcdCombinedPercentageFactor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductWithDiscountInfo = `-- name: GetProductWithDiscountInfo :one
SELECT
    p.id,
    p.category_id,
    c.name AS category_name,
    p.name,
    p.slug,
    p.description,
    p.short_description,
    p.price_cents AS original_price_cents,
    p.stock_quantity,
    p.status,
    p.brand,
    p.image_urls,
    p.spec_highlights,
    p.created_at,
    p.updated_at,
    p.deleted_at,
    p.avg_rating,
    p.num_ratings,
    vpcd.total_fixed_discount_cents::BIGINT,
    vpcd.combined_percentage_factor::FLOAT,
    COALESCE(vpcd.calculated_discounted_price_cents, p.price_cents) AS discounted_price_cents,
    -- Use the has_active_discount boolean directly from the view
    COALESCE(vpcd.has_active_discount, FALSE) AS has_active_discount
FROM
    products p
INNER JOIN categories c ON p.category_id = c.id -- Join with categories table
LEFT JOIN
    v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id
WHERE
    p.id = $1 AND p.deleted_at IS NULL
`

type GetProductWithDiscountInfoRow struct {
	ID                           uuid.UUID          `json:"id"`
	CategoryID                   uuid.UUID          `json:"category_id"`
	CategoryName                 string             `json:"category_name"`
	Name                         string             `json:"name"`
	Slug                         string             `json:"slug"`
	Description                  *string            `json:"description"`
	ShortDescription             *string            `json:"short_description"`
	OriginalPriceCents           int64              `json:"original_price_cents"`
	StockQuantity                int32              `json:"stock_quantity"`
	Status                       string             `json:"status"`
	Brand                        string             `json:"brand"`
	ImageUrls                    []byte             `json:"image_urls"`
	SpecHighlights               []byte             `json:"spec_highlights"`
	CreatedAt                    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                    pgtype.Timestamptz `json:"updated_at"`
	DeletedAt                    pgtype.Timestamptz `json:"deleted_at"`
	AvgRating                    pgtype.Numeric     `json:"avg_rating"`
	NumRatings                   *int32             `json:"num_ratings"`
	VpcdTotalFixedDiscountCents  int64              `json:"vpcd_total_fixed_discount_cents"`
	VpcdCombinedPercentageFactor float64            `json:"vpcd_combined_percentage_factor"`
	DiscountedPriceCents         int64              `json:"discounted_price_cents"`
	HasActiveDiscount            bool               `json:"has_active_discount"`
}

func (q *Queries) GetProductWithDiscountInfo(ctx context.Context, id uuid.UUID) (GetProductWithDiscountInfoRow, error) {
	row := q.db.QueryRow(ctx, getProductWithDiscountInfo, id)
	var i GetProductWithDiscountInfoRow
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.CategoryName,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.OriginalPriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AvgRating,
		&i.NumRatings,
		&i.VpcdTotalFixedDiscountCents,
		&i.VpcdCombinedPercentageFactor,
		&i.DiscountedPriceCents,
		&i.HasActiveDiscount,
	)
	return i, err
}

const getProductWithDiscountInfoBySlug = `-- name: GetProductWithDiscountInfoBySlug :one

SELECT
    p.id,
    p.category_id,
    c.name AS category_name,
    p.name,
    p.slug,
    p.description,
    p.short_description,
    p.price_cents AS original_price_cents,
    p.stock_quantity,
    p.status,
    p.brand,
    p.image_urls,
    p.spec_highlights,
    p.created_at,
    p.updated_at,
    p.deleted_at,
    p.avg_rating,
    p.num_ratings,
    vpcd.total_fixed_discount_cents::BIGINT,
    vpcd.combined_percentage_factor::FLOAT,
    COALESCE(vpcd.calculated_discounted_price_cents, p.price_cents) AS discounted_price_cents,
    -- Use the has_active_discount boolean directly from the view
    COALESCE(vpcd.has_active_discount, FALSE) AS has_active_discount
FROM
    products p
INNER JOIN categories c ON p.category_id = c.id -- Join with categories table
LEFT JOIN
    v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id
WHERE
    p.slug = $1 AND p.deleted_at IS NULL
`

type GetProductWithDiscountInfoBySlugRow struct {
	ID                           uuid.UUID          `json:"id"`
	CategoryID                   uuid.UUID          `json:"category_id"`
	CategoryName                 string             `json:"category_name"`
	Name                         string             `json:"name"`
	Slug                         string             `json:"slug"`
	Description                  *string            `json:"description"`
	ShortDescription             *string            `json:"short_description"`
	OriginalPriceCents           int64              `json:"original_price_cents"`
	StockQuantity                int32              `json:"stock_quantity"`
	Status                       string             `json:"status"`
	Brand                        string             `json:"brand"`
	ImageUrls                    []byte             `json:"image_urls"`
	SpecHighlights               []byte             `json:"spec_highlights"`
	CreatedAt                    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                    pgtype.Timestamptz `json:"updated_at"`
	DeletedAt                    pgtype.Timestamptz `json:"deleted_at"`
	AvgRating                    pgtype.Numeric     `json:"avg_rating"`
	NumRatings                   *int32             `json:"num_ratings"`
	VpcdTotalFixedDiscountCents  int64              `json:"vpcd_total_fixed_discount_cents"`
	VpcdCombinedPercentageFactor float64            `json:"vpcd_combined_percentage_factor"`
	DiscountedPriceCents         int64              `json:"discounted_price_cents"`
	HasActiveDiscount            bool               `json:"has_active_discount"`
}

// Query: GetProductWithDiscountInfoBySlug
// Retrieves a specific product by slug along with its calculated discount information using the pre-calculated view.
func (q *Queries) GetProductWithDiscountInfoBySlug(ctx context.Context, slug string) (GetProductWithDiscountInfoBySlugRow, error) {
	row := q.db.QueryRow(ctx, getProductWithDiscountInfoBySlug, slug)
	var i GetProductWithDiscountInfoBySlugRow
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.CategoryName,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.OriginalPriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AvgRating,
		&i.NumRatings,
		&i.VpcdTotalFixedDiscountCents,
		&i.VpcdCombinedPercentageFactor,
		&i.DiscountedPriceCents,
		&i.HasActiveDiscount,
	)
	return i, err
}

const getProductsWithDiscountInfo = `-- name: GetProductsWithDiscountInfo :many
SELECT
    p.id,
    p.category_id,
    c.name AS category_name,
    p.name,
    p.slug,
    p.description,
    p.short_description,
    p.price_cents AS original_price_cents,
    p.stock_quantity,
    p.status,
    p.brand,
    p.image_urls,
    p.spec_highlights,
    p.created_at,
    p.updated_at,
    p.deleted_at,
    p.avg_rating,
    p.num_ratings,
    vpcd.total_fixed_discount_cents::BIGINT,
    vpcd.combined_percentage_factor::FLOAT,
    COALESCE(vpcd.calculated_discounted_price_cents, p.price_cents) AS discounted_price_cents,
    -- Use the has_active_discount boolean directly from the view
    COALESCE(vpcd.has_active_discount, FALSE) AS has_active_discount
FROM
    products p
INNER JOIN categories c ON p.category_id = c.id -- Join with categories table
LEFT JOIN
    v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id
WHERE
    p.deleted_at IS NULL -- Add other filters if needed (e.g., category, price range)
ORDER BY
    p.created_at DESC -- Or other ordering
LIMIT $1 OFFSET $2
`

type GetProductsWithDiscountInfoParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetProductsWithDiscountInfoRow struct {
	ID                           uuid.UUID          `json:"id"`
	CategoryID                   uuid.UUID          `json:"category_id"`
	CategoryName                 string             `json:"category_name"`
	Name                         string             `json:"name"`
	Slug                         string             `json:"slug"`
	Description                  *string            `json:"description"`
	ShortDescription             *string            `json:"short_description"`
	OriginalPriceCents           int64              `json:"original_price_cents"`
	StockQuantity                int32              `json:"stock_quantity"`
	Status                       string             `json:"status"`
	Brand                        string             `json:"brand"`
	ImageUrls                    []byte             `json:"image_urls"`
	SpecHighlights               []byte             `json:"spec_highlights"`
	CreatedAt                    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                    pgtype.Timestamptz `json:"updated_at"`
	DeletedAt                    pgtype.Timestamptz `json:"deleted_at"`
	AvgRating                    pgtype.Numeric     `json:"avg_rating"`
	NumRatings                   *int32             `json:"num_ratings"`
	VpcdTotalFixedDiscountCents  int64              `json:"vpcd_total_fixed_discount_cents"`
	VpcdCombinedPercentageFactor float64            `json:"vpcd_combined_percentage_factor"`
	DiscountedPriceCents         int64              `json:"discounted_price_cents"`
	HasActiveDiscount            bool               `json:"has_active_discount"`
}

func (q *Queries) GetProductsWithDiscountInfo(ctx context.Context, arg GetProductsWithDiscountInfoParams) ([]GetProductsWithDiscountInfoRow, error) {
	rows, err := q.db.Query(ctx, getProductsWithDiscountInfo, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsWithDiscountInfoRow
	for rows.Next() {
		var i GetProductsWithDiscountInfoRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.CategoryName,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ShortDescription,
			&i.OriginalPriceCents,
			&i.StockQuantity,
			&i.Status,
			&i.Brand,
			&i.ImageUrls,
			&i.SpecHighlights,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.AvgRating,
			&i.NumRatings,
			&i.VpcdTotalFixedDiscountCents,
			&i.VpcdCombinedPercentageFactor,
			&i.DiscountedPriceCents,
			&i.HasActiveDiscount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}


File: internal/db/refresh_token.sql.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: refresh_token.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupExpiredRefreshTokens = `-- name: CleanupExpiredRefreshTokens :exec
DELETE FROM refresh_tokens WHERE expires_at < NOW() AND revoked_at IS NULL
`

func (q *Queries) CleanupExpiredRefreshTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredRefreshTokens)
	return err
}

const createRefreshToken = `-- name: CreateRefreshToken :exec
INSERT INTO refresh_tokens (jti, user_id, token_hash, expires_at)
VALUES ($1::text, $2::uuid, $3::char(64), $4::timestamptz)
`

type CreateRefreshTokenParams struct {
	Jti       string             `json:"jti"`
	UserID    uuid.UUID          `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, createRefreshToken,
		arg.Jti,
		arg.UserID,
		arg.TokenHash,
		arg.ExpiresAt,
	)
	return err
}

const getValidRefreshTokenRecord = `-- name: GetValidRefreshTokenRecord :one
SELECT id, jti, user_id, token_hash, expires_at, revoked_at, created_at, updated_at
FROM refresh_tokens
WHERE jti = $1::text AND expires_at > NOW() AND revoked_at IS NULL
`

func (q *Queries) GetValidRefreshTokenRecord(ctx context.Context, jti string) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, getValidRefreshTokenRecord, jti)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.Jti,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.RevokedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const revokeAllRefreshTokensByUserID = `-- name: RevokeAllRefreshTokensByUserID :exec
UPDATE refresh_tokens
SET revoked_at = NOW(), updated_at = NOW()
WHERE user_id = $1::uuid AND revoked_at IS NULL
`

// Revokes all refresh tokens for a specific user.
func (q *Queries) RevokeAllRefreshTokensByUserID(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeAllRefreshTokensByUserID, userID)
	return err
}

const revokeRefreshTokenByJTI = `-- name: RevokeRefreshTokenByJTI :exec
UPDATE refresh_tokens SET revoked_at = NOW(), updated_at = NOW() WHERE jti = $1::text
`

func (q *Queries) RevokeRefreshTokenByJTI(ctx context.Context, jti string) error {
	_, err := q.db.Exec(ctx, revokeRefreshTokenByJTI, jti)
	return err
}


File: internal/db/user.sql.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const activateUser = `-- name: ActivateUser :exec
UPDATE users
SET deleted_at = NULL, updated_at = NOW()
WHERE id = $1::uuid
`

// Removes the soft-delete marker by setting deleted_at to NULL.
func (q *Queries) ActivateUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, activateUser, userID)
	return err
}

const adminGetUser = `-- name: AdminGetUser :one
SELECT id, email, password_hash, full_name, is_admin, created_at, updated_at, deleted_at
FROM users
WHERE id = $1::uuid
`

// Gets a specific user by ID, regardless of soft-delete status.
// Useful for admin to see any user, active or inactive.
func (q *Queries) AdminGetUser(ctx context.Context, userID uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, adminGetUser, userID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const countSearchUsers = `-- name: CountSearchUsers :one
SELECT COUNT(*) AS total_matching_users
FROM users
WHERE 
  (LOWER(email) LIKE LOWER($1::text || '%') OR LOWER(full_name) LIKE LOWER($1::text || '%'))
  AND
  -- Filter by active status (NULL means active, NOT NULL means soft-deleted/inactive)
  CASE 
    WHEN $2::boolean THEN deleted_at IS NULL 
    WHEN NOT $2::boolean THEN TRUE -- Include both active and inactive
    ELSE TRUE -- Default if active_only is NULL (count all matching)
  END
`

type CountSearchUsersParams struct {
	SearchTerm string `json:"search_term"`
	ActiveOnly bool   `json:"active_only"`
}

// Counts users matching the search term, optionally filtered by active status.
// Useful for pagination metadata with search.
func (q *Queries) CountSearchUsers(ctx context.Context, arg CountSearchUsersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchUsers, arg.SearchTerm, arg.ActiveOnly)
	var total_matching_users int64
	err := row.Scan(&total_matching_users)
	return total_matching_users, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) AS total_users
FROM users
WHERE 
    is_admin = false
    AND
  -- Filter by active status (NULL means active, NOT NULL means soft-deleted/inactive)
  CASE 
    WHEN $1::boolean THEN deleted_at IS NULL 
    WHEN NOT $1::boolean THEN TRUE -- Include both active and inactive
    ELSE TRUE -- Default if active_only is NULL (count all)
  END
`

// Counts total users, optionally filtered by active status (soft-deleted).
// Useful for pagination metadata.
func (q *Queries) CountUsers(ctx context.Context, activeOnly bool) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers, activeOnly)
	var total_users int64
	err := row.Scan(&total_users)
	return total_users, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email, password_hash, full_name, is_admin, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, email, password_hash, full_name, is_admin, created_at, updated_at, deleted_at
`

type CreateUserParams struct {
	Email        string             `json:"email"`
	PasswordHash []byte             `json:"password_hash"`
	FullName     *string            `json:"full_name"`
	IsAdmin      bool               `json:"is_admin"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.FullName,
		arg.IsAdmin,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, email, password_hash, full_name, is_admin, created_at, updated_at, deleted_at
FROM users
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, full_name, is_admin, created_at, updated_at, deleted_at
FROM users
WHERE email = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserWithDetails = `-- name: GetUserWithDetails :one
SELECT 
    u.id, 
    u.email, 
    u.full_name, 
    u.created_at AS registration_date, -- User registration date
    u.deleted_at, -- Needed to determine activity status
    COUNT(o.id) AS total_order_count,
    MAX(o.created_at) AS last_order_date -- Get the latest order date
FROM 
    users u
LEFT JOIN 
    orders o ON u.id = o.user_id
WHERE 
    u.id = $1::uuid
GROUP BY 
    u.id
`

type GetUserWithDetailsRow struct {
	ID               uuid.UUID          `json:"id"`
	Email            string             `json:"email"`
	FullName         *string            `json:"full_name"`
	RegistrationDate pgtype.Timestamptz `json:"registration_date"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
	TotalOrderCount  int64              `json:"total_order_count"`
	LastOrderDate    interface{}        `json:"last_order_date"`
}

// Fetches a specific user by ID along with order count and last order date.
// Joins with the orders table to get aggregated details.
// Includes soft-deleted users as well.
func (q *Queries) GetUserWithDetails(ctx context.Context, userID uuid.UUID) (GetUserWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getUserWithDetails, userID)
	var i GetUserWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.RegistrationDate,
		&i.DeletedAt,
		&i.TotalOrderCount,
		&i.LastOrderDate,
	)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, email, password_hash, full_name, is_admin, created_at, updated_at, deleted_at
FROM users
WHERE 
    is_admin = false
    AND
  -- Filter by active status (NULL means active, NOT NULL means soft-deleted/inactive)
  CASE 
    WHEN $1::boolean THEN deleted_at IS NULL 
    WHEN NOT $1::boolean THEN TRUE -- Include both active and inactive
    ELSE TRUE -- Default if active_only is NULL (list all)
  END
ORDER BY created_at DESC -- Or another relevant order
LIMIT $3::int4 OFFSET $2::int4
`

type ListUsersParams struct {
	ActiveOnly bool  `json:"active_only"`
	PageOffset int32 `json:"page_offset"`
	PageLimit  int32 `json:"page_limit"`
}

// Lists users, optionally filtered by active status (soft-deleted).
// Paginated using LIMIT and OFFSET.
func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.ActiveOnly, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.FullName,
			&i.IsAdmin,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersWithListDetails = `-- name: ListUsersWithListDetails :many
SELECT
    u.id,
    u.email,
    u.full_name,
    u.created_at AS registration_date, -- User's registration date
    MAX(o.created_at) AS last_order_date, -- Latest order date for the user (will be NULL if no orders)
    COUNT(o.id) AS total_order_count,
    u.deleted_at -- Needed for determining activity status
FROM
    users u
LEFT JOIN
    orders o ON u.id = o.user_id
WHERE
is_admin = false
AND
  CASE
    WHEN $1::boolean THEN u.deleted_at IS NULL
    WHEN NOT $1::boolean THEN TRUE
    ELSE TRUE
  END
GROUP BY
    u.id
ORDER BY
    u.created_at DESC -- Or another relevant order
LIMIT $3::int4 OFFSET $2::int4
`

type ListUsersWithListDetailsParams struct {
	ActiveOnly bool  `json:"active_only"`
	PageOffset int32 `json:"page_offset"`
	PageLimit  int32 `json:"page_limit"`
}

type ListUsersWithListDetailsRow struct {
	ID               uuid.UUID          `json:"id"`
	Email            string             `json:"email"`
	FullName         *string            `json:"full_name"`
	RegistrationDate pgtype.Timestamptz `json:"registration_date"`
	LastOrderDate    interface{}        `json:"last_order_date"`
	TotalOrderCount  int64              `json:"total_order_count"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
}

// Lists users with essential details for admin list view (name, email, registration date, last order date, order count, status).
// Optionally filter by active status.
// Paginated using LIMIT and OFFSET.
func (q *Queries) ListUsersWithListDetails(ctx context.Context, arg ListUsersWithListDetailsParams) ([]ListUsersWithListDetailsRow, error) {
	rows, err := q.db.Query(ctx, listUsersWithListDetails, arg.ActiveOnly, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersWithListDetailsRow
	for rows.Next() {
		var i ListUsersWithListDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FullName,
			&i.RegistrationDate,
			&i.LastOrderDate,
			&i.TotalOrderCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersWithOrderCounts = `-- name: ListUsersWithOrderCounts :many
SELECT 
    u.id, 
    u.email, 
    u.full_name, 
    u.is_admin, 
    u.created_at, 
    u.updated_at, 
    u.deleted_at,
    COUNT(o.id) AS total_order_count
FROM 
    users u
LEFT JOIN 
    orders o ON u.id = o.user_id
WHERE 
  CASE 
    WHEN $1::boolean THEN u.deleted_at IS NULL 
    WHEN NOT $1::boolean THEN TRUE 
    ELSE TRUE 
  END
GROUP BY 
    u.id
ORDER BY 
    u.created_at DESC -- Or another relevant order
LIMIT $3::int4 OFFSET $2::int4
`

type ListUsersWithOrderCountsParams struct {
	ActiveOnly bool  `json:"active_only"`
	PageOffset int32 `json:"page_offset"`
	PageLimit  int32 `json:"page_limit"`
}

type ListUsersWithOrderCountsRow struct {
	ID              uuid.UUID          `json:"id"`
	Email           string             `json:"email"`
	FullName        *string            `json:"full_name"`
	IsAdmin         bool               `json:"is_admin"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	TotalOrderCount int64              `json:"total_order_count"`
}

// Lists users with their total order counts.
// Optionally filter by active status.
// Paginated using LIMIT and OFFSET.
func (q *Queries) ListUsersWithOrderCounts(ctx context.Context, arg ListUsersWithOrderCountsParams) ([]ListUsersWithOrderCountsRow, error) {
	rows, err := q.db.Query(ctx, listUsersWithOrderCounts, arg.ActiveOnly, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersWithOrderCountsRow
	for rows.Next() {
		var i ListUsersWithOrderCountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FullName,
			&i.IsAdmin,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalOrderCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsers = `-- name: SearchUsers :many
SELECT id, email, password_hash, full_name, is_admin, created_at, updated_at, deleted_at
FROM users
WHERE 
  (LOWER(email) LIKE LOWER($1::text || '%') OR LOWER(full_name) LIKE LOWER($1::text || '%'))
  AND
  -- Filter by active status (NULL means active, NOT NULL means soft-deleted/inactive)
  CASE 
    WHEN $2::boolean THEN deleted_at IS NULL 
    WHEN NOT $2::boolean THEN TRUE -- Include both active and inactive
    ELSE TRUE -- Default if active_only is NULL (list all matching)
  END
ORDER BY created_at DESC -- Or relevance if using full-text search
LIMIT $4::int4 OFFSET $3::int4
`

type SearchUsersParams struct {
	SearchTerm string `json:"search_term"`
	ActiveOnly bool   `json:"active_only"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

// Searches users by email or full_name, optionally filtered by active status.
// Paginated using LIMIT and OFFSET.
func (q *Queries) SearchUsers(ctx context.Context, arg SearchUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, searchUsers,
		arg.SearchTerm,
		arg.ActiveOnly,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.FullName,
			&i.IsAdmin,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteUser = `-- name: SoftDeleteUser :exec
UPDATE users
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = $1::uuid
`

// Marks a user as soft-deleted by setting deleted_at to NOW().
func (q *Queries) SoftDeleteUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteUser, userID)
	return err
}


File: internal/db/queries/products_view.sql
================================================
-- name: GetProductsWithDiscountInfoView :many
SELECT *
FROM v_products_with_current_discounts ;


File: internal/db/queries/analytics.sql
================================================
-- --- Sales Performance ---

-- name: GetTotalRevenue :one
-- Calculates the total revenue from all delivered orders within a given time range.
SELECT
    COALESCE(SUM(oi.quantity * oi.price_cents),0)::BIGINT AS total_revenue_cents
FROM
    orders o
JOIN
    order_items oi ON o.id = oi.order_id
WHERE
    o.status = 'delivered' -- Only delivered orders contribute to revenue
    AND o.created_at BETWEEN @start_date AND @end_date; -- $1 = start_date, $2 = end_date

-- name: GetSalesVolume :one
-- Counts the total number of delivered orders within a given time range.
SELECT
    COUNT(*) AS total_orders
FROM
    orders
WHERE
    status = 'delivered'
    AND created_at BETWEEN @start_date AND @end_date; -- @start_date = start_date, @start_date = end_date

-- name: GetAverageOrderValue :one
-- Calculates the average order value (AOV) for delivered orders within a given time range.
SELECT
    AVG(o.total_amount_cents) AS aov_cents
FROM
    orders o
WHERE
    o.status = 'delivered'
    AND o.created_at BETWEEN @start_date AND @end_date; -- $1 = start_date, $2 = end_date

-- name: GetTopSellingProducts :many
-- Retrieves the top N selling products (by quantity sold) within a given time range.
SELECT
    p.id AS product_id,
    p.name AS product_name,
    SUM(oi.quantity) AS total_units_sold
FROM
    order_items oi
JOIN
    orders o ON oi.order_id = o.id
JOIN
    products p ON oi.product_id = p.id
WHERE
    o.status = 'delivered'
    AND o.created_at BETWEEN @start_date AND @end_date -- $1 = start_date, $2 = end_date
GROUP BY
    p.id, p.name
ORDER BY
    total_units_sold DESC
LIMIT @limits; -- $3 = number of top products to return (N)

-- name: GetTopSellingCategories :many
-- Retrieves the top N selling categories (by quantity sold) within a given time range.
SELECT
    c.id AS category_id,
    c.name AS category_name,
    SUM(oi.quantity) AS total_units_sold
FROM
    order_items oi
JOIN
    orders o ON oi.order_id = o.id
JOIN
    products p ON oi.product_id = p.id
JOIN
    categories c ON p.category_id = c.id
WHERE
    o.status = 'delivered'
    AND o.created_at BETWEEN @start_date AND @end_date -- $1 = start_date, $2 = end_date
GROUP BY
    c.id, c.name
ORDER BY
    total_units_sold DESC
LIMIT @limits; -- $3 = number of top products to return (N)

-- --- Product Performance ---

-- name: GetLowStockProducts :many
-- Retrieves products with stock quantity below a specified threshold.
SELECT
    id AS product_id,
    name AS product_name,
    stock_quantity
FROM
    products
WHERE
    stock_quantity < $1 -- $1 = threshold quantity
    AND deleted_at IS NULL
ORDER BY
    stock_quantity ASC;

-- name: GetProductReviewStats :one
-- Retrieves average rating and number of ratings for a specific product.
-- (This might already be covered by the existing product queries selecting avg_rating, num_ratings)
-- But here's a dedicated query if needed:
SELECT
    avg_rating,
    num_ratings
FROM
    products
WHERE
    id = $1 AND deleted_at IS NULL;

-- --- Customer Insights ---

-- name: GetNewCustomersCount :one
-- Counts the number of new customers registered within a given time range.
SELECT
    COUNT(*) AS new_customers_count
FROM
    users
WHERE
    created_at BETWEEN @start_date AND @end_date-- $1 = start_date, $2 = end_date
    AND deleted_at IS NULL; -- Exclude soft-deleted users

-- --- Order Metrics ---

-- name: GetOrderStatusCounts :many
-- Counts the number of orders in each status (pending, confirmed, shipped, delivered, cancelled).
SELECT
    status,
    COUNT(*) AS count
FROM
    orders
WHERE
    created_at BETWEEN @start_date AND @end_date -- $1 = start_date, $2 = end_date (optional, remove if counting all time)
GROUP BY
    status;

-- name: GetAverageFulfillmentTime :one
-- Calculates the average time between order confirmation and shipment/delivery completion.
-- Assumes 'confirmed' status is the start and 'shipped' or 'delivered' is the end.
SELECT
    AVG(EXTRACT(EPOCH FROM (o_shipped_or_delivered.updated_at - o_confirmed.updated_at))) AS avg_seconds
FROM
    orders o_confirmed
JOIN
    orders o_shipped_or_delivered ON o_confirmed.id = o_shipped_or_delivered.id
WHERE
    o_confirmed.status = 'confirmed'
    AND (o_shipped_or_delivered.status = 'shipped' OR o_shipped_or_delivered.status = 'delivered')
    AND o_confirmed.created_at BETWEEN @start_date AND @end_date; -- $1 = start_date, $2 = end_date
-- Note: This query is complex because order status updates modify the same row.
-- A more robust approach might involve an order_status_history table or window functions.
-- Simplified version assuming statuses are updated sequentially and we just compare timestamps.
-- A better way might be to track status change events explicitly.
-- For now, let's simplify the logic assuming we just want the difference between created_at and updated_at
-- for 'shipped' or 'delivered' orders, IF created_at represents the time it became confirmed.
-- This might not be accurate depending on how status transitions are handled.
-- Let's revise:
-- Assume 'confirmed' status sets confirmed_at, 'shipped' sets shipped_at, 'delivered' sets delivered_at.
-- Add these timestamp fields to the orders table if they don't exist.
-- ALTER TABLE orders ADD COLUMN confirmed_at TIMESTAMPTZ, shipped_at TIMESTAMPTZ, delivered_at TIMESTAMPTZ;
-- Then update these timestamps in the service layer upon status changes.
-- Query would then be:
-- SELECT AVG(EXTRACT(EPOCH FROM (delivered_at - confirmed_at))) FROM orders WHERE status = 'delivered' AND ...;
-- For now, acknowledging this complexity, we'll note it and move on, assuming status timestamps exist or are derivable.
-- This query might need adjustment based on how status changes are tracked in the DB.
-- Let's add a simpler one based on status counts for now.
-- name: GetOrdersByStatusWithinTimeRange :many
-- Counts orders by status within a time range.
-- This is similar to GetOrderStatusCounts but with a time filter.
SELECT
    status,
    COUNT(*) AS count
FROM
    orders
WHERE
    created_at BETWEEN @start_date AND @end_date -- $1 = start_date, $2 = end_date (optional, remove if counting all time)
GROUP BY
    status;

-- --- Discount Effectiveness ---

-- name: GetDiscountUsage :many
-- Retrieves usage count and revenue attributed to specific discount codes within a time range.
SELECT
    d.code AS discount_code,
    d.discount_type,
    d.discount_value,
    COUNT(o.id) AS usage_count,
    SUM(o.total_amount_cents) AS total_revenue_with_discount
FROM
    orders o
JOIN
    discounts d ON o.applied_discount_code = d.code -- Assuming orders table stores the code used
WHERE
    o.status = 'delivered'
    AND o.created_at BETWEEN @start_date AND @end_date -- $1 = start_date, $2 = end_date
GROUP BY
    d.code, d.discount_type, d.discount_value;


File: internal/db/queries/order.sql
================================================
-- name: CreateOrder :one
-- Creates a new order with denormalized address fields and returns its details.
INSERT INTO orders (
    user_id, user_full_name, status, total_amount_cents, payment_method,
    province, city, phone_number_1, phone_number_2,
    notes, delivery_service_id
) VALUES (
    sqlc.arg(user_id), sqlc.arg(user_full_name), sqlc.arg(status), sqlc.arg(total_amount_cents), sqlc.arg(payment_method),
    sqlc.arg(province), sqlc.arg(city), sqlc.arg(phone_number_1), sqlc.arg(phone_number_2),
    sqlc.arg(notes), sqlc.arg(delivery_service_id)
)
RETURNING id, user_id, user_full_name, status, total_amount_cents, payment_method,
         province, city, phone_number_1, phone_number_2,
         notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at;

-- name: InsertOrderItemsBulk :exec
-- Inserts multiple order items efficiently in a single query.
-- Requires arrays of equal length for product_ids, quantities, names, and prices_cents.
INSERT INTO order_items (order_id, product_id, product_name, price_cents, quantity)
SELECT
    sqlc.arg(order_id) AS order_id, -- The single order ID for all items
    unnest(sqlc.arg(product_ids)::UUID[]) AS product_id, -- Array of product IDs
    unnest(sqlc.arg(product_names)::TEXT[]) AS product_name, -- Array of product names (denormalized)
    unnest(sqlc.arg(prices_cents)::BIGINT[]) AS price_cents, -- Array of final prices (including discounts)
    unnest(sqlc.arg(quantities)::INTEGER[]) AS quantity; -- Array of quantities

-- name: GetOrder :one
-- Retrieves an order by its ID with denormalized address fields.
SELECT 
    id, user_id, user_full_name, status, total_amount_cents, payment_method,
    province, city, phone_number_1, phone_number_2,
    notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
FROM orders
WHERE id = sqlc.arg(order_id);

-- name: GetOrderWithItems :many
-- Retrieves an order by its ID along with all its items, including denormalized address fields.
-- This query uses a join and might return multiple rows if there are items.
-- The service layer needs to aggregate these rows into a single Order object with a slice of OrderItems.
SELECT 
    o.id, o.user_id, o.user_full_name, o.status, o.total_amount_cents, o.payment_method,
    o.province, o.city, o.phone_number_1, o.phone_number_2,
    o.notes, o.delivery_service_id, o.created_at, o.updated_at, o.completed_at, o.cancelled_at,
    oi.id AS item_id, oi.order_id AS item_order_id, oi.product_id AS item_product_id,
    oi.product_name AS item_product_name, oi.price_cents AS item_price_cents,
    oi.quantity AS item_quantity, oi.subtotal_cents AS item_subtotal_cents,
    oi.created_at AS item_created_at, oi.updated_at AS item_updated_at
FROM orders o
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE o.id = sqlc.arg(order_id)
ORDER BY oi.created_at ASC; -- Order items consistently

-- name: ListUserOrders :many
-- Retrieves a paginated list of orders for a specific user with denormalized address fields, optionally filtered by status.
-- Excludes cancelled orders by default. Admins should use ListAllOrders.
SELECT 
    id, user_id, user_full_name, status, total_amount_cents, payment_method,
    province, city, phone_number_1, phone_number_2,
    notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
FROM orders
WHERE user_id = sqlc.arg(user_id)
  AND (sqlc.arg(filter_status)::TEXT = '' OR status = sqlc.arg(filter_status)) -- Filter by status if provided
  -- Explicitly exclude cancelled orders for user list
  AND cancelled_at IS NULL 
ORDER BY created_at DESC
LIMIT sqlc.arg(page_limit) OFFSET sqlc.arg(page_offset); -- Page limit and offset

-- name: ListAllOrders :many
-- Retrieves a paginated list of all orders with denormalized address fields, optionally filtered by status or user_id.
-- Intended for admin use. Includes cancelled orders.
-- If filter_user_id is the zero UUID ('00000000-0000-0000-0000-000000000000'), it retrieves orders for all users.
-- If filter_status is an empty string (''), it retrieves orders of all statuses.
SELECT 
    id, user_id, user_full_name, status, total_amount_cents, payment_method,
    province, city, phone_number_1, phone_number_2,
    notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
FROM orders
WHERE (sqlc.arg(filter_user_id)::UUID = '00000000-0000-0000-0000-000000000000'::UUID OR user_id = sqlc.arg(filter_user_id)) -- Filter by user_id if provided
  AND (sqlc.arg(filter_status)::TEXT = '' OR status = sqlc.arg(filter_status)) -- Filter by status if provided
ORDER BY created_at DESC
LIMIT sqlc.arg(page_limit) OFFSET sqlc.arg(page_offset); -- Page limit and offset

-- name: UpdateOrder :one
-- Updates other details of an order (notes, timestamps).
-- Address fields are denormalized and set during creation.
UPDATE orders
SET
    notes = COALESCE(sqlc.narg(notes), notes), -- Use narg for potentially nil values
    updated_at = NOW()
WHERE id = sqlc.arg(order_id)
RETURNING id, user_id, user_full_name, status, total_amount_cents, payment_method,
         province, city, phone_number_1, phone_number_2,
         notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at;

-- name: UpdateOrderStatus :one
-- Updates the status of an order and manages completion/cancellation timestamps.
UPDATE orders
SET status = sqlc.arg(status)::TEXT ,
    updated_at = NOW(),
    completed_at = CASE
        WHEN sqlc.arg(status) IN ('delivered', 'cancelled') AND completed_at IS NULL THEN NOW()
        ELSE completed_at -- Don't overwrite if already set
    END,
    cancelled_at = CASE
        WHEN sqlc.arg(status) = 'cancelled' AND cancelled_at IS NULL THEN NOW()
        ELSE cancelled_at -- Don't overwrite if already set
    END
WHERE id = sqlc.arg(order_id)
RETURNING id, user_id, user_full_name, status, total_amount_cents, payment_method,
         province, city, phone_number_1, phone_number_2,
         notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at;

-- name: GetOrderItemsByOrderID :many
-- Retrieves all items for a specific order ID.
SELECT 
    id, order_id, product_id, product_name, price_cents, quantity, subtotal_cents, created_at, updated_at
FROM order_items
WHERE order_id = sqlc.arg(order_id)
ORDER BY created_at ASC; -- Order items consistently

-- name: CancelOrder :one
-- Updates the status of an order to 'cancelled' and sets the cancelled_at and completed_at timestamps.
-- This is a soft cancellation.
UPDATE orders
SET 
    status = 'cancelled',
    cancelled_at = NOW(),
    completed_at = COALESCE(completed_at, NOW()), -- Set completed_at if it wasn't already
    updated_at = NOW()
WHERE id = sqlc.arg(order_id)
RETURNING 
    id, user_id, user_full_name, status, total_amount_cents, payment_method,
    province, city, phone_number_1, phone_number_2,
    notes, delivery_service_id, 
    created_at, updated_at, completed_at, cancelled_at;

-- name: DecrementStockIfSufficient :one
-- Attempts to decrement the stock_quantity for a product by a given amount.
-- Succeeds only if the resulting stock_quantity would be >= 0.
-- Returns the updated product row if successful, or an error if insufficient stock.
-- Note: The RETURNING clause might not be strictly necessary if we only care about RowsAffected.
-- If RETURNING is omitted, the querier function will likely return sql.Result.
-- Let's include RETURNING to get the updated stock if needed for debugging/logging.
UPDATE products
SET stock_quantity = stock_quantity - sqlc.arg(decrement_amount)
WHERE id = sqlc.arg(product_id) AND stock_quantity >= sqlc.arg(decrement_amount) -- The crucial condition
RETURNING id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at, deleted_at;

-- name: IncrementStock :one
-- Increments the stock_quantity for a product by a given amount.
-- Suitable for releasing stock back when cancelling an order.
UPDATE products
SET stock_quantity = stock_quantity + sqlc.arg(increment_amount)
WHERE id = sqlc.arg(product_id)
RETURNING id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at, deleted_at;

-- name: InsertOrderItemsFromCart :exec
-- Inserts order items into the order_items table by copying them from the user's current cart.
-- This ensures the item details (product, name, price, quantity) reflect the exact state of the cart at order creation time.
-- It fetches the final price (including discounts) from the cart_items joined with the calculated discount view.
INSERT INTO order_items (order_id, product_id, product_name, price_cents, quantity, created_at)
SELECT
    sqlc.arg(order_id) AS order_id, -- The single order ID for all items
    ci.product_id,
    p.name AS product_name, -- Get the name from the products table
    COALESCE(vpcd.calculated_discounted_price_cents, p.price_cents) AS price_cents, -- Use the final price from the cart or fallback to original
    ci.quantity,
    NOW() -- Set the created_at timestamp for the order item
FROM
    cart_items ci
JOIN
    products p ON ci.product_id = p.id -- Join to get product name
LEFT JOIN
    v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id -- Join with the discount view to get final price
WHERE
    ci.cart_id = sqlc.arg(cart_id) -- Fetch items from the specific cart
    AND ci.deleted_at IS NULL; -- Only include items not marked as deleted in the cart
 
-- name: CountUserOrders :one
-- Counts orders for a specific user based on optional status filter.
-- NOTE: UserID is a specific user to count for, FilterStatus is optional.
SELECT COUNT(*) FROM orders
WHERE user_id = sqlc.arg(user_id) -- Fixed user ID, not a filter
  AND (sqlc.narg(filter_status)::TEXT IS NULL OR status = sqlc.narg(filter_status)); -- Nullable status filter

-- name: CountAllOrders :one
-- Counts all orders based on optional user and status filters.
SELECT COUNT(*) FROM orders
WHERE (sqlc.arg(filter_user_id)::UUID ='00000000-0000-0000-0000-000000000000'OR user_id = sqlc.arg(filter_user_id)) -- Nullable user filter
  AND (sqlc.arg(filter_status)::TEXT = '' OR status = sqlc.arg(filter_status)); -- Nullable status filter


File: internal/models/analytics.go
================================================
package models

import (
	"time"

	"github.com/google/uuid"
)

// BaseAnalyticsRequest holds common parameters for analytics requests.
type BaseAnalyticsRequest struct {
	StartDate *time.Time `json:"start_date,omitempty" validate:"omitempty,datetime"`                 // ISO 8601 format: "2024-01-01T00:00:00Z"
	EndDate   *time.Time `json:"end_date,omitempty" validate:"omitempty,datetime,gtfield=StartDate"` // End date must be after start date
}

// GetTopNRequest extends BaseAnalyticsRequest with a limit parameter.
type GetTopNRequest struct {
	BaseAnalyticsRequest
	Limit int `json:"limit,omitempty" validate:"omitempty,min=1,max=100"` // Number of top items to return
}

// GetLowStockRequest holds parameters for low stock queries.
type GetLowStockRequest struct {
	Threshold int `json:"threshold" validate:"required,min=1"` // Minimum stock quantity threshold
}

// TotalRevenueResponse holds the total revenue calculation result.
type TotalRevenueResponse struct {
	TotalRevenueCents int64     `json:"total_revenue_cents"` // Total revenue in cents
	StartDate         time.Time `json:"start_date"`
	EndDate           time.Time `json:"end_date"`
}

// SalesVolumeResponse holds the sales volume calculation result.
type SalesVolumeResponse struct {
	TotalOrders int       `json:"total_orders"` // Total number of delivered orders
	StartDate   time.Time `json:"start_date"`
	EndDate     time.Time `json:"end_date"`
}

// AverageOrderValueResponse holds the average order value calculation result.
type AverageOrderValueResponse struct {
	AovCents  int64     `json:"aov_cents"`  // Average Order Value in cents
	StartDate time.Time `json:"start_date"` // Period start
	EndDate   time.Time `json:"end_date"`   // Period end
}

// TopSellingItem represents a product or category in top-selling lists.
type TopSellingItem struct {
	ID             uuid.UUID `json:"id"`               // Product or Category ID
	Name           string    `json:"name"`             // Product or Category Name
	TotalUnitsSold int64     `json:"total_units_sold"` // Quantity sold
}

// TopSellingProductsResponse holds the top-selling products list.
type TopSellingProductsResponse struct {
	Data      []TopSellingItem `json:"data"`       // List of top-selling products
	StartDate time.Time        `json:"start_date"` // Period start
	EndDate   time.Time        `json:"end_date"`   // Period end
	Limit     int              `json:"limit"`      // Number of items requested
}

// TopSellingCategoriesResponse holds the top-selling categories list.
type TopSellingCategoriesResponse struct {
	Data      []TopSellingItem `json:"data"`       // List of top-selling categories
	StartDate time.Time        `json:"start_date"` // Period start
	EndDate   time.Time        `json:"end_date"`   // Period end
	Limit     int              `json:"limit"`      // Number of items requested
}

// LowStockProduct represents a product with low stock.
type LowStockProduct struct {
	ID            uuid.UUID `json:"id"`             // Product ID
	Name          string    `json:"name"`           // Product Name
	StockQuantity int       `json:"stock_quantity"` // Current stock level
}

// LowStockProductsResponse holds the list of low-stock products.
type LowStockProductsResponse struct {
	Data      []LowStockProduct `json:"data"`      // List of low-stock products
	Threshold int               `json:"threshold"` // Threshold used for the query
}

// CustomerInsightsResponse holds new customer count.
type CustomerInsightsResponse struct {
	NewCustomersCount int       `json:"new_customers_count"` // Number of new registrations
	StartDate         time.Time `json:"start_date"`          // Period start
	EndDate           time.Time `json:"end_date"`            // Period end
}

// OrderStatusCount represents the count for a specific order status.
type OrderStatusCount struct {
	Status string `json:"status"` // Order status (e.g., pending, confirmed, shipped, delivered, cancelled)
	Count  int64  `json:"count"`  // Number of orders with this status
}

// OrderStatusCountsResponse holds the counts for all order statuses.
type OrderStatusCountsResponse struct {
	Data      []OrderStatusCount `json:"data"`       // List of status counts
	StartDate time.Time          `json:"start_date"` // Period start (if applicable)
	EndDate   time.Time          `json:"end_date"`   // Period end (if applicable)
}

// DiscountUsageReport represents usage data for a specific discount code.
type DiscountUsageReport struct {
	Code                     string `json:"code"`                              // Discount code used
	DiscountType             string `json:"discount_type"`                     // Type of discount (e.g., percentage, fixed_amount)
	DiscountValue            int64  `json:"discount_value"`                    // Value of the discount
	UsageCount               int64  `json:"usage_count"`                       // Number of times the discount was used
	TotalRevenueWithDiscount int64  `json:"total_revenue_with_discount_cents"` // Total revenue generated using this discount (in cents)
}

// DiscountUsageResponse holds the list of discount usage reports.
type DiscountUsageResponse struct {
	Data      []DiscountUsageReport `json:"data"`       // List of discount usage reports
	StartDate time.Time             `json:"start_date"` // Period start
	EndDate   time.Time             `json:"end_date"`   // Period end
}

// GenericAnalyticsResponse is a wrapper for different analytics data types.
type GenericAnalyticsResponse struct {
	Metric string      `json:"metric"` // e.g., "total_revenue", "top_products"
	Value  interface{} `json:"value"`  // The actual data payload
}


File: internal/models/order.go
================================================
package models

import (
	"time"

	"github.com/google/uuid"
)

// Address represents the structure for shipping and billing addresses stored as JSONB.
type Address struct {
	FullName     string  `json:"full_name" validate:"required"`      // Required
	PhoneNumber1 string  `json:"phone_number_1" validate:"required"` // Required
	PhoneNumber2 *string `json:"phone_number_2,omitempty"`           // Optional
	Province     string  `json:"province" validate:"required"`       // Required (formerly 'Provenance')
	City         string  `json:"city" validate:"required"`           // Required
	// Add other potential address fields if needed later
}

func (a *Address) Validate() error {
	return Validate.Struct(a)
}

func (i *BulkAddItemRequest_Item) Validate() error {
	return Validate.Struct(i)
}

// CreateOrderFromCartRequest represents the request body for creating an order from the current cart state.
type CreateOrderFromCartRequest struct {
	ShippingAddress   Address   `json:"shipping_address"`
	Notes             *string   `json:"notes,omitempty"`     // Optional notes for the order
	DeliveryServiceID uuid.UUID `json:"delivery_service_id"` // Required delivery service ID
}

func (r *CreateOrderFromCartRequest) Validate() error {
	return Validate.Struct(r)
}

// UpdateOrderStatusRequest represents the request body for updating an order's status.
type UpdateOrderStatusRequest struct {
	Status string `json:"status" validate:"required,oneof=pending confirmed shipped delivered cancelled"`
}

func (r *UpdateOrderStatusRequest) Validate() error {
	return Validate.Struct(r)
}

// UpdateOrderRequest represents the request body for updating other order details (e.g., notes).
type UpdateOrderRequest struct {
	Notes *string `json:"notes,omitempty" validate:"omitempty,max=500"` // Optional notes, max length 500 chars
}

func (r *UpdateOrderRequest) Validate() error {
	return Validate.Struct(r)
}

// Order represents the main order entity returned by the service.
type Order struct {
	ID                uuid.UUID  `json:"id"`
	UserID            uuid.UUID  `json:"user_id"`
	UserFullName      string     `json:"user_full_name"`
	Status            string     `json:"status"`
	TotalAmountCents  int64      `json:"total_amount_cents"`
	PaymentMethod     string     `json:"payment_method"`
	Province          string     `json:"province"`
	City              string     `json:"city"`
	PhoneNumber1      string     `json:"phone_number_1"`
	PhoneNumber2      *string    `json:"phone_number_2"`
	DeliveryServiceID uuid.UUID  `json:"delivery_service_id"`
	Notes             *string    `json:"notes,omitempty"`
	CreatedAt         time.Time  `json:"created_at"`
	UpdatedAt         time.Time  `json:"updated_at"`
	CompletedAt       *time.Time `json:"completed_at,omitempty"`
	CancelledAt       *time.Time `json:"cancelled_at,omitempty"`
}

// OrderItem represents an individual item within an order.
type OrderItem struct {
	ID            uuid.UUID `json:"id"`
	OrderID       uuid.UUID `json:"order_id"`
	ProductID     uuid.UUID `json:"product_id"`
	ProductName   string    `json:"product_name"`
	PriceCents    int64     `json:"price_cents"`
	Quantity      int32     `json:"quantity"`
	SubtotalCents int64     `json:"subtotal_cents"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
}

// OrderWithItems represents the complete state of an order for display purposes.
type OrderWithItems struct {
	Order Order       `json:"order"`
	Items []OrderItem `json:"items"`
}

// ListOrdersResponse wraps the result of a list orders query.
type ListOrdersResponse struct {
	Orders []Order `json:"orders"`
}


File: internal/handlers/product.go
================================================
package handlers

import (
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"strconv"
	"strings"

	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/MihoZaki/DzTech/internal/services"
	"github.com/MihoZaki/DzTech/internal/utils"
	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
)

type ProductHandler struct {
	productService *services.ProductService
}

func NewProductHandler(productService *services.ProductService) *ProductHandler {
	return &ProductHandler{
		productService: productService,
	}
}

func (h *ProductHandler) CreateProduct(w http.ResponseWriter, r *http.Request) {
	contentType := r.Header.Get("Content-Type")
	var createdProduct *models.Product
	var err error

	if strings.HasPrefix(contentType, "multipart/form-data") {
		slog.Debug("Handling multipart product creation request")

		createdProduct, err = h.createProductFromMultipart(r)
	} else if contentType == "application/json" || strings.HasPrefix(contentType, "application/json;") {
		slog.Debug("Handling JSON product creation request")

		createdProduct, err = h.createProductFromJSON(w, r)
	} else {
		utils.SendErrorResponse(w, http.StatusUnsupportedMediaType, "Unsupported Media Type", fmt.Sprintf("Unsupported Content-Type: %s", contentType))
		slog.Debug("Unsupported Content-Type received", "content_type", contentType)
		return
	}

	if err != nil {
		slog.Error("Failed to create product", "error", err)
		utils.SendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to create product")
		return
	}

	slog.Debug("Successfully created product", "product_id", createdProduct.ID)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(createdProduct)
}

func (h *ProductHandler) createProductFromMultipart(r *http.Request) (*models.Product, error) {
	err := r.ParseMultipartForm(32 << 20) // 32 MB
	if err != nil {
		return nil, fmt.Errorf("error parsing multipart form: %w", err)
	}
	name := r.FormValue("name")
	descriptionStr := r.FormValue("description")
	var description *string
	if descriptionStr != "" {
		description = &descriptionStr
	}
	shortDescriptionStr := r.FormValue("short_description")
	var shortDescription *string
	if shortDescriptionStr != "" {
		shortDescription = &shortDescriptionStr
	}
	priceCentsStr := r.FormValue("price_cents")
	priceCents, err := strconv.ParseInt(priceCentsStr, 10, 64)
	if err != nil || priceCents < 0 {
		return nil, fmt.Errorf("invalid price_cents: %v", err)
	}
	stockQuantityStr := r.FormValue("stock_quantity")
	stockQuantity, err := strconv.Atoi(stockQuantityStr)
	if err != nil || stockQuantity < 0 {
		return nil, fmt.Errorf("invalid stock_quantity: %v", err)
	}
	status := r.FormValue("status")
	brand := r.FormValue("brand")
	categoryIDStr := r.FormValue("category_id")
	categoryID, err := uuid.Parse(categoryIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid category_id format: %v", err)
	}

	specHighlightsJSONStr := r.FormValue("spec_highlights")
	var specHighlights map[string]any
	if specHighlightsJSONStr != "" {
		if err := json.Unmarshal([]byte(specHighlightsJSONStr), &specHighlights); err != nil {
			return nil, fmt.Errorf("invalid spec_highlights JSON: %w", err)
		}
	} else {
		specHighlights = make(map[string]any) // Initialize as empty map if not provided
	}
	imageFileHeaders := r.MultipartForm.File["images"] // Get []*multipart.FileHeader
	slog.Debug("backend received the image files headers", "image_headers", imageFileHeaders)

	req := models.CreateProductRequest{
		CategoryID:       categoryID,
		Name:             name,
		Description:      description,
		ShortDescription: shortDescription,
		PriceCents:       priceCents,
		StockQuantity:    stockQuantity, // Keep as int, service converts to int32
		Status:           status,
		Brand:            brand,
		ImageUrls:        []string{}, // Initialize as empty, will be filled by service
		SpecHighlights:   specHighlights,
	}

	err = req.Validate()
	if err != nil {
		return nil, fmt.Errorf("validation failed for text fields: %w", err)
	}

	return h.productService.CreateProductWithUpload(r.Context(), req, imageFileHeaders)
}

func (h *ProductHandler) createProductFromJSON(w http.ResponseWriter, r *http.Request) (*models.Product, error) {
	var req models.CreateProductRequest

	if err := DecodeAndValidateJSON(w, r, &req); err != nil {
		slog.Debug("Create product request failed validation/decoding", "error", err)
		return nil, err
	}

	product, err := h.productService.CreateProduct(r.Context(), req)
	if err != nil {
		return nil, err
	}

	return product, nil
}

func (h *ProductHandler) GetProduct(w http.ResponseWriter, r *http.Request) {
	identifier := chi.URLParam(r, "id")

	var product *models.Product
	var err error

	// Try to parse as UUID first (more specific format)
	if id, uuidErr := uuid.Parse(identifier); uuidErr == nil {
		// It's a UUID
		product, err = h.productService.GetProduct(r.Context(), id)
	} else {
		// Assume it's a slug
		product, err = h.productService.GetProductWithDiscountInfoBySlug(r.Context(), identifier)
	}

	if err != nil {
		slog.Debug("Product not found", "identifier", identifier, "error", err)
		utils.SendErrorResponse(w, http.StatusNotFound, "Not Found", "Product not found")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(product)
}

// Add new ListAllProducts endpoint (uses basic ListProducts function)
func (h *ProductHandler) ListAllProducts(w http.ResponseWriter, r *http.Request) {
	page := 1
	limit := 20

	pageStr := r.URL.Query().Get("page")
	if pageStr != "" {
		if p, err := strconv.Atoi(pageStr); err == nil && p > 0 {
			page = p
		}
	}

	limitStr := r.URL.Query().Get("limit")
	if limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 && l <= 100 {
			limit = l
		}
	}

	products, err := h.productService.ListAllProducts(r.Context(), page, limit)
	if err != nil {
		slog.Error("Failed to list all products", "error", err)
		utils.SendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to list products")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(products)
}

func (h *ProductHandler) SearchProducts(w http.ResponseWriter, r *http.Request) {
	filter := models.ProductFilter{
		Page:  1,
		Limit: 20,
	}

	// Parse query parameters
	query := r.URL.Query()
	if q := query.Get("q"); q != "" {
		filter.Query = q
	}
	if categoryIDStr := query.Get("category_id"); categoryIDStr != "" {
		categoryID, err := uuid.Parse(categoryIDStr)
		if err == nil && categoryID != uuid.Nil {
			filter.CategoryID = categoryID
		}
	}
	if brand := query.Get("brand"); brand != "" {
		filter.Brand = brand
	}
	if pageStr := query.Get("page"); pageStr != "" {
		page, err := strconv.Atoi(pageStr)
		if err == nil && page > 0 {
			filter.Page = page
		}
	}
	if limitStr := query.Get("limit"); limitStr != "" {
		limit, err := strconv.Atoi(limitStr)
		if err == nil && limit > 0 && limit <= 100 {
			filter.Limit = limit
		}
	}
	if minPriceStr := query.Get("min_price"); minPriceStr != "" {
		minPrice, err := strconv.ParseInt(minPriceStr, 10, 64)
		if err == nil && minPrice >= 0 {
			filter.MinPrice = &minPrice
		}
	}
	if maxPriceStr := query.Get("max_price"); maxPriceStr != "" {
		maxPrice, err := strconv.ParseInt(maxPriceStr, 10, 64)
		if err == nil && maxPrice >= 0 {
			filter.MaxPrice = &maxPrice
		}
	}
	if inStockOnlyStr := query.Get("in_stock_only"); inStockOnlyStr != "" {
		inStockOnly := strings.ToLower(inStockOnlyStr) == "true"
		filter.InStockOnly = &inStockOnly
	}

	includeDiscountedOnlyStr := r.URL.Query().Get("include_discounted_only") // e.g., ?include_discounted_only=true
	var includeDiscountedOnly *bool
	if includeDiscountedOnlyStr != "" {
		includeDiscountedOnlyVal := strings.ToLower(includeDiscountedOnlyStr) == "true"
		includeDiscountedOnly = &includeDiscountedOnlyVal
		filter.IncludeDiscountedOnly = includeDiscountedOnly
	}

	specFilterStr := r.URL.Query().Get("spec_filter") // e.g., ?spec_filter=socket=AM5
	var specFilterKey, specFilterValue string
	if specFilterStr != "" {
		parts := strings.SplitN(specFilterStr, ":", 2) // Split on first ':' only
		if len(parts) == 2 {
			specFilterKey = strings.TrimSpace(parts[0])   // e.g., "socket"
			specFilterValue = strings.TrimSpace(parts[1]) // e.g., "AM5"
			slog.Debug("the filter key value for spec filter is", "key", specFilterKey, "value", specFilterValue)
		} else {
			utils.SendErrorResponse(w, http.StatusBadRequest, "Invalid Spec Filter Format", "spec_filter must be in the format 'key=value'")
			return
		}
	}
	filter.SpecFilter = &specFilterStr
	products, err := h.productService.SearchProducts(r.Context(), filter, specFilterKey, specFilterValue)
	if err != nil {
		slog.Error("Failed to search products", "error", err)
		utils.SendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to search products")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(products)
}

func (h *ProductHandler) UpdateProduct(w http.ResponseWriter, r *http.Request) {
	productID, err := ParseUUIDPathParam(w, r, "id")
	if err != nil {
		slog.Debug("Update product request failed to parse productID", "error", err)
		return // Error response already sent by helper
	}

	contentType := r.Header.Get("Content-Type")

	// --- Detect Content-Type and Parse Accordingly ---
	var updatedProduct *models.Product

	if strings.HasPrefix(contentType, "multipart/form-data") {
		slog.Debug("Handling multipart product update request", "product_id", productID)
		// Handle Multipart Form (File Uploads)
		updatedProduct, err = h.updateProductFromMultipart(r, productID)
	} else if contentType == "application/json" || strings.HasPrefix(contentType, "application/json;") {
		slog.Debug("Handling JSON product update request", "product_id", productID)
		// Handle Standard JSON - use the new helper-based logic
		updatedProduct, err = h.updateProductFromJSON(w, r, productID)
	} else {
		utils.SendErrorResponse(w, http.StatusUnsupportedMediaType, "Unsupported Media Type", fmt.Sprintf("Unsupported Content-Type: %s", contentType))
		slog.Debug("Unsupported Content-Type received for update", "content_type", contentType, "product_id", productID)
		return
	}

	if err != nil {
		// Map service errors more specifically if possible, or use a generic helper
		if strings.Contains(err.Error(), "product not found") {
			utils.SendErrorResponse(w, http.StatusNotFound, "Not Found", "Product not found")
			return
		}
		if strings.Contains(err.Error(), "category not found") {
			utils.SendErrorResponse(w, http.StatusBadRequest, "Bad Request", "Category not found")
			return
		}
		slog.Error("Failed to update product", "error", err, "product_id", productID)
		utils.SendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to update product")
		return
	}

	// Successfully updated product
	slog.Debug("Successfully updated product", "product_id", updatedProduct.ID)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(updatedProduct)
}

func (h *ProductHandler) updateProductFromJSON(w http.ResponseWriter, r *http.Request, productID uuid.UUID) (*models.Product, error) {
	var req models.UpdateProductRequest
	// Use the existing helper for JSON decoding and validation
	if err := DecodeAndValidateJSON(w, r, &req); err != nil {
		slog.Debug("Update product request failed validation/decoding", "error", err, "product_id", productID)
		return nil, err // Propagate error to main handler
	}

	// Call the service to update the product (passing the validated struct and ID)
	product, err := h.productService.UpdateProduct(r.Context(), productID, req)
	if err != nil {
		return nil, err // Propagate error to main handler
	}

	return product, nil
}

func (h *ProductHandler) updateProductFromMultipart(r *http.Request, productID uuid.UUID) (*models.Product, error) {
	err := r.ParseMultipartForm(32 << 20) // 32 MB
	if err != nil {
		return nil, fmt.Errorf("error parsing multipart form: %w", err)
	}

	var req models.UpdateProductRequest

	// Check if each field is present in the form and assign to the pointer in the struct
	if val := r.FormValue("name"); val != "" {
		req.Name = &val
	}
	if val := r.FormValue("description"); val != "" {
		req.Description = &val
	}
	if val := r.FormValue("short_description"); val != "" {
		req.ShortDescription = &val
	}
	if val := r.FormValue("price_cents"); val != "" {
		if parsedVal, err := strconv.ParseInt(val, 10, 64); err == nil && parsedVal >= 0 {
			req.PriceCents = &parsedVal
		} else {
			return nil, fmt.Errorf("invalid price_cents: %v", err)
		}
	}
	if val := r.FormValue("stock_quantity"); val != "" {
		if parsedVal, err := strconv.Atoi(val); err == nil && parsedVal >= 0 {
			req.StockQuantity = &parsedVal
		} else {
			return nil, fmt.Errorf("invalid stock_quantity: %v", err)
		}
	}
	if val := r.FormValue("status"); val != "" {
		req.Status = &val
	}
	if val := r.FormValue("brand"); val != "" {
		req.Brand = &val
	}
	if val := r.FormValue("category_id"); val != "" {
		if parsedUUID, err := uuid.Parse(val); err == nil {
			req.CategoryID = &parsedUUID
		} else {
			return nil, fmt.Errorf("invalid category_id format: %v", err)
		}
	}
	if val := r.FormValue("spec_highlights"); val != "" {
		var specHighlights map[string]any
		if err := json.Unmarshal([]byte(val), &specHighlights); err == nil {
			req.SpecHighlights = &specHighlights
		} else {
			return nil, fmt.Errorf("invalid spec_highlights JSON: %w", err)
		}
	}
	imageFiles := r.MultipartForm.File["images"]
	slog.Debug("Update handler received the update image headers", "headers", imageFiles)

	product, err := h.productService.UpdateProductWithUpload(
		r.Context(),
		productID,
		req,        // Pass the UpdateProductRequest struct
		imageFiles, // Pass the []*multipart.FileHeader
	)
	if err != nil {
		return nil, fmt.Errorf("service error during update with upload: %w", err)
	}

	return product, nil
}
func (h *ProductHandler) DeleteProduct(w http.ResponseWriter, r *http.Request) {
	// Use the helper for parsing UUID from path
	productID, err := ParseUUIDPathParam(w, r, "id")
	if err != nil {
		slog.Debug("Delete product request failed to parse productID", "error", err)
		return // Error response already sent by helper
	}

	err = h.productService.DeleteProduct(r.Context(), productID)
	if err != nil {
		if strings.Contains(err.Error(), "product not found") {
			utils.SendErrorResponse(w, http.StatusNotFound, "Not Found", "Product not found")
			return
		}
		slog.Error("Failed to delete product", "error", err, "product_id", productID)
		utils.SendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to delete product")
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// Add new ListCategories endpoint
func (h *ProductHandler) ListCategories(w http.ResponseWriter, r *http.Request) {

	page := 1
	limit := 20

	pageStr := r.URL.Query().Get("page")
	if pageStr != "" {
		if p, err := strconv.Atoi(pageStr); err == nil && p > 0 {
			page = p
		}
	}

	limitStr := r.URL.Query().Get("limit")
	if limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 && l <= 100 {
			limit = l
		}
	}

	categories, err := h.productService.ListCategories(r.Context(), page, limit)
	if err != nil {
		slog.Error("Failed to list categories", "error", err)
		utils.SendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to list categories")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(categories)
}

// Add new GetCategory endpoint that handles both ID and slug
func (h *ProductHandler) GetCategory(w http.ResponseWriter, r *http.Request) {
	identifier := chi.URLParam(r, "id")

	// Try to parse as UUID first (more specific format)
	if id, uuidErr := uuid.Parse(identifier); uuidErr == nil {
		// It's a UUID - get by ID
		category, err := h.productService.GetCategoryByID(r.Context(), id)
		if err != nil {
			if strings.Contains(err.Error(), "category not found") {
				utils.SendErrorResponse(w, http.StatusNotFound, "Not Found", "Category not found")
				return
			}
			utils.SendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to get category")
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(category)
		return
	} else {
		// Assume it's a slug - get by slug
		category, err := h.productService.GetCategoryBySlug(r.Context(), identifier)
		if err != nil {
			if strings.Contains(err.Error(), "category not found") {
				utils.SendErrorResponse(w, http.StatusNotFound, "Not Found", "Category not found")
				return
			}
			utils.SendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to get category")
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(category)
		return
	}
}

func (h *ProductHandler) RegisterRoutes(r chi.Router) {
	r.Post("/", h.CreateProduct)
	r.Get("/{id}", h.GetProduct)

	r.Get("/", h.ListAllProducts)
	r.Get("/categories", h.ListCategories)

	r.Get("/categories/{id}", h.GetCategory)

	r.Patch("/{id}", h.UpdateProduct)
	r.Delete("/{id}", h.DeleteProduct)

	r.Get("/search", h.SearchProducts)
}


File: internal/handlers/order.go
================================================
package handlers

import (
	"encoding/json"
	"errors"
	"log/slog"
	"net/http"
	"strconv"

	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/MihoZaki/DzTech/internal/services"
	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
)

// OrderHandler manages HTTP requests for order-related operations.
type OrderHandler struct {
	service *services.OrderService
	logger  *slog.Logger
}

// NewOrderHandler creates a new instance of OrderHandler.
func NewOrderHandler(service *services.OrderService, logger *slog.Logger) *OrderHandler {
	return &OrderHandler{
		service: service,
		logger:  logger,
	}
}

// RegisterUserRoutes registers the order-related routes accessible to authenticated users.
func (h *OrderHandler) RegisterUserRoutes(r chi.Router) {
	r.Post("/", h.CreateOrder)   // POST /api/v1/orders (checkout)
	r.Get("/{id}", h.GetOrder)   // GET /api/v1/orders/{id}
	r.Get("/", h.ListUserOrders) // GET /api/v1/orders?page=&limit=&status=

}

func (h *OrderHandler) RegisterGuestRoutes(r chi.Router) {
	r.Post("/guest", h.CreateGuestOrder) // POST /api/v1/order(checkout)

}

// RegisterAdminRoutes registers the order-related routes accessible only to admins.
func (h *OrderHandler) RegisterAdminRoutes(r chi.Router) {
	r.Get("/all", h.ListAllOrders)             // GET /api/v1/admin/orders/all?page=&limit=&user_id=&status=
	r.Get("/{id}", h.GetOrderByID)             // GET /api/v1/admin/orders/{id} (admin access)
	r.Put("/{id}/status", h.UpdateOrderStatus) // PUT /api/v1/admin/orders/{id}/status
	r.Put("/{id}/cancel", h.CancelOrder)       // PUT /api/v1/admin/orders/{id}/cancel
}

// CreateOrder handles the creation of a new order.
// Expected JSON body: models.CreateOrderRequest
// Requires UserID from JWT context.
func (h *OrderHandler) CreateOrder(w http.ResponseWriter, r *http.Request) {
	// 1. Extract UserID from JWT context (existing logic)
	var userIDVal *uuid.UUID
	if user, ok := models.GetUserFromContext(r.Context()); ok {
		h.logger.Debug("Authenticated user accessing order", "user_id", user.ID)
		userIDVal = &user.ID
	}
	if userIDVal == nil {
		http.Error(w, "Unauthorized: missing user context", http.StatusUnauthorized)
		return
	}
	userID := *userIDVal // Dereference for easier use
	sessionID := ""
	// 2. Decode Request Body into CreateOrderFromCartRequest
	var req models.CreateOrderFromCartRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid JSON in request body: "+err.Error(), http.StatusBadRequest)
		return
	}

	// 3. Validate the request struct
	if err := req.Validate(); err != nil {
		http.Error(w, "Validation error: "+err.Error(), http.StatusBadRequest)
		return
	}

	// 4. Call the Service Method
	orderSummary, err := h.service.CreateOrder(r.Context(), req, &userID, sessionID) // Pass the NEW req and userID
	if err != nil {
		// Log the error server-side
		h.logger.Error("Failed to create order", "error", err, "user_id", userID)
		// Return a generic error message to the client
		http.Error(w, "Failed to create order: "+err.Error(), http.StatusInternalServerError) // More specific error message
		return
	}

	// 5. Send Success Response (201 Created) (existing logic)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated) // 201 Created
	if err := json.NewEncoder(w).Encode(orderSummary); err != nil {
		// Log encoding error, but response headers might already be sent
		h.logger.Error("Failed to encode CreateOrder response", "error", err)
	}
}

// CreateGuestOrder handles the creation of a new order for unauthenticated (guest) users.
// Expected JSON body: models.CreateOrderFromCartRequest
// Does NOT require UserID from JWT context. Requires sessionID from the frontend.
func (h *OrderHandler) CreateGuestOrder(w http.ResponseWriter, r *http.Request) {
	// 1. Extract SessionID from a header or cookie set by the frontend (or potentially from the request body if less secure)
	// Assuming the frontend sends it in a header called X-Session-ID
	sessionIDStr, ok := GetSessionIDFromCookie(r)
	if !ok {
		http.Error(w, "Missing session identifier (session Cookie)", http.StatusBadRequest)
		return
	}

	if sessionIDStr == "" {
		http.Error(w, "Session ID cant be empty", http.StatusBadRequest)
		return
	}
	sessionID := sessionIDStr // Convert to *string

	// userID is nil for guest users
	var userID *uuid.UUID

	// 2. Decode Request Body into CreateOrderFromCartRequest
	var req models.CreateOrderFromCartRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid JSON in request body: "+err.Error(), http.StatusBadRequest)
		return
	}

	// 3. Validate the request struct
	if err := req.Validate(); err != nil {
		http.Error(w, "Validation error: "+err.Error(), http.StatusBadRequest)
		return
	}

	// 4. Call the Service Method (pass nil for userID, sessionID)
	orderSummary, err := h.service.CreateOrder(r.Context(), req, userID, sessionID) // Pass req, nil userID, and sessionID
	if err != nil {
		// Log the error server-side
		h.logger.Error("Failed to create order for guest user", "error", err, "session_id", sessionIDStr)
		// Return a generic error message to the client
		http.Error(w, "Failed to create order: "+err.Error(), http.StatusInternalServerError) // More specific error message
		return
	}

	// 5. Send Success Response (201 Created)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated) // 201 Created
	if err := json.NewEncoder(w).Encode(orderSummary); err != nil {
		// Log encoding error, but response headers might already be sent
		h.logger.Error("Failed to encode CreateGuestOrder response", "error", err)
	}
}

// GetOrder handles retrieving a specific order by its ID.
// Requires the order to belong to the authenticated user (UserID from JWT context).
func (h *OrderHandler) GetOrder(w http.ResponseWriter, r *http.Request) {
	// Extract OrderID from URL path
	orderIDStr := chi.URLParam(r, "id")
	orderID, err := uuid.Parse(orderIDStr)
	if err != nil {
		http.Error(w, "Invalid order ID format", http.StatusBadRequest)
		return
	}

	// Extract UserID from JWT context
	var userIDVal *uuid.UUID
	if user, ok := models.GetUserFromContext(r.Context()); ok {
		h.logger.Debug("Authenticated user accessing cart", "user_id", user.ID)
		userIDVal = &user.ID
		// sessionID remains empty for authenticated users
	}
	if userIDVal == nil {
		http.Error(w, "Unauthorized: missing user context", http.StatusUnauthorized)
		return
	}

	orderWithItems, err := h.service.GetOrder(r.Context(), orderID)
	if err != nil {
		if errors.Is(err, services.ErrOrderNotFound) {
			http.Error(w, "Order not found", http.StatusNotFound)
			return
		}
		h.logger.Error("Failed to get order", "error", err, "order_id", orderID, "user_id", *userIDVal)
		http.Error(w, "Failed to retrieve order", http.StatusInternalServerError)
		return
	}

	// Check if the order belongs to the requesting user
	if orderWithItems.Order.UserID != *userIDVal {
		// Log potential security issue
		h.logger.Warn("User attempted to access another user's order", "requesting_user_id", *userIDVal, "order_owner_id", orderWithItems.Order.UserID, "order_id", orderID)
		http.Error(w, "Forbidden: access denied", http.StatusForbidden)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK) // 200 OK
	if err := json.NewEncoder(w).Encode(orderWithItems); err != nil {
		h.logger.Error("Failed to encode GetOrder response", "error", err)
	}
}

// GetOrderByID handles retrieving a specific order by its ID (admin only).
// Does NOT check if the order belongs to the requesting user.
func (h *OrderHandler) GetOrderByID(w http.ResponseWriter, r *http.Request) {
	// Extract OrderID from URL path
	orderIDStr := chi.URLParam(r, "id")
	orderID, err := uuid.Parse(orderIDStr)
	if err != nil {
		http.Error(w, "Invalid order ID format", http.StatusBadRequest)
		return
	}
	var userID *uuid.UUID
	if user, ok := models.GetUserFromContext(r.Context()); ok {
		h.logger.Debug("Authenticated user accessing cart", "user_id", user.ID)
		userID = &user.ID
		// sessionID remains empty for authenticated users
	}
	if userID == nil {
		http.Error(w, "Unauthorized: missing user context", http.StatusUnauthorized)
		return
	}

	// Fetch the order with items using the service
	orderWithItems, err := h.service.GetOrder(r.Context(), orderID)
	if err != nil {
		if errors.Is(err, services.ErrOrderNotFound) {
			http.Error(w, "Order not found", http.StatusNotFound)
			return
		}
		h.logger.Error("Failed to get order by ID (admin)", "error", err, "order_id", orderID, "user_id", userID)
		http.Error(w, "Failed to retrieve order", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK) // 200 OK
	if err := json.NewEncoder(w).Encode(orderWithItems); err != nil {
		h.logger.Error("Failed to encode GetOrderByID response", "error", err)
	}
}

// ListUserOrders handles listing orders for the authenticated user.
// Requires UserID from JWT context.
func (h *OrderHandler) ListUserOrders(w http.ResponseWriter, r *http.Request) {
	// Extract UserID from JWT context
	var userIDVal *uuid.UUID
	if user, ok := models.GetUserFromContext(r.Context()); ok {
		h.logger.Debug("Authenticated user accessing cart", "user_id", user.ID)
		userIDVal = &user.ID
		// sessionID remains empty for authenticated users
	}
	if userIDVal == nil {
		http.Error(w, "Unauthorized: missing user context", http.StatusUnauthorized)
		return
	}

	// Parse query parameters for pagination and filtering
	statusFilter := r.URL.Query().Get("status")
	pageStr := r.URL.Query().Get("page")
	limitStr := r.URL.Query().Get("limit")

	page := 1 // Default page
	if pageStr != "" {
		if p, err := strconv.Atoi(pageStr); err == nil && p > 0 {
			page = p
		} // else, keep default
	}

	limit := 20 // Default limit
	if limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 {
			limit = l
		} // else, keep default
	}

	// Call the service method which now returns PaginatedResponse
	paginatedResult, err := h.service.ListUserOrders(r.Context(), *userIDVal, statusFilter, page, limit)
	if err != nil {
		h.logger.Error("Failed to list user orders", "error", err, "user_id", *userIDVal)
		http.Error(w, "Failed to retrieve orders", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK) // 200 OK
	// Encode the PaginatedResponse struct directly
	if err := json.NewEncoder(w).Encode(paginatedResult); err != nil {
		h.logger.Error("Failed to encode ListUserOrders response", "error", err)
	}
}

// ListAllOrders handles listing all orders (admin only).
// Requires UserID from JWT context and admin privileges
func (h *OrderHandler) ListAllOrders(w http.ResponseWriter, r *http.Request) {
	// Extract UserID from JWT context
	var userIDVal *uuid.UUID
	if user, ok := models.GetUserFromContext(r.Context()); ok {
		h.logger.Debug("Authenticated user accessing cart", "user_id", user.ID)
		userIDVal = &user.ID
		// sessionID remains empty for authenticated users
	}
	if userIDVal == nil {
		http.Error(w, "Unauthorized: missing user context", http.StatusUnauthorized)
		return
	}
	// Parse query parameters for pagination and filtering
	userFilterStr := r.URL.Query().Get("user_id")
	statusFilter := r.URL.Query().Get("status")
	pageStr := r.URL.Query().Get("page")
	limitStr := r.URL.Query().Get("limit")

	var userFilterID uuid.UUID // Zero value if not provided
	if userFilterStr != "" {
		if parsedID, err := uuid.Parse(userFilterStr); err != nil {
			http.Error(w, "Invalid user ID filter format", http.StatusBadRequest)
			return
		} else {
			userFilterID = parsedID
		}
	}

	page := 1 // Default page
	if pageStr != "" {
		if p, err := strconv.Atoi(pageStr); err == nil && p > 0 {
			page = p
		} // else, keep default
	}

	limit := 20 // Default limit
	if limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 {
			limit = l
		} // else, keep default
	}

	// Call the service method which now returns PaginatedResponse
	paginatedResult, err := h.service.ListAllOrders(r.Context(), userFilterID, statusFilter, page, limit)
	if err != nil {
		h.logger.Error("Failed to list all orders", "error", err, "user_id", *userIDVal) // Log the admin user ID making the request
		http.Error(w, "Failed to retrieve orders", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK) // 200 OK
	// Encode the PaginatedResponse struct directly
	if err := json.NewEncoder(w).Encode(paginatedResult); err != nil {
		h.logger.Error("Failed to encode ListAllOrders response", "error", err)
	}
}

// UpdateOrderStatus handles updating the status of an order (admin only).
// Expected JSON body: models.UpdateOrderStatusRequest
// Requires UserID from JWT context and admin privileges.
func (h *OrderHandler) UpdateOrderStatus(w http.ResponseWriter, r *http.Request) {
	// Extract OrderID from URL path
	orderIDStr := chi.URLParam(r, "id")
	orderID, err := uuid.Parse(orderIDStr)
	if err != nil {
		http.Error(w, "Invalid order ID format", http.StatusBadRequest)
		return
	}

	var userIDVal *uuid.UUID
	if user, ok := models.GetUserFromContext(r.Context()); ok {
		h.logger.Debug("Authenticated user accessing cart", "user_id", user.ID)
		userIDVal = &user.ID
		// sessionID remains empty for authenticated users
	}
	if userIDVal == nil {
		http.Error(w, "Unauthorized: missing user context", http.StatusUnauthorized)
		return
	}

	var req models.UpdateOrderStatusRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid JSON in request body: "+err.Error(), http.StatusBadRequest)
		return
	}

	// Validate the request struct (optional, if using validator tags)
	if err := req.Validate(); err != nil {
		http.Error(w, "Validation error: "+err.Error(), http.StatusBadRequest)
		return
	}

	updatedOrder, err := h.service.UpdateOrderStatus(r.Context(), orderID, req)
	if err != nil {
		if errors.Is(err, services.ErrOrderNotFound) {
			http.Error(w, "Order not found", http.StatusNotFound)
			return
		}
		// Check for other specific errors like invalid status transition
		var statusErr *services.StatusTransitionError //
		if errors.As(err, &statusErr) {
			http.Error(w, err.Error(), http.StatusConflict) // 409 Conflict for invalid transitions
			return
		}
		h.logger.Error("Failed to update order status", "error", err, "order_id", orderID, "user_id", *userIDVal, "new_status", req.Status)
		http.Error(w, "Failed to update order status", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK) // 200 OK
	if err := json.NewEncoder(w).Encode(updatedOrder); err != nil {
		h.logger.Error("Failed to encode UpdateOrderStatus response", "error", err)
	}
}

// CancelOrder handles cancelling an order (admin only).
// Requires UserID from JWT context and admin privileges.
func (h *OrderHandler) CancelOrder(w http.ResponseWriter, r *http.Request) {
	// Extract OrderID from URL path
	orderIDStr := chi.URLParam(r, "id")
	orderID, err := uuid.Parse(orderIDStr)
	if err != nil {
		http.Error(w, "Invalid order ID format", http.StatusBadRequest)
		return
	}

	var userIDVal *uuid.UUID
	if user, ok := models.GetUserFromContext(r.Context()); ok {
		h.logger.Debug("Authenticated user accessing cart", "user_id", user.ID)
		userIDVal = &user.ID
		// sessionID remains empty for authenticated users
	}
	if userIDVal == nil {
		http.Error(w, "Unauthorized: missing user context", http.StatusUnauthorized)
		return
	}

	updatedOrder, err := h.service.CancelOrder(r.Context(), orderID)
	if err != nil {
		if errors.Is(err, services.ErrOrderNotFound) {
			http.Error(w, "Order not found", http.StatusNotFound)
			return
		}
		// Check for other specific errors like cannot cancel in current state
		var cancelErr *services.CannotCancelError //
		if errors.As(err, &cancelErr) {
			http.Error(w, err.Error(), http.StatusConflict) // 409 Conflict for invalid cancellation
			return
		}
		h.logger.Error("Failed to cancel order", "error", err, "order_id", orderID, "user_id", *userIDVal)
		http.Error(w, "Failed to cancel order", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK) // 200 OK
	if err := json.NewEncoder(w).Encode(updatedOrder); err != nil {
		h.logger.Error("Failed to encode CancelOrder response", "error", err)
	}
}


File: internal/services/product_service.go
================================================
package services

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"math"
	"mime/multipart"
	"slices"
	"strings"
	"time"

	"github.com/MihoZaki/DzTech/internal/db"
	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/MihoZaki/DzTech/internal/storage"
	"github.com/MihoZaki/DzTech/internal/utils"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/redis/go-redis/v9"
)

type ProductService struct {
	querier db.Querier
	storer  storage.Storer
	cache   *redis.Client
	logger  *slog.Logger
}

const (
	CacheKeyProductByID   = "product:id:%s"   // Format: product:id:{uuid_string}
	CacheKeyProductBySlug = "product:slug:%s" // Format: product:slug:{slug_string}
	ProductCacheTTL       = 30 * time.Minute  // Define TTL for product cache entries
)

func NewProductService(querier db.Querier, storer storage.Storer, cache *redis.Client, logger *slog.Logger) *ProductService {
	return &ProductService{
		querier: querier,
		storer:  storer,
		cache:   cache,
		logger:  logger,
	}
}

func (s *ProductService) CreateProduct(ctx context.Context, req models.CreateProductRequest) (*models.Product, error) {
	// Validate category exists
	_, err := s.querier.GetCategory(ctx, req.CategoryID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("category not found")
		}
		return nil, err
	}
	// Marshal spec highlights to JSON
	specHighlightsJSON, err := json.Marshal(req.SpecHighlights)
	if err != nil {
		return nil, errors.New("invalid spec highlights format")
	}
	// Marshal image urls to JSON
	imageUrlsJSON, err := json.Marshal(req.ImageUrls) // Uses URLs from request (JSON or handler processing)
	if err != nil {
		return nil, errors.New("invalid image urls format")
	}
	// --- Generate Slug ---
	baseSlug := utils.GenerateSlug(req.Name)
	finalSlug := s.ensureUniqueSlug(ctx, baseSlug)

	params := prepareCreateProductParams(
		req.CategoryID,
		req.Name,
		finalSlug,
		req.Description,      // Pass *string directly
		req.ShortDescription, // Pass *string directly
		req.PriceCents,
		int32(req.StockQuantity),
		req.Status,
		req.Brand,
		imageUrlsJSON,
		specHighlightsJSON,
	)

	dbProduct, err := s.querier.CreateProduct(ctx, params)
	if err != nil {
		return nil, err
	}

	return s.toProductModel(dbProduct), nil
}

func (s *ProductService) CreateProductWithUpload(ctx context.Context, req models.CreateProductRequest, imageFileHeaders []*multipart.FileHeader) (*models.Product, error) {
	// Validate category exists
	_, err := s.querier.GetCategory(ctx, req.CategoryID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("category not found")
		}
		return nil, err
	}

	// --- Process Files using the Storer (Business Logic) ---
	var processedImageUrls []string
	for _, fileHeader := range imageFileHeaders {
		// Open the file
		file, err := fileHeader.Open()
		if err != nil {
			return nil, fmt.Errorf("failed to open uploaded file %s: %w", fileHeader.Filename, err)
		}

		// Upload the file using the injected storer
		url, err := s.storer.UploadFile(file, fileHeader)
		file.Close() // Close the file after uploading (regardless of success/error)
		if err != nil {
			return nil, fmt.Errorf("failed to upload image %s: %w", fileHeader.Filename, err)
		}

		processedImageUrls = append(processedImageUrls, url)
	}

	req.ImageUrls = processedImageUrls // Assign the processed URLs back to the struct
	specHighlightsJSON, err := json.Marshal(req.SpecHighlights)
	if err != nil {
		return nil, errors.New("invalid spec highlights format")
	}
	imageUrlsJSON, err := json.Marshal(req.ImageUrls) // Uses URLs from req (populated by service)
	if err != nil {
		return nil, errors.New("invalid image urls format")
	}

	// --- Generate Slug ---
	baseSlug := utils.GenerateSlug(req.Name)
	finalSlug := s.ensureUniqueSlug(ctx, baseSlug)
	params := prepareCreateProductParams(
		req.CategoryID,
		req.Name,
		finalSlug,
		req.Description,      // Pass *string directly
		req.ShortDescription, // Pass *string directly
		req.PriceCents,
		int32(req.StockQuantity), // Convert int to int32
		req.Status,
		req.Brand,
		imageUrlsJSON,
		specHighlightsJSON,
	)

	dbProduct, err := s.querier.CreateProduct(ctx, params)
	if err != nil {
		return nil, err
	}

	return s.toProductModel(dbProduct), nil
}

// GetProduct retrieves a product by its ID, including calculated discount information, utilizing caching.
func (s *ProductService) GetProduct(ctx context.Context, id uuid.UUID) (*models.Product, error) {
	cacheKey := fmt.Sprintf(CacheKeyProductByID, id.String())

	// --- Try to get from cache first ---
	cachedData, err := s.cache.Get(ctx, cacheKey).Result()
	if err == nil {
		// Cache hit - deserialize and return
		var product models.Product
		if err := json.Unmarshal([]byte(cachedData), &product); err != nil {
			s.logger.Error("Failed to unmarshal cached product", "key", cacheKey, "error", err)
			// Proceed to fetch from DB below
		} else {
			s.logger.Debug("Product fetched from cache", "id", id)
			return &product, nil
		}
	} else if !errors.Is(err, redis.Nil) {
		// Some other Redis error occurred
		s.logger.Error("Redis error fetching product by ID", "key", cacheKey, "error", err)
		// Proceed to fetch from DB below
	}
	// If err was redis.Nil (cache miss) or unmarshalling failed, fetch from DB
	// ---

	s.logger.Debug("Product cache miss, fetching from database", "id", id)

	// Fetch from database using the existing query
	// Assuming you have a query like db.GetProductWithDiscountInfoRow(id)
	dbProduct, err := s.querier.GetProductWithDiscountInfo(ctx, id) // Use the actual query name
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("product not found")
		}
		return nil, fmt.Errorf("failed to fetch product from database: %w", err)
	}

	// Map the database product (with discount info) to the application model
	product := s.toProductModelWithDiscount(dbProduct) // Use the actual mapping function name

	// --- Store the result in cache ---
	productJSON, err := json.Marshal(product)
	if err != nil {
		s.logger.Error("Failed to marshal product for caching", "id", id, "error", err)
		// Still return the product fetched from the DB
	} else {
		// Cache for 30 minutes (adjust TTL as needed)
		if err := s.cache.Set(ctx, cacheKey, productJSON, ProductCacheTTL).Err(); err != nil {
			s.logger.Error("Failed to cache product", "key", cacheKey, "error", err)
		} else {
			s.logger.Debug("Product cached", "id", id, "key", cacheKey)
		}
	}

	return product, nil
}

// GetProductWithDiscountInfoBySlug retrieves a product by its slug, including calculated discount information, utilizing caching.
func (s *ProductService) GetProductWithDiscountInfoBySlug(ctx context.Context, slug string) (*models.Product, error) {
	cacheKey := fmt.Sprintf(CacheKeyProductBySlug, slug)

	// --- Try to get from cache first ---
	cachedData, err := s.cache.Get(ctx, cacheKey).Result()
	if err == nil {
		// Cache hit - deserialize and return
		var product models.Product
		if err := json.Unmarshal([]byte(cachedData), &product); err != nil {
			s.logger.Error("Failed to unmarshal cached product by slug", "key", cacheKey, "error", err)
			// Proceed to fetch from DB below
		} else {
			s.logger.Debug("Product fetched from cache by slug", "slug", slug)
			return &product, nil
		}
	} else if !errors.Is(err, redis.Nil) {
		// Some other Redis error occurred
		s.logger.Error("Redis error fetching product by slug", "key", cacheKey, "error", err)
		// Proceed to fetch from DB below
	}
	// If err was redis.Nil (cache miss) or unmarshalling failed, fetch from DB
	// ---

	s.logger.Debug("Product by slug cache miss, fetching from database", "slug", slug)

	// Fetch from database using the existing query
	// Assuming you have a query like db.GetProductWithDiscountInfoBySlugRow(slug)
	dbProduct, err := s.querier.GetProductWithDiscountInfoBySlug(ctx, slug) // Use the actual query name
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("product not found")
		}
		return nil, fmt.Errorf("failed to fetch product from database: %w", err)
	}

	// Map the database product (with discount info) to the application model
	product := s.toProductModelWithDiscount(db.GetProductWithDiscountInfoRow(dbProduct)) // Pass the row struct directly, not a call to GetProductWithDiscountInfoRow

	// --- Store the result in cache ---
	productJSON, err := json.Marshal(product)
	if err != nil {
		s.logger.Error("Failed to marshal product for caching by slug", "slug", slug, "error", err)
		// Still return the product fetched from the DB
	} else {
		// Cache for 30 minutes (adjust TTL as needed)
		if err := s.cache.Set(ctx, cacheKey, productJSON, ProductCacheTTL).Err(); err != nil {
			s.logger.Error("Failed to cache product by slug", "key", cacheKey, "error", err)
		} else {
			s.logger.Debug("Product cached by slug", "slug", slug, "key", cacheKey)
		}
	}

	return product, nil
}

// Add a method that uses the basic ListProducts function (without search)
func (s *ProductService) ListAllProducts(ctx context.Context, page, limit int) (*models.PaginatedResponse, error) {
	if limit == 0 {
		limit = 20
	}
	if page == 0 {
		page = 1
	}
	offset := (page - 1) * limit
	dbProducts, err := s.querier.GetProductsWithDiscountInfo(ctx, db.GetProductsWithDiscountInfoParams{
		Limit:  int32(limit),
		Offset: int32(offset),
	})
	if err != nil {
		return nil, err
	}

	// Get total count using a separate count query
	total, err := s.countAllProducts(ctx)
	if err != nil {
		return nil, err
	}
	slog.Info("the total number of products is", "total", total)
	result := make([]*models.Product, len(dbProducts))
	for i, p := range dbProducts {
		result[i] = s.toProductModelWithDiscount(db.GetProductWithDiscountInfoRow(p))
	}

	totalPages := int(math.Ceil(float64(total) / float64(limit)))

	return &models.PaginatedResponse{
		Data:       result,
		Page:       page,
		Limit:      limit,
		Total:      total,
		TotalPages: totalPages,
	}, nil
}

// Add a helper method to count all products
func (s *ProductService) countAllProducts(ctx context.Context) (int64, error) {
	// Use the dedicated count query for all products
	count, err := s.querier.CountAllProducts(ctx)
	if err != nil {
		return 0, err
	}

	return count, nil
}

func (s *ProductService) ListProductsByCategory(ctx context.Context, categoryID uuid.UUID, page, limit int) (*models.PaginatedResponse, error) {
	if limit == 0 {
		limit = 20
	}
	if page == 0 {
		page = 1
	}
	offset := (page - 1) * limit

	dbProducts, err := s.querier.ListProductsByCategory(ctx, db.ListProductsByCategoryParams{
		CategoryID: categoryID,
		PageLimit:  int32(limit),
		PageOffset: int32(offset),
	})
	if err != nil {
		return nil, err
	}

	// Count total products in category
	countQuery, err := s.querier.ListProductsByCategory(ctx, db.ListProductsByCategoryParams{
		CategoryID: categoryID,
		PageLimit:  int32(1000000), // Large number to get all
		PageOffset: 0,
	})
	if err != nil {
		return nil, err
	}

	result := make([]*models.Product, len(dbProducts))
	for i, p := range dbProducts {
		result[i] = s.toProductModel(p)
	}

	totalPages := int(math.Ceil(float64(len(countQuery)) / float64(limit)))

	return &models.PaginatedResponse{
		Data:       result,
		Page:       page,
		Limit:      limit,
		Total:      int64(len(countQuery)),
		TotalPages: totalPages,
	}, nil
}

func (s *ProductService) ListCategories(ctx context.Context, page, limit int) ([]*models.Category, error) {
	if limit == 0 {
		limit = 20
	}
	if page == 0 {
		page = 1
	}
	offset := (page - 1) * limit

	dbCategories, err := s.querier.ListCategories(ctx, db.ListCategoriesParams{
		Limit:  20,
		Offset: int32(offset),
	})
	if err != nil {
		return nil, err
	}

	result := make([]*models.Category, len(dbCategories))
	for i, c := range dbCategories {
		result[i] = s.toCategoryModel(c)
	}

	return result, nil
}

// UpdateProduct updates an existing product and invalidates its cache entries.
func (s *ProductService) UpdateProduct(ctx context.Context, id uuid.UUID, req models.UpdateProductRequest) (*models.Product, error) {
	// Fetch the *existing* product to get its current values (including slug) for potential cache invalidation
	existingDbProduct, err := s.querier.GetProduct(ctx, id)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("product not found")
		}
		return nil, fmt.Errorf("failed to fetch existing product for cache invalidation: %w", err)
	}

	// --- Perform the actual update logic (keeping existing validation and parameter preparation) ---
	var finalImageUrls []string
	if req.ImageUrls != nil {
		finalImageUrls = *req.ImageUrls
	} else {
		if err := json.Unmarshal(existingDbProduct.ImageUrls, &finalImageUrls); err != nil {
			return nil, fmt.Errorf("failed to unmarshal existing image URLs: %w", err)
		}
	}

	params, err := prepareUpdateProductParams(existingDbProduct, req, finalImageUrls)
	if err != nil {
		return nil, fmt.Errorf("failed to prepare update parameters: %w", err)
	}

	if req.CategoryID != nil {
		_, err := s.querier.GetCategory(ctx, *req.CategoryID)
		if err != nil {
			if errors.Is(err, pgx.ErrNoRows) {
				return nil, errors.New("category not found")
			}
			return nil, err
		}
	}

	// If Name is being updated, generate a new slug
	if req.Name != nil && *req.Name != existingDbProduct.Name { // Check if name actually changed
		newBaseSlug := utils.GenerateSlug(*req.Name)
		newFinalSlug := s.ensureUniqueSlug(ctx, newBaseSlug) // Use the helper again
		params.Slug = newFinalSlug                           // Update the slug in params
	} else {
		// If name didn't change, keep the existing slug
		params.Slug = existingDbProduct.Slug
	}

	updatedDbProduct, err := s.querier.UpdateProduct(ctx, params)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("product not found") // Should ideally not happen if GetProduct succeeded
		}
		if strings.Contains(err.Error(), "duplicate key value violates unique constraint") {
			if strings.Contains(err.Error(), "slug") {
				return nil, errors.New("product slug already exists")
			}
		}
		return nil, fmt.Errorf("failed to update product in database: %w", err)
	}

	updatedProduct := s.toProductModel(updatedDbProduct)

	// --- Invalidate Cache Entries ---
	// Invalidate the entry for the product ID
	cacheKeyByID := fmt.Sprintf(CacheKeyProductByID, id.String())
	if err := s.cache.Del(ctx, cacheKeyByID).Err(); err != nil {
		s.logger.Error("Failed to invalidate product cache by ID on update", "key", cacheKeyByID, "error", err)
	} else {
		s.logger.Debug("Product cache invalidated by ID on update", "id", id, "key", cacheKeyByID)
	}

	// Invalidate the entry for the OLD slug if it changed
	oldSlug := existingDbProduct.Slug
	newSlug := updatedProduct.Slug // Get the new slug from the *updated* product model
	if oldSlug != newSlug {
		cacheKeyByOldSlug := fmt.Sprintf(CacheKeyProductBySlug, oldSlug)
		if err := s.cache.Del(ctx, cacheKeyByOldSlug).Err(); err != nil {
			s.logger.Error("Failed to invalidate product cache by old slug on update", "slug", oldSlug, "key", cacheKeyByOldSlug, "error", err)
		} else {
			s.logger.Debug("Product cache invalidated by old slug on update", "slug", oldSlug, "key", cacheKeyByOldSlug)
		}
	}

	// Always invalidate the entry for the NEW slug (in case it's used elsewhere or if slug didn't change)
	cacheKeyByNewSlug := fmt.Sprintf(CacheKeyProductBySlug, newSlug)
	if err := s.cache.Del(ctx, cacheKeyByNewSlug).Err(); err != nil {
		s.logger.Error("Failed to invalidate product cache by new slug on update", "slug", newSlug, "key", cacheKeyByNewSlug, "error", err)
	} else {
		s.logger.Debug("Product cache invalidated by new slug on update", "slug", newSlug, "key", cacheKeyByNewSlug)
	}
	// ---

	return updatedProduct, nil
}

// UpdateProductWithUpload updates a product, replacing its images if new ones are provided.
// It also cleans up the old images from storage after the update succeeds.
func (s *ProductService) UpdateProductWithUpload(ctx context.Context, productID uuid.UUID, req models.UpdateProductRequest, imageFileHeaders []*multipart.FileHeader,
) (*models.Product, error) {
	// Step 1: Fetch the existing product to get its current image URLs for potential cleanup
	// Also get the old slug for cache invalidation
	existingDbProduct, err := s.querier.GetProduct(ctx, productID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("product not found")
		}
		return nil, fmt.Errorf("failed to get existing product: %w", err)
	}

	// Store the old slug for cache invalidation later
	oldSlug := existingDbProduct.Slug

	// Step 2: Determine the final image URLs based on input
	var finalImageUrls []string
	var uploadedUrlsForCleanup []string // Track newly uploaded URLs in case DB update fails

	if len(imageFileHeaders) > 0 {
		// If new files are provided, REPLACE ALL existing images with the new ones ("Replace All" strategy).
		for _, fileHeader := range imageFileHeaders {
			file, err := fileHeader.Open()
			if err != nil {
				return nil, fmt.Errorf("failed to open uploaded file %s: %w", fileHeader.Filename, err)
			}

			url, err := s.storer.UploadFile(file, fileHeader)
			file.Close() // Ensure file is closed after processing
			if err != nil {
				return nil, fmt.Errorf("failed to upload image %s: %w", fileHeader.Filename, err)
			}
			finalImageUrls = append(finalImageUrls, url)
			uploadedUrlsForCleanup = append(uploadedUrlsForCleanup, url) // Track for potential cleanup if DB fails
		}
	} else {
		// If no new files, keep the existing ones
		if err := json.Unmarshal(existingDbProduct.ImageUrls, &finalImageUrls); err != nil {
			return nil, fmt.Errorf("failed to unmarshal existing image URLs: %w", err)
		}
	}

	// Step 3: Prepare parameters for the database update
	params, err := prepareUpdateProductParams(existingDbProduct, req, finalImageUrls)
	if err != nil {
		// If parameters preparation failed, and we uploaded files, consider cleaning them up
		// (though unlikely unless spec highlight marshalling fails)
		// For now, let's assume prepareUpdateProductParams doesn't fail due to file issues.
		return nil, fmt.Errorf("failed to prepare update parameters: %w", err)
	}

	// Handle category validation if needed
	if req.CategoryID != nil {
		_, err := s.querier.GetCategory(ctx, *req.CategoryID)
		if err != nil {
			if errors.Is(err, pgx.ErrNoRows) {
				return nil, errors.New("category not found")
			}
			return nil, err
		}
	}

	// Handle slug generation if name changed
	if req.Name != nil && *req.Name != existingDbProduct.Name {
		newBaseSlug := utils.GenerateSlug(*req.Name)
		newFinalSlug := s.ensureUniqueSlug(ctx, newBaseSlug)
		params.Slug = newFinalSlug
	} else {
		params.Slug = existingDbProduct.Slug
	}

	// Step 4: Perform the database update
	updatedDbProduct, err := s.querier.UpdateProduct(ctx, params)
	if err != nil {
		// DB update failed. Clean up any newly uploaded files.
		if len(uploadedUrlsForCleanup) > 0 {
			slog.Warn("Cleaning up uploaded files after DB update failure", "product_id", productID, "urls", uploadedUrlsForCleanup)
			for _, url := range uploadedUrlsForCleanup {
				if delErr := s.storer.DeleteFile(url); delErr != nil {
					slog.Error("Failed to clean up uploaded file after DB failure", "url", url, "error", delErr)
					// Log error but don't return it, as the original DB error is more important
				}
			}
		}
		// Handle potential DB constraint errors (e.g., unique slug violation)
		if strings.Contains(err.Error(), "duplicate key value violates unique constraint") && strings.Contains(err.Error(), "slug") {
			return nil, errors.New("product slug already exists")
		}
		return nil, fmt.Errorf("failed to update product in database: %w", err)
	}

	// Step 5: DB update succeeded. Now, delete the OLD images that are no longer referenced.
	// Unmarshal the old image URLs from the existing product record.
	var oldImageUrls []string
	if err := json.Unmarshal(existingDbProduct.ImageUrls, &oldImageUrls); err != nil {
		// Log the error but continue, as the product update itself was successful.
		slog.Error("Failed to unmarshal old image URLs for cleanup after successful update", "product_id", productID, "error", err)
		// Do NOT return here, the product update is complete.
	} else {
		// Iterate through old URLs and delete them using the storer, skipping those still in the new list.
		for _, oldUrl := range oldImageUrls {
			// Use slices.Contains to check if the old URL is in the new list.
			if !slices.Contains(finalImageUrls, oldUrl) {
				if err := s.storer.DeleteFile(oldUrl); err != nil {
					slog.Error("Failed to delete old image file during update", "url", oldUrl, "product_id", productID, "error", err)
				} else {
					slog.Debug("Deleted old image file during product update", "url", oldUrl, "product_id", productID)
				}
			} else {
				slog.Debug("Keeping image file during product update (still referenced)", "url", oldUrl, "product_id", productID)
			}
		}
	}

	// Step 6: Return the updated product model
	updatedProduct := s.toProductModel(updatedDbProduct)

	// --- CACHE INVALIDATION (Added) ---
	// Invalidate the entry for the product ID
	cacheKeyByID := fmt.Sprintf(CacheKeyProductByID, productID.String())
	if err := s.cache.Del(ctx, cacheKeyByID).Err(); err != nil {
		s.logger.Error("Failed to invalidate product cache by ID on update with upload", "key", cacheKeyByID, "error", err)
	} else {
		s.logger.Debug("Product cache invalidated by ID on update with upload", "id", productID, "key", cacheKeyByID)
	}

	// Get the new slug from the updated product model
	newSlug := updatedProduct.Slug

	// Invalidate the entry for the OLD slug if it changed
	if oldSlug != newSlug {
		cacheKeyByOldSlug := fmt.Sprintf(CacheKeyProductBySlug, oldSlug)
		if err := s.cache.Del(ctx, cacheKeyByOldSlug).Err(); err != nil {
			s.logger.Error("Failed to invalidate product cache by old slug on update with upload", "slug", oldSlug, "key", cacheKeyByOldSlug, "error", err)
		} else {
			s.logger.Debug("Product cache invalidated by old slug on update with upload", "slug", oldSlug, "key", cacheKeyByOldSlug)
		}
	}

	// Always invalidate the entry for the NEW slug (in case it's used elsewhere or if slug didn't change)
	cacheKeyByNewSlug := fmt.Sprintf(CacheKeyProductBySlug, newSlug)
	if err := s.cache.Del(ctx, cacheKeyByNewSlug).Err(); err != nil {
		s.logger.Error("Failed to invalidate product cache by new slug on update with upload", "slug", newSlug, "key", cacheKeyByNewSlug, "error", err)
	} else {
		s.logger.Debug("Product cache invalidated by new slug on update with upload", "slug", newSlug, "key", cacheKeyByNewSlug)
	}
	// ---

	return updatedProduct, nil
}

func coalesceUUIDPtr(newVal *uuid.UUID, existingVal uuid.UUID) uuid.UUID {
	if newVal != nil {
		return *newVal
	}
	return existingVal
}

func coalesceString(newVal *string, existingVal string) string {
	if newVal != nil {
		return *newVal
	}
	return existingVal
}

func coalesceStringPtr(newVal *string, existingVal *string) *string {
	if newVal != nil {
		return newVal
	}
	return existingVal
}

func coalesceInt64(newVal *int64, existingVal int64) int64 {
	if newVal != nil {
		return *newVal
	}
	return existingVal
}
func coalesceInt32(newVal *int, existingVal int32) int32 {
	if newVal != nil {
		return int32(*newVal)
	}
	return existingVal
}

// DeleteProduct soft-deletes a product and cleans up its associated image files.
// It also invalidates the product's cache entries.
func (s *ProductService) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	// Step 1: Fetch the existing product *before* deletion to get its slug for cache invalidation.
	existingDbProduct, err := s.querier.GetProduct(ctx, id)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return errors.New("product not found")
		}
		return fmt.Errorf("failed to get product for deletion/cleanup/cache invalidation: %w", err)
	}

	// Step 2: Perform the soft-delete in the database.
	err = s.querier.DeleteProduct(ctx, id)
	if err != nil {
		return err // Return DB error directly if deletion fails
	}

	// Step 3: DB deletion succeeded. Now, delete the associated image files.
	var imageUrlsToDelete []string
	if err := json.Unmarshal(existingDbProduct.ImageUrls, &imageUrlsToDelete); err != nil {
		// Log the error but continue, as the product deletion itself was successful.
		slog.Error("Failed to unmarshal image URLs for cleanup after successful deletion", "product_id", id, "error", err)
		// Do NOT return here, the product deletion is complete.
	} else {
		// Iterate through the URLs and delete them using the storer.
		for _, url := range imageUrlsToDelete {
			if err := s.storer.DeleteFile(url); err != nil {
				slog.Error("Failed to delete image file during product deletion", "url", url, "product_id", id, "error", err)
				// Log error but don't return it, as the product deletion itself was successful.
			} else {
				slog.Debug("Deleted image file during product deletion", "url", url, "product_id", id)
			}
		}
	}

	// --- Invalidate Cache Entries ---
	// Invalidate the entry for the product ID
	cacheKeyByID := fmt.Sprintf(CacheKeyProductByID, id.String())
	if err := s.cache.Del(ctx, cacheKeyByID).Err(); err != nil {
		s.logger.Error("Failed to invalidate product cache by ID on delete", "key", cacheKeyByID, "error", err)
	} else {
		s.logger.Debug("Product cache invalidated by ID on delete", "id", id, "key", cacheKeyByID)
	}

	// Invalidate the entry for the product slug
	cacheKeyBySlug := fmt.Sprintf(CacheKeyProductBySlug, existingDbProduct.Slug)
	if err := s.cache.Del(ctx, cacheKeyBySlug).Err(); err != nil {
		s.logger.Error("Failed to invalidate product cache by slug on delete", "slug", existingDbProduct.Slug, "key", cacheKeyBySlug, "error", err)
	} else {
		s.logger.Debug("Product cache invalidated by slug on delete", "slug", existingDbProduct.Slug, "key", cacheKeyBySlug)
	}
	// ---

	return nil
}

func (s *ProductService) SearchProducts(ctx context.Context, filter models.ProductFilter, specFilterKey, specFilterValue string) (*models.PaginatedResponse, error) {
	limit := filter.Limit
	if limit == 0 {
		limit = 20
	}
	page := filter.Page
	if page == 0 {
		page = 1
	}
	offset := (page - 1) * limit

	// Handle nullable parameters - use zero values when not provided
	categoryID := uuid.Nil
	if filter.CategoryID != uuid.Nil {
		categoryID = filter.CategoryID
	}

	minPrice := int64(0)
	if filter.MinPrice != nil {
		minPrice = *filter.MinPrice
	}

	maxPrice := int64(0)
	if filter.MaxPrice != nil {
		maxPrice = *filter.MaxPrice
	}

	inStockOnly := false
	if filter.InStockOnly != nil {
		inStockOnly = *filter.InStockOnly
	}
	includeDiscountedOnly := false
	if filter.IncludeDiscountedOnly != nil {
		includeDiscountedOnly = *filter.IncludeDiscountedOnly
	}
	specFilter := ""
	if filter.SpecFilter != nil {
		specFilter = *filter.SpecFilter
	}

	applySpecFilter := specFilter != ""

	// Use the existing SearchProducts query
	dbProducts, err := s.querier.SearchProductsWithDiscounts(ctx, db.SearchProductsWithDiscountsParams{
		Query:                 filter.Query,
		CategoryID:            categoryID,
		Brand:                 filter.Brand,
		MinPrice:              minPrice,
		MaxPrice:              maxPrice,
		IncludeDiscountedOnly: includeDiscountedOnly,
		InStockOnly:           inStockOnly,
		ApplySpecFilter:       applySpecFilter,
		SpecFilterKey:         specFilterKey,
		SpecFilterValue:       &specFilterValue,
		PageLimit:             int32(limit),
		PageOffset:            int32(offset),
	})
	if err != nil {
		return nil, err
	}

	// Get total count for pagination using CountProducts with same filters
	total, err := s.countSearchProducts(ctx, filter, specFilterKey, specFilterValue)
	if err != nil {
		return nil, err
	}

	result := make([]*models.Product, len(dbProducts))
	for i, p := range dbProducts {
		result[i] = s.toProductModelWithDiscount(db.GetProductWithDiscountInfoRow(p))
	}

	totalPages := int(math.Ceil(float64(total) / float64(limit)))

	return &models.PaginatedResponse{
		Data:       result,
		Page:       page,
		Limit:      limit,
		Total:      total,
		TotalPages: totalPages,
	}, nil
}

// Helper method to count search results
func (s *ProductService) countSearchProducts(ctx context.Context, filter models.ProductFilter, specFilterKey, SpecFilterValue string) (int64, error) {
	// Handle nullable parameters - use zero values when not provided
	categoryID := uuid.Nil
	if filter.CategoryID != uuid.Nil {
		categoryID = filter.CategoryID
	}

	minPrice := int64(0)
	if filter.MinPrice != nil {
		minPrice = *filter.MinPrice
	}

	maxPrice := int64(0)
	if filter.MaxPrice != nil {
		maxPrice = *filter.MaxPrice
	}

	inStockOnly := false
	if filter.InStockOnly != nil {
		inStockOnly = *filter.InStockOnly
	}
	includeDiscountedOnly := false
	if filter.IncludeDiscountedOnly != nil {
		includeDiscountedOnly = *filter.IncludeDiscountedOnly
	}

	specFilter := ""
	if filter.SpecFilter != nil {
		specFilter = *filter.SpecFilter
	}

	applySpecFilter := specFilter != ""

	count, err := s.querier.CountProducts(ctx, db.CountProductsParams{
		Query:                 filter.Query,
		CategoryID:            categoryID,
		Brand:                 filter.Brand,
		MinPrice:              minPrice,
		MaxPrice:              maxPrice,
		InStockOnly:           inStockOnly,
		IncludeDiscountedOnly: includeDiscountedOnly,
		ApplySpecFilter:       applySpecFilter,
		SpecFilterKey:         specFilterKey,
		SpecFilterValue:       &SpecFilterValue,
	})
	if err != nil {
		return 0, err
	}

	return count, nil
}

func (s *ProductService) GetCategoryByID(ctx context.Context, id uuid.UUID) (*models.Category, error) {
	dbCategory, err := s.querier.GetCategory(ctx, id)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("category not found")
		}
		return nil, err
	}

	return s.toCategoryModel(dbCategory), nil
}

func (s *ProductService) GetCategoryBySlug(ctx context.Context, slug string) (*models.Category, error) {
	dbCategory, err := s.querier.GetCategoryBySlug(ctx, slug)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("category not found")
		}
		return nil, err
	}

	return s.toCategoryModel(dbCategory), nil
}

// Add the Category model conversion function
func (s *ProductService) toCategoryModel(dbCategory db.Category) *models.Category {
	category := &models.Category{
		ID:        dbCategory.ID, // uuid.UUID
		Name:      dbCategory.Name,
		Slug:      dbCategory.Slug,
		Type:      dbCategory.Type,
		CreatedAt: dbCategory.CreatedAt.Time,
	}

	// Handle nullable ParentID - now correctly as *uuid.UUID
	if dbCategory.ParentID != uuid.Nil {
		category.ParentID = &dbCategory.ParentID
	}

	return category
}

func (s *ProductService) toProductModel(dbProduct db.Product) *models.Product {
	product := &models.Product{
		ID:            dbProduct.ID,
		CategoryID:    dbProduct.CategoryID,
		Name:          dbProduct.Name,
		Slug:          dbProduct.Slug,
		PriceCents:    dbProduct.PriceCents,
		StockQuantity: int(dbProduct.StockQuantity),
		Status:        dbProduct.Status,
		Brand:         dbProduct.Brand,
		CreatedAt:     dbProduct.CreatedAt.Time,
		UpdatedAt:     dbProduct.UpdatedAt.Time,
	}

	// Handle optional fields
	if dbProduct.Description != nil {
		product.Description = dbProduct.Description
	}
	if dbProduct.ShortDescription != nil {
		product.ShortDescription = dbProduct.ShortDescription
	}
	if dbProduct.DeletedAt.Valid {
		deletedAt := dbProduct.DeletedAt.Time
		product.DeletedAt = &deletedAt
	}

	// Unmarshal JSON fields
	var imageUrls []string
	if err := json.Unmarshal(dbProduct.ImageUrls, &imageUrls); err == nil {
		product.ImageURLs = imageUrls
	}

	var specHighlights map[string]any
	if err := json.Unmarshal(dbProduct.SpecHighlights, &specHighlights); err == nil {
		product.SpecHighlights = specHighlights
	}

	return product
}

// toProductModelWithDiscount converts the SQLC-generated GetProductWithDiscountInfoRow to the application model Product.
// This version includes discount information calculated by the view.
func (s *ProductService) toProductModelWithDiscount(dbRow db.GetProductWithDiscountInfoRow) *models.Product {
	product := &models.Product{
		ID:           dbRow.ID,
		CategoryID:   dbRow.CategoryID,
		Name:         dbRow.Name,
		CategoryName: &dbRow.CategoryName,
		Slug:         dbRow.Slug,
		// Use OriginalPriceCents from the query result for the base price in the model
		PriceCents:    dbRow.OriginalPriceCents,
		StockQuantity: int(dbRow.StockQuantity), // Convert int32 to int
		NumRatings:    dbRow.NumRatings,
		Status:        dbRow.Status,
		Brand:         dbRow.Brand,
		CreatedAt:     dbRow.CreatedAt.Time, // Convert pgtype.Timestamptz to time.Time
		UpdatedAt:     dbRow.UpdatedAt.Time, // Convert pgtype.Timestamptz to time.Time
		// Initialize discount fields
		DiscountedPriceCents: &dbRow.DiscountedPriceCents,
		HasActiveDiscount:    dbRow.HasActiveDiscount, // Map boolean directly
		// Map the new breakdown fields from the view
		TotalCalculatedFixedDiscountCents:  &dbRow.VpcdTotalFixedDiscountCents,
		CalculatedCombinedPercentageFactor: &dbRow.VpcdCombinedPercentageFactor,
		// Set single discount details to nil as they are less meaningful with stacking
		DiscountCode:  nil,
		DiscountType:  nil,
		DiscountValue: nil,
	}

	// Calculate EffectiveDiscountPercentage based on Original and Discounted prices
	// Formula: ((OriginalPrice - DiscountedPrice) / OriginalPrice) * 100
	if dbRow.OriginalPriceCents > 0 && dbRow.DiscountedPriceCents < dbRow.OriginalPriceCents {
		original := float64(dbRow.OriginalPriceCents)
		discounted := float64(dbRow.DiscountedPriceCents)
		effectivePct := ((original - discounted) / original) * 100.0
		// Round to a reasonable number of decimal places (e.g., 2)
		effectivePct = math.Round(effectivePct*100) / 100
		product.EffectiveDiscountPercentage = &effectivePct
	}

	avgRating, err := dbRow.AvgRating.Float64Value()
	if err == nil {
		product.AvgRating = avgRating.Float64
	}

	// Handle optional fields from the base product info
	if dbRow.Description != nil {
		product.Description = dbRow.Description
	}
	if dbRow.ShortDescription != nil {
		product.ShortDescription = dbRow.ShortDescription
	}
	if dbRow.DeletedAt.Valid {
		deletedAt := dbRow.DeletedAt.Time // Convert pgtype.Timestamptz to time.Time
		product.DeletedAt = &deletedAt
	}

	// Unmarshal JSON fields (ImageUrls, SpecHighlights are []byte from the query result)
	var imageUrls []string
	if err := json.Unmarshal(dbRow.ImageUrls, &imageUrls); err == nil {
		product.ImageURLs = imageUrls
	} else {
		// Log error or handle failure to unmarshal
		// slog.Warn("Failed to unmarshal ImageUrls", "product_id", dbRow.ID, "error", err)
		product.ImageURLs = []string{} // Fallback to empty slice
	}

	var specHighlights map[string]interface{} // Use interface{} to match models.Product
	if err := json.Unmarshal(dbRow.SpecHighlights, &specHighlights); err == nil {
		product.SpecHighlights = specHighlights
	} else {
		// Log error or handle failure to unmarshal
		// slog.Warn("Failed to unmarshal SpecHighlights", "product_id", dbRow.ID, "error", err)
		product.SpecHighlights = map[string]interface{}{} // Fallback to empty map
	}

	return product
}

func prepareCreateProductParams(categoryID uuid.UUID, name, slug string, description, shortDescription *string, priceCents int64, stockQuantity int32, status, brand string, imageUrlsJSON, specHighlightsJSON []byte) db.CreateProductParams { // Changed description, shortDescription to *string
	params := db.CreateProductParams{
		CategoryID:       categoryID,
		Name:             name,
		Slug:             slug,
		Description:      nil, // Will be set conditionally below
		ShortDescription: nil, // Will be set conditionally below
		PriceCents:       priceCents,
		StockQuantity:    stockQuantity,
		Status:           status,
		Brand:            brand,
		ImageUrls:        imageUrlsJSON,      // Already marshalled JSON bytes
		SpecHighlights:   specHighlightsJSON, // Already marshalled JSON bytes
	}

	// Conditionally set optional fields based on whether the pointers are not nil
	if description != nil {
		params.Description = description
	}
	if shortDescription != nil {
		params.ShortDescription = shortDescription
	}

	return params
}
func prepareUpdateProductParams(
	existingDbProduct db.Product,
	updates models.UpdateProductRequest,
	newImageUrls []string,
) (db.UpdateProductParams, error) {
	imageUrlsJSON, err := json.Marshal(newImageUrls)
	if err != nil {
		return db.UpdateProductParams{}, errors.New("failed to marshal updated image URLs")
	}

	params := db.UpdateProductParams{
		ProductID:        existingDbProduct.ID,
		CategoryID:       coalesceUUIDPtr(updates.CategoryID, existingDbProduct.CategoryID),
		Name:             coalesceString(updates.Name, existingDbProduct.Name),
		Description:      coalesceStringPtr(updates.Description, existingDbProduct.Description),
		ShortDescription: coalesceStringPtr(updates.ShortDescription, existingDbProduct.ShortDescription),
		PriceCents:       coalesceInt64(updates.PriceCents, existingDbProduct.PriceCents),
		StockQuantity:    coalesceInt32(updates.StockQuantity, existingDbProduct.StockQuantity),
		Status:           coalesceString(updates.Status, existingDbProduct.Status),
		Brand:            coalesceString(updates.Brand, existingDbProduct.Brand),
		ImageUrls:        imageUrlsJSON,
		SpecHighlights:   existingDbProduct.SpecHighlights,
	}

	if updates.SpecHighlights != nil {
		newSpecHighlightsJSON, err := json.Marshal(*updates.SpecHighlights)
		if err != nil {
			return params, errors.New("failed to marshal updated spec highlights")
		}
		params.SpecHighlights = newSpecHighlightsJSON
	}

	return params, nil
}

// ensureUniqueSlug generates a unique slug based on the base slug.
// It checks the database and appends a suffix if necessary.
func (s *ProductService) ensureUniqueSlug(ctx context.Context, baseSlug string) string {
	slugToTry := baseSlug
	counter := 0

	for {
		// Check if the slug already exists
		exists, err := s.checkSlugExists(ctx, slugToTry)
		if err != nil {
			slog.Error("Error checking slug existence", "slug", slugToTry, "error", err)
			panic(err) // Or return "", err if you want to handle it upstream
		}

		if !exists {
			return slugToTry // Found a unique slug
		}

		// Slug exists, increment counter and try again
		counter++
		slugToTry = fmt.Sprintf("%s-%d", baseSlug, counter)
	}
}

func (s *ProductService) checkSlugExists(ctx context.Context, slug string) (bool, error) {
	exists, err := s.querier.CheckSlugExists(ctx, slug) // Assumes CheckSlugExists is generated
	if err != nil {
		return false, err
	}
	return exists, nil
}
func calculateDiscountPercentage(originalPrice, finalPrice int64) int64 {
	if originalPrice == 0 {
		return 0 // Avoid division by zero
	}
	discount := ((originalPrice - finalPrice) / originalPrice) * 100
	return discount
}


File: internal/services/discount_service.go
================================================
package services

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"math"
	"time"

	"github.com/MihoZaki/DzTech/internal/db"
	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/redis/go-redis/v9"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

// DiscountService handles business logic for discounts.
type DiscountService struct {
	querier db.Querier
	cache   *redis.Client
	logger  *slog.Logger
}

// NewDiscountService creates a new instance of DiscountService.
func NewDiscountService(querier db.Querier, cache *redis.Client, logger *slog.Logger) *DiscountService {
	return &DiscountService{
		querier: querier,
		cache:   cache,
		logger:  logger,
	}
}

const (
	CacheKeyDiscountByID   = "discount:id:%s"   // Format: discount:id:{uuid_string}
	CacheKeyDiscountByCode = "discount:code:%s" // Format: discount:code:{code_string}
	DiscountCacheTTL       = 1 * time.Hour      // Define TTL for discount cache entries
)

// CreateDiscount creates a new discount rule.
func (s *DiscountService) CreateDiscount(ctx context.Context, req models.CreateDiscountRequest) (*models.Discount, error) {
	// Validate DiscountValue based on DiscountType
	if req.DiscountType == models.DiscountTypePercentage && req.DiscountValue > 100 {
		return nil, errors.New("percentage discount value cannot exceed 100")
	}

	// Check if code already exists
	_, err := s.querier.GetDiscountByCode(ctx, req.Code)
	if err == nil {
	}
	if err != nil && !errors.Is(err, pgx.ErrNoRows) {
		// An unexpected DB error occurred while checking existence
		return nil, fmt.Errorf("failed to check for existing discount code: %w", err)
	}
	// The DB UNIQUE constraint will ultimately enforce global uniqueness.

	// Prepare parameters for the query, converting from models to db types
	params := db.CreateDiscountParams{
		Code:               req.Code,
		Description:        req.Description, // *string maps directly
		DiscountType:       string(req.DiscountType),
		DiscountValue:      req.DiscountValue,
		MinOrderValueCents: req.MinOrderValueCents,          // *int64 maps directly
		MaxUses:            Int32PtrFromIntPtr(req.MaxUses), // Helper to convert *int to *int32
		ValidFrom:          ToPgTimestamptz(req.ValidFrom),  // Helper to convert time.Time to pgtype.Timestamptz
		ValidUntil:         ToPgTimestamptz(req.ValidUntil),
		IsActive:           req.IsActive,
	}

	// Execute the query to create the discount
	dbDiscount, err := s.querier.CreateDiscount(ctx, params)
	if err != nil {
		// Check if the error is due to UNIQUE constraint violation (duplicate code)
		if IsUniqueViolation(err, "discounts_code_key") { // Helper to check error code
			return nil, fmt.Errorf("discount with code '%s' already exists", req.Code)
		}
		return nil, fmt.Errorf("failed to create discount in database: %w", err)
	}

	// Map the created database discount to the application model
	createdDiscount := s.mapDbDiscountToModel(dbDiscount)

	s.logger.Info("Discount created successfully", "discount_id", createdDiscount.ID, "code", createdDiscount.Code)
	return createdDiscount, nil
}

// GetDiscount retrieves a discount by its ID, utilizing caching.
func (s *DiscountService) GetDiscount(ctx context.Context, id uuid.UUID) (*models.Discount, error) {
	cacheKey := fmt.Sprintf(CacheKeyDiscountByID, id.String())

	// --- Try to get from cache first ---
	cachedData, err := s.cache.Get(ctx, cacheKey).Result()
	if err == nil {
		// Cache hit - deserialize and return
		var discount models.Discount
		if err := json.Unmarshal([]byte(cachedData), &discount); err != nil {
			s.logger.Error("Failed to unmarshal cached discount", "key", cacheKey, "error", err)
			// Proceed to fetch from DB below
		} else {
			s.logger.Debug("Discount fetched from cache", "id", id)
			return &discount, nil
		}
	} else if !errors.Is(err, redis.Nil) {
		// Some other Redis error occurred
		s.logger.Error("Redis error fetching discount by ID", "key", cacheKey, "error", err)
		// Proceed to fetch from DB below
	}

	s.logger.Debug("Discount cache miss, fetching from database", "id", id)

	// Fetch from database using the existing query
	dbDiscount, err := s.querier.GetDiscountByID(ctx, id)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("discount not found")
		}
		return nil, fmt.Errorf("failed to fetch discount from database: %w", err)
	}

	// Map the database discount to the application model
	discount := s.mapDbDiscountToModel(dbDiscount)

	// --- Store the result in cache ---
	discountJSON, err := json.Marshal(discount)
	if err != nil {
		s.logger.Error("Failed to marshal discount for caching", "id", id, "error", err)
		// Still return the discount fetched from the DB
	} else {
		// Cache for 1 hour (adjust TTL as needed)
		if err := s.cache.Set(ctx, cacheKey, discountJSON, DiscountCacheTTL).Err(); err != nil {
			s.logger.Error("Failed to cache discount", "key", cacheKey, "error", err)
		} else {
			s.logger.Debug("Discount cached", "id", id, "key", cacheKey)
		}
	}

	return discount, nil
}

// GetDiscountsByProductID retrieves active discounts applicable to a specific product.
func (s *DiscountService) GetDiscountsByProductID(ctx context.Context, productID uuid.UUID) ([]*models.Discount, error) {
	// Execute the query to get discounts for the product ID
	dbDiscounts, err := s.querier.GetDiscountsByProductID(ctx, productID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch discounts for product (ID: %s) from database: %w", productID, err)
	}

	result := make([]*models.Discount, len(dbDiscounts))
	for i, dbDisc := range dbDiscounts {
		result[i] = s.mapDbDiscountToModel(dbDisc)
	}

	return result, nil
}

// UpdateDiscount updates an existing discount rule.
// UpdateDiscount updates an existing discount rule and invalidates its cache.
func (s *DiscountService) UpdateDiscount(ctx context.Context, id uuid.UUID, req models.UpdateDiscountRequest) (*models.Discount, error) {
	// Fetch the existing discount to get its current values (including code) for potential cache invalidation
	existingDBDisc, err := s.querier.GetDiscountByID(ctx, id)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("discount not found")
		}
		return nil, fmt.Errorf("failed to fetch existing discount: %w", err)
	}

	// Prepare update parameters, using existing values if not provided in request
	code := CoalesceString(req.Code, existingDBDisc.Code)
	// ... (prepare other parameters like description, discountType, etc., as before) ...
	description := CoalesceStringPtr(req.Description, existingDBDisc.Description)
	discountTypeStr := CoalesceString((*string)(req.DiscountType), existingDBDisc.DiscountType)
	discountValue := CoalesceInt64(req.DiscountValue, existingDBDisc.DiscountValue)
	minOrderValueCents := CoalesceInt64Ptr(req.MinOrderValueCents, existingDBDisc.MinOrderValueCents)
	maxUses := CoalesceInt32Ptr(Int32PtrFromIntPtr(req.MaxUses), existingDBDisc.MaxUses)
	validFrom := CoalesceTime(req.ValidFrom, existingDBDisc.ValidFrom.Time)
	validUntil := CoalesceTime(req.ValidUntil, existingDBDisc.ValidUntil.Time)
	isActive := CoalesceBool(req.IsActive, existingDBDisc.IsActive)

	// Validate DiscountValue based on DiscountType if it's being updated
	currentType := models.DiscountType(discountTypeStr)
	if req.DiscountType != nil || req.DiscountValue != nil {
		newValue := discountValue
		if req.DiscountType != nil {
			currentType = *req.DiscountType
		}
		if currentType == models.DiscountTypePercentage && newValue > 100 {
			return nil, errors.New("percentage discount value cannot exceed 100")
		}
	}

	// Check if the new code (if being updated) already exists for a *different* discount
	if req.Code != nil && *req.Code != existingDBDisc.Code {
		_, err := s.querier.GetDiscountByCode(ctx, *req.Code)
		if err == nil {
			return nil, fmt.Errorf("discount with code '%s' already exists", *req.Code)
		}
		if err != nil && !errors.Is(err, pgx.ErrNoRows) {
			return nil, fmt.Errorf("failed to check for existing discount code: %w", err)
		}
		// If err is pgx.ErrNoRows, it means the new code is unique, proceed.
	}

	// Prepare the query parameters
	params := db.UpdateDiscountParams{
		ID:                 id,
		Code:               code,
		Description:        description,
		DiscountType:       discountTypeStr,
		DiscountValue:      discountValue,
		MinOrderValueCents: minOrderValueCents,
		MaxUses:            maxUses,
		ValidFrom:          ToPgTimestamptz(validFrom),
		ValidUntil:         ToPgTimestamptz(validUntil),
		IsActive:           isActive,
	}

	// Execute the update query
	updatedDBDisc, err := s.querier.UpdateDiscount(ctx, params)
	if err != nil {
		if IsUniqueViolation(err, "discounts_code_key") {
			return nil, fmt.Errorf("discount with code '%s' already exists", params.Code)
		}
		return nil, fmt.Errorf("failed to update discount in database: %w", err)
	}

	// Map the updated database discount to the application model
	updatedDiscount := s.mapDbDiscountToModel(updatedDBDisc)

	// --- Invalidate Cache Entries ---
	// Invalidate the entry for the discount ID
	cacheKeyByID := fmt.Sprintf(CacheKeyDiscountByID, id.String())
	if err := s.cache.Del(ctx, cacheKeyByID).Err(); err != nil {
		s.logger.Error("Failed to invalidate discount cache by ID", "key", cacheKeyByID, "error", err)
	} else {
		s.logger.Debug("Discount cache invalidated by ID", "id", id, "key", cacheKeyByID)
	}

	// Invalidate the entry for the OLD code if it changed
	oldCode := existingDBDisc.Code
	newCode := updatedDiscount.Code
	if oldCode != newCode {
		cacheKeyByOldCode := fmt.Sprintf(CacheKeyDiscountByCode, oldCode)
		if err := s.cache.Del(ctx, cacheKeyByOldCode).Err(); err != nil {
			s.logger.Error("Failed to invalidate discount cache by old code", "code", oldCode, "key", cacheKeyByOldCode, "error", err)
		} else {
			s.logger.Debug("Discount cache invalidated by old code", "code", oldCode, "key", cacheKeyByOldCode)
		}
	}

	// Always invalidate the entry for the NEW code (in case it's used elsewhere or if code didn't change)
	cacheKeyByNewCode := fmt.Sprintf(CacheKeyDiscountByCode, newCode)
	if err := s.cache.Del(ctx, cacheKeyByNewCode).Err(); err != nil {
		s.logger.Error("Failed to invalidate discount cache by new code", "code", newCode, "key", cacheKeyByNewCode, "error", err)
	} else {
		s.logger.Debug("Discount cache invalidated by new code", "code", newCode, "key", cacheKeyByNewCode)
	}
	// ---

	s.logger.Info("Discount updated successfully", "discount_id", updatedDiscount.ID, "code", updatedDiscount.Code)
	return updatedDiscount, nil
}

// DeleteDiscount deletes a discount by its ID and invalidates its cache.
func (s *DiscountService) DeleteDiscount(ctx context.Context, id uuid.UUID) error {
	// Fetch the discount first to get its code for cache invalidation
	dbDiscount, err := s.querier.GetDiscountByID(ctx, id)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return errors.New("discount not found")
		}
		return fmt.Errorf("failed to fetch discount for cache invalidation: %w", err)
	}

	// Execute the delete query
	err = s.querier.DeleteDiscount(ctx, id)
	if err != nil {
		return fmt.Errorf("failed to delete discount from database: %w", err)
	}

	// --- Invalidate Cache Entries ---
	// Invalidate the entry for the discount ID
	cacheKeyByID := fmt.Sprintf(CacheKeyDiscountByID, id.String())
	if err := s.cache.Del(ctx, cacheKeyByID).Err(); err != nil {
		s.logger.Error("Failed to invalidate discount cache by ID on delete", "key", cacheKeyByID, "error", err)
	} else {
		s.logger.Debug("Discount cache invalidated by ID on delete", "id", id, "key", cacheKeyByID)
	}

	// Invalidate the entry for the discount code
	cacheKeyByCode := fmt.Sprintf(CacheKeyDiscountByCode, dbDiscount.Code)
	if err := s.cache.Del(ctx, cacheKeyByCode).Err(); err != nil {
		s.logger.Error("Failed to invalidate discount cache by code on delete", "code", dbDiscount.Code, "key", cacheKeyByCode, "error", err)
	} else {
		s.logger.Debug("Discount cache invalidated by code on delete", "code", dbDiscount.Code, "key", cacheKeyByCode)
	}
	// ---

	s.logger.Info("Discount deleted successfully", "discount_id", id, "code", dbDiscount.Code)
	return nil
}

// GetDiscountByCode retrieves a discount by its unique code, utilizing caching.
// You would add similar logic here as GetDiscount, but with CacheKeyDiscountByCode.
// This is a placeholder for the concept.
func (s *DiscountService) GetDiscountByCode(ctx context.Context, code string) (*models.Discount, error) {
	cacheKey := fmt.Sprintf(CacheKeyDiscountByCode, code)

	// --- Try to get from cache first ---
	cachedData, err := s.cache.Get(ctx, cacheKey).Result()
	if err == nil {
		// Cache hit - deserialize and return
		var discount models.Discount
		if err := json.Unmarshal([]byte(cachedData), &discount); err != nil {
			s.logger.Error("Failed to unmarshal cached discount by code", "key", cacheKey, "error", err)
			// Proceed to fetch from DB below
		} else {
			s.logger.Debug("Discount fetched from cache by code", "code", code)
			return &discount, nil
		}
	} else if !errors.Is(err, redis.Nil) {
		// Some other Redis error occurred
		s.logger.Error("Redis error fetching discount by code", "key", cacheKey, "error", err)
		// Proceed to fetch from DB below
	}

	s.logger.Debug("Discount by code cache miss, fetching from database", "code", code)

	// Fetch from database using the existing query
	dbDiscount, err := s.querier.GetDiscountByCode(ctx, code)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("discount not found")
		}
		return nil, fmt.Errorf("failed to fetch discount from database: %w", err)
	}

	// Map the database discount to the application model
	discount := s.mapDbDiscountToModel(dbDiscount)

	// --- Store the result in cache ---
	discountJSON, err := json.Marshal(discount)
	if err != nil {
		s.logger.Error("Failed to marshal discount for caching by code", "code", code, "error", err)
		// Still return the discount fetched from the DB
	} else {
		// Cache for 1 hour (adjust TTL as needed)
		if err := s.cache.Set(ctx, cacheKey, discountJSON, DiscountCacheTTL).Err(); err != nil {
			s.logger.Error("Failed to cache discount by code", "key", cacheKey, "error", err)
		} else {
			s.logger.Debug("Discount cached by code", "code", code, "key", cacheKey)
		}
	}

	return discount, nil
}

// ListDiscounts retrieves a paginated list of discounts based on filters.
func (s *DiscountService) ListDiscounts(ctx context.Context, req models.ListDiscountsRequest) (*models.DiscountListResponse, error) {
	page := req.Page
	if page == 0 {
		page = 1
	}
	limit := req.Limit
	if limit == 0 {
		limit = 20
	}
	if limit > 100 {
		limit = 100 // Enforce a maximum limit
	}
	offset := (page - 1) * limit

	// Prepare query parameters for ListDiscounts
	// Use the generated db.ListDiscountsParams which includes IsActive, FromDate, UntilDate, PageOffset, PageLimit
	listParams := db.ListDiscountsParams{
		IsActive:   req.IsActive != nil && *req.IsActive, // Convert *bool to bool for sqlc arg (default false if nil)
		FromDate:   pgtype.Timestamptz{},                 // Initialize pgtype struct
		UntilDate:  pgtype.Timestamptz{},                 // Initialize pgtype struct
		PageOffset: int32(offset),
		PageLimit:  int32(limit),
	}

	// Set FromDate and UntilDate if provided in the request
	if req.ValidFrom != nil {
		listParams.FromDate = ToPgTimestamptz(*req.ValidFrom)
		// Note: The generated ListDiscountsParams struct likely uses pgtype.Timestamptz directly.
		// The ToPgTimestamptz helper ensures Valid=true.
	}
	if req.ValidUntil != nil {
		listParams.UntilDate = ToPgTimestamptz(*req.ValidUntil)
	}

	dbDiscounts, err := s.querier.ListDiscounts(ctx, listParams)
	if err != nil {
		return nil, fmt.Errorf("failed to list discounts from database: %w", err)
	}

	// Map database results to application models
	result := make([]models.Discount, len(dbDiscounts))
	for i, dbDisc := range dbDiscounts {
		result[i] = *s.mapDbDiscountToModel(dbDisc)
	}

	// Get total count for pagination using the new CountDiscounts query
	// Prepare parameters for CountDiscounts, matching the filters used in ListDiscounts
	countParams := db.CountDiscountsParams{
		IsActive:  req.IsActive != nil && *req.IsActive, // Use the same IsActive filter
		FromDate:  pgtype.Timestamptz{},                 // Initialize pgtype struct
		UntilDate: pgtype.Timestamptz{},                 // Initialize pgtype struct
	}

	// Set FromDate and UntilDate for the count query if provided in the request
	if req.ValidFrom != nil {
		countParams.FromDate = ToPgTimestamptz(*req.ValidFrom)
	}
	if req.ValidUntil != nil {
		countParams.UntilDate = ToPgTimestamptz(*req.ValidUntil)
	}

	total, err := s.querier.CountDiscounts(ctx, countParams)
	if err != nil {
		return nil, fmt.Errorf("failed to count discounts for pagination: %w", err)
	}

	totalPages := int(math.Ceil(float64(total) / float64(limit)))

	response := &models.DiscountListResponse{
		Data:       result,
		Page:       page,
		Limit:      limit,
		Total:      total,
		TotalPages: totalPages,
	}

	return response, nil
}

// getCountForList is a helper to get the total count matching ListDiscounts filters.
// This now uses the CountDiscounts query and handles date filters.
func (s *DiscountService) getCountForList(ctx context.Context, req models.ListDiscountsRequest) (int64, error) {
	// Prepare parameters for CountDiscounts, matching the filters used in ListDiscounts
	countParams := db.CountDiscountsParams{
		IsActive:  req.IsActive != nil && *req.IsActive, // Use the same IsActive filter
		FromDate:  pgtype.Timestamptz{},                 // Initialize pgtype struct
		UntilDate: pgtype.Timestamptz{},                 // Initialize pgtype struct
	}

	// Set FromDate and UntilDate for the count query if provided in the request
	if req.ValidFrom != nil {
		countParams.FromDate = ToPgTimestamptz(*req.ValidFrom)
	}
	if req.ValidUntil != nil {
		countParams.UntilDate = ToPgTimestamptz(*req.ValidUntil)
	}

	count, err := s.querier.CountDiscounts(ctx, countParams)
	if err != nil {
		return 0, fmt.Errorf("failed to count discounts: %w", err)
	}
	return count, nil
}

// LinkDiscountToProduct associates a discount with a specific product.
func (s *DiscountService) LinkDiscountToProduct(ctx context.Context, discountID, productID uuid.UUID) error {
	// Validate that the discount exists
	_, err := s.querier.GetDiscountByID(ctx, discountID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return errors.New("discount not found")
		}
		return fmt.Errorf("failed to verify discount: %w", err)
	}

	// Execute the link query
	err = s.querier.LinkProductToDiscount(ctx, db.LinkProductToDiscountParams{
		ProductID:  productID,
		DiscountID: discountID,
	})
	if err != nil {
		// Check for unique violation if linking fails due to existing link
		if IsUniqueViolation(err, "product_discounts_product_id_discount_id_key") {
			return fmt.Errorf("discount %s is already linked to product %s", discountID, productID)
		}
		return fmt.Errorf("failed to link discount to product: %w", err)
	}

	// --- Invalidate Product Cache ---
	// The product's discount status has changed, so its cache entry is stale.
	productCacheKeyByID := fmt.Sprintf(CacheKeyProductByID, productID.String())
	if err := s.cache.Del(ctx, productCacheKeyByID).Err(); err != nil {
		s.logger.Error("Failed to invalidate product cache by ID after linking discount", "product_id", productID, "discount_id", discountID, "key", productCacheKeyByID, "error", err)
	} else {
		s.logger.Debug("Product cache invalidated by ID after linking discount", "product_id", productID, "discount_id", discountID, "key", productCacheKeyByID)
	}

	s.logger.Info("Discount linked to product", "discount_id", discountID, "product_id", productID)
	return nil
}

// UnlinkDiscountFromProduct removes the association between a discount and a specific product.
func (s *DiscountService) UnlinkDiscountFromProduct(ctx context.Context, discountID, productID uuid.UUID) error {
	// Execute the unlink query
	err := s.querier.UnlinkProductFromDiscount(ctx, db.UnlinkProductFromDiscountParams{
		ProductID:  productID,
		DiscountID: discountID,
	})
	if err != nil {
		return fmt.Errorf("failed to unlink discount from product: %w", err)
	}

	// --- Invalidate Product Cache ---
	// The product's discount status has changed, so its cache entry is stale.
	productCacheKeyByID := fmt.Sprintf(CacheKeyProductByID, productID.String())
	if err := s.cache.Del(ctx, productCacheKeyByID).Err(); err != nil {
		s.logger.Error("Failed to invalidate product cache by ID after unlinking discount", "product_id", productID, "discount_id", discountID, "key", productCacheKeyByID, "error", err)
	} else {
		s.logger.Debug("Product cache invalidated by ID after unlinking discount", "product_id", productID, "discount_id", discountID, "key", productCacheKeyByID)
	}
	s.logger.Info("Discount unlinked from product", "discount_id", discountID, "product_id", productID)
	return nil
}

// LinkDiscountToCategory associates a discount with a specific category.
func (s *DiscountService) LinkDiscountToCategory(ctx context.Context, discountID, categoryID uuid.UUID) error {
	// Validate that the discount exists
	_, err := s.querier.GetDiscountByID(ctx, discountID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return errors.New("discount not found")
		}
		return fmt.Errorf("failed to verify discount: %w", err)
	}

	// Validate that the category exists (you'd need a category query/service method)
	// Example: _, err = s.categoryService.GetCategory(ctx, categoryID)
	// if err != nil { return fmt.Errorf("failed to verify category: %w", err) }

	// Execute the link query
	err = s.querier.LinkCategoryToDiscount(ctx, db.LinkCategoryToDiscountParams{
		CategoryID: categoryID,
		DiscountID: discountID,
	})
	if err != nil {
		// Check for unique violation if linking fails due to existing link
		if IsUniqueViolation(err, "category_discounts_category_id_discount_id_key") {
			return fmt.Errorf("discount %s is already linked to category %s", discountID, categoryID)
		}
		return fmt.Errorf("failed to link discount to category: %w", err)
	}

	s.logger.Info("Discount linked to category", "discount_id", discountID, "category_id", categoryID)
	return nil
}

// UnlinkDiscountFromCategory removes the association between a discount and a specific category.
func (s *DiscountService) UnlinkDiscountFromCategory(ctx context.Context, discountID, categoryID uuid.UUID) error {
	// Execute the unlink query
	err := s.querier.UnlinkCategoryFromDiscount(ctx, db.UnlinkCategoryFromDiscountParams{
		CategoryID: categoryID,
		DiscountID: discountID,
	})
	if err != nil {
		return fmt.Errorf("failed to unlink discount from category: %w", err)
	}

	s.logger.Info("Discount unlinked from category", "discount_id", discountID, "category_id", categoryID)
	return nil
}

// --- Helper Functions ---

// mapDbDiscountToModel converts the generated db.Discount to the service-level models.Discount.
func (s *DiscountService) mapDbDiscountToModel(dbDisc db.Discount) *models.Discount {
	modelDisc := &models.Discount{
		ID:                 dbDisc.ID,
		Code:               dbDisc.Code,
		DiscountType:       models.DiscountType(dbDisc.DiscountType),
		DiscountValue:      dbDisc.DiscountValue,
		MinOrderValueCents: dbDisc.MinOrderValueCents, // Assumes it's not null based on DB schema default
		CurrentUses:        int(*dbDisc.CurrentUses),  // Assumes it's not null based on DB schema default
		ValidFrom:          dbDisc.ValidFrom.Time,
		ValidUntil:         dbDisc.ValidUntil.Time,
		IsActive:           dbDisc.IsActive,
		CreatedAt:          dbDisc.CreatedAt.Time,
		UpdatedAt:          dbDisc.UpdatedAt.Time,
	}

	// Handle nullable fields
	if dbDisc.Description != nil {
		modelDisc.Description = dbDisc.Description
	}
	if dbDisc.MaxUses != nil {
		maxUses := int(*dbDisc.MaxUses)
		modelDisc.MaxUses = &maxUses
	}

	return modelDisc
}

// ToPgTimestamptz converts time.Time to pgtype.Timestamptz with Valid=true.
func ToPgTimestamptz(t time.Time) pgtype.Timestamptz {
	return pgtype.Timestamptz{Time: t, Valid: true}
}

// Int32PtrFromIntPtr converts *int to *int32.
func Int32PtrFromIntPtr(i *int) *int32 {
	if i == nil {
		return nil
	}
	val := int32(*i)
	return &val
}

// Coalesce functions to pick the first non-nil value or a default
func CoalesceString(a *string, b string) string {
	if a != nil {
		return *a
	}
	return b
}

func CoalesceStringPtr(a *string, b *string) *string {
	if a != nil {
		return a
	}
	return b
}

func CoalesceInt64(a *int64, b int64) int64 {
	if a != nil {
		return *a
	}
	return b
}

func CoalesceInt64Ptr(a *int64, b *int64) *int64 {
	if a != nil {
		return a
	}
	return b
}

func CoalesceInt32Ptr(a *int32, b *int32) *int32 {
	if a != nil {
		return a
	}
	return b
}

func CoalesceTime(a *time.Time, b time.Time) time.Time {
	if a != nil {
		return *a
	}
	return b
}

func CoalesceBool(a *bool, b bool) bool {
	if a != nil {
		return *a
	}
	return b
}

func IsUniqueViolation(err error, constraintName string) bool {
	var pgErr *pgconn.PgError
	if errors.As(err, &pgErr) {
		// Check for unique_violation code and specific constraint name
		return pgErr.Code == "23505" && pgErr.ConstraintName == constraintName
	}
	return false
}


File: migrations/00012_create_password_reset_token_table.sql
================================================
-- +goose Up
-- +goose StatementBegin
CREATE TABLE password_reset_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    token VARCHAR(255) UNIQUE NOT NULL, -- The reset token string
    expires_at TIMESTAMPTZ NOT NULL, -- When the token expires
    created_at TIMESTAMPTZ DEFAULT NOW()
);
-- +goose StatementEnd

-- +goose Down
-- +goose StatementBegin
DROP TABLE IF EXISTS password_reset_tokens;
-- +goose StatementEnd


File: migrations/00004_create_cart_table.sql
================================================
-- +goose Up
CREATE TABLE carts (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    session_id TEXT, -- For guest users
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    CONSTRAINT user_or_session_id CHECK (
        (user_id IS NOT NULL AND session_id IS NULL) OR
        (user_id IS NULL AND session_id IS NOT NULL)
    ),
    -- Optionally, add separate UNIQUE constraints if needed:
    UNIQUE(user_id),-- Ensures one cart per user (if NULLs allowed, only one non-NULL allowed)
    UNIQUE(session_id) -- Ensures one cart per session ID
);

CREATE TABLE cart_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    cart_id UUID REFERENCES carts(id) ON DELETE CASCADE,
    product_id UUID REFERENCES products(id) ON DELETE CASCADE,
    quantity INTEGER NOT NULL DEFAULT 1 CHECK (quantity > 0),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    UNIQUE(cart_id, product_id) -- One item per product per cart
);

-- Indexes for performance
CREATE INDEX idx_carts_user_id ON carts(user_id);
CREATE INDEX idx_carts_session_id ON carts(session_id);
CREATE INDEX idx_cart_items_cart_id ON cart_items(cart_id);
CREATE INDEX idx_cart_items_product_id ON cart_items(product_id);

-- +goose Down
DROP TABLE IF EXISTS cart_items CASCADE;
DROP TABLE IF EXISTS carts CASCADE;


File: migrations/00013_create_admin_user.sql
================================================
-- +goose Up
-- Insert the initial admin user only if it doesn't exist
INSERT INTO users (email, password_hash, full_name, is_admin)
SELECT 'admin@example.com', -- Replace with your desired admin email
       '$2a$10$ex6VtC5ZoHSmJHZbwun/4.MsKJ2OW0Ji2DIwqzOYK2SYGhB1Ku3nK', -- Replace with the actual bcrypt hash
       'Admin User', -- Replace with the desired admin full name
       TRUE
WHERE NOT EXISTS (
    SELECT 1 FROM users WHERE email = 'admin@example.com' -- Match on email or another unique field
);

-- +goose Down
-- Optionally, remove the admin user when rolling back this specific migration
DELETE FROM users WHERE email = 'admin@example.com' AND is_admin = TRUE;


File: website/package.json
================================================
{
  "name": "frontend-user",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@headlessui/react": "^2.2.9",
    "@heroicons/react": "^2.2.0",
    "@hookform/resolvers": "^5.2.2",
    "@tanstack/react-query": "^5.90.21",
    "@uidotdev/usehooks": "^2.4.1",
    "axios": "^1.13.4",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-hook-form": "^7.71.1",
    "react-router-dom": "^7.13.0",
    "sonner": "^2.0.7",
    "zod": "^4.3.6",
    "zustand": "^5.0.10"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.23",
    "daisyui": "^4",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.5.6",
    "sharp": "^0.34.5",
    "svgo": "^4.0.0",
    "tailwindcss": "^3.4.19",
    "vite": "^7.2.4",
    "vite-plugin-image-optimizer": "^2.0.3"
  }
}


File: website/src/components/NavBar.jsx
================================================
import React, { useEffect, useState } from "react";
import { Link, useLocation, useNavigate } from "react-router-dom";
import {
  ComputerDesktopIcon,
  CubeIcon, // Added
  EnvelopeIcon,
  MapPinIcon,
  PhoneIcon,
  ShoppingCartIcon,
  UserCircleIcon, // Added
} from "@heroicons/react/24/outline";
import { useCart } from "../contexts/CartContext";
import { useAuth } from "../contexts/AuthContext"; // Import useAuth
import { useQuery } from "@tanstack/react-query"; // Import useQuery
import { fetchCategories } from "../services/api"; // Import fetchCategories
import ThemeSwitcher from "./ThemeSwitcher"; // Import the new component

// Import the logo image
import logoImage from "../assets/logo.jpg"; // Adjust the filename if needed (e.g., logo.svg, logo.jpg)

const Navbar = () => {
  const [searchTerm, setSearchTerm] = useState("");
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const [isMiniCartOpen, setIsMiniCartOpen] = useState(false); // State for mini-cart
  const navigate = useNavigate();
  const location = useLocation();
  const { cart, subtotal } = useCart(); // Get cart items and subtotal
  const { user, isLoading } = useAuth(); // Get user and loading state from auth context

  // Fetch categories using useQuery
  const {
    data: categories = [],
    isLoading: categoriesLoading,
    isError: categoriesError,
  } = useQuery({
    queryKey: ["navbar-categories"],
    queryFn: fetchCategories,
    staleTime: 15 * 60 * 1000, // Cache for 15 minutes
    refetchOnWindowFocus: false, // Don't refetch when window gains focus
  });

  const handleSearch = (e) => {
    e.preventDefault();
    let queryParams = new URLSearchParams();

    if (searchTerm.trim()) {
      queryParams.append("q", searchTerm.trim());
    }
    if (selectedCategory) {
      queryParams.append("category", selectedCategory);
    }

    navigate(`/products?${queryParams.toString()}`);
  };

  useEffect(() => {
    setIsMobileMenuOpen(false);
  }, [location.pathname]);

  const isBuildPCPage = location.pathname === "/build-pc";

  // State for the category dropdown - initialize to empty string
  const [selectedCategory, setSelectedCategory] = useState("");

  const handleCategoryChange = (e) => {
    const newCategory = e.target.value;
    setSelectedCategory(newCategory);
    // Optionally, trigger a filter action here if needed globally
    // .setSearchParams({ ...params, category: newCategory === 'All Categories' ? '' : newCategory });
  };

  let phoneNumber = "+0791781303";
  let address = "TAHER, Jijel, Algeria";
  let currency = "DZD";
  // Determine the account link destination based on auth state
  let accountLinkDestination = "/auth"; // Default to auth page
  if (isLoading) {
    accountLinkDestination = "#"; // Or maybe don't render the link at all temporarily
  } else if (user) {
    accountLinkDestination = "/account";
  } else {
    accountLinkDestination = "/auth";
  }

  // Improved hover handlers
  const handleCartHover = () => {
    setIsMiniCartOpen(true);
  };

  const handleCartLeave = () => {
    // Use a timeout to allow for brief movement to the dropdown
    setTimeout(() => {
      if (!document.querySelector(".mini-cart-dropdown:hover")) {
        setIsMiniCartOpen(false);
      }
    }, 100); // 100ms delay before closing
  };

  const handleDropdownHover = () => {
    setIsMiniCartOpen(true); // Keep it open if hovering dropdown
  };

  const handleDropdownLeave = () => {
    setIsMiniCartOpen(false); // Close when leaving dropdown
  };

  return (
    <React.Fragment>
      {/* Top Info Bar — Desktop Only - Using daisyUI semantic classes */}
      <div className="bg-base-300 text-base-content text-sm py-1 px-4 flex justify-between items-center hidden md:flex">
        {/* Changed bg-gray-900 to bg-base-300 */}
        <div className="flex items-center space-x-6">
          <a className="flex items-center hover:text-primary transition">
            {/* Changed hover:text-white to hover:text-primary */}
            <PhoneIcon className="h-4 w-4 mr-1" />
            {phoneNumber}
          </a>
          <a
            href="mailto:ycinfo2026@gmail.com"
            className="flex items-center hover:text-primary transition"
          >
            {/* Changed hover:text-white to hover:text-primary */}
            <EnvelopeIcon className="h-4 w-4 mr-1" />
            ycinfo2026@gmail.com
          </a>
          <span className="flex items-center">
            <MapPinIcon className="h-4 w-4 mr-1" />
            {address}
          </span>
        </div>
        <div className="flex items-center space-x-4">
          <span className="font-medium">{currency}</span>
          {/* Dynamic Link */}
          <Link
            to={accountLinkDestination}
            className="hover:text-primary transition"
          >
            {/* Changed hover:text-white to hover:text-primary */}
            {user ? `Hello, ${user.full_name}` : "My Account"}{" "}
            {/* Show username if logged in */}
          </Link>
        </div>
      </div>

      {/* Main Navbar - Using daisyUI semantic classes */}
      <nav className="bg-base-100 border-b border-base-300 py-3 px-4">
        {/* Changed bg-gray-900 to bg-base-100, border-gray-800 to border-base-300 */}
        <div className="container mx-auto flex items-center justify-between">
          {/* Logo - Left */}
          <Link to="/" className="flex items-center space-x-2">
            {/* Added space-x-2 for gap between logo and text */}
            {/* Imported Logo Image - Rounded */}
            <img
              src={logoImage} // Use the imported variable
              alt="ALM Informatique Logo"
              className="h-8 w-8 rounded-full" // Added rounded-full for rounded corners
            />
            <span className="text-xl md:text-2xl font-bold text-base-content">
              {/* Changed text-white to text-base-content */}
              YC<span className="text-primary">.</span> Informatique
            </span>
          </Link>

          {/* Centered Search Bar (Desktop) - Updated to use native select dropdown with arrow and separator */}
          <div className="hidden md:flex justify-center flex-1 max-w-2xl">
            <form
              onSubmit={handleSearch}
              className="w-full max-w-lg border border-secondary-content rounded-lg"
            >
              <div className="flex rounded-lg overflow-hidden bg-base-200">
                {/* Changed bg-gray-800 to bg-base-200 */}
                {/* Category Select with Custom Arrow */}
                <div className="relative">
                  {/* Wrapper for arrow positioning */}
                  <select
                    value={selectedCategory}
                    onChange={handleCategoryChange}
                    className="bg-base-200 text-base-content px-4 py-3 border-none focus:outline-none min-w-[120px] appearance-none pl-4 pr-8 cursor-pointer"
                    disabled={categoriesLoading}
                  >
                    <option value="">All Categories</option>
                    {categories.map((category) => (
                      <option
                        key={category.id}
                        value={category.name}
                      >
                        {category.name}
                      </option>
                    ))}
                  </select>{" "}
                  {/* Custom Arrow SVG */}
                  <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-base-content">
                    {/* Changed text-gray-300 to text-base-content */}
                    <svg
                      width="12px"
                      height="12px"
                      className="h-3 w-3 fill-current"
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 2048 2048"
                    >
                      <path d="M1799 349l242 241-1017 1017L7 590l242-241 775 775 775-775z">
                      </path>
                    </svg>
                  </div>
                </div>
                {/* Separator Bar */}
                <div className="self-stretch w-px bg-base-300"></div>{" "}
                {/* Changed bg-gray-700 to bg-base-300 */}
                <input
                  type="text"
                  placeholder="Search here"
                  className="flex-1 px-4 py-3 bg-base-200 text-base-content focus:outline-none focus:ring-2 focus:ring-primary" // Changed bg-gray-800 to bg-base-200, text-white to text-base-content, focus:ring-red-500 to focus:ring-primary
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                />
                <button
                  type="submit"
                  className="bg-primary hover:bg-primary-focus text-primary-content px-5 py-3 font-medium transition"
                  disabled={categoriesLoading}
                >
                  {categoriesLoading ? "Searching..." : "Search"}
                </button>
              </div>
            </form>
          </div>

          {/* Right Icons - Desktop - Added Theme Switcher */}
          <div className="hidden md:flex items-center space-x-4">
            {/* Reduced space-x from 6 to 4 */}
            <ThemeSwitcher /> {/* Add the ThemeSwitcher component */}
            <Link
              to="/build-pc"
              className={`flex flex-col items-center ${
                isBuildPCPage
                  ? "text-primary"
                  : "text-base-content hover:text-primary"
              } transition`} // Changed text-red-500 to text-primary, text-gray-300 to text-base-content, hover:text-white to hover:text-primary
            >
              <ComputerDesktopIcon className="h-6 w-6" />
              <span className="text-xs mt-1">Build PC</span>
            </Link>
            {/* Mini-Cart Dropdown Container - Added relative */}
            <div
              className="relative group" // Added relative for dropdown positioning
              onMouseEnter={handleCartHover} // Hover handler for the container
              onMouseLeave={handleCartLeave} // Leave handler for the container
            >
              {/* Cart Link with Badge - Removed hover triggers from here */}
              <Link
                to="/cart"
                className="flex flex-col items-center text-base-content hover:text-primary transition relative" // Changed text-gray-300 to text-base-content, hover:text-white to hover:text-primary
              >
                <ShoppingCartIcon className="h-6 w-6" />
                <span className="text-xs mt-1">Your Cart</span>
                {cart.length > 0 && (
                  <span className="absolute -top-1 -right-1 bg-primary text-primary-content text-xs rounded-full h-5 w-5 flex items-center justify-center">
                    {/* Changed bg-red-500 to bg-primary, text-white to text-primary-content */}
                    {cart.length}
                  </span>
                )}
              </Link>

              {/* Mini-Cart Dropdown - Conditionally Rendered */}
              {isMiniCartOpen &&
                cart.length > 0 && ( // Show only if open and cart has items
                  <div
                    className="mini-cart-dropdown absolute right-0 mt-2 w-80 bg-base-100 shadow-xl z-[1] rounded-box border border-base-300" // Used bg-base-100 for dropdown
                    onMouseEnter={handleDropdownHover} // Keep open if hovering dropdown
                    onMouseLeave={handleDropdownLeave} // Close when leaving dropdown
                  >
                    <div className="p-4">
                      <h3 className="font-bold text-lg mb-2">Your Cart</h3>
                      <div className="space-y-2 max-h-60 overflow-y-auto">
                        {/* Scrollable if many items */}
                        {cart.map((item) => (
                          <div
                            key={item.id}
                            className="flex items-center space-x-3 p-2 bg-inherit rounded"
                          >
                            {/* Used bg-base-200 for item background */}
                            <img
                              src={item.image} // <-- Ensure it uses item.image
                              alt={item.title}
                              className="w-12 h-12 object-contain bg-inherit p-1 rounded" // Added bg-base-200 and padding
                            />
                            <div className="flex-1 min-w-0">
                              <p className="font-medium truncate text-sm">
                                {item.title}
                              </p>
                              <p className="text-primary font-bold text-sm">
                                DZD {item.price}
                              </p>
                              <p className="text-base-content/70 text-xs">
                                Qty: {item.quantity}
                              </p>{" "}
                              {/* Changed text-gray-500 to text-base-content/70 */}
                            </div>
                          </div>
                        ))}
                      </div>
                      <div className="divider my-2"></div>{" "}
                      {/* Changed divider color */}
                      <div className="flex justify-between items-center font-bold">
                        <span>Total:</span>
                        <span>DZD {subtotal.toFixed(2)}</span>
                      </div>
                      <div className="flex gap-2 mt-4">
                        <Link
                          to="/cart"
                          className="btn btn-primary btn-outline flex-1"
                          onClick={() => setIsMiniCartOpen(false)} // Close dropdown on click
                        >
                          View Cart
                        </Link>
                        {/* Updated Checkout button to link to /checkout */}
                        <Link
                          to="/checkout"
                          className="btn btn-secondary flex-1"
                          onClick={() => setIsMiniCartOpen(false)} // Close dropdown on click
                        >
                          Checkout
                        </Link>
                      </div>
                    </div>
                  </div>
                )}

              {/* Empty Cart Message - Shown when dropdown is open but cart is empty */}
              {isMiniCartOpen && cart.length === 0 && (
                <div
                  className="mini-cart-dropdown absolute right-0 mt-2 w-80 bg-base-100 shadow-xl z-[1] rounded-box border border-base-300"
                  onMouseEnter={handleDropdownHover} // Keep open if hovering dropdown
                  onMouseLeave={handleDropdownLeave} // Close when leaving dropdown
                >
                  <div className="p-4 text-center">
                    <p>Your cart is empty.</p>
                    <Link
                      to="/products"
                      className="btn btn-primary mt-2"
                      onClick={() => setIsMiniCartOpen(false)} // Close dropdown on click
                    >
                      Browse Products
                    </Link>
                  </div>
                </div>
              )}
            </div>
          </div>

          {/* Mobile Menu Toggle */}
          <button
            className="md:hidden text-base-content hover:text-primary" // Changed text-gray-300 to text-base-content, hover:text-white to hover:text-primary
            onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)}
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              className="h-6 w-6"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M4 6h16M4 12h16M4 18h16"
              />
            </svg>
          </button>
        </div>

        {/* Mobile Menu */}
        {isMobileMenuOpen && (
          <div className="md:hidden bg-base-200 py-4 px-4 border-t border-base-300">
            {/* Changed bg-gray-800 to bg-base-200, border-gray-700 to border-base-300 */}
            <div className="space-y-3">
              <form onSubmit={handleSearch} className="mb-4">
                <input
                  type="text"
                  placeholder="Search products..."
                  className="w-full px-4 py-3 bg-base-300 text-base-content rounded-lg border-none focus:outline-none focus:ring-2 focus:ring-primary" // Changed bg-gray-700 to bg-base-300, text-white to text-base-content, focus:ring-red-500 to focus:ring-primary
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                />
              </form>
              <ThemeSwitcher /> {/* Add the ThemeSwitcher component */}
              <Link
                to="/build-pc"
                className={`flex items-center px-4 py-2 rounded-lg ${
                  isBuildPCPage
                    ? "bg-primary text-primary-content"
                    : "text-base-content hover:bg-base-300"
                }`} // Changed bg-red-500 to bg-primary, text-white to text-primary-content, text-gray-300 to text-base-content, hover:bg-gray-700 to hover:bg-base-300
                onClick={() => setIsMobileMenuOpen(false)}
              >
                <ComputerDesktopIcon className="h-5 w-5 mr-3" />
                Build Your PC
              </Link>
              <Link
                to="/cart"
                className="flex items-center px-4 py-2 text-base-content hover:bg-base-300 rounded-lg" // Changed text-gray-300 to text-base-content, hover:bg-gray-700 to hover:bg-base-300
                onClick={() => setIsMobileMenuOpen(false)}
              >
                <ShoppingCartIcon className="h-5 w-5 mr-3" />
                Your Cart ({cart.length})
              </Link>
              {/* Dynamic Link for Mobile */}
              <Link
                to={accountLinkDestination}
                className="flex items-center px-4 py-2 text-base-content hover:bg-base-300 rounded-lg" // Changed text-gray-300 to text-base-content, hover:bg-gray-700 to hover:bg-base-300
                onClick={() => setIsMobileMenuOpen(false)}
              >
                <UserCircleIcon className="h-5 w-5 mr-3" />
                {user ? `Account (${user.name})` : "Log In / Sign Up"}
              </Link>
              <Link
                to="/products"
                className="flex items-center px-4 py-2 text-base-content hover:bg-base-300 rounded-lg" // Changed text-gray-300 to text-base-content, hover:bg-gray-700 to hover:bg-base-300
                onClick={() => setIsMobileMenuOpen(false)}
              >
                <CubeIcon className="h-5 w-5 mr-3" />
                All Products
              </Link>
            </div>
          </div>
        )}
      </nav>
    </React.Fragment>
  );
};

export default Navbar;


File: website/src/pages/Cart.jsx
================================================
import React, { useEffect, useMemo, useRef, useState } from "react";
import { Link } from "react-router-dom";
import { useCart } from "../contexts/CartContext"; // Use the refactored context
import { TrashIcon } from "@heroicons/react/24/solid";

const Cart = () => {
  const {
    cart,
    subtotal,
    total,
    updateQuantity,
    removeFromCart,
    clearCart,
    isLoading, // Get loading state from the context
    isError, // Get error state from the context
    error, // Get error details from the context
    isUpdatingQuantity, // Get mutation loading states if needed for UI
    isRemovingItem,
    // ... potentially other mutation states
  } = useCart();

  // Initialize localQuantities with the current cart quantities
  const [localQuantities, setLocalQuantities] = useState(
    cart.reduce((acc, item) => {
      acc[item.id] = item.quantity;
      return acc;
    }, {}),
  );

  // Ref to store timeout IDs for each item
  const timeoutRefs = useRef({});

  // Update localQuantities whenever the cart changes (when refetched from API)
  useEffect(() => {
    setLocalQuantities(
      cart.reduce((acc, item) => {
        acc[item.id] = item.quantity;
        return acc;
      }, {}),
    );
  }, [cart]); // Depend on the cart array from the context (which updates after refetch)

  // Cleanup timeouts on unmount
  useEffect(() => {
    return () => {
      Object.values(timeoutRefs.current).forEach((timeoutId) => {
        if (timeoutId) clearTimeout(timeoutId);
      });
    };
  }, []);

  // Function to handle quantity update with debounce and stock limit
  const handleQuantityUpdate = (productId, newQuantity) => {
    // Find the cart item to get its stock quantity
    const item = cart.find((i) => i.id === productId);
    if (!item) return;

    // Limit the quantity to the available stock
    const maxQuantity = item.stock_quantity;
    const limitedQuantity = Math.min(newQuantity, maxQuantity);

    // Update local state immediately for instant UI feedback
    setLocalQuantities((prev) => ({
      ...prev,
      [productId]: limitedQuantity,
    }));

    // Clear existing timeout for this product if it exists
    if (timeoutRefs.current[productId]) {
      clearTimeout(timeoutRefs.current[productId]);
    }

    // Schedule the backend update after 500ms
    timeoutRefs.current[productId] = setTimeout(() => {
      // Check if the item is still in the cart (might be redundant if item exists check above passes)
      const itemExists = cart.some((item) => item.id === productId);
      if (itemExists) {
        // Call the actual cart update function with the limited quantity
        // This now triggers a TanStack Query mutation
        updateQuantity(productId, limitedQuantity);
      }
      // Clean up the timeout ref after execution
      delete timeoutRefs.current[productId];
    }, 500); // 500ms delay before API call
  };

  // Handler for quantity decrease
  const handleDecreaseQuantity = (item) => {
    const newQuantity = Math.max(
      1,
      (localQuantities[item.id] !== undefined
        ? localQuantities[item.id]
        : item.quantity) - 1,
    );
    handleQuantityUpdate(item.id, newQuantity);
  };

  // Handler for quantity increase
  const handleIncreaseQuantity = (item) => {
    // Calculate the new quantity (current + 1)
    const currentQuantity = localQuantities[item.id] !== undefined
      ? localQuantities[item.id]
      : item.quantity;
    const newQuantity = currentQuantity + 1;

    // This will be limited by handleQuantityUpdate
    handleQuantityUpdate(item.id, newQuantity);
  };

  // Calculate total original value, total discounted value, and total savings from the cart
  // These values come directly from the backend response (now via the context's query/memo)
  const { totalOriginalValue, totalDiscountedValue, totalSavings } = useMemo(
    () => {
      let originalValue = 0;
      let discountedValue = 0;
      let savings = 0;

      cart.forEach((item) => {
        const quantity = localQuantities[item.id] !== undefined
          ? localQuantities[item.id]
          : item.quantity;

        // Extract price info from the product object
        const originalPrice = item.original_price_cents
          ? item.original_price_cents / 100
          : (typeof item.price === "number" ? item.price : 0);
        const finalPrice = item.final_price_cents
          ? item.final_price_cents / 100
          : (typeof item.price === "number" ? item.price : 0);
        const hasDiscount = item.has_active_discount;

        // Only add to totals if both price and quantity are valid numbers
        if (
          typeof originalPrice === "number" && !isNaN(originalPrice) &&
          typeof quantity === "number" && !isNaN(quantity)
        ) {
          originalValue += originalPrice * quantity;
        }

        if (
          typeof finalPrice === "number" && !isNaN(finalPrice) &&
          typeof quantity === "number" && !isNaN(quantity)
        ) {
          discountedValue += finalPrice * quantity;
        }

        if (
          hasDiscount && typeof originalPrice === "number" &&
          !isNaN(originalPrice) &&
          typeof finalPrice === "number" && !isNaN(finalPrice) &&
          typeof quantity === "number" && !isNaN(quantity)
        ) {
          savings += (originalPrice - finalPrice) * quantity;
        }
      });

      return {
        totalOriginalValue: isNaN(originalValue) ? 0 : originalValue,
        totalDiscountedValue: isNaN(discountedValue) ? 0 : discountedValue,
        totalSavings: isNaN(savings) ? 0 : savings,
      };
    },
    [cart, localQuantities],
  );

  // Show loading state while fetching cart data
  if (isLoading) {
    return (
      <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
        <h1 className="text-3xl font-bold mb-8">Shopping Cart</h1>
        <div className="flex justify-center items-center min-h-[50vh]">
          <span className="loading loading-spinner loading-lg"></span>
        </div>
      </div>
    );
  }

  // Show error state if fetching cart data failed
  if (isError) {
    return (
      <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
        <h1 className="text-3xl font-bold mb-8">Shopping Cart</h1>
        <div className="alert alert-error">
          <p>
            Error loading cart: {error?.message || "An unknown error occurred"}
          </p>
          <button
            className="btn btn-sm"
            onClick={() => window.location.reload()}
          >
            Retry
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
      <h1 className="text-3xl font-bold mb-8">Shopping Cart</h1>

      {cart.length === 0
        ? (
          <div className="text-center py-12">
            <p className="text-xl mb-4">Your cart is empty</p>
            <Link to="/products" className="btn btn-primary">
              Continue Shopping
            </Link>
          </div>
        )
        : (
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <div className="lg:col-span-2">
              <div className="space-y-4">
                {cart.map((item) => {
                  // Use the local quantity if available, otherwise use the item's quantity
                  const displayQuantity = localQuantities[item.id] !== undefined
                    ? localQuantities[item.id]
                    : item.quantity;

                  // Extract price info from the product object
                  const originalPrice = item.original_price_cents
                    ? item.original_price_cents / 100
                    : (typeof item.price === "number" ? item.price : 0);
                  const finalPrice = item.final_price_cents
                    ? item.final_price_cents / 100
                    : (typeof item.price === "number" ? item.price : 0);
                  const hasDiscount = item.has_active_discount;

                  // Calculate max quantity based on stock
                  const maxQuantity = item.stock_quantity;
                  const isAtMaxStock = displayQuantity >= maxQuantity;

                  // Determine if the +/- buttons are disabled based on mutation state
                  const isQuantityUpdating = isUpdatingQuantity; // Simplified: disable all while any update is in progress
                  // Or, you could make it more granular by tracking individual item updates if needed.

                  return (
                    <div
                      key={item.id}
                      className="card bg-base-100 shadow-lg border border-base-200"
                    >
                      <div className="card-body">
                        <div className="flex items-center space-x-4">
                          <img
                            src={item.image}
                            alt={item.name}
                            className="w-20 h-20 object-contain bg-inherit p-2 rounded"
                          />
                          <div className="flex-1">
                            <h3 className="font-semibold">{item.name}</h3>
                            <div className="flex items-center gap-2">
                              {hasDiscount && (
                                <span className="line-through text-gray-500">
                                  DZD {isNaN(originalPrice)
                                    ? "0.00"
                                    : originalPrice.toFixed(2)}
                                </span>
                              )}
                              <span className="text-primary font-bold">
                                DZD {isNaN(finalPrice)
                                  ? "0.00"
                                  : finalPrice.toFixed(2)}
                              </span>
                              {hasDiscount && (
                                <span className="badge badge-success bg-green-600 text-white">
                                  -{originalPrice > 0 &&
                                      !isNaN(originalPrice) &&
                                      !isNaN(finalPrice)
                                    ? ((1 - finalPrice / originalPrice) * 100)
                                      .toFixed(0)
                                    : "0"}%
                                </span>
                              )}
                            </div>
                            {/* Stock availability indicator */}
                            <div className="text-sm mt-1">
                              {isAtMaxStock
                                ? (
                                  <span className="text-warning">
                                    Maximum stock reached ({maxQuantity})
                                  </span>
                                )
                                : (
                                  <span className="text-success">
                                    In Stock: {maxQuantity} available
                                  </span>
                                )}
                            </div>
                          </div>
                          <div className="flex items-center space-x-2">
                            <button
                              className="btn btn-xs"
                              onClick={() => handleDecreaseQuantity(item)}
                              type="button"
                              disabled={isQuantityUpdating} // Disable during mutation
                            >
                              -
                            </button>
                            <span className="mx-2">
                              {displayQuantity}
                            </span>
                            <button
                              className={`btn btn-xs ${
                                isAtMaxStock ? "btn-disabled" : ""
                              }`}
                              onClick={() => handleIncreaseQuantity(item)}
                              type="button"
                              disabled={isAtMaxStock || isQuantityUpdating} // Disable during mutation or at max stock
                            >
                              +
                            </button>
                          </div>
                          <button
                            className="btn btn-error btn-xs"
                            onClick={() => removeFromCart(item.id)}
                            disabled={isRemovingItem} // Disable during remove mutation
                          >
                            <TrashIcon className="h-4 w-4 text-white" />
                          </button>
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>

              <div className="mt-6">
                <button className="btn btn-error btn-sm" onClick={clearCart}>
                  Clear Cart
                </button>
              </div>
            </div>

            <div className="lg:col-span-1">
              <div className="card bg-base-100 shadow-lg sticky top-24 border border-base-200">
                <div className="card-body">
                  <h3 className="card-title">Order Summary</h3>

                  <div className="space-y-2">
                    {/* Original price with discount strikethrough */}
                    <div className="flex justify-between">
                      <span>Original Price:</span>
                      <span className="line-through text-gray-500">
                        DZD {isNaN(totalOriginalValue)
                          ? "0.00"
                          : totalOriginalValue.toFixed(2)}
                      </span>
                    </div>

                    {/* Current subtotal - SAFEGUARDED */}
                    <div className="flex justify-between">
                      <span>Subtotal:</span>
                      <span>
                        DZD {isNaN(subtotal) ? "0.00" : subtotal.toFixed(2)}
                      </span>
                    </div>

                    {/* Total savings */}
                    {totalSavings > 0 && (
                      <div className="flex justify-between text-success">
                        <span>You Save:</span>
                        <span>
                          -DZD{" "}
                          {isNaN(totalSavings)
                            ? "0.00"
                            : totalSavings.toFixed(2)}
                        </span>
                      </div>
                    )}

                    {/* Display additional backend-calculated totals */}
                    <div className="flex justify-between">
                      <span>Items:</span>
                      <span>{cart.length}</span>
                    </div>
                    <div className="flex justify-between">
                      <span>Total Quantity:</span>
                      <span>
                        {cart.reduce((sum, item) => {
                          const qty = localQuantities[item.id] !== undefined
                            ? localQuantities[item.id]
                            : item.quantity;
                          return sum + (typeof qty === "number" ? qty : 0);
                        }, 0)}
                      </span>
                    </div>

                    <div className="divider"></div>

                    {/* Total - SAFEGUARDED */}
                    <div className="flex justify-between font-bold text-lg">
                      <span>Total:</span>
                      <span>
                        DZD {isNaN(total) ? "0.00" : total.toFixed(2)}
                      </span>
                    </div>
                  </div>

                  <Link to="/checkout" className="btn btn-primary w-full mt-4">
                    Proceed to Checkout
                  </Link>

                  <Link
                    to="/products"
                    className="btn btn-secondary btn-outline w-full mt-2"
                  >
                    Continue Shopping
                  </Link>
                </div>
              </div>
            </div>
          </div>
        )}
    </div>
  );
};

export default Cart;


File: website/src/pages/BuildPC.jsx
================================================
// src/pages/BuildPC.jsx
import React, { useEffect, useState } from "react";
import { useStore } from "../stores/useStore"; // Assuming useStore manages cart and PC build components
import BuildGif from "../assets/PcBuild.gif";
import { useNavigate } from "react-router-dom";
import { useQuery, useQueryClient } from "@tanstack/react-query"; // Import useQueryClient
import {
  bulkAddToCart,
  fetchCategories,
  searchProducts,
} from "../services/api"; // Import API functions
import { toast } from "sonner"; // Import toast for notifications

const BACKEND_BASE_URL = import.meta.env.VITE_BACKEND_BASE_URL ||
  "http://localhost:8080";
const BuildPC = () => {
  const queryClient = useQueryClient(); // <-- Add this line

  const navigate = useNavigate();
  const [currentStep, setCurrentStep] = useState(0);
  const { buildPcComponents, setPcComponent, cart, addToCart } = useStore(); // Get cart and addToCart from store
  const [quantities, setQuantities] = useState({}); // Local state for quantities

  // State for pagination
  const [currentPage, setCurrentPage] = useState({}); // Use an object to track page per step

  // Tooltips for each step (now used in the modal)
  const stepInfoTexts = {
    cpu:
      "The CPU is the PC’s brain that handles calculations. It must match your motherboard’s CPU socket. Ensure it’s properly cooled for stable performance (use a good CPU cooler).",
    motherboard:
      "The motherboard connects all components in your PC. It must support your CPU’s socket and the right type of RAM. Also, check that the board’s size (ATX, mATX, etc.) fits your case.",
    ram:
      "RAM provides temporary storage for data the CPU needs quick access to. Ensure it's compatible with your motherboard's RAM type (DDR4, DDR5) and speed.",
    case:
      "The case houses all your components. Ensure it's compatible with your motherboard's form factor (ATX, Micro-ATX, etc.) and has enough space for your GPU and PSU.",
    "cooler":
      "A CPU cooler dissipates heat generated by the CPU. Choose one compatible with your CPU socket and fits within your case's clearance limits.",
    storage:
      "Storage devices hold your operating system, programs, and files. Choose between SSDs (faster) and HDDs (larger capacity). Ensure your motherboard has the necessary connections (SATA, M.2).",
    gpu:
      "The GPU processes graphics and video. It's essential for gaming and video editing. Ensure your PSU has enough power and your case has enough space.",
    psu:
      "The PSU supplies power to all components. Choose one with enough wattage for your build and good efficiency ratings (80+ Bronze, Gold, etc.).",
  };

  const steps = [
    { id: "cpu", name: "CPU", title: "Select CPU" },
    { id: "motherboard", name: "Motherboard", title: "Select Motherboard" },
    { id: "ram", name: "RAM", title: "Select RAM" },
    { id: "case", name: "Case", title: "Select Case" },
    { id: "cooler", name: "CPU Cooler", title: "Select CPU Cooler" },
    { id: "storage", name: "Storage", title: "Select Storage" },
    { id: "gpu", name: "GPU", title: "Select GPU" },
    { id: "power-supply", name: "PSU", title: "Select Power Supply" },
  ];

  // --- FETCH CATEGORIES ONCE ---
  const {
    data: categoriesData,
    isLoading: categoriesLoading,
    isError: categoriesError,
    error: categoriesFetchError,
  } = useQuery({
    queryKey: ["categories"],
    queryFn: fetchCategories, // API function to fetch categories
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
    cacheTime: 10 * 60 * 1000, // Cache for 10 minutes
    onError: (error) => {
      console.error("Error fetching categories:", error);
      toast.error("Failed to load categories. Please try again later.");
    },
  });

  // Create a mapping from step ID to category ID
  const categoryMap = React.useMemo(() => {
    if (!categoriesData) return {};
    // Example mapping - adjust based on your actual category names/IDs
    const map = {};
    categoriesData.forEach((cat) => {
      // Assuming category names align closely with step IDs or have a known mapping
      // You might need a more robust mapping strategy if names don't match
      const stepId = cat.name.toLowerCase().replace(/\s+/g, "-"); // e.g., "CPU" -> "cpu", "Power Supply" -> "power-supply"
      if (steps.some((step) => step.id === stepId)) {
        map[stepId] = cat.id;
      }
    });
    // Add specific mappings if names don't directly translate
    // map['cpu-cooler'] = 'specific-cooler-category-id';
    return map;
  }, [categoriesData, steps]);

  const currentStepId = steps[currentStep]?.id;
  const currentCategoryId = categoryMap[currentStepId];

  // Determine filters based on previously selected components
  const getFiltersForStep = () => {
    let filters = { category_id: currentCategoryId, limit: 20 }; // Default filter for current category

    // Apply compatibility filters based on previous selections using spec_filter
    switch (currentStepId) {
      case "motherboard":
        if (buildPcComponents.cpu?.spec_highlights?.socket) {
          filters.spec_filter =
            `socket:${buildPcComponents.cpu.spec_highlights.socket}`;
        }
        break;
      case "case":
        if (buildPcComponents.motherboard?.spec_highlights?.form_factor) {
          filters.spec_filter =
            `form_factor:${buildPcComponents.motherboard.spec_highlights.form_factor}`;
        }
        break;
      case "ram":
        if (
          buildPcComponents.motherboard?.spec_highlights?.supported_memory_types
        ) {
          // Assuming backend can handle comma-separated string like "DDR4,DDR5" for a 'type' filter
          // filters.spec_filter = `type:${buildPcComponents.motherboard.spec_highlights.supported_memory_types}`;
        }
        break;
      case "cpu-cooler":
        if (buildPcComponents.cpu?.spec_highlights?.socket) {
          filters.spec_filter =
            `supported_sockets:${buildPcComponents.cpu.spec_highlights.socket}`;
        }
        break;
      case "storage":
        // Could filter based on available SATA/M.2 slots on motherboard if backend supports it
        // Example: filters.spec_filter = `interface:SATA` or `interface:NVMe`;
        break;
      case "gpu":
        if (buildPcComponents.case?.spec_highlights?.max_gpu_length) {
          // Backend might need a specific operator for numeric comparison (e.g., max_gpu_length_lte: 285)
          // For now, let's assume a direct filter if backend supports it or filter client-side later if needed
          // filters.spec_filter = `max_gpu_length_lte:${buildPcComponents.case.spec_highlights.max_gpu_length}`;
          // For now, we'll fetch all GPUs for the category and potentially filter client-side if needed
        }
        // Check integrated graphics option - this is more of a display logic than a backend filter
        break;
      case "psu":
        // Could filter based on total system power draw estimation if backend supports it
        break;
      default:
        break;
    }
    return filters;
  };

  const filters = getFiltersForStep();

  const {
    data: productsData,
    isLoading: productsLoading,
    isError: productsError,
    error: productsFetchError,
    refetch: refetchProducts,
  } = useQuery({
    queryKey: ["products", currentStepId, filters], // Include filters in key
    queryFn: () => searchProducts(filters), // API function to fetch products for category with spec_filter
    enabled: !!currentCategoryId, // Only run query if category ID is known
    staleTime: 2 * 60 * 1000, // Consider data fresh for 2 minutes per step
    cacheTime: 5 * 60 * 1000, // Cache for 5 minutes
    onError: (error) => {
      console.error(`Error fetching products for ${currentStepId}:`, error);
      toast.error(`Failed to load ${currentStepId} options. Please try again.`);
    },
  });

  // Process fetched products for display (pagination)
  const allFetchedProducts = productsData?.data || []; // Assuming API returns {  [...], page, limit, total, total_pages }

  // --- PAGINATION LOGIC ---
  const ITEMS_PER_PAGE = 20; // Keep consistent with query limit if possible
  const currentPageNumber = currentPage[currentStepId] || 1;

  const startIndex = (currentPageNumber - 1) * ITEMS_PER_PAGE;
  const endIndex = startIndex + ITEMS_PER_PAGE;
  const paginatedProducts = allFetchedProducts.slice(startIndex, endIndex);

  const totalPages = Math.ceil(allFetchedProducts.length / ITEMS_PER_PAGE);

  const goToPage = (page) => {
    // Validate input page number
    const validatedPage = Math.max(1, Math.min(page, totalPages));
    setCurrentPage((prev) => ({
      ...prev,
      [currentStepId]: validatedPage, // Update page number for the current step
    }));
  };

  const nextPage = () => {
    if (currentPageNumber < totalPages) {
      goToPage(currentPageNumber + 1);
    }
  };

  const prevPage = () => {
    if (currentPageNumber > 1) {
      goToPage(currentPageNumber - 1);
    }
  };

  const renderPageNumbers = () => {
    const pageButtons = [];
    const maxVisiblePages = 5;

    let startPage = Math.max(
      1,
      currentPageNumber - Math.floor(maxVisiblePages / 2),
    );
    let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);

    // Adjust startPage if the range is too small
    if (endPage - startPage + 1 < maxVisiblePages) {
      startPage = Math.max(1, endPage - maxVisiblePages + 1);
    }

    for (let i = startPage; i <= endPage; i++) {
      pageButtons.push(
        <button
          key={i}
          onClick={() => goToPage(i)}
          className={`btn btn-sm mx-1 ${
            currentPageNumber === i ? "btn-accent" : "btn-secondary btn-outline" // Use accent for current page, secondary outline for others
          }`}
          disabled={productsLoading} // Disable buttons while loading
        >
          {i}
        </button>,
      );
    }

    return pageButtons;
  };

  // Handler for quantity changes
  const handleQuantityChange = (category, value) => {
    // Validate input to ensure it's a positive integer
    const numValue = Math.max(1, parseInt(value) || 1);
    setQuantities((prev) => ({
      ...prev,
      [category]: numValue,
    }));
  };

  // Handler to add the entire build to the cart
  const handleAddBuildToCart = async () => { // Make function async
    if (!buildPcComponents || Object.keys(buildPcComponents).length === 0) {
      toast.error("Your build is empty!");
      return;
    }

    try {
      // Prepare the payload for bulkAddToCart
      const itemsToAdd = Object.entries(buildPcComponents).map(
        ([category, component]) => {
          if (component) {
            const quantity = quantities[category] || 1; // Use selected quantity or default to 1
            return {
              product_id: component.id, // Use the actual product ID from the fetched component
              quantity: quantity,
            };
          }
          return null; // Shouldn't happen if buildPcComponents is checked, but handle gracefully
        },
      ).filter(Boolean); // Remove any null entries

      if (itemsToAdd.length === 0) {
        toast.error("No valid components to add.");
        return;
      }

      console.log("Bulk adding items:", itemsToAdd); // Debug log

      // Call the bulk API function
      const response = await bulkAddToCart(itemsToAdd);

      console.log("Bulk add response:", response); // Debug log
      toast.success("Build added to cart successfully!");
      // This will cause the useQuery hook in CartContext to refetch the data once.
      await queryClient.invalidateQueries({ queryKey: ["cart"] }); // Invalidate all queries starting with 'cart'

      useStore.getState().clearBuildPcComponents(); // Assuming you have a clear function in your store

      // Navigate to the cart page after successful addition
      navigate("/cart"); // Uncomment if you have a navigate hook from react-router-dom
    } catch (error) {
      console.error("Error adding build to cart:", error);
      // Try to get a user-friendly message from the backend response
      const errorMessage = error?.response?.data?.message || error.message ||
        "Failed to add build to cart. Please try again.";
      toast.error(errorMessage);
    }
  };

  // Determine if it's the last step
  const isLastStep = currentStep === steps.length - 1;

  // Determine if all required steps have a selected component
  const isBuildComplete = steps.every((step) =>
    buildPcComponents[step.id] != null
  );

  // Show loading state if categories are still loading
  if (categoriesLoading) {
    return (
      <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen flex items-center justify-center">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  }

  // Show error state if categories failed to load
  if (categoriesError) {
    return (
      <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen flex items-center justify-center">
        <div className="text-center">
          <p className="text-xl text-error mb-4">
            Error loading categories:{" "}
            {categoriesFetchError?.message || "An unknown error occurred"}
          </p>
          <button
            className="btn btn-primary"
            onClick={() => window.location.reload()}
          >
            Retry
          </button>
        </div>
      </div>
    );
  }

  // Check if the current step has a valid category mapping
  if (!currentCategoryId) {
    // This might happen if the categoryMap doesn't have an entry for the current step ID
    // You might want to show an error or skip this step, depending on your requirements
    console.warn(`No category ID found for step: ${currentStepId}`);
    // For now, let's render an empty state or a message
    return (
      <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen flex items-center justify-center">
        <div className="text-center">
          <p className="text-xl text-warning mb-4">
            Configuration issue: Category for '{currentStepId}' not found.
          </p>
          <button
            className="btn btn-secondary"
            onClick={() => setCurrentStep(Math.max(0, currentStep - 1))}
          >
            Previous
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
      <h1 className="text-3xl font-bold mb-8">Build Your PC</h1>

      {/* Introductory Section - Full Width, Bigger, with Overlay Text */}
      <div className="relative w-full h-96 mb-8 rounded-xl overflow-hidden shadow-xl border border-base-300">
        {/* Adjust h-96 for desired height */}
        <img
          src={BuildGif}
          alt="Building a PC illustration"
          className="w-full h-full object-cover"
        />
        {/* Overlay Text Container */}
        <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/50 p-6">
          {/* bg-black/50 adds semi-transparent dark overlay */}
          <h2 className="text-4xl md:text-5xl font-bold text-white mb-4 text-center">
            {/* Larger text, centered */}
            Build Your Dream PC
          </h2>
          <p className="text-xl text-white/90 mb-6 text-center max-w-2xl">
            {/* Slightly smaller text, centered, limited width */}
            Customize your perfect computer by selecting each component
            step-by-step. Follow the guide to choose compatible parts, configure
            quantities, and finalize your build.
          </p>
          <p className="text-sm text-white/70 text-center">
            {/* Smaller hint text, centered */}
            Need help? Click the information icons next to each step name for
            tips!
          </p>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
        {/* Steps Navigation with Information Icon Modals (unchanged) */}
        <div className="lg:col-span-1">
          <div className="card bg-base-100 shadow-lg border border-secondary-content">
            <div className="card-body">
              <h3 className="font-bold text-lg mb-4">Build Progress</h3>
              <div className="steps steps-vertical">
                {steps.map((step, index) => (
                  <div
                    key={step.id}
                    className={`step ${
                      index <= currentStep ? "step-primary" : ""
                    } ${buildPcComponents[step.id] ? "step-success" : ""}`}
                    // onClick={() => setCurrentStep(index)} // <-- REMOVED onClick
                    style={{ cursor: "default" }} // Optional: Change cursor to indicate non-clickability
                  >
                    <div className="flex items-center justify-between">
                      <span>{step.name}</span>
                      <button
                        className="badge badge-sm badge-info text-info-content rounded-full w-5 h-5 flex items-center justify-center text-xs cursor-help ml-1"
                        onClick={(e) => {
                          e.stopPropagation();
                          document.getElementById(`info_modal_${step.id}`)
                            .showModal();
                        }}
                      >
                        i
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>

        {/* Component Selection */}
        <div className="lg:col-span-2">
          <div className="card bg-base-100 shadow-lg border border-secondary-content">
            <div className="card-body">
              <h2 className="card-title text-2xl mb-6">
                {steps[currentStep]?.title}
              </h2>

              {/* Loading State for Products */}
              {productsLoading && (
                <div className="flex justify-center items-center h-48">
                  <span className="loading loading-spinner loading-lg"></span>
                </div>
              )}

              {/* Error State for Products */}
              {productsError && !productsLoading && (
                <div className="alert alert-error">
                  <p>
                    Error loading {steps[currentStep]?.title} options:{" "}
                    {productsFetchError?.message || "An unknown error occurred"}
                  </p>
                  <button
                    className="btn btn-sm"
                    onClick={() => refetchProducts()}
                  >
                    Retry
                  </button>
                </div>
              )}

              {/* Pagination Controls Above Grid (Always rendered now) */}
              {!productsLoading && !productsError && totalPages > 1 && (
                <div className="flex items-center justify-between mb-4">
                  <button
                    className="btn btn-sm btn-secondary btn-outline" // Changed to secondary outline
                    onClick={prevPage}
                    disabled={currentPageNumber === 1 || productsLoading} // Disable when loading or on first page
                  >
                    Previous
                  </button>
                  <div className="flex items-center">
                    {renderPageNumbers()}
                  </div>
                  <button
                    className="btn btn-sm btn-accent btn-outline" // Changed to secondary outline
                    onClick={nextPage}
                    disabled={currentPageNumber === totalPages ||
                      productsLoading} // Disable when loading or on last page
                  >
                    Next
                  </button>
                </div>
              )}

              {/* Component Grid (Rendered when not loading and no error) */}
              {!productsLoading && !productsError && (
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                  {paginatedProducts.map((component) => (
                    <div
                      key={component.id} // Use the actual product ID
                      className={`card bg-base-100 shadow-md rounded-lg border border-secondary-content cursor-pointer transition-all duration-200 ${
                        buildPcComponents[steps[currentStep]?.id]?.id ===
                            component.id
                          ? "bg-primary/10 border-2 border-primary shadow-lg"
                          : "hover:shadow-lg"
                      }`}
                      onClick={() =>
                        setPcComponent(steps[currentStep].id, component)} // Pass the full component object
                    >
                      <div className="card-body p-4">
                        <div className="flex items-center gap-4">
                          {/* Use the actual image URL from the component */}
                          <div className="rounded-md overflow-hidden bg-base-200 p-1">
                            <img
                              src={component.image_urls &&
                                  component.image_urls.length > 0
                                ? `${
                                  import.meta.env.VITE_BACKEND_BASE_URL ||
                                  "http://localhost:8080"
                                }${component.image_urls[0]}`
                                : "https://placehold.co/100x100?text=No+Image  "} // Fallback placeholder
                              alt={component.name}
                              className="w-16 h-16 object-contain rounded-none"
                            />
                          </div>
                          <div className="flex-1 min-w-0">
                            <h3 className="card-title font-bold text-sm truncate">
                              {component.name}
                            </h3>
                            <p className="text-lg font-bold text-primary bg-primary/10 px-2 py-1 rounded inline-block mb-1">
                              DZD {component.price_cents / 100}{" "}
                              {/* Assuming price is in cents */}
                            </p>
                            {/* Display relevant spec highlights - adjust keys as needed */}
                            <div className="text-xs opacity-75 mt-1">
                              {Object.entries(component.spec_highlights || {})
                                .slice(0, 3).map(([key, value]) => ( // Show first 3 spec highlights
                                  <div key={key} className="truncate">
                                    <span className="font-medium capitalize">
                                      {key}:
                                    </span>{" "}
                                    {typeof value === "object"
                                      ? JSON.stringify(value)
                                      : value}
                                  </div>
                                ))}
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {/* Summary Section (always visible, updated) */}
              <div className="card bg-inherit shadow-inner mt-6 border border-secondary-content">
                <div className="card-body">
                  <h3 className="card-title text-lg">Current Build</h3>
                  <div className="space-y-2">
                    {Object.entries(buildPcComponents).map(
                      ([category, component]) => (
                        <div
                          key={category}
                          className="flex justify-between items-center"
                        >
                          <div className="flex-1">
                            <span className="font-medium text-base-content">
                              {category.toUpperCase()}:
                            </span>
                            <span className="text-sm ml-2">
                              {component?.name}
                            </span>
                          </div>
                          <div className="flex items-center space-x-2">
                            {/* Use price_cents and convert to display format */}
                            <span className="mr-2">
                              {(component?.price_cents / 100).toFixed(2)} DA
                            </span>
                            <input
                              type="number"
                              min="1"
                              value={quantities[category] || 1}
                              onChange={(e) =>
                                handleQuantityChange(category, e.target.value)}
                              className="input input-xs w-20 text-right" // Adjust width as needed
                            />
                          </div>
                        </div>
                      ),
                    )}
                  </div>
                  <div className="divider"></div>
                  {/* Calculate total using price_cents */}
                  <div className="flex justify-between font-bold text-lg">
                    <span>Total:</span>
                    <span className="text-primary">
                      DZD {Object.entries(buildPcComponents).reduce(
                        (sum, [category, component]) => {
                          const quantity = quantities[category] || 1;
                          return sum +
                            ((component?.price_cents || 0) / 100) * quantity;
                        },
                        0,
                      ).toFixed(2)}
                    </span>
                  </div>
                </div>
              </div>

              {/* Navigation Buttons */}
              <div className="flex justify-between mt-4">
                <button
                  className="btn btn-secondary"
                  onClick={() => setCurrentStep(Math.max(0, currentStep - 1))}
                  disabled={currentStep === 0}
                >
                  Previous
                </button>

                {/* Last Step: Replace "Next" with "Add Build to Cart" */}
                {isLastStep
                  ? (
                    <button
                      className="btn btn-primary"
                      onClick={handleAddBuildToCart}
                      disabled={!isBuildComplete || productsLoading} // Disable if build is incomplete or loading
                    >
                      Add Build to Cart
                    </button>
                  )
                  : (
                    <button
                      className="btn btn-primary"
                      onClick={() =>
                        setCurrentStep(
                          Math.min(steps.length - 1, currentStep + 1),
                        )}
                      disabled={!buildPcComponents[steps[currentStep]?.id] ||
                        productsLoading} // Disable if no selection for current step or loading
                    >
                      Next
                    </button>
                  )}
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Modals for Step Information (unchanged) */}
      {steps.map((step) => (
        <dialog
          key={step.id}
          id={`info_modal_${step.id}`}
          className="modal"
        >
          <div className="modal-box max-w-2xl">
            <h3 className="font-bold text-lg mb-2">{step.name} Information</h3>
            <p className="py-2">{stepInfoTexts[step.id]}</p>
            <div className="modal-action">
              <form method="dialog">
                <button className="btn">Close</button>
              </form>
            </div>
          </div>
          <form method="dialog" className="modal-backdrop">
            <button>close</button>
          </form>
        </dialog>
      ))}
    </div>
  );
};

export default BuildPC;


File: website/src/contexts/AuthContext.jsx
================================================
import React, { createContext, useContext, useEffect, useState } from "react";
import { loginUser, logoutUser, registerUser } from "../services/api";

const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null); // Initially null (not logged in)
  const [isLoading, setIsLoading] = useState(true); // To handle initial loading state

  // Check for stored session on app start
  useEffect(() => {
    const checkAuthStatus = async () => {
      try {
        // Check for stored token in localStorage
        const token = localStorage.getItem("access_token"); // Fixed to match API config
        if (token) {
          // If token exists, we could verify it by making a user profile request
          // For now, we'll just set the user if token exists
          // In a real scenario, you'd want to validate the token with an API call
          const storedUserData = localStorage.getItem("userData");
          if (storedUserData) {
            setUser(JSON.parse(storedUserData));
          }
        }
      } catch (error) {
        console.error("Error checking auth status:", error);
        // Clear any potentially corrupted auth data
        localStorage.removeItem("access_token");
        localStorage.removeItem("userData");
      } finally {
        setIsLoading(false); // Finished checking
      }
    };

    checkAuthStatus();
  }, []);

  const login = async (credentials) => {
    try {
      const response = await loginUser(credentials);
      const { user: userData, access_token } = response;

      // Store the access token and user data
      localStorage.setItem("access_token", access_token); // Fixed to match API config
      localStorage.setItem("userData", JSON.stringify(userData));

      // Update the user state
      setUser(userData);
      return response;
    } catch (error) {
      console.error("Login error:", error);
      throw error;
    }
  };

  const register = async (userData) => {
    try {
      const response = await registerUser(userData);
      // Auto-login after successful registration
      const loginResponse = await loginUser({
        email: userData.email,
        password: userData.password,
      });

      const { user: loggedInUser, access_token } = loginResponse;

      // Store the access token and user data
      localStorage.setItem("access_token", access_token); // Fixed to match API config
      localStorage.setItem("userData", JSON.stringify(loggedInUser));

      // Update the user state
      setUser(loggedInUser);
      return response;
    } catch (error) {
      console.error("Registration error:", error);
      throw error;
    }
  };

  const logout = async () => {
    try {
      // Call the API to logout (revokes refresh token)
      await logoutUser();
    } catch (error) {
      console.error("Logout error:", error);
      // Continue with local logout even if API call fails
    } finally {
      // Clear stored tokens and user data
      localStorage.removeItem("access_token"); // Fixed to match API config
      localStorage.removeItem("userData");

      // Update the user state
      setUser(null);
    }
  };

  // Value object passed to consumers
  const value = {
    user,
    login,
    register,
    logout,
    isLoading, // Expose loading state
    isAuthenticated: !!user, // Convenient boolean check
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error("useAuth must be used within an AuthProvider");
  return context;
};


File: website/vite.config.js
================================================
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import { ViteImageOptimizer } from "vite-plugin-image-optimizer";

export default defineConfig({
  plugins: [
    react(),
    ViteImageOptimizer({
      png: { quality: 80 },
      jpeg: { quality: 75 },
      webp: { quality: 80 },
      avif: { quality: 70 },
      svg: {
        plugins: [
          { name: "removeViewBox", active: false },
          { name: "sortAttrs" },
        ],
      },
    }),
  ],
});


File: devbox.json
================================================
{
  "$schema": "https://raw.githubusercontent.com/jetify-com/devbox/0.16.0/.schema/devbox.schema.json",
  "packages": [
    "go@latest",
    "postgresql@latest",
    "goose@latest",
    "sqlc@latest",
    "github:seatedro/glimpse",
    "glow@latest",
    "nodejs@latest",
    "gcc",
    "redis@latest"
  ],
  "env": {
    "PGPORT": "5433"
  },
  "env_from": ".env",
  "shell": {
    "init_hook": [
      "echo 'Starting development environment....'",
      "devbox services ls"
    ],
    "scripts": {
      "run": [
        "just dev"
      ]
    }
  }
}


File: db/migrate.go
================================================
package db

import (
	"database/sql"
	"fmt"
	"log/slog"
	"os"

	_ "github.com/jackc/pgx/v5/stdlib" // Import for side effects - registers the pgx driver
	"github.com/pressly/goose/v3"
)

func RunMigrations() error {
	dbURL := os.Getenv("DATABASE_URL")
	if dbURL == "" {
		return fmt.Errorf("DATABASE_URL environment variable is required")
	}

	// Create a *sql.DB for migrations using pgx driver
	sqlDB, err := sql.Open("pgx", dbURL)
	if err != nil {
		return fmt.Errorf("failed to create sql.DB for migrations: %w", err)
	}
	defer sqlDB.Close()

	if err := goose.SetDialect("postgres"); err != nil {
		return err
	}

	if err := goose.Up(sqlDB, "migrations"); err != nil {
		return err
	}

	slog.Info("Migrations completed successfully")
	return nil
}


File: dashboard/index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="./src//assets/logo.jpg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>yc-dashboard</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


File: dashboard/tailwind.config.js
================================================
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [require("daisyui")],
  daisyui: {
    themes: [
      "night",
    ],
  },
};


File: dashboard/src/components/SideBar.jsx
================================================
// src/components/Sidebar.jsx
import React from "react";
import { Link, NavLink } from "react-router-dom";
import {
  CogIcon,
  DocumentTextIcon,
  HomeIcon,
  ShoppingBagIcon,
  Squares2X2Icon, // Icon for the main grouping section
  TagIcon,
  TruckIcon,
  UserGroupIcon,
} from "@heroicons/react/24/outline"; // Use outline style initially
import Logo from "../assets/logo.jpg";

const Sidebar = () => {
  // Group navigation items
  const groupedNavItems = [
    {
      name: "Main",
      icon: Squares2X2Icon, // Generic icon for the group
      items: [
        { name: "Dashboard", path: "/admin/dashboard", icon: HomeIcon },
      ],
    },
    {
      name: "Catalog",
      icon: ShoppingBagIcon, // Use an icon representative of the group
      items: [
        { name: "Products", path: "/admin/products", icon: ShoppingBagIcon },
        { name: "Categories", path: "/admin/categories", icon: TagIcon },
        { name: "Discounts", path: "/admin/discounts", icon: TagIcon }, // Add Discounts link
      ],
    },
    {
      name: "Sales",
      icon: DocumentTextIcon, // Use an icon representative of the group
      items: [
        { name: "Orders", path: "/admin/orders", icon: DocumentTextIcon },
        { name: "Customers", path: "/admin/customers", icon: UserGroupIcon },
      ],
    },
    {
      name: "Operations",
      icon: TruckIcon, // Use an icon representative of the group
      items: [
        { name: "Delivery", path: "/admin/delivery", icon: TruckIcon },
      ],
    },
    {
      name: "System",
      icon: CogIcon, // Use an icon representative of the group
      items: [
        { name: "Settings", path: "/admin/settings", icon: CogIcon },
      ],
    },
  ];

  return (
    <ul className="menu bg-neutral w-64 min-h-full p-4 text-base-content">
      <li className="mb-4 avatar">
        <div className="flex mask mask-hexagon items-center space-x-2 p-2">
          <img src={Logo} alt="Logo" />
        </div>
      </li>
      <div className="divider"></div>

      {groupedNavItems.map((group) => (
        <li key={group.name} tabIndex={0}>
          {/* Add tabIndex for keyboard accessibility */}
          <details open>
            {/* You can set open={false} to have groups collapsed by default */}
            <summary className="flex items-center">
              {/* Render the group icon */}
              <group.icon className="w-5 h-5 mr-2" />
              {group.name}
            </summary>
            <ul>
              {group.items.map((item) => (
                <li key={item.path}>
                  <NavLink
                    to={item.path}
                    className={({ isActive }) =>
                      isActive ? "active bg-primary text-primary-content" : ""}
                    end
                  >
                    {/* Render the item icon */}
                    <item.icon className="w-5 h-5" />
                    {item.name}
                  </NavLink>
                </li>
              ))}
            </ul>
          </details>
        </li>
      ))}
    </ul>
  );
};

export default Sidebar;


File: dashboard/src/pages/auth/LoginPage.jsx
================================================
// src/pages/auth/LoginPage.jsx
import React, { useState } from "react";
import { useNavigate } from "react-router-dom";
import { useAuthStore } from "../../stores/authStore";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { login as loginApiCall } from "../../services/api"; // Import the real API function
import { ArrowRightStartOnRectangleIcon } from "@heroicons/react/24/outline"; // Import icon if needed

// Optional: Define validation schema using Zod
const loginSchema = z.object({
  email: z.string().email({ message: "Please enter a valid email address." }),
  password: z.string().min(1, { message: "Password is required." }), // Adjust min length as needed
});

const LoginPage = () => {
  const navigate = useNavigate();
  const { login: loginAction } = useAuthStore(); // Get login action from store
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const { register, handleSubmit, formState: { errors } } = useForm({
    resolver: zodResolver(loginSchema),
  });

  const onSubmit = async (data) => {
    setLoading(true);
    setError("");
    try {
      console.log("Attempting to log in with:", data);
      const response = await loginApiCall(data.email, data.password); // Call the real API function
      console.log("Login response:", response.data);

      const { user, access_token } = response.data; // Extract user and access_token from response body

      // On success, update store and navigate
      loginAction(user, access_token); // Update Zustand store and localStorage
      navigate("/admin/dashboard", { replace: true }); // Go to dashboard
    } catch (err) {
      console.error("Login error:", err);
      // Try to get specific error message from response, fallback to generic message
      let errorMessage = "Login failed";
      if (err.response) {
        // Server responded with error status
        if (err.response.status === 401) {
          errorMessage = "Invalid email or password.";
        } else {
          errorMessage = err.response.data?.message ||
            err.response.statusText || errorMessage;
        }
      } else if (err.request) {
        // Request was made but no response received (network error)
        errorMessage = "Network error. Please check your connection.";
      } else {
        // Something else happened
        errorMessage = err.message || errorMessage;
      }
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="hero min-h-screen bg-base-200">
      <div className="hero-content flex-col">
        <div className="card flex-shrink-0 w-full bg-primary-content max-w-sm shadow-2xl border border-primary">
          <div className="card-body">
            <h1 className="text-2xl font-bold text-center">Login</h1>
            {error && <p className="text-red-500 text-sm">{error}</p>}
            <form onSubmit={handleSubmit(onSubmit)}>
              <div className="form-control">
                <label className="label">
                  <span className="label-text">Email</span>
                </label>
                <input
                  type="email"
                  placeholder="email@domain.com"
                  className={`input input-bordered ${
                    errors.email ? "input-error" : ""
                  }`}
                  {...register("email")}
                />
                {errors.email && (
                  <p className="text-red-500 text-xs">{errors.email.message}</p>
                )}
              </div>
              <div className="form-control">
                <label className="label">
                  <span className="label-text">Password</span>
                </label>
                <input
                  type="password"
                  placeholder="password"
                  className={`input input-bordered ${
                    errors.password ? "input-error" : ""
                  }`}
                  {...register("password")}
                />
                {errors.password && (
                  <p className="text-red-500 text-xs">
                    {errors.password.message}
                  </p>
                )}
              </div>
              <div className="form-control mt-6">
                <button
                  type="submit"
                  className="btn btn-primary"
                  disabled={loading}
                >
                  {loading
                    ? (
                      <>
                        <span className="loading loading-spinner loading-xs mr-2">
                        </span>{" "}
                        Logging In...
                      </>
                    )
                    : "Login"}
                </button>
              </div>
            </form>
          </div>
        </div>
      </div>
    </div>
  );
};

export default LoginPage;


File: dashboard/src/pages/discounts/DiscountsList.jsx
================================================
// src/pages/discounts/DiscountsList.jsx
import React, { useState } from "react";
import { Link } from "react-router-dom";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { deleteDiscount, fetchDiscounts } from "../../services/api";
import {
  PencilSquareIcon,
  PlusCircleIcon,
  TrashIcon,
} from "@heroicons/react/24/outline";
import { toast } from "sonner";

const DiscountsList = () => {
  const queryClient = useQueryClient();

  // State for pagination
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage, setItemsPerPage] = useState(20);

  // State for active filter (boolean)
  const [filterActiveOnly, setFilterActiveOnly] = useState(null); // null = all, true = active only, false = inactive only

  const buildQueryParams = () => {
    const params = {
      page: currentPage,
      limit: itemsPerPage,
    };
    // Add filter parameter if it exists
    if (filterActiveOnly !== null) {
      params.is_active = filterActiveOnly.toString(); // Convert boolean to string ("true" or "false")
    }
    return params;
  };

  const {
    data,
    isLoading,
    isError,
    error,
    refetch,
  } = useQuery({
    queryKey: ["discounts", currentPage, itemsPerPage, filterActiveOnly], // Include filter in key
    queryFn: () => fetchDiscounts(buildQueryParams()),
    select: (response) => {
      // Assuming the response structure is {  [...], pagination_info }
      // Adjust based on your actual API response shape for discounts list
      const { data, page, limit, total, total_pages } = response.data;
      return {
        discounts: data,
        pagination: { page, limit, total, totalPages: total_pages },
      };
    },
  });

  const { discounts = [], pagination } = data || {};

  const deleteMutation = useMutation({
    mutationFn: deleteDiscount,
    onSuccess: (data, deletedId) => {
      queryClient.invalidateQueries({ queryKey: ["discounts"] });
      toast.success(`Discount ID ${deletedId} deleted successfully.`);
    },
    onError: (error, deletedId) => {
      console.error("Delete Error:", error);
      toast.error(
        `Failed to delete discount ID ${deletedId}: ${
          error.message || "Unknown error"
        }`,
      );
    },
  });

  const handleDelete = (discountId) => {
    if (
      window.confirm(
        `Are you sure you want to delete discount ID: ${discountId}? This action cannot be undone.`,
      )
    ) {
      deleteMutation.mutate(discountId);
    }
  };

  // Handler for changing pages
  const goToPage = (newPage) => {
    if (pagination) {
      const { page: currentPageFromMeta, totalPages } = pagination;
      if (newPage >= 1 && (!totalPages || newPage <= totalPages)) {
        setCurrentPage(newPage);
      }
    } else {
      if (newPage >= 1) {
        setCurrentPage(newPage);
      }
    }
  };

  // Handler for changing items per page
  const handleItemsPerPageChange = (newLimit) => {
    setItemsPerPage(newLimit);
    setCurrentPage(1); // Reset to first page when limit changes
  };

  // Handler for active filter toggle change
  const handleFilterActiveToggle = (e) => {
    // Toggle between null (all), true (active only), false (inactive only)
    if (filterActiveOnly === null) {
      setFilterActiveOnly(true); // Switch to active only
    } else if (filterActiveOnly === true) {
      setFilterActiveOnly(false); // Switch to inactive only
    } else { // filterActiveOnly is false
      setFilterActiveOnly(null); // Switch to all
    }
    setCurrentPage(1); // Reset to first page when filter changes
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  }

  if (isError) {
    return (
      <div className="alert alert-error shadow-lg">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          className="stroke-current flex-shrink-0 h-6 w-6"
          fill="none"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="2"
            d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"
          />
        </svg>
        <span>Error: {error.message}</span>
        <button onClick={() => refetch()} className="btn btn-sm">Retry</button>
      </div>
    );
  }

  // Helper function to truncate UUID
  const truncateUuid = (uuid) => {
    if (!uuid || typeof uuid !== "string") return "N/A";
    return `${uuid.substring(0, 8)}...`;
  };

  // Helper function to format date
  const formatDate = (dateString) => {
    if (!dateString) return "N/A";
    return new Date(dateString).toLocaleString();
  };

  // Determine the label for the toggle based on its current state
  let toggleLabel = "All";
  if (filterActiveOnly === true) {
    toggleLabel = "Active Only";
  } else if (filterActiveOnly === false) {
    toggleLabel = "Inactive Only";
  }

  return (
    <div className="bg-neutral p-6 rounded-lg shadow-md">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-xl font-bold">Discounts</h2>
        <Link
          to="/admin/discounts/add"
          className="btn btn-accent flex items-center gap-2"
        >
          <PlusCircleIcon className="w-5 h-5" />
          Add Discount
        </Link>
      </div>

      {/* Filter Controls */}
      <div className="bg-base-100 p-4 rounded-box mb-4 flex flex-wrap items-center gap-4">
        <div className="form-control">
          <label className="label cursor-pointer justify-between gap-2">
            <span className="label-text">Status Filter</span>
            <div className="flex items-center gap-2">
              <span
                className={`text-xs ${
                  filterActiveOnly === null ? "font-bold" : ""
                }`}
              >
                All
              </span>
              <input
                type="checkbox"
                className="toggle toggle-primary"
                checked={filterActiveOnly === true} // Checked when active only
                onChange={handleFilterActiveToggle}
              />
              <span
                className={`text-xs ${
                  filterActiveOnly === true ? "font-bold" : ""
                }`}
              >
                Active
              </span>
            </div>
          </label>
        </div>
        {/* Add more filters here if needed (e.g., date range, type) */}
      </div>

      {/* Pagination Controls Top */}
      {pagination && (
        <div className="flex flex-col sm:flex-row justify-between items-center mb-4 gap-2">
          <div className="text-sm">
            Showing {(pagination.page - 1) * pagination.limit + 1} -
            {Math.min(pagination.page * pagination.limit, pagination.total)} of
            {" "}
            {pagination.total} discounts
          </div>
          <div className="join">
            <button
              className="join-item btn btn-xs"
              onClick={() => goToPage(pagination.page - 1)}
              disabled={pagination.page <= 1}
            >
              « Prev
            </button>
            <button className="join-item btn btn-xs">
              Page {pagination.page} of {pagination.totalPages}
            </button>
            <button
              className="join-item btn btn-xs"
              onClick={() => goToPage(pagination.page + 1)}
              disabled={pagination.page >= pagination.totalPages}
            >
              Next »
            </button>
          </div>
          <select
            className="select select-bordered select-xs w-24"
            value={itemsPerPage}
            onChange={(e) => handleItemsPerPageChange(Number(e.target.value))}
          >
            <option value={10}>10/page</option>
            <option value={20}>20/page</option>
            <option value={50}>50/page</option>
            <option value={100}>100/page</option>
          </select>
        </div>
      )}

      <div className="overflow-x-auto">
        <table className="table table-zebra w-full">
          <thead>
            <tr>
              <th>ID (Truncated)</th>
              <th>Code</th>
              <th>Name</th>
              <th>Type</th>
              <th>Value</th>
              <th>Valid From</th>
              <th>Valid Until</th>
              <th>Active</th>
              <th>Created At</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {discounts.length > 0
              ? (
                discounts.map((discount) => {
                  const statusClass = discount.is_active
                    ? "badge-success"
                    : "badge-error";

                  return (
                    <tr key={discount.id}>
                      <td title={discount.id}>{truncateUuid(discount.id)}</td>
                      <td>{discount.code}</td>
                      <td>{discount.name}</td>
                      <td>{discount.discount_type}</td>
                      <td>{discount.discount_value}</td>
                      <td>{formatDate(discount.valid_from)}</td>
                      <td>{formatDate(discount.valid_until)}</td>
                      <td>
                        <span className={`badge ${statusClass}`}>
                          {discount.is_active ? "Yes" : "No"}
                        </span>
                      </td>
                      <td>{new Date(discount.created_at).toLocaleString()}</td>
                      <td>
                        <div className="flex gap-2">
                          <Link
                            to={`/admin/discounts/${discount.id}/edit`}
                            className="btn btn-xs btn-info"
                          >
                            <PencilSquareIcon className="w-4 h-4" />
                          </Link>
                          <button
                            className="btn btn-xs btn-error"
                            onClick={() => handleDelete(discount.id)}
                            disabled={deleteMutation.isPending}
                          >
                            {deleteMutation.isPending &&
                                deleteMutation.variables === discount.id
                              ? (
                                <span className="loading loading-spinner loading-xs">
                                </span>
                              )
                              : <TrashIcon className="w-4 h-4" />}
                          </button>
                        </div>
                      </td>
                    </tr>
                  );
                })
              )
              : (
                <tr>
                  <td colSpan="14" className="text-center py-4">
                    No discounts found.
                  </td>
                </tr>
              )}
          </tbody>
        </table>
      </div>

      {/* Pagination Controls Bottom */}
      {pagination && (
        <div className="flex flex-col sm:flex-row justify-between items-center mt-4 gap-2">
          <div className="text-sm">
            Showing {(pagination.page - 1) * pagination.limit + 1} -
            {Math.min(pagination.page * pagination.limit, pagination.total)} of
            {" "}
            {pagination.total} discounts
          </div>
          <div className="join">
            <button
              className="join-item btn btn-xs"
              onClick={() => goToPage(pagination.page - 1)}
              disabled={pagination.page <= 1}
            >
              « Prev
            </button>
            <button className="join-item btn btn-xs">
              Page {pagination.page} of {pagination.totalPages}
            </button>
            <button
              className="join-item btn btn-xs"
              onClick={() => goToPage(pagination.page + 1)}
              disabled={pagination.page >= pagination.totalPages}
            >
              Next »
            </button>
          </div>
          <select
            className="select select-bordered select-xs w-24"
            value={itemsPerPage}
            onChange={(e) => handleItemsPerPageChange(Number(e.target.value))}
          >
            <option value={10}>10/page</option>
            <option value={20}>20/page</option>
            <option value={50}>50/page</option>
            <option value={100}>100/page</option>
          </select>
        </div>
      )}
    </div>
  );
};

export default DiscountsList;


File: dashboard/src/pages/products/AddProduct.jsx
================================================
import React from "react";
import { useNavigate } from "react-router-dom";
import { useMutation, useQuery } from "@tanstack/react-query";
import { useFieldArray, useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { createProduct, fetchCategories } from "../../services/api";
import { toast } from "sonner";
import {
  ArrowLeftIcon,
  MinusIcon,
  PlusIcon,
} from "@heroicons/react/24/outline";
import FileUploadField from "../../components/FileUploadField";

// Define a schema for individual spec pairs
const specPairSchema = z.object({
  key: z.string().min(1, { message: "Key is required." }),
  value: z.string().min(1, { message: "Value is required." }),
});

// Modified main schema
const addProductSchema = z.object({
  name: z.string().min(2, { message: "Name must be at least 2 characters." }),
  description: z.string().optional(),
  short_description: z.string().optional(),
  price_cents: z.number().int().positive({
    message: "Price (in cents) must be a positive integer.",
  }),
  stock_quantity: z.number().int().gte(0, {
    message: "Stock quantity cannot be negative.",
  }),
  status: z.enum(["active", "draft", "discontinued"], {
    message: "Status must be active, draft, or discontinued.",
  }),
  brand: z.string().min(1, { message: "Brand is required." }),
  category_id: z.uuid({
    message: "Category ID must be a valid UUID.",
  }),
  spec_highlights: z.array(specPairSchema).optional(),
  images: z.array(z.instanceof(File)).optional(),
});

const AddProduct = () => {
  const navigate = useNavigate();

  const {
    data: categories,
    isLoading: categoriesLoading,
    error: categoriesError,
  } = useQuery({
    queryKey: ["categories"],
    queryFn: fetchCategories,
    select: (response) => response.data.data.data,
  });
  console.log(categories);

  const createProductMutation = useMutation({
    mutationFn: createProduct,
    onSuccess: (data) => {
      console.log("Product created successfully:", data.data);
      toast.success("Product created successfully!");
      navigate("/admin/products");
    },
    onError: (error) => {
      console.error("Create Product Error:", error);
      let errorMessage = "Failed to create product.";
      if (error.response?.data?.message) {
        errorMessage = error.response.data.message;
      } else if (error.message) {
        errorMessage = error.message;
      }
      toast.error(errorMessage);
    },
  });

  const {
    register,
    control,
    handleSubmit,
    formState: { errors },
    setValue,
  } = useForm({
    resolver: zodResolver(addProductSchema),
    defaultValues: {
      status: "draft",
      spec_highlights: [],
    },
  });

  const { fields, append, remove } = useFieldArray({
    control,
    name: "spec_highlights",
  });

  const onSubmit = async (data) => {
    const formData = new FormData();

    // Append all fields except spec_highlights
    Object.entries(data).forEach(([key, value]) => {
      if (key !== "spec_highlights") {
        formData.append(key, value);
      }
    });

    // Append spec_highlights as JSON
    if (data.spec_highlights && data.spec_highlights.length > 0) {
      const specHighlightsObj = data.spec_highlights.reduce((obj, pair) => {
        obj[pair.key] = pair.value;
        return obj;
      }, {});
      formData.append("spec_highlights", JSON.stringify(specHighlightsObj));
    }
    // Add this line right before the image appending loop
    console.log("Submitting images:", data.images);

    // Append images
    if (data.images && data.images.length > 0) {
      data.images.forEach((file) => {
        console.log("Appending file:", file); // Optional: log each file being appended
        formData.append("images", file, file.name);
      });
    } else {
      console.log("No images to append or data.images is falsy/empty"); // Optional: log if no images
    }

    // Debug
    for (let [key, value] of formData.entries()) {
      console.log(key, value);
    }

    // Submit
    createProductMutation.mutate(formData);
  };
  if (categoriesLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  }

  if (categoriesError) {
    return (
      <div className="alert alert-error">
        Error loading categories: {categoriesError.message}
      </div>
    );
  }

  return (
    <div className="bg-neutral p-6 rounded-lg shadow-md max-w-4xl mx-auto border border-secondary">
      <div className="flex items-center mb-6">
        <button onClick={() => navigate(-1)} className="btn btn-ghost btn-sm">
          <ArrowLeftIcon className="w-5 h-5" />
        </button>
        <h2 className="text-xl font-bold ml-2">Add New Product</h2>
      </div>

      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
        {/* Name */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Name *</span>
          </label>
          <input
            type="text"
            className={`input input-bordered ${
              errors.name ? "input-error" : ""
            }`}
            {...register("name")}
          />
          {errors.name && (
            <p className="text-red-500 text-xs">{errors.name.message}</p>
          )}
        </div>

        {/* Description */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Description</span>
          </label>
          <textarea
            className={`textarea textarea-bordered ${
              errors.description ? "textarea-error" : ""
            }`}
            rows="3"
            {...register("description")}
          />
          {errors.description && (
            <p className="text-red-500 text-xs">{errors.description.message}</p>
          )}
        </div>

        {/* Short Description */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Short Description</span>
          </label>
          <input
            type="text"
            className={`input input-bordered ${
              errors.short_description ? "input-error" : ""
            }`}
            {...register("short_description")}
          />
          {errors.short_description && (
            <p className="text-red-500 text-xs">
              {errors.short_description.message}
            </p>
          )}
        </div>

        {/* Price (in cents) */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Price (in cents) *</span>
          </label>
          <input
            type="number"
            min="0"
            className={`input input-bordered ${
              errors.price_cents ? "input-error" : ""
            }`}
            {...register("price_cents", { valueAsNumber: true })}
          />
          {errors.price_cents && (
            <p className="text-red-500 text-xs">{errors.price_cents.message}</p>
          )}
        </div>

        {/* Category ID */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Category *</span>
          </label>
          <select
            className={`select select-bordered ${
              errors.category_id ? "select-error" : ""
            }`}
            {...register("category_id")}
          >
            <option value="">Select a category...</option>
            {Array.isArray(categories) &&
              categories.map((category) => (
                <option key={category.id} value={category.id}>
                  {category.name}
                </option>
              ))}
          </select>
          {errors.category_id && (
            <p className="text-red-500 text-xs">{errors.category_id.message}</p>
          )}
        </div>

        {/* Stock Quantity */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Stock Quantity *</span>
          </label>
          <input
            type="number"
            min="0"
            placeholder="0"
            className={`input input-bordered ${
              errors.stock_quantity ? "input-error" : ""
            }`}
            {...register("stock_quantity", { valueAsNumber: true })}
          />
          {errors.stock_quantity && (
            <p className="text-red-500 text-xs">
              {errors.stock_quantity.message}
            </p>
          )}
        </div>

        {/* Status */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Status *</span>
          </label>
          <select
            className={`select select-bordered ${
              errors.status ? "select-error" : ""
            }`}
            {...register("status")}
          >
            <option value="active">Active</option>
            <option value="draft">Draft</option>
            <option value="discontinued">Discontinued</option>
          </select>
          {errors.status && (
            <p className="text-red-500 text-xs">{errors.status.message}</p>
          )}
        </div>

        {/* Brand */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Brand *</span>
          </label>
          <input
            type="text"
            className={`input input-bordered ${
              errors.brand ? "input-error" : ""
            }`}
            {...register("brand")}
          />
          {errors.brand && (
            <p className="text-red-500 text-xs">{errors.brand.message}</p>
          )}
        </div>

        {/* Spec Highlights (Dynamic Form) */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Specification Highlights</span>
          </label>
          <div className="space-y-2">
            <button
              type="button"
              className="btn btn-xs btn-outline btn-secondary mb-2"
              onClick={() => append({ key: "", value: "" })}
            >
              <PlusIcon className="w-4 h-4 mr-1" /> Add Spec
            </button>
            {fields.map((field, index) => (
              <div key={field.id} className="flex gap-2 items-center">
                <input
                  type="text"
                  placeholder="Key (e.g., Processor)"
                  className={`input input-bordered input-sm flex-1 ${
                    errors.spec_highlights?.[index]?.key ? "input-error" : ""
                  }`}
                  {...register(`spec_highlights.${index}.key`)}
                />
                <input
                  type="text"
                  placeholder="Value (e.g., Intel i7)"
                  className={`input input-bordered input-sm flex-1 ${
                    errors.spec_highlights?.[index]?.value ? "input-error" : ""
                  }`}
                  {...register(`spec_highlights.${index}.value`)}
                />
                <button
                  type="button"
                  className="btn btn-xs btn-outline btn-error"
                  onClick={() =>
                    remove(index)}
                >
                  <MinusIcon className="w-4 h-4" />
                </button>
              </div>
            ))}
            {errors.spec_highlights && (
              <p className="text-red-500 text-xs">
                At least one spec is required and keys/values cannot be blank.
              </p>
            )}
          </div>
        </div>

        {/* Image Files */}
        <div className="form-control">
          <label className="label">
            <span className="label-text">Images * (Multiple allowed)</span>
          </label>
          <FileUploadField
            name="images"
            control={control}
            rules={{
              required: "At least one image file is required.",
              validate: (value) => {
                if (!value || value.length === 0) {
                  return "At least one image file is required.";
                }
                return true;
              },
            }}
            accept="image/*"
            multiple={true}
          />
        </div>

        {/* Submit Button */}
        <div className="form-control mt-6">
          <button
            type="submit"
            className="btn btn-primary"
            disabled={createProductMutation.isPending}
          >
            {createProductMutation.isPending
              ? (
                <>
                  <span className="loading loading-spinner loading-xs mr-2">
                  </span>
                  Creating...
                </>
              )
              : (
                "Create Product"
              )}
          </button>
        </div>
      </form>
    </div>
  );
};

export default AddProduct;


File: dashboard/src/main.jsx
================================================
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.jsx";
import "./index.css"; // Make sure this is imported
import { BrowserRouter } from "react-router-dom"; // Import BrowserRouter
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "sonner";

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, 
      retry: 1, 
    },
  },
});

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      {/* Wrap App with BrowserRouter */}
      <BrowserRouter>
        {/* Sonner Toaster for notifications */}
        <Toaster position="top-right" richColors />
        <App />
      </BrowserRouter>
    </QueryClientProvider>
  </React.StrictMode>,
);


File: dashboard/eslint.config.js
================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])


File: nginx.conf
================================================
server {
    listen 80;
    server_name ycinformatique.com www.ycinformatique.com;

    location / {
        proxy_pass http://website:80;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /dashboard {
        proxy_pass http://dashboard:80;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /api {
        proxy_pass http://backend:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}


File: internal/db/order.sql.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: order.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelOrder = `-- name: CancelOrder :one

UPDATE orders
SET 
    status = 'cancelled',
    cancelled_at = NOW(),
    completed_at = COALESCE(completed_at, NOW()), -- Set completed_at if it wasn't already
    updated_at = NOW()
WHERE id = $1
RETURNING 
    id, user_id, user_full_name, status, total_amount_cents, payment_method,
    province, city, phone_number_1, phone_number_2,
    notes, delivery_service_id, 
    created_at, updated_at, completed_at, cancelled_at
`

// Order items consistently
// Updates the status of an order to 'cancelled' and sets the cancelled_at and completed_at timestamps.
// This is a soft cancellation.
func (q *Queries) CancelOrder(ctx context.Context, orderID uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, cancelOrder, orderID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserFullName,
		&i.Status,
		&i.TotalAmountCents,
		&i.PaymentMethod,
		&i.Province,
		&i.City,
		&i.PhoneNumber1,
		&i.PhoneNumber2,
		&i.Notes,
		&i.DeliveryServiceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}

const countAllOrders = `-- name: CountAllOrders :one

SELECT COUNT(*) FROM orders
WHERE ($1::UUID ='00000000-0000-0000-0000-000000000000'OR user_id = $1) -- Nullable user filter
  AND ($2::TEXT = '' OR status = $2)
`

type CountAllOrdersParams struct {
	FilterUserID uuid.UUID `json:"filter_user_id"`
	FilterStatus string    `json:"filter_status"`
}

// Nullable status filter
// Counts all orders based on optional user and status filters.
func (q *Queries) CountAllOrders(ctx context.Context, arg CountAllOrdersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllOrders, arg.FilterUserID, arg.FilterStatus)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserOrders = `-- name: CountUserOrders :one
 
SELECT COUNT(*) FROM orders
WHERE user_id = $1 -- Fixed user ID, not a filter
  AND ($2::TEXT IS NULL OR status = $2)
`

type CountUserOrdersParams struct {
	UserID       uuid.UUID `json:"user_id"`
	FilterStatus *string   `json:"filter_status"`
}

// Only include items not marked as deleted in the cart
// Counts orders for a specific user based on optional status filter.
// NOTE: UserID is a specific user to count for, FilterStatus is optional.
func (q *Queries) CountUserOrders(ctx context.Context, arg CountUserOrdersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUserOrders, arg.UserID, arg.FilterStatus)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    user_id, user_full_name, status, total_amount_cents, payment_method,
    province, city, phone_number_1, phone_number_2,
    notes, delivery_service_id
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9,
    $10, $11
)
RETURNING id, user_id, user_full_name, status, total_amount_cents, payment_method,
         province, city, phone_number_1, phone_number_2,
         notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
`

type CreateOrderParams struct {
	UserID            uuid.UUID `json:"user_id"`
	UserFullName      string    `json:"user_full_name"`
	Status            string    `json:"status"`
	TotalAmountCents  int64     `json:"total_amount_cents"`
	PaymentMethod     string    `json:"payment_method"`
	Province          string    `json:"province"`
	City              string    `json:"city"`
	PhoneNumber1      string    `json:"phone_number_1"`
	PhoneNumber2      *string   `json:"phone_number_2"`
	Notes             *string   `json:"notes"`
	DeliveryServiceID uuid.UUID `json:"delivery_service_id"`
}

// Creates a new order with denormalized address fields and returns its details.
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.UserID,
		arg.UserFullName,
		arg.Status,
		arg.TotalAmountCents,
		arg.PaymentMethod,
		arg.Province,
		arg.City,
		arg.PhoneNumber1,
		arg.PhoneNumber2,
		arg.Notes,
		arg.DeliveryServiceID,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserFullName,
		&i.Status,
		&i.TotalAmountCents,
		&i.PaymentMethod,
		&i.Province,
		&i.City,
		&i.PhoneNumber1,
		&i.PhoneNumber2,
		&i.Notes,
		&i.DeliveryServiceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}

const decrementStockIfSufficient = `-- name: DecrementStockIfSufficient :one
UPDATE products
SET stock_quantity = stock_quantity - $1
WHERE id = $2 AND stock_quantity >= $1 -- The crucial condition
RETURNING id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at, deleted_at
`

type DecrementStockIfSufficientParams struct {
	DecrementAmount int32     `json:"decrement_amount"`
	ProductID       uuid.UUID `json:"product_id"`
}

type DecrementStockIfSufficientRow struct {
	ID               uuid.UUID          `json:"id"`
	CategoryID       uuid.UUID          `json:"category_id"`
	Name             string             `json:"name"`
	Slug             string             `json:"slug"`
	Description      *string            `json:"description"`
	ShortDescription *string            `json:"short_description"`
	PriceCents       int64              `json:"price_cents"`
	StockQuantity    int32              `json:"stock_quantity"`
	Status           string             `json:"status"`
	Brand            string             `json:"brand"`
	ImageUrls        []byte             `json:"image_urls"`
	SpecHighlights   []byte             `json:"spec_highlights"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
}

// Attempts to decrement the stock_quantity for a product by a given amount.
// Succeeds only if the resulting stock_quantity would be >= 0.
// Returns the updated product row if successful, or an error if insufficient stock.
// Note: The RETURNING clause might not be strictly necessary if we only care about RowsAffected.
// If RETURNING is omitted, the querier function will likely return sql.Result.
// Let's include RETURNING to get the updated stock if needed for debugging/logging.
func (q *Queries) DecrementStockIfSufficient(ctx context.Context, arg DecrementStockIfSufficientParams) (DecrementStockIfSufficientRow, error) {
	row := q.db.QueryRow(ctx, decrementStockIfSufficient, arg.DecrementAmount, arg.ProductID)
	var i DecrementStockIfSufficientRow
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrder = `-- name: GetOrder :one

SELECT 
    id, user_id, user_full_name, status, total_amount_cents, payment_method,
    province, city, phone_number_1, phone_number_2,
    notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
FROM orders
WHERE id = $1
`

// Array of quantities
// Retrieves an order by its ID with denormalized address fields.
func (q *Queries) GetOrder(ctx context.Context, orderID uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, orderID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserFullName,
		&i.Status,
		&i.TotalAmountCents,
		&i.PaymentMethod,
		&i.Province,
		&i.City,
		&i.PhoneNumber1,
		&i.PhoneNumber2,
		&i.Notes,
		&i.DeliveryServiceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}

const getOrderItemsByOrderID = `-- name: GetOrderItemsByOrderID :many
SELECT 
    id, order_id, product_id, product_name, price_cents, quantity, subtotal_cents, created_at, updated_at
FROM order_items
WHERE order_id = $1
ORDER BY created_at ASC
`

// Retrieves all items for a specific order ID.
func (q *Queries) GetOrderItemsByOrderID(ctx context.Context, orderID uuid.UUID) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, getOrderItemsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderItem
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.ProductName,
			&i.PriceCents,
			&i.Quantity,
			&i.SubtotalCents,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderWithItems = `-- name: GetOrderWithItems :many
SELECT 
    o.id, o.user_id, o.user_full_name, o.status, o.total_amount_cents, o.payment_method,
    o.province, o.city, o.phone_number_1, o.phone_number_2,
    o.notes, o.delivery_service_id, o.created_at, o.updated_at, o.completed_at, o.cancelled_at,
    oi.id AS item_id, oi.order_id AS item_order_id, oi.product_id AS item_product_id,
    oi.product_name AS item_product_name, oi.price_cents AS item_price_cents,
    oi.quantity AS item_quantity, oi.subtotal_cents AS item_subtotal_cents,
    oi.created_at AS item_created_at, oi.updated_at AS item_updated_at
FROM orders o
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE o.id = $1
ORDER BY oi.created_at ASC
`

type GetOrderWithItemsRow struct {
	ID                uuid.UUID          `json:"id"`
	UserID            uuid.UUID          `json:"user_id"`
	UserFullName      string             `json:"user_full_name"`
	Status            string             `json:"status"`
	TotalAmountCents  int64              `json:"total_amount_cents"`
	PaymentMethod     string             `json:"payment_method"`
	Province          string             `json:"province"`
	City              string             `json:"city"`
	PhoneNumber1      string             `json:"phone_number_1"`
	PhoneNumber2      *string            `json:"phone_number_2"`
	Notes             *string            `json:"notes"`
	DeliveryServiceID uuid.UUID          `json:"delivery_service_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	CompletedAt       pgtype.Timestamptz `json:"completed_at"`
	CancelledAt       pgtype.Timestamptz `json:"cancelled_at"`
	ItemID            uuid.UUID          `json:"item_id"`
	ItemOrderID       uuid.UUID          `json:"item_order_id"`
	ItemProductID     uuid.UUID          `json:"item_product_id"`
	ItemProductName   *string            `json:"item_product_name"`
	ItemPriceCents    *int64             `json:"item_price_cents"`
	ItemQuantity      *int32             `json:"item_quantity"`
	ItemSubtotalCents *int64             `json:"item_subtotal_cents"`
	ItemCreatedAt     pgtype.Timestamptz `json:"item_created_at"`
	ItemUpdatedAt     pgtype.Timestamptz `json:"item_updated_at"`
}

// Retrieves an order by its ID along with all its items, including denormalized address fields.
// This query uses a join and might return multiple rows if there are items.
// The service layer needs to aggregate these rows into a single Order object with a slice of OrderItems.
func (q *Queries) GetOrderWithItems(ctx context.Context, orderID uuid.UUID) ([]GetOrderWithItemsRow, error) {
	rows, err := q.db.Query(ctx, getOrderWithItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderWithItemsRow
	for rows.Next() {
		var i GetOrderWithItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserFullName,
			&i.Status,
			&i.TotalAmountCents,
			&i.PaymentMethod,
			&i.Province,
			&i.City,
			&i.PhoneNumber1,
			&i.PhoneNumber2,
			&i.Notes,
			&i.DeliveryServiceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.ItemID,
			&i.ItemOrderID,
			&i.ItemProductID,
			&i.ItemProductName,
			&i.ItemPriceCents,
			&i.ItemQuantity,
			&i.ItemSubtotalCents,
			&i.ItemCreatedAt,
			&i.ItemUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementStock = `-- name: IncrementStock :one
UPDATE products
SET stock_quantity = stock_quantity + $1
WHERE id = $2
RETURNING id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at, deleted_at
`

type IncrementStockParams struct {
	IncrementAmount int32     `json:"increment_amount"`
	ProductID       uuid.UUID `json:"product_id"`
}

type IncrementStockRow struct {
	ID               uuid.UUID          `json:"id"`
	CategoryID       uuid.UUID          `json:"category_id"`
	Name             string             `json:"name"`
	Slug             string             `json:"slug"`
	Description      *string            `json:"description"`
	ShortDescription *string            `json:"short_description"`
	PriceCents       int64              `json:"price_cents"`
	StockQuantity    int32              `json:"stock_quantity"`
	Status           string             `json:"status"`
	Brand            string             `json:"brand"`
	ImageUrls        []byte             `json:"image_urls"`
	SpecHighlights   []byte             `json:"spec_highlights"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
}

// Increments the stock_quantity for a product by a given amount.
// Suitable for releasing stock back when cancelling an order.
func (q *Queries) IncrementStock(ctx context.Context, arg IncrementStockParams) (IncrementStockRow, error) {
	row := q.db.QueryRow(ctx, incrementStock, arg.IncrementAmount, arg.ProductID)
	var i IncrementStockRow
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const insertOrderItemsBulk = `-- name: InsertOrderItemsBulk :exec
INSERT INTO order_items (order_id, product_id, product_name, price_cents, quantity)
SELECT
    $1 AS order_id, -- The single order ID for all items
    unnest($2::UUID[]) AS product_id, -- Array of product IDs
    unnest($3::TEXT[]) AS product_name, -- Array of product names (denormalized)
    unnest($4::BIGINT[]) AS price_cents, -- Array of final prices (including discounts)
    unnest($5::INTEGER[]) AS quantity
`

type InsertOrderItemsBulkParams struct {
	OrderID      uuid.UUID   `json:"order_id"`
	ProductIds   []uuid.UUID `json:"product_ids"`
	ProductNames []string    `json:"product_names"`
	PricesCents  []int64     `json:"prices_cents"`
	Quantities   []int32     `json:"quantities"`
}

// Inserts multiple order items efficiently in a single query.
// Requires arrays of equal length for product_ids, quantities, names, and prices_cents.
func (q *Queries) InsertOrderItemsBulk(ctx context.Context, arg InsertOrderItemsBulkParams) error {
	_, err := q.db.Exec(ctx, insertOrderItemsBulk,
		arg.OrderID,
		arg.ProductIds,
		arg.ProductNames,
		arg.PricesCents,
		arg.Quantities,
	)
	return err
}

const insertOrderItemsFromCart = `-- name: InsertOrderItemsFromCart :exec
INSERT INTO order_items (order_id, product_id, product_name, price_cents, quantity, created_at)
SELECT
    $1 AS order_id, -- The single order ID for all items
    ci.product_id,
    p.name AS product_name, -- Get the name from the products table
    COALESCE(vpcd.calculated_discounted_price_cents, p.price_cents) AS price_cents, -- Use the final price from the cart or fallback to original
    ci.quantity,
    NOW() -- Set the created_at timestamp for the order item
FROM
    cart_items ci
JOIN
    products p ON ci.product_id = p.id -- Join to get product name
LEFT JOIN
    v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id -- Join with the discount view to get final price
WHERE
    ci.cart_id = $2 -- Fetch items from the specific cart
    AND ci.deleted_at IS NULL
`

type InsertOrderItemsFromCartParams struct {
	OrderID uuid.UUID `json:"order_id"`
	CartID  uuid.UUID `json:"cart_id"`
}

// Inserts order items into the order_items table by copying them from the user's current cart.
// This ensures the item details (product, name, price, quantity) reflect the exact state of the cart at order creation time.
// It fetches the final price (including discounts) from the cart_items joined with the calculated discount view.
func (q *Queries) InsertOrderItemsFromCart(ctx context.Context, arg InsertOrderItemsFromCartParams) error {
	_, err := q.db.Exec(ctx, insertOrderItemsFromCart, arg.OrderID, arg.CartID)
	return err
}

const listAllOrders = `-- name: ListAllOrders :many

SELECT 
    id, user_id, user_full_name, status, total_amount_cents, payment_method,
    province, city, phone_number_1, phone_number_2,
    notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
FROM orders
WHERE ($1::UUID = '00000000-0000-0000-0000-000000000000'::UUID OR user_id = $1) -- Filter by user_id if provided
  AND ($2::TEXT = '' OR status = $2) -- Filter by status if provided
ORDER BY created_at DESC
LIMIT $4 OFFSET $3
`

type ListAllOrdersParams struct {
	FilterUserID uuid.UUID `json:"filter_user_id"`
	FilterStatus string    `json:"filter_status"`
	PageOffset   int32     `json:"page_offset"`
	PageLimit    int32     `json:"page_limit"`
}

// Page limit and offset
// Retrieves a paginated list of all orders with denormalized address fields, optionally filtered by status or user_id.
// Intended for admin use. Includes cancelled orders.
// If filter_user_id is the zero UUID ('00000000-0000-0000-0000-000000000000'), it retrieves orders for all users.
// If filter_status is an empty string (”), it retrieves orders of all statuses.
func (q *Queries) ListAllOrders(ctx context.Context, arg ListAllOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listAllOrders,
		arg.FilterUserID,
		arg.FilterStatus,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserFullName,
			&i.Status,
			&i.TotalAmountCents,
			&i.PaymentMethod,
			&i.Province,
			&i.City,
			&i.PhoneNumber1,
			&i.PhoneNumber2,
			&i.Notes,
			&i.DeliveryServiceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOrders = `-- name: ListUserOrders :many

SELECT 
    id, user_id, user_full_name, status, total_amount_cents, payment_method,
    province, city, phone_number_1, phone_number_2,
    notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
FROM orders
WHERE user_id = $1
  AND ($2::TEXT = '' OR status = $2) -- Filter by status if provided
  -- Explicitly exclude cancelled orders for user list
  AND cancelled_at IS NULL 
ORDER BY created_at DESC
LIMIT $4 OFFSET $3
`

type ListUserOrdersParams struct {
	UserID       uuid.UUID `json:"user_id"`
	FilterStatus string    `json:"filter_status"`
	PageOffset   int32     `json:"page_offset"`
	PageLimit    int32     `json:"page_limit"`
}

// Order items consistently
// Retrieves a paginated list of orders for a specific user with denormalized address fields, optionally filtered by status.
// Excludes cancelled orders by default. Admins should use ListAllOrders.
func (q *Queries) ListUserOrders(ctx context.Context, arg ListUserOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listUserOrders,
		arg.UserID,
		arg.FilterStatus,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserFullName,
			&i.Status,
			&i.TotalAmountCents,
			&i.PaymentMethod,
			&i.Province,
			&i.City,
			&i.PhoneNumber1,
			&i.PhoneNumber2,
			&i.Notes,
			&i.DeliveryServiceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :one

UPDATE orders
SET
    notes = COALESCE($1, notes), -- Use narg for potentially nil values
    updated_at = NOW()
WHERE id = $2
RETURNING id, user_id, user_full_name, status, total_amount_cents, payment_method,
         province, city, phone_number_1, phone_number_2,
         notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
`

type UpdateOrderParams struct {
	Notes   *string   `json:"notes"`
	OrderID uuid.UUID `json:"order_id"`
}

// Page limit and offset
// Updates other details of an order (notes, timestamps).
// Address fields are denormalized and set during creation.
func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrder, arg.Notes, arg.OrderID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserFullName,
		&i.Status,
		&i.TotalAmountCents,
		&i.PaymentMethod,
		&i.Province,
		&i.City,
		&i.PhoneNumber1,
		&i.PhoneNumber2,
		&i.Notes,
		&i.DeliveryServiceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders
SET status = $1::TEXT ,
    updated_at = NOW(),
    completed_at = CASE
        WHEN $1 IN ('delivered', 'cancelled') AND completed_at IS NULL THEN NOW()
        ELSE completed_at -- Don't overwrite if already set
    END,
    cancelled_at = CASE
        WHEN $1 = 'cancelled' AND cancelled_at IS NULL THEN NOW()
        ELSE cancelled_at -- Don't overwrite if already set
    END
WHERE id = $2
RETURNING id, user_id, user_full_name, status, total_amount_cents, payment_method,
         province, city, phone_number_1, phone_number_2,
         notes, delivery_service_id, created_at, updated_at, completed_at, cancelled_at
`

type UpdateOrderStatusParams struct {
	Status  string    `json:"status"`
	OrderID uuid.UUID `json:"order_id"`
}

// Updates the status of an order and manages completion/cancellation timestamps.
func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderStatus, arg.Status, arg.OrderID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserFullName,
		&i.Status,
		&i.TotalAmountCents,
		&i.PaymentMethod,
		&i.Province,
		&i.City,
		&i.PhoneNumber1,
		&i.PhoneNumber2,
		&i.Notes,
		&i.DeliveryServiceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}


File: internal/db/products.sql.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkCategorySlugExists = `-- name: CheckCategorySlugExists :one
SELECT EXISTS(
    SELECT 1 FROM categories
    WHERE slug = $1 
) AS exists
`

func (q *Queries) CheckCategorySlugExists(ctx context.Context, slug string) (bool, error) {
	row := q.db.QueryRow(ctx, checkCategorySlugExists, slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkSlugExists = `-- name: CheckSlugExists :one
SELECT EXISTS(SELECT 1 FROM products WHERE slug = $1 AND deleted_at IS NULL) AS exists
`

// Checks if a product slug already exists (excluding soft-deleted products).
func (q *Queries) CheckSlugExists(ctx context.Context, slug string) (bool, error) {
	row := q.db.QueryRow(ctx, checkSlugExists, slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countAllProducts = `-- name: CountAllProducts :one
SELECT COUNT(*) FROM products WHERE deleted_at IS NULL
`

func (q *Queries) CountAllProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCategories = `-- name: CountCategories :one
SELECT COUNT(*) FROM categories
`

func (q *Queries) CountCategories(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countCategories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM products p
LEFT JOIN v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id
WHERE p.deleted_at IS NULL
    -- Main text search filter (name, description)
    AND (
        $1::TEXT = '' 
        OR p.name ILIKE '%' || $1 || '%' 
        OR COALESCE(p.short_description, '') ILIKE '%' || $1 || '%' 
        OR to_tsvector('english', p.name || ' ' || COALESCE(p.short_description, '')) @@ plainto_tsquery('english', $1)
        OR p.spec_highlights::TEXT ILIKE '%' || $1 || '%'
    )
    -- Spec highlight filter: Check if apply_spec_filter is true, then match the value for the given key
    AND (NOT $2::BOOLEAN OR ($3::TEXT != '' AND p.spec_highlights ->> $3 ILIKE '%' || $4 || '%'))
    -- Category filter
    AND ($5::UUID = '00000000-0000-0000-0000-000000000000' OR p.category_id = $5)
    -- Brand filter
    AND ($6::TEXT = '' OR p.brand ILIKE '%' || $6 || '%')
    -- Price range filter
    AND ($7::BIGINT = 0 OR p.price_cents >= $7)
    AND ($8::BIGINT = 0 OR p.price_cents <= $8)
    -- Stock availability filter
    AND (
        ($9::BOOLEAN = false AND $9 IS NOT NULL)
        OR ($9 = true AND p.stock_quantity > 0)
        OR ($9 = false AND p.stock_quantity <= 0)
    )
    -- Discount filter
    AND ($10::BOOLEAN = false OR vpcd.has_active_discount = TRUE)
`

type CountProductsParams struct {
	Query                 string    `json:"query"`
	ApplySpecFilter       bool      `json:"apply_spec_filter"`
	SpecFilterKey         string    `json:"spec_filter_key"`
	SpecFilterValue       *string   `json:"spec_filter_value"`
	CategoryID            uuid.UUID `json:"category_id"`
	Brand                 string    `json:"brand"`
	MinPrice              int64     `json:"min_price"`
	MaxPrice              int64     `json:"max_price"`
	InStockOnly           bool      `json:"in_stock_only"`
	IncludeDiscountedOnly bool      `json:"include_discounted_only"`
}

func (q *Queries) CountProducts(ctx context.Context, arg CountProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts,
		arg.Query,
		arg.ApplySpecFilter,
		arg.SpecFilterKey,
		arg.SpecFilterValue,
		arg.CategoryID,
		arg.Brand,
		arg.MinPrice,
		arg.MaxPrice,
		arg.InStockOnly,
		arg.IncludeDiscountedOnly,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (
    name, slug, type
) VALUES (
    $1, $2, $3
) RETURNING id, name, slug, type, parent_id, created_at
`

type CreateCategoryParams struct {
	Name string `json:"name"`
	Slug string `json:"slug"`
	Type string `json:"type"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, createCategory, arg.Name, arg.Slug, arg.Type)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Type,
		&i.ParentID,
		&i.CreatedAt,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at
) VALUES (
    $1, 
    $2, 
    $3, 
    $4, 
    $5, 
    $6, 
    $7, 
    $8, 
    $9, 
    $10, 
    $11, 
    NOW(), -- created_at
    NOW()  -- updated_at
) 
RETURNING  id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	CategoryID       uuid.UUID `json:"category_id"`
	Name             string    `json:"name"`
	Slug             string    `json:"slug"`
	Description      *string   `json:"description"`
	ShortDescription *string   `json:"short_description"`
	PriceCents       int64     `json:"price_cents"`
	StockQuantity    int32     `json:"stock_quantity"`
	Status           string    `json:"status"`
	Brand            string    `json:"brand"`
	ImageUrls        []byte    `json:"image_urls"`
	SpecHighlights   []byte    `json:"spec_highlights"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.CategoryID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.ShortDescription,
		arg.PriceCents,
		arg.StockQuantity,
		arg.Status,
		arg.Brand,
		arg.ImageUrls,
		arg.SpecHighlights,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.AvgRating,
		&i.NumRatings,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCategory, id)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
UPDATE products
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, productID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProduct, productID)
	return err
}

const getCategory = `-- name: GetCategory :one
SELECT id, name, slug, type, parent_id, created_at 
FROM categories
WHERE id = $1
`

func (q *Queries) GetCategory(ctx context.Context, id uuid.UUID) (Category, error) {
	row := q.db.QueryRow(ctx, getCategory, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Type,
		&i.ParentID,
		&i.CreatedAt,
	)
	return i, err
}

const getCategoryBySlug = `-- name: GetCategoryBySlug :one
SELECT id, name, slug, type, parent_id, created_at 
FROM categories
WHERE slug = $1
`

func (q *Queries) GetCategoryBySlug(ctx context.Context, slug string) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryBySlug, slug)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Type,
		&i.ParentID,
		&i.CreatedAt,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetProduct(ctx context.Context, productID uuid.UUID) (Product, error) {
	row := q.db.QueryRow(ctx, getProduct, productID)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.AvgRating,
		&i.NumRatings,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductBySlug = `-- name: GetProductBySlug :one
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE slug = $1 AND deleted_at IS NULL
`

func (q *Queries) GetProductBySlug(ctx context.Context, slug string) (Product, error) {
	row := q.db.QueryRow(ctx, getProductBySlug, slug)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.AvgRating,
		&i.NumRatings,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listCategories = `-- name: ListCategories :many
SELECT id, name, slug, type, parent_id, created_at 
FROM categories
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListCategoriesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCategories(ctx context.Context, arg ListCategoriesParams) ([]Category, error) {
	rows, err := q.db.Query(ctx, listCategories, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Type,
			&i.ParentID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

type ListProductsParams struct {
	PageOffset int32 `json:"page_offset"`
	PageLimit  int32 `json:"page_limit"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProducts, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ShortDescription,
			&i.PriceCents,
			&i.StockQuantity,
			&i.Status,
			&i.Brand,
			&i.AvgRating,
			&i.NumRatings,
			&i.ImageUrls,
			&i.SpecHighlights,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByCategory = `-- name: ListProductsByCategory :many
SELECT id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at
FROM products
WHERE category_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type ListProductsByCategoryParams struct {
	CategoryID uuid.UUID `json:"category_id"`
	PageOffset int32     `json:"page_offset"`
	PageLimit  int32     `json:"page_limit"`
}

func (q *Queries) ListProductsByCategory(ctx context.Context, arg ListProductsByCategoryParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProductsByCategory, arg.CategoryID, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ShortDescription,
			&i.PriceCents,
			&i.StockQuantity,
			&i.Status,
			&i.Brand,
			&i.AvgRating,
			&i.NumRatings,
			&i.ImageUrls,
			&i.SpecHighlights,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsWithCategory = `-- name: ListProductsWithCategory :many
SELECT 
    p.id, p.category_id, p.name, p.slug, p.description, p.short_description, p.price_cents, p.stock_quantity, p.status, p.brand, p.avg_rating, p.num_ratings, p.image_urls, p.spec_highlights, p.created_at, p.updated_at, p.deleted_at,
    c.name as category_name,
    c.slug as category_slug,
    c.type as category_type
FROM products p
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.deleted_at IS NULL
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $1
`

type ListProductsWithCategoryParams struct {
	PageOffset int32 `json:"page_offset"`
	PageLimit  int32 `json:"page_limit"`
}

type ListProductsWithCategoryRow struct {
	Product      Product `json:"product"`
	CategoryName *string `json:"category_name"`
	CategorySlug *string `json:"category_slug"`
	CategoryType *string `json:"category_type"`
}

func (q *Queries) ListProductsWithCategory(ctx context.Context, arg ListProductsWithCategoryParams) ([]ListProductsWithCategoryRow, error) {
	rows, err := q.db.Query(ctx, listProductsWithCategory, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsWithCategoryRow
	for rows.Next() {
		var i ListProductsWithCategoryRow
		if err := rows.Scan(
			&i.Product.ID,
			&i.Product.CategoryID,
			&i.Product.Name,
			&i.Product.Slug,
			&i.Product.Description,
			&i.Product.ShortDescription,
			&i.Product.PriceCents,
			&i.Product.StockQuantity,
			&i.Product.Status,
			&i.Product.Brand,
			&i.Product.AvgRating,
			&i.Product.NumRatings,
			&i.Product.ImageUrls,
			&i.Product.SpecHighlights,
			&i.Product.CreatedAt,
			&i.Product.UpdatedAt,
			&i.Product.DeletedAt,
			&i.CategoryName,
			&i.CategorySlug,
			&i.CategoryType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsWithCategoryDetail = `-- name: ListProductsWithCategoryDetail :many
SELECT 
    p.id, p.category_id, p.name, p.slug, p.description, p.short_description, p.price_cents, p.stock_quantity, p.status, p.brand, p.avg_rating, p.num_ratings, p.image_urls, p.spec_highlights, p.created_at, p.updated_at, p.deleted_at,
    c.id, c.name, c.slug, c.type, c.parent_id, c.created_at
FROM products p
JOIN categories c ON p.category_id = c.id
WHERE p.category_id = $1 AND p.deleted_at IS NULL
ORDER BY p.created_at DESC
LIMIT $3 OFFSET $2
`

type ListProductsWithCategoryDetailParams struct {
	CategoryID uuid.UUID `json:"category_id"`
	PageOffset int32     `json:"page_offset"`
	PageLimit  int32     `json:"page_limit"`
}

type ListProductsWithCategoryDetailRow struct {
	Product  Product  `json:"product"`
	Category Category `json:"category"`
}

func (q *Queries) ListProductsWithCategoryDetail(ctx context.Context, arg ListProductsWithCategoryDetailParams) ([]ListProductsWithCategoryDetailRow, error) {
	rows, err := q.db.Query(ctx, listProductsWithCategoryDetail, arg.CategoryID, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsWithCategoryDetailRow
	for rows.Next() {
		var i ListProductsWithCategoryDetailRow
		if err := rows.Scan(
			&i.Product.ID,
			&i.Product.CategoryID,
			&i.Product.Name,
			&i.Product.Slug,
			&i.Product.Description,
			&i.Product.ShortDescription,
			&i.Product.PriceCents,
			&i.Product.StockQuantity,
			&i.Product.Status,
			&i.Product.Brand,
			&i.Product.AvgRating,
			&i.Product.NumRatings,
			&i.Product.ImageUrls,
			&i.Product.SpecHighlights,
			&i.Product.CreatedAt,
			&i.Product.UpdatedAt,
			&i.Product.DeletedAt,
			&i.Category.ID,
			&i.Category.Name,
			&i.Category.Slug,
			&i.Category.Type,
			&i.Category.ParentID,
			&i.Category.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProductsWithCategory = `-- name: SearchProductsWithCategory :many
SELECT 
    p.id, p.category_id, p.name, p.slug, p.description, p.short_description, p.price_cents, p.stock_quantity, p.status, p.brand, p.avg_rating, p.num_ratings, p.image_urls, p.spec_highlights, p.created_at, p.updated_at, p.deleted_at,
    c.name as category_name,
    c.slug as category_slug,
    c.type as category_type
FROM products p
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.deleted_at IS NULL
  AND ($1::TEXT = '' OR p.name ILIKE '%' || $1 || '%' OR COALESCE(p.short_description, '') ILIKE '%' || $1 || '%' OR to_tsvector('english', p.name || ' ' || COALESCE(p.short_description, '')) @@ plainto_tsquery('english', $1))
  AND ($2::UUID = '00000000-0000-0000-0000-000000000000' OR p.category_id = $2)
  AND ($3::TEXT = '' OR p.brand ILIKE '%' || $3 || '%')
  AND ($4::BIGINT = 0 OR p.price_cents >= $4)
  AND ($5::BIGINT = 0 OR p.price_cents <= $5)
  AND (($6::BOOLEAN = false AND $6 IS NOT NULL) OR ($6 = true AND p.stock_quantity > 0) OR ($6 = false AND p.stock_quantity <= 0))
ORDER BY p.created_at DESC
LIMIT $8 OFFSET $7
`

type SearchProductsWithCategoryParams struct {
	Query       string    `json:"query"`
	CategoryID  uuid.UUID `json:"category_id"`
	Brand       string    `json:"brand"`
	MinPrice    int64     `json:"min_price"`
	MaxPrice    int64     `json:"max_price"`
	InStockOnly bool      `json:"in_stock_only"`
	PageOffset  int32     `json:"page_offset"`
	PageLimit   int32     `json:"page_limit"`
}

type SearchProductsWithCategoryRow struct {
	Product      Product `json:"product"`
	CategoryName *string `json:"category_name"`
	CategorySlug *string `json:"category_slug"`
	CategoryType *string `json:"category_type"`
}

func (q *Queries) SearchProductsWithCategory(ctx context.Context, arg SearchProductsWithCategoryParams) ([]SearchProductsWithCategoryRow, error) {
	rows, err := q.db.Query(ctx, searchProductsWithCategory,
		arg.Query,
		arg.CategoryID,
		arg.Brand,
		arg.MinPrice,
		arg.MaxPrice,
		arg.InStockOnly,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProductsWithCategoryRow
	for rows.Next() {
		var i SearchProductsWithCategoryRow
		if err := rows.Scan(
			&i.Product.ID,
			&i.Product.CategoryID,
			&i.Product.Name,
			&i.Product.Slug,
			&i.Product.Description,
			&i.Product.ShortDescription,
			&i.Product.PriceCents,
			&i.Product.StockQuantity,
			&i.Product.Status,
			&i.Product.Brand,
			&i.Product.AvgRating,
			&i.Product.NumRatings,
			&i.Product.ImageUrls,
			&i.Product.SpecHighlights,
			&i.Product.CreatedAt,
			&i.Product.UpdatedAt,
			&i.Product.DeletedAt,
			&i.CategoryName,
			&i.CategorySlug,
			&i.CategoryType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProductsWithDiscounts = `-- name: SearchProductsWithDiscounts :many
SELECT
    p.id,
    p.category_id,
    c.name AS category_name,
    p.name,
    p.slug,
    p.description,
    p.short_description,
    p.price_cents AS original_price_cents,
    p.stock_quantity,
    p.status,
    p.brand,
    p.image_urls,
    p.spec_highlights,
    p.created_at,
    p.updated_at,
    p.deleted_at,
    p.avg_rating,
    p.num_ratings,
    vpcd.total_fixed_discount_cents::BIGINT,
    vpcd.combined_percentage_factor::FLOAT,
    COALESCE(vpcd.calculated_discounted_price_cents, p.price_cents) AS discounted_price_cents,
    -- Use the has_active_discount boolean directly from the view
    COALESCE(vpcd.has_active_discount, FALSE) AS has_active_discount
FROM
    products p
INNER JOIN categories c ON p.category_id = c.id -- Join with categories table
LEFT JOIN
    v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id
WHERE
    p.deleted_at IS NULL
    -- Main text search filter (name, description)
    AND (
        $1::TEXT = '' 
        OR p.name ILIKE '%' || $1 || '%' 
        OR COALESCE(p.short_description, '') ILIKE '%' || $1 || '%' 
        OR to_tsvector('english', p.name || ' ' || COALESCE(p.short_description, '')) @@ plainto_tsquery('english', $1)
        OR p.spec_highlights::TEXT ILIKE '%' || $1 || '%'
    )
    -- Spec highlight filter: Check if apply_spec_filter is true, then match the value for the given key
    AND (NOT $2::BOOLEAN OR ($3::TEXT != '' AND p.spec_highlights ->> $3 ILIKE '%' || $4 || '%'))
    -- Category filter
    AND ($5::UUID = '00000000-0000-0000-0000-000000000000' OR p.category_id = $5)
    -- Brand filter
    AND ($6::TEXT = '' OR p.brand ILIKE '%' || $6 || '%')
    -- Price range filter
    AND ($7::BIGINT = 0 OR p.price_cents >= $7)
    AND ($8::BIGINT = 0 OR p.price_cents <= $8)
    -- Stock availability filter
    AND (
        ($9::BOOLEAN = false AND $9 IS NOT NULL)
        OR ($9 = true AND p.stock_quantity > 0)
        OR ($9 = false AND p.stock_quantity <= 0)
    )
    -- Discount filter
    AND ($10::BOOLEAN = false OR vpcd.has_active_discount = TRUE)
ORDER BY
    p.created_at DESC
LIMIT $12 OFFSET $11
`

type SearchProductsWithDiscountsParams struct {
	Query                 string    `json:"query"`
	ApplySpecFilter       bool      `json:"apply_spec_filter"`
	SpecFilterKey         string    `json:"spec_filter_key"`
	SpecFilterValue       *string   `json:"spec_filter_value"`
	CategoryID            uuid.UUID `json:"category_id"`
	Brand                 string    `json:"brand"`
	MinPrice              int64     `json:"min_price"`
	MaxPrice              int64     `json:"max_price"`
	InStockOnly           bool      `json:"in_stock_only"`
	IncludeDiscountedOnly bool      `json:"include_discounted_only"`
	PageOffset            int32     `json:"page_offset"`
	PageLimit             int32     `json:"page_limit"`
}

type SearchProductsWithDiscountsRow struct {
	ID                           uuid.UUID          `json:"id"`
	CategoryID                   uuid.UUID          `json:"category_id"`
	CategoryName                 string             `json:"category_name"`
	Name                         string             `json:"name"`
	Slug                         string             `json:"slug"`
	Description                  *string            `json:"description"`
	ShortDescription             *string            `json:"short_description"`
	OriginalPriceCents           int64              `json:"original_price_cents"`
	StockQuantity                int32              `json:"stock_quantity"`
	Status                       string             `json:"status"`
	Brand                        string             `json:"brand"`
	ImageUrls                    []byte             `json:"image_urls"`
	SpecHighlights               []byte             `json:"spec_highlights"`
	CreatedAt                    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                    pgtype.Timestamptz `json:"updated_at"`
	DeletedAt                    pgtype.Timestamptz `json:"deleted_at"`
	AvgRating                    pgtype.Numeric     `json:"avg_rating"`
	NumRatings                   *int32             `json:"num_ratings"`
	VpcdTotalFixedDiscountCents  int64              `json:"vpcd_total_fixed_discount_cents"`
	VpcdCombinedPercentageFactor float64            `json:"vpcd_combined_percentage_factor"`
	DiscountedPriceCents         int64              `json:"discounted_price_cents"`
	HasActiveDiscount            bool               `json:"has_active_discount"`
}

// Searches for products and includes pre-calculated discount information using the view.
// Includes a flexible spec highlight filter for partial matching within values.
func (q *Queries) SearchProductsWithDiscounts(ctx context.Context, arg SearchProductsWithDiscountsParams) ([]SearchProductsWithDiscountsRow, error) {
	rows, err := q.db.Query(ctx, searchProductsWithDiscounts,
		arg.Query,
		arg.ApplySpecFilter,
		arg.SpecFilterKey,
		arg.SpecFilterValue,
		arg.CategoryID,
		arg.Brand,
		arg.MinPrice,
		arg.MaxPrice,
		arg.InStockOnly,
		arg.IncludeDiscountedOnly,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProductsWithDiscountsRow
	for rows.Next() {
		var i SearchProductsWithDiscountsRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.CategoryName,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ShortDescription,
			&i.OriginalPriceCents,
			&i.StockQuantity,
			&i.Status,
			&i.Brand,
			&i.ImageUrls,
			&i.SpecHighlights,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.AvgRating,
			&i.NumRatings,
			&i.VpcdTotalFixedDiscountCents,
			&i.VpcdCombinedPercentageFactor,
			&i.DiscountedPriceCents,
			&i.HasActiveDiscount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET
    name = COALESCE($2, name),
    slug = COALESCE($3, slug),
    type = COALESCE($4, type)
WHERE id = $1 
RETURNING id, name, slug, type, parent_id, created_at
`

type UpdateCategoryParams struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
	Slug string    `json:"slug"`
	Type string    `json:"type"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, updateCategory,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Type,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Type,
		&i.ParentID,
		&i.CreatedAt,
	)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET
    category_id = COALESCE($1, category_id),
    name = COALESCE($2, name),
    slug = COALESCE($3, slug),
    description = COALESCE($4, description),
    short_description = COALESCE($5, short_description),
    price_cents = COALESCE($6, price_cents),
    stock_quantity = COALESCE($7, stock_quantity),
    status = COALESCE($8, status),
    brand = COALESCE($9, brand),
    image_urls = COALESCE($10, image_urls),
    spec_highlights = COALESCE($11, spec_highlights),
    updated_at = NOW()
WHERE id = $12 AND deleted_at IS NULL
RETURNING  id, category_id, name, slug, description, short_description, price_cents, stock_quantity, status, brand, 
    avg_rating, num_ratings,image_urls, spec_highlights, created_at, updated_at, deleted_at
`

type UpdateProductParams struct {
	CategoryID       uuid.UUID `json:"category_id"`
	Name             string    `json:"name"`
	Slug             string    `json:"slug"`
	Description      *string   `json:"description"`
	ShortDescription *string   `json:"short_description"`
	PriceCents       int64     `json:"price_cents"`
	StockQuantity    int32     `json:"stock_quantity"`
	Status           string    `json:"status"`
	Brand            string    `json:"brand"`
	ImageUrls        []byte    `json:"image_urls"`
	SpecHighlights   []byte    `json:"spec_highlights"`
	ProductID        uuid.UUID `json:"product_id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.CategoryID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.ShortDescription,
		arg.PriceCents,
		arg.StockQuantity,
		arg.Status,
		arg.Brand,
		arg.ImageUrls,
		arg.SpecHighlights,
		arg.ProductID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.PriceCents,
		&i.StockQuantity,
		&i.Status,
		&i.Brand,
		&i.AvgRating,
		&i.NumRatings,
		&i.ImageUrls,
		&i.SpecHighlights,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}


File: internal/db/queries/calculate_discounts.sql
================================================
-- name: GetProductWithDiscountInfo :one
SELECT
    p.id,
    p.category_id,
    c.name AS category_name,
    p.name,
    p.slug,
    p.description,
    p.short_description,
    p.price_cents AS original_price_cents,
    p.stock_quantity,
    p.status,
    p.brand,
    p.image_urls,
    p.spec_highlights,
    p.created_at,
    p.updated_at,
    p.deleted_at,
    p.avg_rating,
    p.num_ratings,
    vpcd.total_fixed_discount_cents::BIGINT,
    vpcd.combined_percentage_factor::FLOAT,
    COALESCE(vpcd.calculated_discounted_price_cents, p.price_cents) AS discounted_price_cents,
    -- Use the has_active_discount boolean directly from the view
    COALESCE(vpcd.has_active_discount, FALSE) AS has_active_discount
FROM
    products p
INNER JOIN categories c ON p.category_id = c.id -- Join with categories table
LEFT JOIN
    v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id
WHERE
    p.id = $1 AND p.deleted_at IS NULL;

-- Query: GetProductWithDiscountInfoBySlug
-- Retrieves a specific product by slug along with its calculated discount information using the pre-calculated view.

-- name: GetProductWithDiscountInfoBySlug :one
SELECT
    p.id,
    p.category_id,
    c.name AS category_name,
    p.name,
    p.slug,
    p.description,
    p.short_description,
    p.price_cents AS original_price_cents,
    p.stock_quantity,
    p.status,
    p.brand,
    p.image_urls,
    p.spec_highlights,
    p.created_at,
    p.updated_at,
    p.deleted_at,
    p.avg_rating,
    p.num_ratings,
    vpcd.total_fixed_discount_cents::BIGINT,
    vpcd.combined_percentage_factor::FLOAT,
    COALESCE(vpcd.calculated_discounted_price_cents, p.price_cents) AS discounted_price_cents,
    -- Use the has_active_discount boolean directly from the view
    COALESCE(vpcd.has_active_discount, FALSE) AS has_active_discount
FROM
    products p
INNER JOIN categories c ON p.category_id = c.id -- Join with categories table
LEFT JOIN
    v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id
WHERE
    p.slug = $1 AND p.deleted_at IS NULL;

-- name: GetProductsWithDiscountInfo :many
SELECT
    p.id,
    p.category_id,
    c.name AS category_name,
    p.name,
    p.slug,
    p.description,
    p.short_description,
    p.price_cents AS original_price_cents,
    p.stock_quantity,
    p.status,
    p.brand,
    p.image_urls,
    p.spec_highlights,
    p.created_at,
    p.updated_at,
    p.deleted_at,
    p.avg_rating,
    p.num_ratings,
    vpcd.total_fixed_discount_cents::BIGINT,
    vpcd.combined_percentage_factor::FLOAT,
    COALESCE(vpcd.calculated_discounted_price_cents, p.price_cents) AS discounted_price_cents,
    -- Use the has_active_discount boolean directly from the view
    COALESCE(vpcd.has_active_discount, FALSE) AS has_active_discount
FROM
    products p
INNER JOIN categories c ON p.category_id = c.id -- Join with categories table
LEFT JOIN
    v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id
WHERE
    p.deleted_at IS NULL -- Add other filters if needed (e.g., category, price range)
ORDER BY
    p.created_at DESC -- Or other ordering
LIMIT $1 OFFSET $2; -- $1 = page_limit, $2 = page_offset


-- name: GetCartWithItemsAndProductsWithDiscounts :many
-- Assuming this returns one cart object with many items
SELECT
    c.id AS cart_id,
    c.user_id,
    c.session_id,
    c.created_at,
    c.updated_at,
    -- Cart Items
    ci.id AS item_id,
    ci.cart_id AS item_cart_id,
    ci.product_id AS item_product_id,
    ci.quantity AS item_quantity,
    ci.created_at AS item_created_at,
    ci.updated_at AS item_updated_at,
    -- Product Details (with discount calculation from the view)
    p.id AS product_id,
    p.name AS product_name,
    p.price_cents AS original_price_cents,
    p.stock_quantity AS product_stock_quantity,
    p.image_urls AS product_image_urls,
    p.brand AS product_brand,
    -- Use the pre-calculated discounted price from the view
    COALESCE(vpcd.calculated_discounted_price_cents, p.price_cents, 0)::BIGINT AS final_price_cents, -- This is the price *per unit* after discount
    -- Use the has_active_discount boolean directly from the view
    COALESCE(vpcd.has_active_discount, FALSE) AS has_active_discount,
    -- Include the breakdown fields for potential use in the cart context
 COALESCE(vpcd.total_fixed_discount_cents, 0)::BIGINT AS vpcd_total_fixed_discount_cents, -- Fallback to 0
    COALESCE(vpcd.combined_percentage_factor, 1.0)::FLOAT AS vpcd_combined_percentage_factor -- Fallback to 1.0 (no discount factor)
FROM
    carts c
LEFT JOIN
    cart_items ci ON c.id = ci.cart_id AND ci.deleted_at IS NULL
LEFT JOIN
    products p ON ci.product_id = p.id AND p.deleted_at IS NULL
LEFT JOIN
    v_products_with_calculated_discounts vpcd ON p.id = vpcd.product_id -- Join with the view
WHERE
    c.id = $1 AND c.deleted_at IS NULL
ORDER BY
    ci.created_at ASC; -- Or other ordering for items


File: internal/db/queries/delivery_services.sql
================================================
-- name: GetDeliveryServiceByID :one
-- Retrieves a delivery service by its ID, regardless of its active status.
-- Suitable for admin operations.
SELECT id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
FROM delivery_services
WHERE id = sqlc.arg(id);

-- name: GetActiveDeliveryServices :many
-- Retrieves all delivery services that are currently active.
-- Suitable for user-facing contexts like checkout.
SELECT id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
FROM delivery_services
WHERE is_active = TRUE
ORDER BY name ASC;

-- name: ListAllDeliveryServices :many
-- Retrieves delivery services, optionally filtered by active status.
-- Suitable for admin operations.
SELECT id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
FROM delivery_services
WHERE is_active = sqlc.arg(active_filter) -- Filter by active status
ORDER BY name ASC
LIMIT sqlc.arg(page_limit) OFFSET sqlc.arg(page_offset);

-- name: CreateDeliveryService :one
INSERT INTO delivery_services (
    name, description, base_cost_cents, estimated_days, is_active
) VALUES (
    sqlc.arg(name), sqlc.arg(description), sqlc.arg(base_cost_cents), sqlc.arg(estimated_days), sqlc.arg(is_active)
)
RETURNING id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at;

-- name: GetDeliveryService :one
SELECT id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
FROM delivery_services
WHERE id = sqlc.arg(id) AND is_active = sqlc.arg(active_filter); -- Allow filtering by active status

-- name: GetDeliveryServiceByName :one
SELECT id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
FROM delivery_services
WHERE name = sqlc.arg(name) AND is_active = sqlc.arg(active_filter); -- Allow filtering by active status

-- name: UpdateDeliveryService :one
UPDATE delivery_services
SET
    name = COALESCE(sqlc.narg(name), name),
    description = COALESCE(sqlc.narg(description), description),
    base_cost_cents = COALESCE(sqlc.narg(base_cost_cents), base_cost_cents),
    estimated_days = COALESCE(sqlc.narg(estimated_days), estimated_days),
    is_active = COALESCE(sqlc.narg(is_active), is_active),
    updated_at = NOW()
WHERE id = sqlc.arg(id)
RETURNING id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at;

-- name: DeleteDeliveryService :exec
-- Soft delete could be achieved by updating is_active to FALSE
-- For hard delete:
DELETE FROM delivery_services WHERE id = sqlc.arg(id);


File: internal/db/review.sql.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: review.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const calculateReviewStatsForProduct = `-- name: CalculateReviewStatsForProduct :one
SELECT
    AVG(r.rating)::NUMERIC(3,2) AS avg_rating,
    COUNT(r.rating)::INTEGER AS num_ratings
FROM reviews r
WHERE r.product_id = $1 AND r.deleted_at IS NULL
`

type CalculateReviewStatsForProductRow struct {
	AvgRating  pgtype.Numeric `json:"avg_rating"`
	NumRatings int32          `json:"num_ratings"`
}

// Calculates the average rating and count of non-deleted reviews for a specific product.
// Used to update the products table.
func (q *Queries) CalculateReviewStatsForProduct(ctx context.Context, productID uuid.UUID) (CalculateReviewStatsForProductRow, error) {
	row := q.db.QueryRow(ctx, calculateReviewStatsForProduct, productID)
	var i CalculateReviewStatsForProductRow
	err := row.Scan(&i.AvgRating, &i.NumRatings)
	return i, err
}

const createReview = `-- name: CreateReview :one
INSERT INTO reviews (
    user_id, product_id, rating
) VALUES (
    $1, $2, $3
)
RETURNING id, user_id, product_id, rating, created_at, updated_at
`

type CreateReviewParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ProductID uuid.UUID `json:"product_id"`
	Rating    int32     `json:"rating"`
}

type CreateReviewRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	ProductID uuid.UUID          `json:"product_id"`
	Rating    int32              `json:"rating"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Inserts a new review and returns its details.
// NOTE: This query alone does not update the product's avg_rating/num_ratings.
func (q *Queries) CreateReview(ctx context.Context, arg CreateReviewParams) (CreateReviewRow, error) {
	row := q.db.QueryRow(ctx, createReview, arg.UserID, arg.ProductID, arg.Rating)
	var i CreateReviewRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteReview = `-- name: DeleteReview :one
UPDATE reviews
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = $1 AND user_id = $2 -- Ensure user owns the review
RETURNING id, user_id, product_id, rating, created_at, updated_at
`

type DeleteReviewParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

type DeleteReviewRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	ProductID uuid.UUID          `json:"product_id"`
	Rating    int32              `json:"rating"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Soft deletes a review by setting deleted_at.
// NOTE: This query alone does not update the product's avg_rating/num_ratings.
func (q *Queries) DeleteReview(ctx context.Context, arg DeleteReviewParams) (DeleteReviewRow, error) {
	row := q.db.QueryRow(ctx, deleteReview, arg.ID, arg.UserID)
	var i DeleteReviewRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReviewByIDAndUser = `-- name: GetReviewByIDAndUser :one
SELECT id, user_id, product_id, rating, created_at, updated_at
FROM reviews
WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL
`

type GetReviewByIDAndUserParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

type GetReviewByIDAndUserRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	ProductID uuid.UUID          `json:"product_id"`
	Rating    int32              `json:"rating"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Retrieves a specific review by its ID and verifies the user owns it.
func (q *Queries) GetReviewByIDAndUser(ctx context.Context, arg GetReviewByIDAndUserParams) (GetReviewByIDAndUserRow, error) {
	row := q.db.QueryRow(ctx, getReviewByIDAndUser, arg.ID, arg.UserID)
	var i GetReviewByIDAndUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReviewByUserAndProduct = `-- name: GetReviewByUserAndProduct :one
SELECT id, user_id, product_id, rating, created_at, updated_at
FROM reviews
WHERE user_id = $1 AND product_id = $2 AND deleted_at IS NULL
`

type GetReviewByUserAndProductParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ProductID uuid.UUID `json:"product_id"`
}

type GetReviewByUserAndProductRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	ProductID uuid.UUID          `json:"product_id"`
	Rating    int32              `json:"rating"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Retrieves a review by a specific user for a specific product.
func (q *Queries) GetReviewByUserAndProduct(ctx context.Context, arg GetReviewByUserAndProductParams) (GetReviewByUserAndProductRow, error) {
	row := q.db.QueryRow(ctx, getReviewByUserAndProduct, arg.UserID, arg.ProductID)
	var i GetReviewByUserAndProductRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReviewsByProductID = `-- name: GetReviewsByProductID :many
SELECT 
    r.id,
    r.user_id,
    r.product_id,
    r.rating,
    r.created_at,
    r.updated_at,
    u.full_name AS reviewer_name 
FROM reviews r
JOIN users u ON r.user_id = u.id -- INNER JOIN to link review to user
WHERE r.product_id = $1 AND r.deleted_at IS NULL
ORDER BY r.created_at DESC -- Or rating DESC, etc.
LIMIT $3 OFFSET $2
`

type GetReviewsByProductIDParams struct {
	ProductID  uuid.UUID `json:"product_id"`
	PageOffset int32     `json:"page_offset"`
	PageLimit  int32     `json:"page_limit"`
}

type GetReviewsByProductIDRow struct {
	ID           uuid.UUID          `json:"id"`
	UserID       uuid.UUID          `json:"user_id"`
	ProductID    uuid.UUID          `json:"product_id"`
	Rating       int32              `json:"rating"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	ReviewerName *string            `json:"reviewer_name"`
}

// Retrieves all reviews for a specific product, including the reviewer's name, potentially paginated.
func (q *Queries) GetReviewsByProductID(ctx context.Context, arg GetReviewsByProductIDParams) ([]GetReviewsByProductIDRow, error) {
	rows, err := q.db.Query(ctx, getReviewsByProductID, arg.ProductID, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsByProductIDRow
	for rows.Next() {
		var i GetReviewsByProductIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProductID,
			&i.Rating,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReviewerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsByUserID = `-- name: GetReviewsByUserID :many
SELECT 
    r.id,
    r.user_id,
    r.product_id,
    r.rating,
    r.created_at,
    r.updated_at,
    p.name AS product_name -- Join with products table to get the name
FROM reviews r
JOIN products p ON r.product_id = p.id -- INNER JOIN to link review to product
WHERE r.user_id = $1 AND r.deleted_at IS NULL
ORDER BY r.created_at DESC
LIMIT $3 OFFSET $2
`

type GetReviewsByUserIDParams struct {
	UserID     uuid.UUID `json:"user_id"`
	PageOffset int32     `json:"page_offset"`
	PageLimit  int32     `json:"page_limit"`
}

type GetReviewsByUserIDRow struct {
	ID          uuid.UUID          `json:"id"`
	UserID      uuid.UUID          `json:"user_id"`
	ProductID   uuid.UUID          `json:"product_id"`
	Rating      int32              `json:"rating"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	ProductName string             `json:"product_name"`
}

// Retrieves all reviews submitted by a specific user, including the product name, potentially paginated.
func (q *Queries) GetReviewsByUserID(ctx context.Context, arg GetReviewsByUserIDParams) ([]GetReviewsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getReviewsByUserID, arg.UserID, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsByUserIDRow
	for rows.Next() {
		var i GetReviewsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProductID,
			&i.Rating,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductReviewStats = `-- name: UpdateProductReviewStats :exec
UPDATE products
SET
    avg_rating = $1,
    num_ratings = $2,
    updated_at = NOW() -- Optionally update the product's general updated_at too
WHERE id = $3
`

type UpdateProductReviewStatsParams struct {
	AvgRating  pgtype.Numeric `json:"avg_rating"`
	NumRatings *int32         `json:"num_ratings"`
	ProductID  uuid.UUID      `json:"product_id"`
}

// Updates the avg_rating and num_ratings fields in the products table for a specific product.
func (q *Queries) UpdateProductReviewStats(ctx context.Context, arg UpdateProductReviewStatsParams) error {
	_, err := q.db.Exec(ctx, updateProductReviewStats, arg.AvgRating, arg.NumRatings, arg.ProductID)
	return err
}

const updateReview = `-- name: UpdateReview :one
UPDATE reviews
SET rating = $1, updated_at = NOW()
WHERE id = $2 AND user_id = $3 -- Ensure user owns the review
RETURNING id, user_id, product_id, rating, created_at, updated_at
`

type UpdateReviewParams struct {
	Rating int32     `json:"rating"`
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

type UpdateReviewRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	ProductID uuid.UUID          `json:"product_id"`
	Rating    int32              `json:"rating"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Updates the rating of an existing review.
// NOTE: This query alone does not update the product's avg_rating/num_ratings.
func (q *Queries) UpdateReview(ctx context.Context, arg UpdateReviewParams) (UpdateReviewRow, error) {
	row := q.db.QueryRow(ctx, updateReview, arg.Rating, arg.ID, arg.UserID)
	var i UpdateReviewRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}


File: internal/models/delivery_service.go
================================================
package models

import (
	"time"

	"github.com/google/uuid"
)

type DeliveryService struct {
	ID            uuid.UUID `json:"id"`
	Name          string    `json:"name"`
	Description   *string   `json:"description,omitempty"`
	BaseCostCents int64     `json:"base_cost_cents"`          // Base cost for this service
	EstimatedDays *int32    `json:"estimated_days,omitempty"` // Estimated delivery time
	IsActive      bool      `json:"is_active"`                // Whether the service is currently offered
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
}

// CreateDeliveryServiceRequest represents data to create a new delivery service.
type CreateDeliveryServiceRequest struct {
	Name          string  `json:"name" validate:"required,max=255"`
	Description   *string `json:"description,omitempty"`
	BaseCostCents int64   `json:"base_cost_cents" validate:"min=0"` // Cost in cents
	EstimatedDays *int32  `json:"estimated_days,omitempty" validate:"omitempty,min=1"`
	IsActive      bool    `json:"is_active"`
}

// UpdateDeliveryServiceRequest represents data to update an existing delivery service.
type UpdateDeliveryServiceRequest struct {
	Name          *string `json:"name,omitempty" validate:"omitempty,max=255"`
	Description   *string `json:"description,omitempty"`
	BaseCostCents *int64  `json:"base_cost_cents,omitempty" validate:"omitempty,min=0"`
	EstimatedDays *int32  `json:"estimated_days,omitempty" validate:"omitempty,min=1"`
	IsActive      *bool   `json:"is_active,omitempty"`
}

// Validate methods for request structs
func (r *CreateDeliveryServiceRequest) Validate() error {
	return Validate.Struct(r)
}

func (r *UpdateDeliveryServiceRequest) Validate() error {
	return Validate.Struct(r)
}


File: internal/models/discount.go
================================================
package models

import (
	"errors"
	"time"

	"github.com/go-playground/validator/v10"
	"github.com/google/uuid"
)

// DiscountType defines the type of discount.
type DiscountType string

const (
	DiscountTypePercentage DiscountType = "percentage"
	DiscountTypeFixed      DiscountType = "fixed" // Matches the schema
)

// Discount represents a discount rule.
// This model maps directly to the 'discounts' table in the database.
type Discount struct {
	ID                 uuid.UUID    `json:"id"`
	Code               string       `json:"code"`                  // Unique code for the discount
	Description        *string      `json:"description,omitempty"` // Nullable description
	DiscountType       DiscountType `json:"discount_type"`         // Either 'percentage' or 'fixed'
	DiscountValue      int64        `json:"discount_value"`        // e.g., 10 for 10%, 500 for $5
	MinOrderValueCents *int64       `json:"min_order_value_cents"` // Minimum order value (default 0)
	MaxUses            *int         `json:"max_uses,omitempty"`    // Nullable maximum uses (NULL means unlimited)
	CurrentUses        int          `json:"current_uses"`          // Counter for current usage (default 0)
	ValidFrom          time.Time    `json:"valid_from"`            // Start date for the discount
	ValidUntil         time.Time    `json:"valid_until"`           // End date for the discount
	IsActive           bool         `json:"is_active"`             // Whether the discount is currently active
	CreatedAt          time.Time    `json:"created_at"`            // Timestamp of creation
	UpdatedAt          time.Time    `json:"updated_at"`            // Timestamp of last update
}

// --- Request Models ---

// CreateDiscountRequest holds data for creating a new discount.
type CreateDiscountRequest struct {
	Code               string       `json:"code" validate:"required,max=50"`                            // Required, alphanumeric, max 50 chars
	Description        *string      `json:"description,omitempty"`                                      // Optional description
	DiscountType       DiscountType `json:"discount_type" validate:"required,oneof=percentage fixed"`   // Required, must be percentage or fixed
	DiscountValue      int64        `json:"discount_value" validate:"required,min=0"`                   // Required, non-negative
	MinOrderValueCents *int64       `json:"min_order_value_cents,omitempty" validate:"omitempty,min=0"` // Optional, non-negative
	MaxUses            *int         `json:"max_uses,omitempty" validate:"omitempty,min=1"`              // Optional, minimum 1 if provided
	ValidFrom          time.Time    `json:"valid_from" validate:"required"`                             // Required
	ValidUntil         time.Time    `json:"valid_until" validate:"required,gtfield=ValidFrom"`          // Required, must be after ValidFrom
	IsActive           bool         `json:"is_active"`                                                  // Required (true/false)
}

// UpdateDiscountRequest holds data for updating an existing discount.
// All fields are pointers, allowing partial updates.
type UpdateDiscountRequest struct {
	Code               *string       `json:"code,omitempty" validate:"omitempty,max=50"`                          // Optional, alphanumeric, max 50 chars
	Description        *string       `json:"description,omitempty"`                                               // Optional description
	DiscountType       *DiscountType `json:"discount_type,omitempty" validate:"omitempty,oneof=percentage fixed"` // Optional, must be percentage or fixed
	DiscountValue      *int64        `json:"discount_value,omitempty" validate:"omitempty,min=0"`                 // Optional, non-negative
	MinOrderValueCents *int64        `json:"min_order_value_cents,omitempty" validate:"omitempty,min=0"`          // Optional, non-negative
	MaxUses            *int          `json:"max_uses,omitempty" validate:"omitempty,min=1"`                       // Optional, minimum 1 if provided
	ValidFrom          *time.Time    `json:"valid_from,omitempty" validate:"omitempty"`                           // Optional datetime
	ValidUntil         *time.Time    `json:"valid_until,omitempty" validate:"omitempty,gtfield=ValidFrom"`        // Optional datetime, must be after ValidFrom if both are provided
	IsActive           *bool         `json:"is_active,omitempty"`                                                 // Optional (true/false)
}

// LinkDiscountRequest holds data for linking a discount to a product.
type LinkDiscountRequest struct {
	ProductID uuid.UUID `json:"product_id" validate:"required,uuid"` // Required product ID
}

// UnlinkDiscountRequest holds data for unlinking a discount from a product.
// This is identical to LinkDiscountRequest for this use case.
type UnlinkDiscountRequest struct {
	ProductID uuid.UUID `json:"product_id" validate:"required,uuid"` // Required product ID
}

// ListDiscountsRequest holds parameters for filtering and paginating discount lists.
type ListDiscountsRequest struct {
	IsActive   *bool      `json:"is_active,omitempty"`                      // Filter by active status (true/false)
	ValidFrom  *time.Time `json:"valid_from,omitempty"`                     // Filter by valid from date (discount starts on or after this date)
	ValidUntil *time.Time `json:"valid_until,omitempty"`                    // Filter by valid until date (discount ends on or before this date)
	Page       int        `json:"page" validate:"omitempty,min=1"`          // Page number (default 1)
	Limit      int        `json:"limit" validate:"omitempty,min=1,max=100"` // Number of items per page (default 20, max 100)
}

// --- Response Models ---

// DiscountListResponse wraps a list of discounts with pagination info.
type DiscountListResponse struct {
	Data       []Discount `json:"data"`
	Page       int        `json:"page"`
	Limit      int        `json:"limit"`
	Total      int64      `json:"total"`       // Total number of discounts matching the filter
	TotalPages int        `json:"total_pages"` // Total number of pages
}

// --- Validation Methods ---

// Validator instance (shared for efficiency)
var ValidateDiscount = validator.New()

// Validate runs validations defined by the 'validate' tags on the struct.
func (r *CreateDiscountRequest) Validate() error {
	return ValidateDiscount.Struct(r)
}

func (r *UpdateDiscountRequest) Validate() error {
	return ValidateDiscount.Struct(r)
}

func (r *LinkDiscountRequest) Validate() error {
	return ValidateDiscount.Struct(r)
}

func (r *UnlinkDiscountRequest) Validate() error {
	return ValidateDiscount.Struct(r)
}

// Validate runs validations defined by the 'validate' tags on the struct.
func (r *ListDiscountsRequest) Validate() error {
	// Basic struct tag validation
	if err := ValidateDiscount.Struct(r); err != nil {
		return err
	}

	// Custom validation: if both dates are provided, ensure ValidUntil is not before ValidFrom
	if r.ValidFrom != nil && r.ValidUntil != nil && r.ValidUntil.Before(*r.ValidFrom) {
		return errors.New("valid_until cannot be before valid_from")
	}

	return nil
}

// --- Helper Methods (if needed) ---

// IsValid checks if the discount is currently valid based on its dates and usage limits.
// This is a business logic method on the model.
func (d *Discount) IsValid() bool {
	now := time.Now()
	return d.IsActive &&
		d.ValidFrom.Before(now) &&
		d.ValidUntil.After(now) &&
		(d.MaxUses == nil || d.CurrentUses < *d.MaxUses)
}


File: internal/handlers/helper.go
================================================
package handlers

import (
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"strings"

	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/MihoZaki/DzTech/internal/utils"
	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
)

// DecodeAndValidateJSON reads the request body, decodes it into the target struct,
// and validates it using the validator library.
// It sends a 400 Bad Request response if decoding or validation fails.
func DecodeAndValidateJSON(w http.ResponseWriter, r *http.Request, target models.Validator) error {
	err := json.NewDecoder(r.Body).Decode(target)
	if err != nil {
		utils.SendErrorResponse(w, http.StatusBadRequest, "Bad Request", "Invalid JSON body.")
		return fmt.Errorf("invalid JSON: %w", err)
	}

	// Directly call Validate on target
	if err := target.Validate(); err != nil {
		utils.SendErrorResponse(w, http.StatusBadRequest, "Bad Request", fmt.Sprintf("Validation failed: %v", err))
		return fmt.Errorf("validation failed: %w", err)
	}
	return nil
}

// ParseUUIDPathParam extracts a UUID from a named path parameter using chi.
// It sends a 400 Bad Request response if the parameter is missing or invalid.
func ParseUUIDPathParam(w http.ResponseWriter, r *http.Request, paramName string) (uuid.UUID, error) {
	paramStr := chi.URLParam(r, paramName)
	if paramStr == "" {
		utils.SendErrorResponse(w, http.StatusBadRequest, "Bad Request", fmt.Sprintf("%s path parameter is required.", paramName))
		return uuid.Nil, fmt.Errorf("missing %s path parameter", paramName)
	}

	parsedUUID, err := uuid.Parse(paramStr)
	if err != nil {
		utils.SendErrorResponse(w, http.StatusBadRequest, "Bad Request", fmt.Sprintf("Invalid %s format.", paramName))
		return uuid.Nil, fmt.Errorf("invalid %s format: %w", paramName, err)
	}

	return parsedUUID, nil
}

// GetSessionIDFromHeader extracts the session ID from the X-Session-ID header.
// It sends a 400 Bad Request response if the header is missing.
func GetSessionIDFromHeader(w http.ResponseWriter, r *http.Request, logger *slog.Logger) (string, bool) {
	sessionID := r.Header.Get("X-Session-ID")
	if sessionID == "" {
		utils.SendErrorResponse(w, http.StatusBadRequest, "Bad Request", "A session ID header (X-Session-ID) is required.")
		logger.Debug("Missing X-Session-ID header")
		return "", false
	}
	return sessionID, true
}

// MapServiceErrToHTTPStatus attempts to map a service-layer error to an appropriate HTTP status code and message.
// It returns the status code and the detail message.
func MapServiceErrToHTTPStatus(err error) (int, string) {
	errMsg := strings.ToLower(err.Error())

	// Add more mappings as needed based on service error messages or types.
	if strings.Contains(errMsg, "not found") {
		return http.StatusNotFound, "Resource not found."
	}
	if strings.Contains(errMsg, "access denied") || strings.Contains(errMsg, "does not belong") {
		return http.StatusForbidden, "Access denied."
	}
	if strings.Contains(errMsg, "stock") || strings.Contains(errMsg, "check") || strings.Contains(errMsg, "constraint") {
		return http.StatusConflict, "Request conflicts with current state (e.g., insufficient stock)."
	}
	return http.StatusInternalServerError, "An internal server error occurred."
}

// SendServiceError sends an appropriate HTTP error response based on the service error.
func SendServiceError(w http.ResponseWriter, logger *slog.Logger, operation string, err error) {
	status, detail := MapServiceErrToHTTPStatus(err)
	logger.Error(fmt.Sprintf("Failed to %s", operation), "error", err)
	utils.SendErrorResponse(w, status, http.StatusText(status), detail)
}

// getSessionIDFromCookie extracts the session ID from the "session_id" cookie.
func GetSessionIDFromCookie(r *http.Request) (string, bool) {
	cookie, err := r.Cookie("session_id")
	if err != nil {
		slog.Debug("Session cookie not found in request", "error", err)
		return "", false
	}
	return cookie.Value, true
}

// setSessionIDCookie sets the "session_id" cookie in the response.
// It generates a new UUID if no session ID exists yet.
// It configures the cookie with HttpOnly and SameSite flags for security.
func SetSessionIDCookie(w http.ResponseWriter, sessionID string) {
	if sessionID == "" {
		// Generate a new session ID if none exists
		sessionID = uuid.New().String()
		slog.Debug("Generated new session ID for cookie", "session_id", sessionID)
	}

	cookie := &http.Cookie{
		Name:     "session_id",            // Name of the cookie
		Value:    sessionID,               // The session ID value
		Path:     "/",                     // Cookie is valid for the entire site
		HttpOnly: true,                    // Prevents JavaScript access (security)
		Secure:   false,                   // Set to true if using HTTPS in production
		SameSite: http.SameSiteStrictMode, // Mitigate CSRF (adjust if needed for cross-origin requests)
		MaxAge:   86400,                   // Cookie expires in 24 hours (86400 seconds)
		// Expires:  time.Now().Add(24 * time.Hour), // Alternative to MaxAge
	}

	http.SetCookie(w, cookie) // Add the cookie to the response headers
}


File: internal/handlers/admin_user_handler.go
================================================
package handlers

import (
	"encoding/json"
	"errors"
	"log/slog"
	"net/http"
	"strconv"

	"github.com/MihoZaki/DzTech/internal/services"

	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
)

// AdminUserHandler manages HTTP requests for admin user management operations.
type AdminUserHandler struct {
	service *services.AdminUserService
	logger  *slog.Logger
}

// NewAdminUserHandler creates a new instance of AdminUserHandler.
func NewAdminUserHandler(service *services.AdminUserService, logger *slog.Logger) *AdminUserHandler {
	return &AdminUserHandler{
		service: service,
		logger:  logger,
	}
}

// RegisterRoutes registers the admin user management-related routes with the provided Chi router.
// Assumes the router 'r' has admin middleware applied (e.g., JWT + RequireAdmin).
func (h *AdminUserHandler) RegisterRoutes(r chi.Router) {
	r.Get("/", h.ListUsers)                      // GET /api/v1/admin/users (with ?active_only=&page=&limit=)
	r.Get("/{id}", h.GetUser)                    // GET /api/v1/admin/users/{id}
	r.Post("/{id}/activate", h.ActivateUser)     // POST /api/v1/admin/users/{id}/activate
	r.Post("/{id}/deactivate", h.DeactivateUser) // POST /api/v1/admin/users/{id}/deactivate
}

// ListUsers handles the request to list users with optional filtering and pagination.
func (h *AdminUserHandler) ListUsers(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters for filtering and pagination
	activeOnlyStr := r.URL.Query().Get("active_only")
	activeOnly := false // Default to false (include both active and inactive)
	if activeOnlyStr == "true" || activeOnlyStr == "1" {
		activeOnly = true
	}

	pageStr := r.URL.Query().Get("page")
	page, err := strconv.Atoi(pageStr)
	if err != nil || page < 1 {
		page = 1 // Default to page 1
	}

	limitStr := r.URL.Query().Get("limit")
	limit, err := strconv.Atoi(limitStr)
	if err != nil || limit < 1 {
		limit = 20 // Default limit
	}
	if limit > 100 { // Example maximum limit
		limit = 100
	}

	paginatedResult, err := h.service.ListUsers(r.Context(), activeOnly, page, limit)
	if err != nil {
		h.logger.Error("Failed to list users", "error", err, "active_only", activeOnly, "page", page, "limit", limit)
		http.Error(w, "Failed to list users", http.StatusInternalServerError)
		return
	}

	// Send the PaginatedResponse as JSON
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK) // Or appropriate status code
	if err := json.NewEncoder(w).Encode(paginatedResult); err != nil {
		h.logger.Error("Failed to encode ListUsers response", "error", err)
	}
}

// GetUser handles retrieving a specific user's details by their ID.
func (h *AdminUserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		http.Error(w, "Invalid user ID format", http.StatusBadRequest)
		return
	}

	userInfo, err := h.service.GetUser(r.Context(), id)
	if err != nil {
		if errors.Is(err, services.ErrUserNotFound) {
			http.Error(w, "User not found", http.StatusNotFound)
			return
		}
		h.logger.Error("Failed to get user details", "error", err, "user_id", id)
		http.Error(w, "Failed to retrieve user details", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK) // 200 OK
	if err := json.NewEncoder(w).Encode(userInfo); err != nil {
		h.logger.Error("Failed to encode GetUser response", "error", err, "user_id", id)
	}
}

// ActivateUser handles activating a user.
func (h *AdminUserHandler) ActivateUser(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		http.Error(w, "Invalid user ID format", http.StatusBadRequest)
		return
	}

	err = h.service.ActivateUser(r.Context(), id)
	if err != nil {
		h.logger.Error("Failed to activate user", "error", err, "user_id", id)
		http.Error(w, "Failed to activate user", http.StatusInternalServerError)
		return
	}

	// Return 204 No Content on successful activation
	w.WriteHeader(http.StatusNoContent) // 204 No Content
}

// DeactivateUser handles deactivating a user.
func (h *AdminUserHandler) DeactivateUser(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		http.Error(w, "Invalid user ID format", http.StatusBadRequest)
		return
	}

	err = h.service.DeactivateUser(r.Context(), id)
	if err != nil {
		h.logger.Error("Failed to deactivate user", "error", err, "user_id", id)
		http.Error(w, "Failed to deactivate user", http.StatusInternalServerError)
		return
	}

	// Return 204 No Content on successful deactivation
	w.WriteHeader(http.StatusNoContent) // 204 No Content
}


File: internal/middleware/middleware.go
================================================
package middleware

import (
	"context"
	"fmt"
	"log/slog"
	"net/http"
	"strings"
	"time"

	"github.com/MihoZaki/DzTech/internal/config"
	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/MihoZaki/DzTech/internal/utils"
	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/go-chi/cors"
	"github.com/go-chi/httprate"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
)

func JWTMiddleware(cfg *config.Config) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			authHeader := r.Header.Get("Authorization")
			if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") {
				// No token provided, allow request to proceed without adding user to context
				next.ServeHTTP(w, r)
				return
			}

			// Token is provided, attempt to validate it
			tokenString := strings.TrimPrefix(authHeader, "Bearer ")
			token, err := jwt.Parse(tokenString, func(token *jwt.Token) (any, error) {
				if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
					return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
				}
				return []byte(cfg.JWTSecret), nil
			})

			if err != nil || !token.Valid {
				slog.Warn("Invalid JWT token", "error", err)
				// Returning 401 here if token is present but invalid.
				utils.SendErrorResponse(w, http.StatusUnauthorized, "Unauthorized", "Invalid or expired token")
				return
			}

			// Token is valid, extract claims and add user to context
			claims, ok := token.Claims.(jwt.MapClaims)
			if !ok {
				slog.Error("Invalid JWT claims format")
				utils.SendErrorResponse(w, http.StatusUnauthorized, "Unauthorized", "Invalid token claims")
				return
			}

			userIDStr, ok := claims["user_id"].(string)
			if !ok {
				slog.Error("Missing user_id claim in JWT")
				utils.SendErrorResponse(w, http.StatusUnauthorized, "Unauthorized", "Invalid token: missing user_id")
				return
			}

			userID, err := uuid.Parse(userIDStr)
			if err != nil {
				slog.Error("Invalid user_id format in JWT", "user_id_str", userIDStr, "error", err)
				utils.SendErrorResponse(w, http.StatusUnauthorized, "Unauthorized", "Invalid token: malformed user_id")
				return
			}

			// Extract other claims if needed (email, isAdmin)
			email, _ := claims["email"].(string) // Use _ to ignore the boolean return value
			isAdmin, _ := claims["is_admin"].(bool)

			user := &models.User{
				ID:      userID,
				Email:   email,
				IsAdmin: isAdmin,
			}

			// Add user to the request context
			ctx := context.WithValue(r.Context(), models.ContextKeyUser, user)
			next.ServeHTTP(w, r.WithContext(ctx))
		})
	}
}

func RequireAdmin(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		user, ok := models.GetUserFromContext(r.Context())
		if !ok || user == nil || !user.IsAdmin {
			slog.Warn("Access denied: Admin access required or user not found in context", "user_found_in_context", ok, "user_is_nil", user == nil)
			utils.SendErrorResponse(w, http.StatusForbidden, "Forbidden", "Admin access required")
			return
		}
		next.ServeHTTP(w, r)
	})
}

// ApplyMiddleware applies essential middleware for the application.
func ApplyMiddleware(r *chi.Mux) {
	// Essential middleware for production
	r.Use(middleware.RequestID) // Important for rate limiting
	r.Use(middleware.RealIP)    // Important for rate limiting, analytics and tracing
	r.Use(middleware.Timeout(60 * time.Second))

	r.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"http://localhost:3001", "http://localhost:3000"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type"},
		AllowCredentials: true,
		MaxAge:           300,
	}))
	r.Use(func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			ip, _ := httprate.KeyByIP(r)
			slog.Debug("Rate limiter middleware hit", "path", r.URL.Path, "ip", ip)
			next.ServeHTTP(w, r)
		})
	})
	r.Use(httprate.Limit(
		100,            // requests
		60*time.Second, // per duration
		httprate.WithKeyFuncs(httprate.KeyByIP, httprate.KeyByEndpoint),
	))
	// Logging middleware with structured logging
	r.Use(middleware.Logger)

	r.Use(middleware.Recoverer)
}


File: internal/services/email_service.go
================================================
package services

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"time"

	"github.com/MihoZaki/DzTech/internal/config"
	"github.com/wneessen/go-mail"
)

// EmailService defines the interface for sending emails.
type EmailService interface {
	SendPasswordResetEmail(ctx context.Context, toEmail, resetToken string) error
}

// ConcreteEmailService implements the EmailService interface using wneessen/go-mail.
type ConcreteEmailService struct {
	config *config.Config
	logger *slog.Logger
	client *mail.Client // Cached client instance
}

// NewEmailService creates a new instance of ConcreteEmailService.
func NewEmailService(cfg *config.Config, logger *slog.Logger) *ConcreteEmailService {
	// Define client options based on configuration
	opts := []mail.Option{
		mail.WithPort(cfg.SMTP.Port),
		mail.WithUsername(cfg.SMTP.Username),
		mail.WithPassword(cfg.SMTP.Password),
	}

	// Determine authentication method (auto-discover or specific like PLAIN/LOGIN)
	// For most external SMTP servers (Gmail, Mailtrap, SendGrid, etc.), auto-discovery works well.
	// If your SMTP server requires a specific auth method, you can use mail.WithSMTPAuth(mail.SMTPAuthLogin) or similar.
	opts = append(opts, mail.WithSMTPAuth(mail.SMTPAuthAutoDiscover))

	// Create the client
	client, err := mail.NewClient(cfg.SMTP.Host, opts...)
	if err != nil {
		// Log the initialization error
		logger.Error("Failed to initialize go-mail client", "host", cfg.SMTP.Host, "port", cfg.SMTP.Port, "error", err)
		// Return the service with a nil client to signal failure
		return &ConcreteEmailService{
			config: cfg,
			logger: logger,
			client: nil,
		}
	}
	logger.Info("succesfully connected to the go-mail client with the host", "host", cfg.SMTP.Host, "port", cfg.SMTP.Port)

	return &ConcreteEmailService{
		config: cfg,
		logger: logger,
		client: client,
	}
}

// SendPasswordResetEmail sends a password reset email using wneessen/go-mail.
func (e *ConcreteEmailService) SendPasswordResetEmail(ctx context.Context, toEmail, resetToken string) error {
	// Check if the client was initialized successfully
	if e.client == nil {
		return errors.New("email client not initialized, check SMTP configuration logs")
	}
	if e.config.SMTP.Sender == "" {
		return errors.New("SMTP sender address not configured in config")
	}

	baseURL := e.config.BaseURL
	if baseURL == "" {
		return errors.New("base URL not configured in config, cannot construct reset link")
	}
	resetURL := fmt.Sprintf("%s/auth/reset-password/%s", baseURL, resetToken)

	// Create the email message
	message := mail.NewMsg()
	if message == nil {
		return errors.New("failed to create new email message object")
	}

	// Set the sender (From header) - Use the configured sender address
	if err := message.From(e.config.SMTP.Sender); err != nil {
		e.logger.Error("Failed to set sender address in message", "error", err, "sender", e.config.SMTP.Sender)
		return fmt.Errorf("failed to set sender address: %w", err)
	}

	// Set the recipient (To header)
	if err := message.To(toEmail); err != nil {
		e.logger.Error("Failed to set recipient address in message", "error", err, "to", toEmail)
		return fmt.Errorf("failed to set recipient address: %w", err)
	}

	// Set the subject
	message.Subject("Password Reset Request")

	// Set the body (plain text)
	textBody := fmt.Sprintf(`Hello,

We received a request to reset your password for your YC Informatique account.

Click the link below to reset your password:
%s

This link will expire in 1 hour.

If you didn't request this reset, please ignore this email.

Best regards,
YC Informatique Team
`, resetURL)
	message.SetBodyString(mail.TypeTextPlain, textBody)

	// Set the body (HTML)
	htmlBody := fmt.Sprintf(`<html>
<body>
<p>Hello,</p>

<p>We received a request to reset your password for your YC Informatique account.</p>

<p><a href="%s">Click here to reset your password</a></p>

<p>This link will expire in 1 hour.</p>

<p>If you didn't request this reset, please ignore this email.</p>

<p>Best regards,<br/>
YC Informatique Team</p>
</body>
</html>`, resetURL)
	message.SetBodyString(mail.TypeTextHTML, htmlBody)

	// Send the email using the cached client
	// Use DialAndSendWithContext to respect the request context and add a timeout
	ctxWithTimeout, cancel := context.WithTimeout(ctx, 15*time.Second) // Adjust timeout as needed
	defer cancel()

	if err := e.client.DialAndSendWithContext(ctxWithTimeout, message); err != nil {
		e.logger.Error("Failed to send password reset email via go-mail", "to", toEmail, "error", err)
		return fmt.Errorf("failed to send email via go-mail: %w", err)
	}

	e.logger.Info("Password reset email sent successfully via go-mail", "to", toEmail, "token_preview", resetToken[:10]+"...")
	return nil
}


File: internal/storage/storage.go
================================================
package storage

import (
	"fmt"
	"io"
	"mime/multipart"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"sync"

	"github.com/google/uuid"
)

type Storer interface {
	UploadFile(file multipart.File, fileHeader *multipart.FileHeader) (string, error)
	DeleteFile(fileURL string) error
	GetFileURL(filename string) string
}

type LocalStorage struct {
	basePath     string
	publicPath   string     // The path portion of the URL that serves the files (e.g., "/uploads")
	allowedTypes []string   // e.g., ["image/jpeg", "image/png"]
	maxSize      int64      // e.g., 5 * 1024 * 1024 for 5MB
	mutex        sync.Mutex // Protect concurrent writes to the filesystem if needed (optional, depends on usage)
}

func NewLocalStorage(basePath, publicPath string, allowedTypes []string, maxSize int64) *LocalStorage {
	if err := os.MkdirAll(basePath, 0755); err != nil {
		panic(fmt.Sprintf("failed to create local storage base path %s: %v", basePath, err))
	}

	return &LocalStorage{
		basePath:     basePath,
		publicPath:   publicPath,
		allowedTypes: allowedTypes,
		maxSize:      maxSize,
	}
}

func (ls *LocalStorage) UploadFile(file multipart.File, fileHeader *multipart.FileHeader) (string, error) {
	ls.mutex.Lock()
	defer ls.mutex.Unlock()

	// --- Size Check ---
	if fileHeader.Size > ls.maxSize {
		return "", fmt.Errorf("file size %d exceeds maximum allowed size %d", fileHeader.Size, ls.maxSize)
	}

	// --- Type Check ---
	ext := strings.ToLower(filepath.Ext(fileHeader.Filename))
	if ext != ".jpg" && ext != ".jpeg" && ext != ".png" && ext != ".gif" && ext != ".webp" {
		return "", fmt.Errorf("file type %s is not allowed", ext)
	}
	// --- Generate Unique Filename ---
	originalFilenameWithoutExt := strings.TrimSuffix(fileHeader.Filename, ext)
	// Sanitize the original name if necessary (remove/replace problematic characters)
	santizedFileNameWithoutExt := sanitize(originalFilenameWithoutExt)
	uuidPart := uuid.New().String()
	uniqueFilename := fmt.Sprintf("%s_%s%s", santizedFileNameWithoutExt, uuidPart, ext)
	// ---

	// --- Save File ---
	fullPath := filepath.Join(ls.basePath, uniqueFilename)

	dst, err := os.Create(fullPath)
	if err != nil {
		return "", fmt.Errorf("failed to create destination file %s: %w", fullPath, err)
	}
	defer dst.Close()

	_, err = io.Copy(dst, file)
	if err != nil {
		// Clean up the partially created file on error
		os.Remove(fullPath)
		return "", fmt.Errorf("failed to copy uploaded file to %s: %w", fullPath, err)
	}
	// ---

	// --- Generate Public URL ---
	publicURL := fmt.Sprintf("%s/%s", strings.TrimSuffix(ls.publicPath, "/"), uniqueFilename)
	// ---

	return publicURL, nil
}

func (ls *LocalStorage) DeleteFile(fileURL string) error {
	ls.mutex.Lock()
	defer ls.mutex.Unlock()
	if !strings.HasPrefix(fileURL, ls.publicPath+"/") {
		return fmt.Errorf("file URL %s does not match base path %s", fileURL, ls.publicPath)
	}
	filename := strings.TrimPrefix(fileURL, ls.publicPath+"/")
	fullPath := filepath.Join(ls.basePath, filename)

	return os.Remove(fullPath)
}
func (ls *LocalStorage) GetFileURL(filename string) string {
	return fmt.Sprintf("%s/%s", strings.TrimSuffix(ls.publicPath, "/"), filename)
}
func sanitize(filename string) string {
	// Remove or replace characters that might be problematic in filenames
	// This is a basic example, might need expansion based on OS/filesystem requirements
	re := regexp.MustCompile(`[^a-zA-Z0-9._-]`)
	return re.ReplaceAllString(filename, "_")
}


File: migrations/00005_create_delivery_service_table.sql
================================================
-- +goose Up
-- Create the 'delivery_services' table
CREATE TABLE delivery_services (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL UNIQUE, -- Unique name for the service
    description TEXT, -- Optional description
    base_cost_cents BIGINT NOT NULL DEFAULT 0, -- Base cost in cents
    estimated_days INTEGER, -- Estimated delivery time in days (optional)
    is_active BOOLEAN NOT NULL DEFAULT TRUE, -- Whether the service is currently offered
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_delivery_services_is_active ON delivery_services(is_active); -- Index for filtering active services

-- +goose StatementBegin
COMMENT ON TABLE delivery_services IS 'Stores available delivery service options.';
COMMENT ON COLUMN delivery_services.name IS 'Unique name identifying the delivery service.';
COMMENT ON COLUMN delivery_services.description IS 'Optional description of the delivery service.';
COMMENT ON COLUMN delivery_services.base_cost_cents IS 'Base cost of the delivery service in cents.';
COMMENT ON COLUMN delivery_services.estimated_days IS 'Estimated number of days for delivery.';
COMMENT ON COLUMN delivery_services.is_active IS 'Indicates if the delivery service is currently offered.';
-- +goose StatementEnd

-- +goose Down
DROP TABLE IF EXISTS delivery_services;


File: website/src/components/CartModel.jsx
================================================
import React from "react";
import { Dialog, Transition } from "@headlessui/react";
import { Fragment } from "react";
import { XMarkIcon } from "@heroicons/react/24/outline";
import { useCart } from "../contexts/CartContext";
import { TrashIcon } from "@heroicons/react/24/solid";

const CartModal = ({ isOpen, onClose }) => {
  const { cart, subtotal, tax, total, updateQuantity, removeFromCart } =
    useCart();

  return (
    <Transition appear show={isOpen} as={Fragment}>
      <Dialog as="div" className="relative z-50" onClose={onClose}>
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black bg-opacity-75" />
        </Transition.Child>

        <div className="fixed inset-0 overflow-y-auto">
          <div className="flex min-h-full items-center justify-center p-4 text-center">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 scale-95"
              enterTo="opacity-100 scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 scale-100"
              leaveTo="opacity-0 scale-95"
            >
              <Dialog.Panel className="w-full max-w-md transform overflow-hidden rounded-2xl bg-base-100 p-6 text-left align-middle shadow-xl transition-all">
                <div className="flex items-center justify-between">
                  <Dialog.Title
                    as="h3"
                    className="text-lg font-medium leading-6"
                  >
                    Shopping Cart ({cart.length})
                  </Dialog.Title>
                  <button
                    type="button"
                    className="rounded-md p-2 hover:bg-base-200"
                    onClick={onClose}
                  >
                    <XMarkIcon className="h-5 w-5" />
                  </button>
                </div>

                <div className="mt-4 max-h-96 overflow-y-auto">
                  {cart.length === 0
                    ? (
                      <p className="text-center py-8 text-gray-500">
                        Your cart is empty
                      </p>
                    )
                    : (
                      <div className="space-y-4">
                        {cart.map((item) => (
                          <div
                            key={item.id}
                            className="flex items-center space-x-4 p-3 border border-base-200 rounded-lg"
                          >
                            <img
                              src={item.image}
                              alt={item.name} // Changed from item.title to item.name
                              className="w-16 h-16 object-contain"
                            />
                            <div className="flex-1 min-w-0">
                              <p className="text-sm font-medium truncate">
                                {item.name}{" "}
                                {/* Changed from item.title to item.name */}
                              </p>
                              <p className="text-sm text-gray-500">
                                DZD {item.price}
                              </p>
                            </div>
                            <div className="flex items-center space-x-2">
                              <button
                                className="btn btn-xs"
                                onClick={() =>
                                  updateQuantity(
                                    item.id,
                                    Math.max(1, item.quantity - 1),
                                  )}
                              >
                                -
                              </button>
                              <span className="text-sm">{item.quantity}</span>
                              {" "}
                              {/* This should now show the correct quantity */}
                              <button
                                className="btn btn-xs"
                                onClick={() =>
                                  updateQuantity(item.id, item.quantity + 1)}
                              >
                                +
                              </button>
                            </div>
                            <button
                              className="btn btn-error btn-xs"
                              onClick={() => removeFromCart(item.id)}
                            >
                              <TrashIcon className="h-4 w-4" />
                            </button>
                          </div>
                        ))}
                      </div>
                    )}
                </div>

                {cart.length > 0 && (
                  <div className="mt-6 space-y-2">
                    <div className="flex justify-between">
                      <span>Subtotal:</span>
                      <span>DZD {subtotal.toFixed(2)}</span>
                    </div>
                    <div className="flex justify-between">
                      <span>Tax (8%):</span>
                      <span>DZD {tax.toFixed(2)}</span>
                    </div>
                    <div className="flex justify-between font-bold text-lg">
                      <span>Total:</span>
                      <span>DZD {total.toFixed(2)}</span>
                    </div>
                    <button className="btn btn-primary w-full mt-4">
                      Checkout
                    </button>
                  </div>
                )}
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition>
  );
};

export default CartModal;


File: website/src/pages/OrderDetails.jsx
================================================
import React from "react";
import { Link, useParams } from "react-router-dom";
import { useQuery } from "@tanstack/react-query";
import { fetchOrderById } from "../services/api"; // Import the API function
import { toast } from "sonner"; // Import toast for error messages

// Base URL for the backend API (adjust this for your deployment environment)
const BACKEND_BASE_URL = import.meta.env.VITE_BACKEND_BASE_URL ||
  "http://localhost:8080";

const OrderDetails = () => {
  const { orderId } = useParams(); // Get the order ID from the URL

  // Helper function to truncate UUID
  const truncateUuid = (uuid) => {
    if (!uuid || typeof uuid !== "string") return "N/A";
    return `${uuid.substring(0, 8)}...`;
  };
  // Function to construct full image URL
  const constructImageUrl = (imageUrl) => {
    if (!imageUrl) return "";

    // If it's already a full URL, return as is
    if (imageUrl.startsWith("http://") || imageUrl.startsWith("https://")) {
      return imageUrl;
    }

    // Otherwise, prepend the backend base URL
    return `${BACKEND_BASE_URL}${imageUrl}`;
  };

  // Use TanStack Query to fetch order details
  const {
    data, // Changed from 'order' to 'data' to match TanStack Query convention
    isLoading,
    isError,
    error,
    refetch,
  } = useQuery({
    queryKey: ["order-details", orderId],
    queryFn: () => fetchOrderById(orderId),
    enabled: !!orderId, // Only run query if orderId exists
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
    cacheTime: 10 * 60 * 1000, // Cache for 10 minutes
    onError: (err) => {
      console.error(`Error fetching order with id ${orderId}:`, err);
      toast.error("Failed to load order details. Please try again later.");
    },
  });

  // Extract the order and items from the API response structure
  const order = data?.order; // Use data.order as per your API response structure
  const items = data?.items; // Use data.items as per your API response structure

  // Format date helper function
  const formatDate = (dateString) => {
    if (!dateString) return "";
    const date = new Date(dateString);
    return date.toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  };

  // Format currency helper function
  const formatCurrency = (cents) => {
    if (!cents) return "DZD 0.00";
    return `DZD ${(cents / 100).toFixed(2)}`;
  };

  return (
    <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
      <h1 className="text-3xl font-bold mb-8">Order Details</h1>

      {/* Loading State */}
      {isLoading && (
        <div className="flex justify-center items-center min-h-[200px]">
          <span className="loading loading-spinner loading-lg"></span>
        </div>
      )}

      {/* Error State */}
      {isError && !isLoading && (
        <div className="alert alert-error">
          <p>
            {error.message ||
              "Failed to load order details. Please try again later."}
          </p>
          <button
            onClick={() => refetch()}
            className="btn btn-sm"
          >
            Retry
          </button>
        </div>
      )}

      {/* Order Details */}
      {!isLoading && !isError && order && (
        <>
          {/* Back Button */}
          <div className="mb-6">
            <Link to="/account/orders" className="btn btn-sm btn-ghost">
              &larr; Back to Orders
            </Link>
          </div>

          {/* Order Summary Card */}
          <div className="card bg-base-100 shadow-lg border border-secondary-content mb-6">
            <div className="card-body">
              <h2 className="card-title text-2xl mb-4">Order #{order.id}</h2>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <p>
                    <strong>Status:</strong>{" "}
                    <span
                      className={`badge ${
                        order.status.toLowerCase() === "delivered" ||
                          order.status.toLowerCase() === "completed"
                          ? "badge-success"
                          : order.status.toLowerCase() === "shipped"
                          ? "badge-info"
                          : order.status.toLowerCase() === "processing"
                          ? "badge-warning"
                          : "badge-neutral" // Default for other statuses
                      }`}
                    >
                      {order.status.charAt(0).toUpperCase() +
                        order.status.slice(1)}
                    </span>
                  </p>
                  <p>
                    <strong>Date:</strong> {formatDate(order.created_at)}
                  </p>
                </div>
                <div>
                  <p>
                    <strong>Total Amount:</strong>{" "}
                    {formatCurrency(order.total_amount_cents)}
                  </p>
                  <p>
                    <strong>Payment Method:</strong> {order.payment_method}
                  </p>
                  <p>
                    <strong>Phone:</strong> {order.phone_number_1 || "N/A"}
                  </p>
                </div>
              </div>
            </div>
          </div>

          {/* Items List Card */}
          <div className="card bg-base-100 shadow-lg border border-secondary-content mb-6">
            <div className="card-body">
              <h3 className="card-title text-xl mb-4">Items Ordered</h3>
              <div className="overflow-x-auto">
                <table className="table">
                  <thead>
                    <tr>
                      <th className="font-bold">Item</th>
                      <th className="font-bold">product ID</th>
                      <th className="font-bold">Price</th>
                      <th className="font-bold">Quantity</th>
                      <th className="font-bold">Total</th>
                    </tr>
                  </thead>
                  <tbody>
                    {items && items.length > 0
                      ? (
                        items.map((orderItem) => {
                          return (
                            <tr key={orderItem.id}>
                              <td>
                                <div className="flex items-center gap-4">
                                  <div>
                                    <p className="font-semibold">
                                      {orderItem.product_name}
                                    </p>
                                    {/* Brand is likely not available in this structure */}
                                    {/* <p className="text-sm text-gray-500">{item.brand}</p> */}
                                  </div>
                                </div>
                              </td>
                              <td>{truncateUuid(orderItem.product_id)}</td>
                              <td>{formatCurrency(orderItem.price_cents)}</td>
                              <td>{orderItem.quantity}</td>
                              <td>
                                {formatCurrency(
                                  orderItem.subtotal_cents, // Use subtotal_cents from the order item
                                )}
                              </td>
                            </tr>
                          );
                        })
                      )
                      : (
                        <tr>
                          <td colSpan="4" className="text-center">
                            No items found for this order.
                          </td>
                        </tr>
                      )}
                  </tbody>
                </table>
              </div>
            </div>
          </div>

          {/* Addresses Card */}
          <div className="card bg-base-100 shadow-lg border border-secondary-content">
            <div className="card-body">
              <h3 className="card-title text-xl mb-4">Delivery Information</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div>
                  <h4 className="font-bold mb-2">Delivery Address</h4>
                  <p>
                    <strong>Full Name:</strong> {order.user_full_name}
                  </p>
                  <p>
                    <strong>Province:</strong> {order.province}
                  </p>
                  <p>
                    <strong>City:</strong> {order.city}
                  </p>
                  <p>
                    <strong>Notes:</strong> {order.notes || "N/A"}
                  </p>
                </div>
                <div>
                  <h4 className="font-bold mb-2">Contact Information</h4>
                  <p>
                    <strong>Phone 1:</strong> {order.phone_number_1 || "N/A"}
                  </p>
                  <p>
                    <strong>Phone 2:</strong> {order.phone_number_2 || "N/A"}
                  </p>
                  <p>
                    <strong>Delivery Service ID:</strong>{" "}
                    {order.delivery_service_id}
                  </p>
                </div>
              </div>
            </div>
          </div>
        </>
      )}

      {/* Order Not Found State (if API returns null) */}
      {!isLoading && !isError && !order && (
        <div className="text-center py-12">
          <p className="text-xl text-error mb-4">Order not found.</p>
          <Link to="/account/orders" className="btn btn-primary">
            Go to My Orders
          </Link>
        </div>
      )}
    </div>
  );
};

export default OrderDetails;


File: website/src/pages/Home.jsx
================================================
// src/pages/Home.jsx
import React, { useEffect, useState } from "react";
import { Link, useSearchParams } from "react-router-dom";
import ProductCard from "../components/ProductCard";
import { useQuery } from "@tanstack/react-query";
import { fetchCategories, searchProducts } from "../services/api"; // Added fetchCategories
import { toast } from "sonner";
// Import Heroicons
import {
  ChatBubbleBottomCenterTextIcon,
  ClockIcon,
  CubeIcon,
  CurrencyDollarIcon,
  ShieldCheckIcon,
  TruckIcon,
} from "@heroicons/react/24/outline"; // Import outline icons

// Import the hero background image
import heroBackgroundImage from "../assets/heroBackgroundImage.png";

// Import category images
import cpuImage from "../assets/categoryCpu.jpg";
import gpuImage from "../assets/categoryGpu.jpg";
import ramImage from "../assets/categoryRam.jpg";
import storageImage from "../assets/categoryStorage.jpg";
import motherboardImage from "../assets/categoryMotherboard.jpg";
import caseImage from "../assets/categoryCase.jpg";
import psuImage from "../assets/categoryPsu.jpg";
import peripheralImage from "../assets/categoryPeripherals.jpg";

import intelLogo from "../assets/intel-logo.png";
import amdLogo from "../assets/amd-logo.png";
import nvidiaLogo from "../assets/nvidia-logo.png";
import corsairLogo from "../assets/corsair-logo.png";
import samsungLogo from "../assets/samsung-logo.png";
import asusLogo from "../assets/asus-logo.png";
import gskillLogo from "../assets/gskill-logo.png";

// Direct mapping based on the actual backend response
const CATEGORY_NAME_MAPPING = {
  cpus: "CPU",
  gpus: "GPU",
  ram: "RAM",
  storage: "Storage",
  motherboards: "Motherboard",
  cases: "Case",
  psus: "Power Supply",
  peripherals: "Accessories", // Correctly maps to Accessories
  coolers: "Cooler", // Added cooler mapping
  laptops: "Laptop", // Added laptop mapping
};

const Home = () => {
  // Fetch both featured products and categories
  const {
    data: featuredProducts = [],
    isLoading: loadingProducts,
    isError: isProductError,
    error: productError,
    refetch: refetchProducts,
  } = useQuery({
    queryKey: ["featured-products"],
    queryFn: async () => {
      try {
        // Use searchProducts with limit of 8 instead of fetchProducts
        const response = await searchProducts({
          page: 1,
          limit: 8,
        });
        return response?.data || []; // Adjust based on your API response structure
      } catch (err) {
        console.error("Error fetching featured products:", err);
        toast.error(
          "Failed to load featured products. Please try again later.",
        );
        throw err;
      }
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
  });

  // Fetch categories to get actual IDs
  const {
    allCategories = [],
    isLoading: loadingCategories,
    isError: isCategoryError,
    error: categoryError,
    refetch: refetchCategories,
  } = useQuery({
    queryKey: ["categories"],
    queryFn: async () => {
      try {
        const response = await fetchCategories();
        return response || [];
      } catch (err) {
        console.error("Error fetching categories:", err);
        toast.error("Failed to load categories. Please try again later.");
        throw err;
      }
    },
    staleTime: 10 * 60 * 1000, // 10 minutes
    cacheTime: 15 * 60 * 1000, // 15 minutes
  });

  // Function to find the backend category ID based on our display name
  const findCategoryId = (displayName) => {
    if (!allCategories.length) return displayName; // Fallback if categories haven't loaded yet

    const targetName = CATEGORY_NAME_MAPPING[displayName];
    if (!targetName) return displayName; // Return the display name if no mapping exists

    // Find the category with the exact name match
    const category = allCategories.find((cat) =>
      cat.name &&
      typeof cat.name === "string" &&
      cat.name.toLowerCase() === targetName.toLowerCase()
    );

    if (category) {
      return category.id; // Return the actual backend ID
    }

    // If no match found, return the display name as fallback
    return displayName;
  };

  // Loading states
  const loading = loadingProducts || loadingCategories;
  const isError = isProductError || isCategoryError;
  const error = productError || categoryError;
  const refetch = () => {
    refetchProducts();
    refetchCategories();
  };

  // Define the brands for the carousel
  const brands = [
    { id: "intel", name: "Intel", image: intelLogo },
    { id: "amd", name: "AMD", image: amdLogo },
    { id: "nvidia", name: "NVIDIA", image: nvidiaLogo },
    { id: "corsair", name: "Corsair", image: corsairLogo },
    { id: "samsung", name: "Samsung", image: samsungLogo },
    { id: "asus", name: "ASUS", image: asusLogo },
    { id: "gskill", name: "G.Skill", image: gskillLogo },
  ];

  // Define the services
  const services = [
    {
      id: "cash-on-delivery",
      title: "Cash on Delivery",
      icon: <CurrencyDollarIcon className="h-8 w-8 text-primary" />,
    },
    {
      id: "fast-delivery",
      title: "Fast Delivery",
      icon: <TruckIcon className="h-8 w-8 text-primary" />,
    },
    {
      id: "province-delivery",
      title: "Ship to all Willayas",
      icon: <TruckIcon className="h-8 w-8 text-primary" />, // Reusing Truck icon
    },
    {
      id: "support",
      title: "24/7 Support",
      icon: <ChatBubbleBottomCenterTextIcon className="h-8 w-8 text-primary" />,
    },
    {
      id: "products",
      title: "Fresh Products",
      icon: <CubeIcon className="h-8 w-8 text-primary" />,
    },
    {
      id: "warranty",
      title: "Guaranteed Warranty",
      icon: <ShieldCheckIcon className="h-10 w-10 text-primary" />, // Added new service with icon
    },
  ];

  // Updated hardcoded categories with dynamic category ID lookup
  const hardcodedCategories = [
    // [0] Big card: CPUs (spans 2 cols × 2 rows)
    {
      id: "cpus",
      name: "CPUs",
      image: cpuImage,
      isBig: true,
      categoryId: findCategoryId("cpus"),
    },
    // [1] Top-right
    {
      id: "gpus",
      name: "GPUs",
      image: gpuImage,
      isBig: false,
      categoryId: findCategoryId("gpus"),
    },
    // [2] Below GPUs
    {
      id: "ram",
      name: "RAM",
      image: ramImage,
      isBig: false,
      categoryId: findCategoryId("ram"),
    },
    // [3] Below RAM
    {
      id: "storage",
      name: "Storage",
      image: storageImage,
      isBig: false,
      categoryId: findCategoryId("storage"),
    },
    // [4] Right of big card (row 1, col 3)
    {
      id: "motherboards",
      name: "Motherboards",
      image: motherboardImage,
      isBig: false,
      categoryId: findCategoryId("motherboards"),
    },
    // [5] Below motherboards
    {
      id: "cases",
      name: "Cases",
      image: caseImage,
      isBig: false,
      categoryId: findCategoryId("cases"),
    },
    // [6] Below cases
    {
      id: "psus",
      name: "PSUs",
      image: psuImage,
      isBig: false,
      categoryId: findCategoryId("psus"),
    },
    // [7] Bottom-right (last slot)
    {
      id: "peripherals",
      name: "Peripherals",
      image: peripheralImage,
      isBig: false,
      categoryId: findCategoryId("Accessories"),
    },
  ];

  return (
    <div className="min-h-screen">
      {/* Hero Section - With Imported Background Image */}
      <section
        className="hero min-h-[550px] text-base-content"
        style={{
          backgroundImage: `url(${heroBackgroundImage})`, // Use the imported variable
          backgroundSize: "cover",
          backgroundPosition: "center",
        }}
      >
        <div className="hero-overlay bg-opacity-35 bg-base-100"></div>{" "}
        {/* Optional overlay for contrast */}
        <div className="hero-content text-center">
          <div className="max-w-md">
            <h1 className="text-4xl md:text-6xl font-bold mb-4">
              Welcome to YC Informatique
            </h1>
            <p className="text-xl mb-8 text-base-content/80">
              Your trusted partner for all your tech needs.
            </p>
            <div className=" w-full flex flex-row items-center justify-center gap-4">
              <Link to="/products" className="btn btn-secondary">Shop Now</Link>
              <Link to="/build-pc" className="btn btn-primary">
                Build Your PC
              </Link>
            </div>
          </div>
        </div>
      </section>

      {/* Services Section */}
      <section className="py-12 bg-inherit">
        <div className="container mx-auto">
          <h2 className="text-3xl font-bold mb-8 text-center">
            Why Choose Us?
          </h2>{" "}
          <div className="grid grid-cols-3 sm:grid-cols-3 md:grid-cols-6 gap-6">
            {services.map((service) => (
              <div
                key={service.id}
                className="flex flex-col items-center justify-center p-4 bg-base-100 rounded-lg shadow-md hover:shadow-lg transition-shadow duration-300 border border-accent"
              >
                <div className="mb-4">
                  {service.icon}
                </div>
                <h3 className="text-center text-xl font-black text-base-content">
                  {service.title}
                </h3>
              </div>
            ))}
          </div>
        </div>
      </section>

      {/* Categories Section — Image with Name Button in Corner */}
      <section className="py-12 bg-base-100">
        <div className="container mx-auto">
          <h2 className="text-3xl font-bold my-12 text-center">
            Shop by Category
          </h2>

          {/* Fixed 4-column grid, explicit placement using hardcoded categories */}
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
            {/* Card 0: Big CPU card — spans col 1-2, row 1-2 */}
            <Link
              key={hardcodedCategories[0].id}
              to={`/products?category=${
                encodeURIComponent(hardcodedCategories[0].categoryId)
              }`}
              className="lg:col-span-2 lg:row-span-2 flex flex-col"
            >
              <div className="relative flex-grow overflow-hidden rounded-xl shadow-lg hover:shadow-xl transition-all duration-300">
                <img
                  loading="lazy"
                  src={hardcodedCategories[0].image}
                  alt={hardcodedCategories[0].name}
                  className="w-full h-full object-cover"
                />
                {/* Shop Now Button Overlay (Center) */}
                <div className="absolute inset-0 bg-black/30 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity">
                  <span className="btn btn-primary text-white">Shop Now</span>
                </div>
                <p className="absolute bottom-4 left-4 text-white px-2 py-1 rounded-md text-6xl font-bold">
                  {hardcodedCategories[0].name}
                </p>
              </div>
            </Link>

            {/* Cards 1–7: Fixed positions using hardcoded categories */}
            {/* Row 1, Col 3 */}
            <Link
              key={hardcodedCategories[1].id}
              to={`/products?category=${
                encodeURIComponent(hardcodedCategories[1].categoryId)
              }`}
              className="lg:col-span-1 lg:row-span-1"
            >
              <div className="relative h-full w-full overflow-hidden rounded-xl shadow-lg hover:shadow-xl transition-all duration-300">
                <img
                  loading="lazy"
                  src={hardcodedCategories[1].image}
                  alt={hardcodedCategories[1].name}
                  className="w-full h-full object-cover"
                />
                {/* Shop Now Button Overlay (Center) */}
                <div className="absolute inset-0 bg-black/30 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity">
                  <span className="btn btn-primary text-white">Shop Now</span>
                </div>
                <p className="absolute bottom-4 left-4 text-white px-2 py-1 rounded-md text-3xl font-bold">
                  {hardcodedCategories[1].name}
                </p>
              </div>
            </Link>

            {/* Row 2, Col 3 */}
            <Link
              key={hardcodedCategories[2].id}
              to={`/products?category=${
                encodeURIComponent(hardcodedCategories[2].categoryId)
              }`}
              className="lg:col-span-1 lg:row-span-1"
            >
              <div className="relative h-64 overflow-hidden rounded-xl shadow-lg hover:shadow-xl transition-all duration-300">
                <img
                  loading="lazy"
                  src={hardcodedCategories[2].image}
                  alt={hardcodedCategories[2].name}
                  className="w-full h-full object-cover"
                />
                {/* Shop Now Button Overlay (Center) */}
                <div className="absolute inset-0 bg-black/30 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity">
                  <span className="btn btn-primary text-white">Shop Now</span>
                </div>
                <p className="absolute bottom-4 left-4 text-white px-2 py-1 rounded-md text-3xl font-bold">
                  {hardcodedCategories[2].name}
                </p>
              </div>
            </Link>

            {/* Row 3, Col 3 */}
            <Link
              key={hardcodedCategories[3].id}
              to={`/products?category=${
                encodeURIComponent(hardcodedCategories[3].categoryId)
              }`}
              className="lg:col-span-1 lg:row-span-1"
            >
              <div className="relative h-64 overflow-hidden rounded-xl shadow-lg hover:shadow-xl transition-all duration-300">
                <img
                  loading="lazy"
                  src={hardcodedCategories[3].image}
                  alt={hardcodedCategories[3].name}
                  className="w-full h-full object-cover"
                />
                {/* Shop Now Button Overlay (Center) */}
                <div className="absolute inset-0 bg-black/30 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity">
                  <span className="btn btn-primary text-white">Shop Now</span>
                </div>
                <p className="absolute bottom-4 left-4 text-white px-2 py-1 rounded-md text-3xl font-bold">
                  {hardcodedCategories[3].name}
                </p>
              </div>
            </Link>

            {/* Row 1, Col 4 */}
            <Link
              key={hardcodedCategories[4].id}
              to={`/products?category=${
                encodeURIComponent(hardcodedCategories[4].categoryId)
              }`}
              className="lg:col-span-1 lg:row-span-1"
            >
              <div className="relative h-64 overflow-hidden rounded-xl shadow-lg hover:shadow-xl transition-all duration-300">
                <img
                  loading="lazy"
                  src={hardcodedCategories[4].image}
                  alt={hardcodedCategories[4].name}
                  className="w-full h-full object-cover"
                />
                {/* Shop Now Button Overlay (Center) */}
                <div className="absolute inset-0 bg-black/30 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity">
                  <span className="btn btn-primary text-white">Shop Now</span>
                </div>
                <p className="absolute bottom-4 left-4 text-white px-2 py-1 rounded-md text-3xl font-bold">
                  {hardcodedCategories[4].name}
                </p>
              </div>
            </Link>

            {/* Row 2, Col 4 */}
            <Link
              key={hardcodedCategories[5].id}
              to={`/products?category=${
                encodeURIComponent(hardcodedCategories[5].categoryId)
              }`}
              className="lg:col-span-1 lg:row-span-1"
            >
              <div className="relative h-64 overflow-hidden rounded-xl shadow-lg hover:shadow-xl transition-all duration-300">
                <img
                  loading="lazy"
                  src={hardcodedCategories[5].image}
                  alt={hardcodedCategories[5].name}
                  className="w-full h-full object-cover"
                />
                {/* Shop Now Button Overlay (Center) */}
                <div className="absolute inset-0 bg-black/30 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity">
                  <span className="btn btn-primary text-white">Shop Now</span>
                </div>
                <p className="absolute bottom-4 left-4 text-white px-2 py-1 rounded-md text-3xl font-bold">
                  {hardcodedCategories[5].name}
                </p>
              </div>
            </Link>

            {/* Row 3, Col 4 */}
            <Link
              key={hardcodedCategories[6].id}
              to={`/products?category=${
                encodeURIComponent(hardcodedCategories[6].categoryId)
              }`}
              className="lg:col-span-1 lg:row-span-1"
            >
              <div className="relative h-64 overflow-hidden rounded-xl shadow-lg hover:shadow-xl transition-all duration-300">
                <img
                  loading="lazy"
                  src={hardcodedCategories[6].image}
                  alt={hardcodedCategories[6].name}
                  className="w-full h-full object-cover"
                />
                {/* Shop Now Button Overlay (Center) */}
                <div className="absolute inset-0 bg-black/30 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity">
                  <span className="btn btn-primary text-white">Shop Now</span>
                </div>
                <p className="absolute bottom-4 left-4 text-white px-2 py-1 rounded-md text-3xl font-bold">
                  {hardcodedCategories[6].name}
                </p>
              </div>
            </Link>

            {/* Row 4, Col 4 (bottom-right) */}
            <Link
              key={hardcodedCategories[7].id}
              to={`/products?category=${
                encodeURIComponent(hardcodedCategories[7].categoryId)
              }`}
              className="lg:col-span-2 lg:row-span-1"
            >
              <div className="relative h-64 overflow-hidden rounded-xl shadow-lg hover:shadow-xl transition-all duration-300">
                <img
                  loading="lazy"
                  src={hardcodedCategories[7].image}
                  alt={hardcodedCategories[7].name}
                  className="w-full h-full object-cover"
                />
                {/* Shop Now Button Overlay (Center) */}
                <div className="absolute inset-0 bg-black/30 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity">
                  <span className="btn btn-primary text-white">Shop Now</span>
                </div>
                <p className="absolute bottom-4 left-4 text-white px-2 py-1 rounded-md text-3xl font-bold">
                  {hardcodedCategories[7].name}
                </p>
              </div>
            </Link>
          </div>
        </div>
      </section>

      {/* Brand Carousel Section */}
      <section className="py-12 bg-inherit">
        <div className="container mx-auto">
          <h2 className="text-3xl font-bold my-8 text-center">
            Trusted Brands
          </h2>
          {/* Wrap carousel in a flex container for centering */}
          <div className="flex justify-center">
            <div className="carousel rounded-box carousel-center bg-base-100 shadow-md p-6 w-full max-w-7xl border border-info">
              {/* Added max-w-6xl or adjust as needed */}
              {brands.map((brand, index) => (
                <div
                  key={brand.id}
                  className="carousel-item flex justify-center items-center p-4"
                >
                  {/* Adjust width/height and styling as needed */}
                  <img
                    loading="lazy"
                    src={brand.image}
                    alt={brand.name}
                    className="object-contain h-24 w-auto max-w-full" // Adjust height (h-24) as needed
                  />
                </div>
              ))}
            </div>
          </div>
        </div>
      </section>

      {/* Featured Products Section */}
      <section className="py-12 px-4 bg-inherit">
        <div className="container mx-auto">
          <h2 className="text-3xl font-bold my-12 text-center">
            Featured Products
          </h2>

          {loading
            ? (
              <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
                {[...Array(8)].map((_, i) => (
                  <div key={i} className="card bg-base-100 shadow-xl">
                    <div className="skeleton h-48 w-full"></div>
                    <div className="card-body">
                      <div className="skeleton h-4 w-3/4 mb-2"></div>
                      <div className="skeleton h-4 w-full mb-2"></div>
                      <div className="skeleton h-4 w-1/2 mb-4"></div>
                      <div className="skeleton h-8 w-full"></div>
                    </div>
                  </div>
                ))}
              </div>
            )
            : isError
            ? ( // Show error state if error occurred
              <div className="text-center py-12">
                <p className="text-xl mb-4 text-error">
                  Error loading :{" "}
                  {error?.message || "An unknown error occurred"}
                </p>
                <button
                  className="btn btn-primary"
                  onClick={() => refetch()} // Use combined refetch
                >
                  Retry
                </button>
              </div>
            )
            : (
              <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
                {featuredProducts.map((product) => (
                  <ProductCard key={product.id} product={product} />
                ))}
              </div>
            )}

          <div className="text-center mt-8">
            <Link to="/products" className="btn btn-outline">
              View All Products
            </Link>
          </div>
        </div>
      </section>
    </div>
  );
};

export default Home;


File: website/src/App.css
================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


File: dashboard/package.json
================================================
{
  "name": "yc-admin-dashboard",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@headlessui/react": "^2.2.9",
    "@heroicons/react": "^2.2.0",
    "@hookform/resolvers": "^5.2.2",
    "@tanstack/react-query": "^5.90.21",
    "axios": "^1.13.5",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-hook-form": "^7.71.1",
    "react-router-dom": "^7.13.0",
    "sonner": "^2.0.7",
    "use-debounce": "^10.1.0",
    "zod": "^4.3.6",
    "zustand": "^5.0.11"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.24",
    "daisyui": "^4",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.19",
    "vite": "^7.3.1"
  }
}


File: dashboard/src/pages/Settings.jsx
================================================
import React, { useState } from "react";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { changeUserPassword, updateUserProfile } from "../services/api";
import { toast } from "sonner";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";

// Schema for Profile Update
const profileSchema = z.object({
  full_name: z.string().min(1, { message: "Full name is required." }),
  email: z.string().email({ message: "Invalid email address." }),
});

// Schema for Password Change
const passwordSchema = z.object({
  current_password: z.string().min(1, {
    message: "Current password is required.",
  }),
  new_password: z.string().min(8, {
    message: "New password must be at least 8 characters long.",
  }),
  confirm_password: z.string().min(1, {
    message: "Please confirm your new password.",
  }),
}).refine((data) => data.new_password === data.confirm_password, {
  message: "Passwords do not match.",
  path: ["confirm_password"],
});

const Settings = () => {
  const queryClient = useQueryClient();
  const storedUserDataString = localStorage.getItem("user"); // Assuming the key is "user"
  let storedUserData = null;
  if (storedUserDataString) {
    try {
      storedUserData = JSON.parse(storedUserDataString);
    } catch (e) {
      console.error("Error parsing user data from localStorage:", e);
      // Handle potential parsing errors gracefully, maybe redirect to login
    }
  }

  const currentUserId = storedUserData?.id; // Extract ID from the parsed object
  // --- END NEW ---

  // Fetch current user data using the ID from localStorage
  // NOTE: This assumes there's an endpoint like GET /v1/user/{id} or GET /v1/user/me
  // If the backend has a specific endpoint for the *current* authenticated user (e.g., /v1/auth/me or /v1/user/profile),
  // you might not need the ID and could fetch directly.
  // For now, let's assume fetchUserById works or you have fetchCurrentUser.
  // Placeholder: Replace with actual API call if needed.
  // const {
  //    userData,
  //   isLoading: userLoading,
  //   isError: userError,
  //   error: userApiError,
  // } = useQuery({
  //   queryKey: ["currentUser", currentUserId],
  //   queryFn: () => fetchUserById(currentUserId), // Use the correct API function
  //   select: (response) => response.data,
  //   enabled: !!currentUserId,
  // });

  const userData = storedUserData; // Use the data from localStorage
  const userLoading = false; // No loading state needed if using localStorage
  const userError = !storedUserData; // Error if data couldn't be retrieved/parsed
  const userApiError = userError
    ? new Error("Could not load user data from storage.")
    : null;

  // --- Profile Update Section ---
  const {
    register: registerProfile,
    handleSubmit: handleSubmitProfile,
    formState: { errors: profileErrors },
    reset: resetProfileForm,
    setValue: setProfileValue,
  } = useForm({
    resolver: zodResolver(profileSchema),
    defaultValues: {
      full_name: "",
      email: "",
    },
  });

  const updateProfileMutation = useMutation({
    mutationFn: updateUserProfile, // Uses the API function defined in api.js
    onSuccess: (data, variables) => { // data is the response, variables are the input (variables.full_name, variables.email)
      if (data && data.data) { // Adjust based on your API response structure (e.g., { success: true, data: { ...updated_user_data... } })
        const updatedStoredData = {
          ...storedUserData, // Spread existing data
          full_name: data.data.full_name || variables.full_name, // Prefer data from API response
          email: data.data.email || variables.email,
          updated_at: data.data.updated_at || new Date().toISOString(), // Update timestamp if provided by API
        };
        localStorage.setItem("user", JSON.stringify(updatedStoredData));
        toast.success("Profile updated successfully!");
        // Reset form to the *new* values from the API response or the submitted ones
        resetProfileForm({
          full_name: updatedStoredData.full_name,
          email: updatedStoredData.email,
        });
      } else {
        // If API response doesn't contain updated user data, optimistically update based on submitted vars
        const optimisticUpdatedData = {
          ...storedUserData,
          full_name: variables.full_name,
          email: variables.email,
          updated_at: new Date().toISOString(), // Update timestamp optimistically
        };
        localStorage.setItem("user", JSON.stringify(optimisticUpdatedData));
        toast.success("Profile updated successfully!");
        resetProfileForm({ // Reset to the submitted values
          full_name: variables.full_name,
          email: variables.email,
        });
      }
      // Optionally invalidate queries if other parts of the app rely on user data fetched via queries
      // queryClient.invalidateQueries({ queryKey: ["currentUser", currentUserId] });
    },
    onError: (error) => {
      console.error("Update Profile Error:", error);
      // Attempt to get error message from response body
      const errorMessage = error.response?.data?.message || error.message ||
        "Unknown error";
      toast.error(`Failed to update profile: ${errorMessage}`);
    },
  });

  const onSubmitProfile = (data) => {
    console.log("Submitting Profile Update Data:", data);
    updateProfileMutation.mutate(data);
  };

  // Prefill profile form when userData is available (from localStorage)
  React.useEffect(() => {
    if (userData) {
      setProfileValue("full_name", userData.full_name || "");
      setProfileValue("email", userData.email || "");
    }
  }, [userData, setProfileValue]); // Depend on userData from localStorage now

  // --- Password Change Section ---
  const {
    register: registerPassword,
    handleSubmit: handleSubmitPassword,
    formState: { errors: passwordErrors },
    reset: resetPasswordForm,
  } = useForm({
    resolver: zodResolver(passwordSchema),
    defaultValues: {
      current_password: "",
      new_password: "",
      confirm_password: "",
    },
  });

  const changePasswordMutation = useMutation({
    mutationFn: changeUserPassword, // Uses the API function defined in api.js
    onSuccess: (data) => {
      toast.success("Password changed successfully!");
      resetPasswordForm(); // Clear the password form after success
      // No need to update localStorage for password change unless the API returns new tokens or user data
    },
    onError: (error) => {
      console.error("Change Password Error:", error);
      // Attempt to get error message from response body
      const errorMessage = error.response?.data?.message || error.message ||
        "Unknown error";
      toast.error(`Failed to change password: ${errorMessage}`);
    },
  });

  const onSubmitPassword = (data) => {
    console.log("Submitting Password Change Data:", data);
    changePasswordMutation.mutate(data);
  };

  if (userError) {
    return (
      <div className="alert alert-error">
        Error: {userApiError.message}. Please log in again.
        {/* You might want to trigger a logout here */}
      </div>
    );
  }

  if (!userData) {
    return (
      <div className="alert alert-warning">
        User data not available.
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">Settings</h1>

      <div className="grid grid-cols-1 gap-8">
        {/* Profile Update Card */}
        <div className="bg-neutral p-6 rounded-lg shadow-md">
          <h2 className="text-xl font-bold mb-4">Update Profile</h2>
          <form
            onSubmit={handleSubmitProfile(onSubmitProfile)}
            className="space-y-4"
          >
            <div className="form-control">
              <label className="label">
                <span className="label-text">Full Name</span>
              </label>
              <input
                type="text"
                className={`input input-bordered ${
                  profileErrors.full_name ? "input-error" : ""
                }`}
                placeholder="Enter your full name..."
                {...registerProfile("full_name")}
              />
              {profileErrors.full_name && (
                <label className="label">
                  <span className="label-text-alt text-error">
                    {profileErrors.full_name.message}
                  </span>
                </label>
              )}
            </div>

            <div className="form-control">
              <label className="label">
                <span className="label-text">Email</span>
              </label>
              <input
                type="email"
                className={`input input-bordered ${
                  profileErrors.email ? "input-error" : ""
                }`}
                placeholder="Enter your email..."
                {...registerProfile("email")}
              />
              {profileErrors.email && (
                <label className="label">
                  <span className="label-text-alt text-error">
                    {profileErrors.email.message}
                  </span>
                </label>
              )}
            </div>

            <div className="form-control mt-6">
              <button
                type="submit"
                className="btn btn-primary"
                disabled={updateProfileMutation.isPending}
              >
                {updateProfileMutation.isPending
                  ? (
                    <>
                      <span className="loading loading-spinner loading-xs mr-2">
                      </span>{" "}
                      Updating...
                    </>
                  )
                  : "Update Profile"}
              </button>
            </div>
          </form>
        </div>

        {/* Password Change Card */}
        <div className="bg-neutral p-6 rounded-lg shadow-md">
          <h2 className="text-xl font-bold mb-4">Change Password</h2>
          <form
            onSubmit={handleSubmitPassword(onSubmitPassword)}
            className="space-y-4"
          >
            <div className="form-control">
              <label className="label">
                <span className="label-text">Current Password</span>
              </label>
              <input
                type="password"
                className={`input input-bordered ${
                  passwordErrors.current_password ? "input-error" : ""
                }`}
                placeholder="Enter your current password..."
                {...registerPassword("current_password")}
              />
              {passwordErrors.current_password && (
                <label className="label">
                  <span className="label-text-alt text-error">
                    {passwordErrors.current_password.message}
                  </span>
                </label>
              )}
            </div>

            <div className="form-control">
              <label className="label">
                <span className="label-text">New Password</span>
              </label>
              <input
                type="password"
                className={`input input-bordered ${
                  passwordErrors.new_password ? "input-error" : ""
                }`}
                placeholder="Enter your new password..."
                {...registerPassword("new_password")}
              />
              {passwordErrors.new_password && (
                <label className="label">
                  <span className="label-text-alt text-error">
                    {passwordErrors.new_password.message}
                  </span>
                </label>
              )}
            </div>

            <div className="form-control">
              <label className="label">
                <span className="label-text">Confirm New Password</span>
              </label>
              <input
                type="password"
                className={`input input-bordered ${
                  passwordErrors.confirm_password ? "input-error" : ""
                }`}
                placeholder="Confirm your new password..."
                {...registerPassword("confirm_password")}
              />
              {passwordErrors.confirm_password && (
                <label className="label">
                  <span className="label-text-alt text-error">
                    {passwordErrors.confirm_password.message}
                  </span>
                </label>
              )}
            </div>

            <div className="form-control mt-6">
              <button
                type="submit"
                className="btn btn-primary"
                disabled={changePasswordMutation.isPending}
              >
                {changePasswordMutation.isPending
                  ? (
                    <>
                      <span className="loading loading-spinner loading-xs mr-2">
                      </span>{" "}
                      Changing...
                    </>
                  )
                  : "Change Password"}
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
};

export default Settings;


File: dashboard/src/pages/customers/CustomerList.jsx
================================================
import React, { useState } from "react";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import {
  activateUser,
  deactivateUser,
  fetchUserById,
  fetchUsers,
} from "../../services/api";
import { toast } from "sonner";

const CustomersList = () => {
  const queryClient = useQueryClient();

  // State for pagination
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage, setItemsPerPage] = useState(20);
  // State for active_only filter
  const [filterActiveOnly, setFilterActiveOnly] = useState(false);

  // State for user details modal
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [modalUserData, setModalUserData] = useState(null);
  const [modalLoading, setModalLoading] = useState(false);
  const [modalError, setModalError] = useState(null);

  const buildQueryParams = () => {
    const params = {
      page: currentPage,
      limit: itemsPerPage,
    };
    if (filterActiveOnly) {
      params.active_only = "true"; // API expects string "true"
    }
    return params;
  };

  const {
    data,
    isLoading,
    isError,
    error,
    refetch,
  } = useQuery({
    queryKey: ["users", currentPage, itemsPerPage, filterActiveOnly], // Include filter in key
    queryFn: () => fetchUsers(buildQueryParams()),
    select: (response) => {
      const { data, page, limit, total, total_pages } = response.data;
      return {
        users: data,
        pagination: { page, limit, total, totalPages: total_pages },
      };
    },
  });

  const { users = [], pagination } = data || {};

  // Fetch user details for modal
  const fetchUserDetails = async (userId) => {
    setModalLoading(true);
    setModalError(null);
    try {
      const response = await fetchUserById(userId);
      // Assuming the response structure is { success: true, data: { ...user_details... } }
      // Adjust based on your actual API response shape for user details
      const userDetails = response.data;
      setModalUserData(userDetails);
    } catch (err) {
      console.error("Error fetching user details:", err);
      setModalError(err.message || "Failed to load user details.");
      setModalUserData(null); // Clear any old data on error
    } finally {
      setModalLoading(false);
    }
  };

  // Mutation for activating user
  const activateUserMutation = useMutation({
    mutationFn: activateUser, // Pass ID directly
    onSuccess: (data, activatedUserId) => {
      // Invalidate and refetch the specific user and the list
      queryClient.invalidateQueries({ queryKey: ["user", activatedUserId] }); // If you had a query for individual user
      queryClient.invalidateQueries({ queryKey: ["users"] });
      toast.success("User activated successfully!");
    },
    onError: (error, activatedUserId) => {
      console.error("Activate User Error:", error);
      toast.error(
        `Failed to activate user ID ${activatedUserId}: ${
          error.message || "Unknown error"
        }`,
      );
    },
  });

  // Mutation for deactivating user
  const deactivateUserMutation = useMutation({
    mutationFn: deactivateUser, // Pass ID directly
    onSuccess: (data, deactivatedUserId) => {
      // Invalidate and refetch the specific user and the list
      queryClient.invalidateQueries({ queryKey: ["user", deactivatedUserId] });
      queryClient.invalidateQueries({ queryKey: ["users"] });
      toast.success("User deactivated successfully!");
    },
    onError: (error, deactivatedUserId) => {
      console.error("Deactivate User Error:", error);
      toast.error(
        `Failed to deactivate user ID ${deactivatedUserId}: ${
          error.message || "Unknown error"
        }`,
      );
    },
  });

  // Handler for changing pages
  const goToPage = (newPage) => {
    if (pagination) {
      const { page: currentPageFromMeta, totalPages } = pagination;
      if (newPage >= 1 && (!totalPages || newPage <= totalPages)) {
        setCurrentPage(newPage);
      }
    } else {
      if (newPage >= 1) {
        setCurrentPage(newPage);
      }
    }
  };

  // Handler for changing items per page
  const handleItemsPerPageChange = (newLimit) => {
    setItemsPerPage(newLimit);
    setCurrentPage(1); // Reset to first page when limit changes
  };

  // Handler for active_only filter change
  const handleFilterActiveOnlyChange = (e) => {
    setFilterActiveOnly(e.target.checked);
    setCurrentPage(1); // Reset to first page when filter changes
  };

  // Handler for opening the user details modal
  const handleOpenModal = async (userId) => {
    setIsModalOpen(true);
    // Fetch details when modal opens
    await fetchUserDetails(userId);
  };

  // Handler for closing the modal
  const handleCloseModal = () => {
    setIsModalOpen(false);
    setModalUserData(null); // Clear data when closing
    setModalError(null); // Clear error when closing
  };

  // Handler for activate user action
  const handleActivateUser = (userId) => {
    if (
      window.confirm(`Are you sure you want to activate user ID: ${userId}?`)
    ) {
      console.log(`Attempting to activate user: ${userId}`);
      activateUserMutation.mutate(userId);
    }
  };

  // Handler for deactivate user action
  const handleDeactivateUser = (userId) => {
    if (
      window.confirm(`Are you sure you want to deactivate user ID: ${userId}?`)
    ) {
      console.log(`Attempting to deactivate user: ${userId}`);
      deactivateUserMutation.mutate(userId);
    }
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  }

  if (isError) {
    return (
      <div className="alert alert-error shadow-lg">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          className="stroke-current flex-shrink-0 h-6 w-6"
          fill="none"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="2"
            d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"
          />
        </svg>
        <span>Error: {error.message}</span>
        <button onClick={() => refetch()} className="btn btn-sm">Retry</button>
      </div>
    );
  }

  // Helper function to truncate UUID
  const truncateUuid = (uuid) => {
    if (!uuid || typeof uuid !== "string") return "N/A";
    return `${uuid.substring(0, 8)}...`;
  };

  // Helper function to format date
  const formatDate = (dateString) => {
    if (!dateString) return "N/A";
    return new Date(dateString).toLocaleString();
  };

  return (
    <div className="bg-neutral p-6 rounded-lg shadow-md">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-xl font-bold">Customers</h2>
        {/* Add any potential global customer actions here if needed */}
      </div>

      {/* Filter Controls */}
      <div className="bg-base-100 p-4 rounded-box mb-4 flex flex-wrap items-center gap-4">
        <div className="form-control">
          <label className="label cursor-pointer justify-start gap-2">
            <span className="label-text">Active Only</span>
            <input
              type="checkbox"
              className="toggle toggle-primary"
              checked={filterActiveOnly}
              onChange={handleFilterActiveOnlyChange}
            />
          </label>
        </div>
        {/* Add more filters here if needed (e.g., date range, name/email search) */}
      </div>

      {/* Pagination Controls Top */}
      {pagination && (
        <div className="flex flex-col sm:flex-row justify-between items-center mb-4 gap-2">
          <div className="text-sm">
            Showing {(pagination.page - 1) * pagination.limit + 1} -
            {Math.min(pagination.page * pagination.limit, pagination.total)} of
            {" "}
            {pagination.total} customers
          </div>
          <div className="join">
            <button
              className="join-item btn btn-xs"
              onClick={() => goToPage(pagination.page - 1)}
              disabled={pagination.page <= 1}
            >
              « Prev
            </button>
            <button className="join-item btn btn-xs">
              Page {pagination.page} of {pagination.totalPages}
            </button>
            <button
              className="join-item btn btn-xs"
              onClick={() => goToPage(pagination.page + 1)}
              disabled={pagination.page >= pagination.totalPages}
            >
              Next »
            </button>
          </div>
          <select
            className="select select-bordered select-xs w-24"
            value={itemsPerPage}
            onChange={(e) => handleItemsPerPageChange(Number(e.target.value))}
          >
            <option value={10}>10/page</option>
            <option value={20}>20/page</option>
            <option value={50}>50/page</option>
            <option value={100}>100/page</option>
          </select>
        </div>
      )}

      <div className="overflow-x-auto">
        <table className="table table-zebra w-full">
          <thead>
            <tr>
              <th>ID (Truncated)</th>
              <th>Name</th>
              <th>Email</th>
              <th>Registration Date</th>
              <th>Order Count</th>
              <th>Activity Status</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {users.length > 0
              ? (
                users.map((user) => {
                  const statusClass = user.activity_status === "Active"
                    ? "badge-success"
                    : "badge-error";

                  return (
                    <tr key={user.id}>
                      <td>
                        <button
                          className="btn btn-xs btn-ghost"
                          onClick={() => handleOpenModal(user.id)}
                          title="View user details"
                        >
                          {truncateUuid(user.id)}
                        </button>
                      </td>
                      <td>{user.name}</td>
                      <td>{user.email}</td>
                      <td>{formatDate(user.registration_date)}</td>
                      <td>{user.order_count}</td>
                      <td>
                        <span className={`badge ${statusClass}`}>
                          {user.activity_status}
                        </span>
                      </td>
                      <td>
                        <div className="flex gap-2">
                          {user.activity_status === "Active"
                            ? (
                              <button
                                className="btn btn-xs btn-error"
                                onClick={() => handleDeactivateUser(user.id)}
                                disabled={deactivateUserMutation.isPending}
                                title="Deactivate user"
                              >
                                {deactivateUserMutation.isPending &&
                                    deactivateUserMutation.variables === user.id
                                  ? (
                                    <span className="loading loading-spinner loading-xs">
                                    </span>
                                  )
                                  : "Deactivate"}
                              </button>
                            )
                            : (
                              <button
                                className="btn btn-xs btn-success"
                                onClick={() => handleActivateUser(user.id)}
                                disabled={activateUserMutation.isPending}
                                title="Activate user"
                              >
                                {activateUserMutation.isPending &&
                                    activateUserMutation.variables === user.id
                                  ? (
                                    <span className="loading loading-spinner loading-xs">
                                    </span>
                                  )
                                  : "Activate"}
                              </button>
                            )}
                        </div>
                      </td>
                    </tr>
                  );
                })
              )
              : (
                <tr>
                  <td colSpan="8" className="text-center py-4">
                    No customers found.
                  </td>
                </tr>
              )}
          </tbody>
        </table>
      </div>

      {/* Pagination Controls Bottom */}
      {pagination && (
        <div className="flex flex-col sm:flex-row justify-between items-center mt-4 gap-2">
          <div className="text-sm">
            Showing {(pagination.page - 1) * pagination.limit + 1} -
            {Math.min(pagination.page * pagination.limit, pagination.total)} of
            {" "}
            {pagination.total} customers
          </div>
          <div className="join">
            <button
              className="join-item btn btn-xs"
              onClick={() => goToPage(pagination.page - 1)}
              disabled={pagination.page <= 1}
            >
              « Prev
            </button>
            <button className="join-item btn btn-xs">
              Page {pagination.page} of {pagination.totalPages}
            </button>
            <button
              className="join-item btn btn-xs"
              onClick={() => goToPage(pagination.page + 1)}
              disabled={pagination.page >= pagination.totalPages}
            >
              Next »
            </button>
          </div>
          <select
            className="select select-bordered select-xs w-24"
            value={itemsPerPage}
            onChange={(e) => handleItemsPerPageChange(Number(e.target.value))}
          >
            <option value={10}>10/page</option>
            <option value={20}>20/page</option>
            <option value={50}>50/page</option>
            <option value={100}>100/page</option>
          </select>
        </div>
      )}

      {/* User Details Modal */}
      {isModalOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-neutral p-6 rounded-lg shadow-lg w-full max-w-md max-h-[90vh] overflow-y-auto">
            <h3 className="text-lg font-bold mb-4">User Details</h3>

            {modalLoading && (
              <div className="flex justify-center items-center h-24">
                <span className="loading loading-spinner loading-lg"></span>
              </div>
            )}

            {modalError && (
              <div className="alert alert-error mb-4">
                <p>Error loading details: {modalError}</p>
              </div>
            )}

            {!modalLoading && !modalError && modalUserData && (
              <div className="space-y-2 text-sm">
                <p>
                  <strong>ID:</strong> {truncateUuid(modalUserData.id)}
                </p>
                <p>
                  <strong>Name:</strong> {modalUserData.name}
                </p>
                <p>
                  <strong>Email:</strong> {modalUserData.email}
                </p>
                <p>
                  <strong>Registration Date:</strong>{" "}
                  {formatDate(modalUserData.registration_date)}
                </p>
                <p>
                  <strong>Last Order Date:</strong>{" "}
                  {formatDate(modalUserData.last_order_date)}
                </p>
                <p>
                  <strong>Order Count:</strong> {modalUserData.order_count}
                </p>
                <p>
                  <strong>Activity Status:</strong>{" "}
                  <span
                    className={`badge ${
                      modalUserData.activity_status === "Active"
                        ? "badge-success"
                        : "badge-error"
                    }`}
                  >
                    {modalUserData.activity_status}
                  </span>
                </p>
              </div>
            )}

            <div className="flex justify-end mt-4">
              <button
                className="btn btn-primary"
                onClick={handleCloseModal}
              >
                Close
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default CustomersList;


File: dashboard/src/pages/delivery/EditDeliveryService.jsx
================================================
// src/pages/delivery/EditDeliveryService.jsx
import React from "react";
import { Link, useNavigate, useParams } from "react-router-dom";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import {
  fetchDeliveryServiceById,
  updateDeliveryService,
} from "../../services/api";
import { ArrowLeftIcon } from "@heroicons/react/24/outline";
import { toast } from "sonner";
// Define the Zod schema for validation (similar to add, can be reused or extended)
const editDeliveryServiceSchema = z.object({
  name: z.string().min(1, { message: "Name is required." }),
  description: z.string().min(1, { message: "Description is required." }),
  base_cost_cents: z.number().int().min(0, {
    message: "Base cost must be zero or positive.",
  }),
  estimated_days: z.number().int().min(1, {
    message: "Estimated days must be at least 1.",
  }),
  is_active: z.boolean(),
});

const EditDeliveryService = () => {
  const { id: deliveryServiceId } = useParams();
  const navigate = useNavigate();
  const queryClient = useQueryClient();

  const {
    data: deliveryService,
    isLoading: serviceLoading,
    isError: serviceError,
    error: serviceFetchError,
  } = useQuery({
    queryKey: ["deliveryService", deliveryServiceId],
    queryFn: () => fetchDeliveryServiceById(deliveryServiceId),
    select: (response) => response.data, // Adjust based on your API response structure (should be the service object itself)
    enabled: !!deliveryServiceId, // Only run query if deliveryServiceId is available
  });

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset, // Use reset to populate form with fetched data
  } = useForm({
    resolver: zodResolver(editDeliveryServiceSchema),
    defaultValues: {
      name: "",
      description: "",
      base_cost_cents: 0,
      estimated_days: 1,
      is_active: true,
    },
  });

  // Prefill form when data is loaded
  React.useEffect(() => {
    if (deliveryService) {
      reset({
        name: deliveryService.name,
        description: deliveryService.description,
        base_cost_cents: deliveryService.base_cost_cents,
        estimated_days: deliveryService.estimated_days,
        is_active: deliveryService.is_active,
      });
    }
  }, [deliveryService, reset]);

  const updateDeliveryServiceMutation = useMutation({
    mutationFn: ({ id, data }) => updateDeliveryService(id, data), // Adjust mutation function signature
    onSuccess: (data, variables) => { // Use variables to get the ID
      // Invalidate and refetch the specific service and the list
      queryClient.invalidateQueries({
        queryKey: ["deliveryService", variables.id],
      });
      queryClient.invalidateQueries({ queryKey: ["deliveryServices"] });
      toast.success("Delivery Service updated successfully!");
      navigate("/admin/delivery"); // Redirect back to the list
    },
    onError: (error) => {
      console.error("Update Error:", error);
      toast.error(
        `Failed to update delivery service: ${
          error.message || "Unknown error"
        }`,
      );
    },
  });

  const onSubmit = (data) => {
    console.log("Submitting Edit Delivery Service Data:", data);
    // Convert base_cost_cents and estimated_days to integers if they are strings from input
    const submitData = {
      ...data,
      base_cost_cents: parseInt(data.base_cost_cents, 10),
      estimated_days: parseInt(data.estimated_days, 10),
    };
    updateDeliveryServiceMutation.mutate({
      id: deliveryServiceId,
      data: submitData,
    }); // Pass id and data object
  };

  if (serviceLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  }

  if (serviceError) {
    return (
      <div className="alert alert-error">
        Error loading delivery service: {serviceFetchError.message}
        <Link to="/admin/delivery" className="btn btn-sm ml-4">
          Go Back to List
        </Link>
      </div>
    );
  }

  if (!deliveryService) {
    return (
      <div className="alert alert-warning">
        Delivery Service not found.
        <Link to="/admin/delivery" className="btn btn-sm ml-4">
          Go Back to List
        </Link>
      </div>
    );
  }

  return (
    <div className="bg-neutral p-6 rounded-lg shadow-md max-w-2xl mx-auto">
      <Link to="/admin/delivery" className="btn btn-ghost btn-sm mb-6">
        <ArrowLeftIcon className="h-4 w-4 mr-2" />
        Back to Delivery Services
      </Link>

      <h2 className="text-xl font-bold mb-6">
        Edit Delivery Service: {deliveryService.name}
      </h2>

      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
        <div className="form-control">
          <label className="label">
            <span className="label-text">Name *</span>
          </label>
          <input
            type="text"
            className={`input input-bordered ${
              errors.name ? "input-error" : ""
            }`}
            placeholder="Enter service name..."
            {...register("name")}
          />
          {errors.name && (
            <label className="label">
              <span className="label-text-alt text-error">
                {errors.name.message}
              </span>
            </label>
          )}
        </div>

        <div className="form-control">
          <label className="label">
            <span className="label-text">Description *</span>
          </label>
          <textarea
            className={`textarea textarea-bordered ${
              errors.description ? "textarea-error" : ""
            }`}
            placeholder="Enter service description..."
            rows="3"
            {...register("description")}
          >
          </textarea>
          {errors.description && (
            <label className="label">
              <span className="label-text-alt text-error">
                {errors.description.message}
              </span>
            </label>
          )}
        </div>

        <div className="form-control">
          <label className="label">
            <span className="label-text">Base Cost (cents) *</span>
          </label>
          <input
            type="number"
            min="0"
            className={`input input-bordered ${
              errors.base_cost_cents ? "input-error" : ""
            }`}
            placeholder="Enter cost in cents (e.g., 1500 for 15.00 DZD)..."
            {...register("base_cost_cents", { valueAsNumber: true })}
          />{" "}
          {errors.base_cost_cents && (
            <label className="label">
              <span className="label-text-alt text-error">
                {errors.base_cost_cents.message}
              </span>
            </label>
          )}
        </div>

        <div className="form-control">
          <label className="label">
            <span className="label-text">Estimated Days *</span>
          </label>
          <input
            type="number"
            min="1"
            className={`input input-bordered ${
              errors.estimated_days ? "input-error" : ""
            }`}
            placeholder="Enter estimated delivery days..."
            {...register("estimated_days", { valueAsNumber: true })}
          />{" "}
          {errors.estimated_days && (
            <label className="label">
              <span className="label-text-alt text-error">
                {errors.estimated_days.message}
              </span>
            </label>
          )}
        </div>

        <div className="form-control">
          <label className="label cursor-pointer justify-between">
            <span className="label-text">Active *</span>
            <input
              type="checkbox"
              className="toggle toggle-primary"
              {...register("is_active")}
            />
          </label>
        </div>

        <div className="form-control mt-6">
          <div className="flex gap-2">
            <button
              type="submit"
              className="btn btn-primary flex-1"
              disabled={updateDeliveryServiceMutation.isPending}
            >
              {updateDeliveryServiceMutation.isPending
                ? (
                  <>
                    <span className="loading loading-spinner loading-xs mr-2">
                    </span>{" "}
                    Saving...
                  </>
                )
                : "Save Changes"}
            </button>
            <button
              type="button"
              className="btn btn-ghost"
              onClick={() => navigate(-1)} // Go back
            >
              Cancel
            </button>
          </div>
        </div>
      </form>
    </div>
  );
};

export default EditDeliveryService;


File: dashboard/src/pages/products/ProductView.jsx
================================================
import React, { useState } from "react";
import { Link, useParams } from "react-router-dom";
import { useQuery } from "@tanstack/react-query";
import { ArrowLeftIcon } from "@heroicons/react/24/outline";
import {
  fetchActiveDiscounts, // Import the new function
  fetchProductById,
  fetchProductDiscounts,
} from "../../services/api";

const ProductView = () => {
  const { id: productId } = useParams();

  // Fetch product details
  const {
    data: product,
    isLoading: productLoading,
    isError: productError,
    error: productFetchError,
  } = useQuery({
    queryKey: ["product", productId],
    queryFn: () => fetchProductById(productId),
    select: (response) => response.data, // Adjust based on your API response structure
    enabled: !!productId,
  });

  // Fetch discounts linked to this product
  const {
    data: productDiscounts,
    isLoading: discountsLoading,
    isError: discountsError,
    error: discountsFetchError,
  } = useQuery({
    queryKey: ["productDiscounts", productId], // Unique query key
    queryFn: () => fetchProductDiscounts(productId),
    select: (response) => response.data,
    enabled: !!productId && !!product,
  });

  // Fetch active discounts
  const {
    data: allDiscounts, // Renamed for clarity, it now holds active discounts
    isLoading: allDiscountsLoading,
    isError: allDiscountsError,
    error: allDiscountsFetchError,
  } = useQuery({
    queryKey: ["activeDiscounts"], // Updated query key
    queryFn: fetchActiveDiscounts, // Use the new function
    select: (response) => response.data.data, // Adjust based on your API response structure for discounts
    // You might want to cache this globally if used elsewhere
  });

  const BACKEND_BASE_URL = import.meta.env.VITE_BACKEND_BASE_URL ||
    "http://localhost:8080";

  // State for image gallery
  const [selectedImageIndex, setSelectedImageIndex] = useState(0);

  // State to manage the link discount modal
  const [isLinkModalOpen, setIsLinkModalOpen] = useState(false);
  const [selectedDiscountToLink, setSelectedDiscountToLink] = useState(""); // State for selected discount ID
  // State for the discount modal search term
  const [searchTerm, setSearchTerm] = useState("");

  // Calculate prices and discounts
  const originalPriceInDZD = product
    ? (product.price_cents / 100).toFixed(2)
    : 0;
  const currentPriceInDZD = product
    ? (product.discounted_price_cents / 100).toFixed(2)
    : 0;
  const hasDiscount = product && product.has_active_discount;
  const discountPercentage =
    product && product.total_calculated_fixed_discount_cents > 0
      ? Math.trunc(product.effective_discount_percentage)
      : 0;

  const truncateUuid = (uuid) => {
    if (!uuid || typeof uuid !== "string") return "N/A"; // Handle invalid/missing IDs gracefully
    return `${uuid.substring(0, 8)}...`; // Take first 8 characters and append '...'
  };

  if (productLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  }

  if (productError) {
    return (
      <div className="alert alert-error">
        Error loading product: {productFetchError.message}
        <Link to="/admin/products" className="btn btn-sm ml-4">
          Go Back to List
        </Link>
      </div>
    );
  }

  if (!product) {
    return (
      <div className="alert alert-warning">
        Product not found.
        <Link to="/admin/products" className="btn btn-sm ml-4">
          Go Back to List
        </Link>
      </div>
    );
  }

  const imageGalleryList = product.image_urls || [];
  const currentImageSrc = imageGalleryList[selectedImageIndex]
    ? `${BACKEND_BASE_URL}${imageGalleryList[selectedImageIndex]}`
    : "https://placehold.co/600x600?text=No+Image  ";

  // Determine loading/error state for discounts section
  const discountsSectionLoading = discountsLoading;
  const discountsSectionError = discountsError;

  // Function to handle opening the modal
  const handleOpenLinkModal = () => {
    setIsLinkModalOpen(true);
    // Optionally, fetch all discounts again if cache is stale or expired here
    // Or rely on the initial query which should ideally be cached globally
  };

  // Function to handle closing the modal
  const handleCloseLinkModal = () => {
    setIsLinkModalOpen(false);
    setSelectedDiscountToLink("");
    setSearchTerm(""); // Clear search term when closing modal
  };

  // Function to handle discount selection in the modal
  const handleDiscountSelect = (discountId) => {
    setSelectedDiscountToLink(discountId);
  };

  // Function to handle the link action (placeholder for now)
  const handleLinkDiscount = async () => {
    if (!selectedDiscountToLink) return; // Nothing selected

    console.log(
      "Attempting to link discount:",
      selectedDiscountToLink,
      "to product:",
      productId,
    );
    // TODO: Implement the actual API call to link the discount
    // Example: await linkProductDiscount(selectedDiscountToLink, productId);
    // TODO: Refetch product discounts after successful link
    // Example: refetchProductDiscounts(); // Assuming you have a refetch function from the query hook
    handleCloseLinkModal(); // Close modal after linking (or on success/error)
  };

  return (
    <div className="container mx-auto px-4 py-8 bg-secondary-content rounded-lg min-h-screen">
      {/* Back Link */}
      <Link to="/admin/products" className="btn btn-accent btn-outline mb-6">
        <ArrowLeftIcon className="h-4 w-4 mr-2" />
        Back to Products
      </Link>

      <div className="divider"></div>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
        {/* Image Gallery */}
        <div>
          <div className="aspect-square mb-4 bg-base-100 rounded-lg p-4">
            <img
              src={currentImageSrc}
              alt={`${product.name} - Image ${selectedImageIndex + 1}`}
              className="w-full h-full object-contain rounded-lg"
              onError={(e) => {
                e.target.src =
                  "https://placehold.co/600x600?text=Image+Error  ";
              }}
            />
          </div>
          <div className="flex flex-wrap gap-2 mt-2 max-h-32 overflow-y-auto">
            {imageGalleryList.map((imgPath, index) => {
              const fullThumbUrl = `${BACKEND_BASE_URL}${imgPath}`;
              return (
                <button
                  key={index}
                  className={`w-16 h-16 border rounded ${
                    selectedImageIndex === index
                      ? "border-primary ring-2 ring-primary"
                      : "border-transparent"
                  } bg-base-200 flex-shrink-0`}
                  onClick={() => setSelectedImageIndex(index)}
                  title={`View Image ${index + 1}`}
                >
                  <img
                    src={fullThumbUrl}
                    alt={`Thumbnail ${index + 1}`}
                    className="w-full h-full object-cover rounded pointer-events-none"
                    onError={(e) => {
                      e.target.src = "https://placehold.co/100x100?text=Err  ";
                    }}
                  />
                </button>
              );
            })}
          </div>
        </div>

        {/* Product Info */}
        <div>
          <h1 className="text-3xl font-bold mb-4">{product.name}</h1>
          <div className="flex items-center gap-2 mb-4">
            <span className="text-2xl font-bold text-primary">
              DA {currentPriceInDZD}
            </span>
            {hasDiscount && originalPriceInDZD !== currentPriceInDZD && (
              <>
                <span className="line-through text-gray-500">
                  DA {originalPriceInDZD}
                </span>
                <span className="badge badge-success bg-green-600 text-white">
                  -{product.effective_discount_percentage}%
                </span>
              </>
            )}
          </div>

          <p className="text-gray-600 mb-4">
            {product.description || product.short_description ||
              "No description available."}
          </p>

          <div className="mb-6">
            <table className="table bg-neutral">
              <tbody>
                <tr>
                  <td>Product ID</td>
                  <td className="font-mono">{product.id}</td>
                </tr>
                <tr>
                  <td>Slug</td>
                  <td className="font-mono">{product.slug}</td>
                </tr>
                <tr>
                  <td>Category</td>
                  <td>
                    {product.category_name || product.category_id || "N/A"}
                  </td>
                </tr>
                <tr>
                  <td>Brand</td>
                  <td>{product.brand}</td>
                </tr>
                <tr>
                  <td>Stock Quantity</td>
                  <td
                    className={product.stock_quantity > 0
                      ? "text-success"
                      : "text-error"}
                  >
                    {product.stock_quantity > 0
                      ? `${product.stock_quantity} In Stock`
                      : "Out of Stock"}
                  </td>
                </tr>
                <tr>
                  <td>Status</td>
                  <td>
                    <span
                      className={`badge ${
                        product.status === "active"
                          ? "badge-success"
                          : product.status === "draft"
                          ? "badge-warning"
                          : "badge-error"
                      }`}
                    >
                      {product.status}
                    </span>
                  </td>
                </tr>
                <tr>
                  <td>Has Active Discount</td>
                  <td>
                    <span
                      className={`badge ${
                        product.has_active_discount
                          ? "badge-success"
                          : "badge-neutral"
                      }`}
                    >
                      {product.has_active_discount ? "Yes" : "No"}
                    </span>
                  </td>
                </tr>
                <tr>
                  <td>Average Rating</td>
                  <td>
                    {product.avg_rating?.toFixed(2) || "N/A"}{" "}
                    ({product.num_ratings} reviews)
                  </td>
                </tr>
                <tr>
                  <td>Created At</td>
                  <td>{new Date(product.created_at).toLocaleString()}</td>
                </tr>
                <tr>
                  <td>Updated At</td>
                  <td>{new Date(product.updated_at).toLocaleString()}</td>
                </tr>
              </tbody>
            </table>
          </div>

          <div className="flex gap-2 mb-6">
            <Link
              to={`/admin/products/${product.id}/edit`}
              className="btn btn-primary flex-1"
            >
              Edit Product
            </Link>
          </div>

          <div className="divider"></div>
          <h2 className="text-2xl content-center font-bold mb-4">
            Specifications
          </h2>
          <div className="bg-secondary-content p-4 rounded-box border border-base-200">
            <table className="table bg-neutral">
              <tbody>
                {product.spec_highlights &&
                    Object.keys(product.spec_highlights).length > 0
                  ? (
                    Object.entries(product.spec_highlights).map((
                      [key, value],
                    ) => (
                      <tr className="hover" key={key}>
                        <td className="font-semibold capitalize">
                          {key.replace(/_/g, " ")}
                        </td>
                        <td>{value}</td>
                      </tr>
                    ))
                  )
                  : (
                    <tr>
                      <td colSpan="2" className="italic text-center">
                        No specifications provided.
                      </td>
                    </tr>
                  )}
              </tbody>
            </table>
          </div>
        </div>
      </div>

      {/* Discounts Applied Section */}
      <div className="mt-12">
        <div className="divider"></div>
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold">Applied Discounts</h2>
          <button
            className="btn btn-primary"
            onClick={handleOpenLinkModal}
          >
            Link Discount
          </button>
        </div>

        {discountsSectionLoading && (
          <div className="flex justify-center items-center h-24">
            <span className="loading loading-spinner loading-lg"></span>
          </div>
        )}

        {discountsSectionError && (
          <div className="alert alert-error">
            Error loading discounts: {discountsFetchError.message}
          </div>
        )}

        {!discountsSectionLoading && !discountsSectionError && (
          <>
            {productDiscounts && productDiscounts.length > 0
              ? (
                <div className="overflow-x-auto">
                  <table className="table  w-full bg-neutral">
                    <thead>
                      <tr>
                        <th>Discount ID</th>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Value</th>
                        <th>Start Date</th>
                        <th>End Date</th>
                        <th>Status</th>
                        <th>Actions</th> {/* Future: Unlink button */}
                      </tr>
                    </thead>
                    <tbody>
                      {productDiscounts.map((discount) => (
                        <tr className="hover" key={discount.id}>
                          <td className="font-mono">
                            {truncateUuid(discount.id)}
                          </td>
                          <td>{discount.code}</td>
                          <td>{discount.discount_type}</td>
                          <td>{discount.discount_value}</td>
                          <td>
                            {discount.valid_from
                              ? new Date(discount.valid_from)
                                .toLocaleDateString()
                              : "N/A"}
                          </td>
                          <td>
                            {discount.valid_until
                              ? new Date(discount.valid_until)
                                .toLocaleDateString()
                              : "N/A"}
                          </td>
                          <td>
                            <span
                              className={`badge ${
                                discount.is_active
                                  ? "badge-success"
                                  : "badge-neutral"
                              }`}
                            >
                              {discount.is_active ? "Active" : "Inactive"}
                            </span>
                          </td>
                          <td>
                            {/* Placeholder for future unlink functionality */}
                            <button className="btn btn-xs btn-error" disabled>
                              Unlink
                            </button>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )
              : (
                <div className="alert alert-info">
                  <p>No discounts are currently applied to this product.</p>
                </div>
              )}
          </>
        )}
      </div>

      {/* Modal for Linking Discount */}
      {isLinkModalOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-neutral p-6 rounded-lg shadow-lg w-full max-w-4xl max-h-[90vh] overflow-y-auto">
            {/* Adjusted size and added scrolling */}
            <h3 className="text-lg font-bold mb-4">Link Discount to Product</h3>

            {allDiscountsLoading && (
              <div className="flex justify-center items-center h-24">
                <span className="loading loading-spinner loading-lg"></span>
              </div>
            )}

            {allDiscountsError && (
              <div className="alert alert-error">
                Error loading discounts: {allDiscountsFetchError.message}
              </div>
            )}

            {!allDiscountsLoading && !allDiscountsError && allDiscounts && (
              <div className="mb-4">
                <p className="label-text mb-2">Select an active discount:</p>
                {/* Search Bar */}
                <input
                  type="text"
                  placeholder="Search discounts..."
                  className="input input-bordered w-full mb-4"
                  value={searchTerm} // State for search term
                  onChange={(e) => setSearchTerm(e.target.value)} // Update state on change
                />
                {/* Grid for discount cards - Filtered by search term */}
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 max-h-[60vh] overflow-y-auto p-2">
                  {allDiscounts
                    .filter((discount) => {
                      // Filter based on search term
                      if (!searchTerm) return true; // If no search term, show all
                      // Case-insensitive search in code, type, or value
                      return (
                        discount.code.toLowerCase().includes(
                          searchTerm.toLowerCase(),
                        ) ||
                        discount.discount_type.toLowerCase().includes(
                          searchTerm.toLowerCase(),
                        ) ||
                        discount.discount_value.toString().toLowerCase()
                          .includes(searchTerm.toLowerCase())
                        // Add more fields to search if needed
                      );
                    })
                    .map((discount) => {
                      // Calculate if this discount is already linked to prevent selection
                      const isAlreadyLinked = productDiscounts &&
                        productDiscounts.some((pd) => pd.id === discount.id);

                      return (
                        <div
                          key={discount.id}
                          className={`card bg-base-100 shadow-md border ${
                            selectedDiscountToLink === discount.id
                              ? "border-primary border-2" // Highlight selected card
                              : isAlreadyLinked
                              ? "border-gray-500 opacity-50" // Visually indicate already linked
                              : "border-base-300"
                          }`}
                          onClick={() => {
                            if (!isAlreadyLinked) { // Only allow selection if not already linked
                              handleDiscountSelect(discount.id);
                            }
                          }}
                          // Optional: Add a tooltip explaining why it's disabled if already linked
                          title={isAlreadyLinked
                            ? "This discount is already linked to this product."
                            : ""}
                        >
                          <div className="card-body p-4">
                            <h3 className="card-title text-lg">
                              {discount.code}
                            </h3>
                            <div className="space-y-1 text-sm">
                              <p>
                                <span className="font-semibold">Type:</span>
                                {" "}
                                {discount.discount_type}
                              </p>
                              <p>
                                <span className="font-semibold">Value:</span>
                                {" "}
                                {discount.discount_value}
                              </p>
                              <p>
                                <span className="font-semibold">
                                  Valid From:
                                </span>{" "}
                                {discount.valid_from
                                  ? new Date(discount.valid_from)
                                    .toLocaleDateString()
                                  : "N/A"}
                              </p>
                              <p>
                                <span className="font-semibold">
                                  Valid Until:
                                </span>{" "}
                                {discount.valid_until
                                  ? new Date(discount.valid_until)
                                    .toLocaleDateString()
                                  : "N/A"}
                              </p>
                              {/* Adjust based on your discount schema */}
                            </div>
                            <div className="card-actions justify-end mt-2">
                              <span
                                className={`badge ${
                                  discount.is_active
                                    ? "badge-success"
                                    : "badge-neutral"
                                }`}
                              >
                                {discount.is_active ? "Active" : "Inactive"}
                              </span>
                            </div>
                          </div>
                        </div>
                      );
                    })}
                </div>
              </div>
            )}

            <div className="flex justify-end gap-2 mt-4">
              <button
                className="btn btn-error"
                onClick={handleCloseLinkModal}
              >
                Cancel
              </button>
              <button
                className="btn btn-primary"
                onClick={handleLinkDiscount}
                disabled={!selectedDiscountToLink} // Disable if nothing is selected
              >
                Link Discount
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default ProductView;


File: dashboard/src/App.css
================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


File: shared/types.ts
================================================
export interface User {
  id: string;
  email: string;
  full_name: string;
  is_admin: boolean;
  created_at: string;
  updated_at: string;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface RegisterRequest {
  email: string;
  password: string;
  full_name: string;
}

export interface AuthResponse {
  token: string;
  user: User;
}

export interface ErrorResponse {
  type: string;
  title: string;
  status: number;
  detail: string;
  instance?: string;
  errors?: Record<string, any>;
}

export interface Pagination {
  page: number;
  per_page: number;
  total: number;
  total_page: number;
}

export interface Product {
  id: string;
  name: string;
  slug: string;
  description?: string;
  short_description?: string;
  price_cents: number;
  stock_quantity: number;
  status: string;
  brand: string;
  image_urls: string[];
  spec_highlights: Record<string, any>;
  category_id: string;
  created_at: string;
  updated_at: string;
}

export interface Category {
  id: string;
  name: string;
  slug: string;
  type: string;
  parent_id?: string;
}


File: internal/db/models.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type Cart struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	SessionID *string            `json:"session_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

type CartItem struct {
	ID        uuid.UUID          `json:"id"`
	CartID    uuid.UUID          `json:"cart_id"`
	ProductID uuid.UUID          `json:"product_id"`
	Quantity  int32              `json:"quantity"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

type Category struct {
	ID        uuid.UUID          `json:"id"`
	Name      string             `json:"name"`
	Slug      string             `json:"slug"`
	Type      string             `json:"type"`
	ParentID  uuid.UUID          `json:"parent_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type CategoryDiscount struct {
	ID         uuid.UUID          `json:"id"`
	CategoryID uuid.UUID          `json:"category_id"`
	DiscountID uuid.UUID          `json:"discount_id"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

// Stores available delivery service options.
type DeliveryService struct {
	ID uuid.UUID `json:"id"`
	// Unique name identifying the delivery service.
	Name string `json:"name"`
	// Optional description of the delivery service.
	Description *string `json:"description"`
	// Base cost of the delivery service in cents.
	BaseCostCents int64 `json:"base_cost_cents"`
	// Estimated number of days for delivery.
	EstimatedDays *int32 `json:"estimated_days"`
	// Indicates if the delivery service is currently offered.
	IsActive  bool               `json:"is_active"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type Discount struct {
	ID                 uuid.UUID          `json:"id"`
	Code               string             `json:"code"`
	Description        *string            `json:"description"`
	DiscountType       string             `json:"discount_type"`
	DiscountValue      int64              `json:"discount_value"`
	MinOrderValueCents *int64             `json:"min_order_value_cents"`
	MaxUses            *int32             `json:"max_uses"`
	CurrentUses        *int32             `json:"current_uses"`
	ValidFrom          pgtype.Timestamptz `json:"valid_from"`
	ValidUntil         pgtype.Timestamptz `json:"valid_until"`
	IsActive           bool               `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

type Order struct {
	ID                uuid.UUID          `json:"id"`
	UserID            uuid.UUID          `json:"user_id"`
	UserFullName      string             `json:"user_full_name"`
	Status            string             `json:"status"`
	TotalAmountCents  int64              `json:"total_amount_cents"`
	PaymentMethod     string             `json:"payment_method"`
	Province          string             `json:"province"`
	City              string             `json:"city"`
	PhoneNumber1      string             `json:"phone_number_1"`
	PhoneNumber2      *string            `json:"phone_number_2"`
	Notes             *string            `json:"notes"`
	DeliveryServiceID uuid.UUID          `json:"delivery_service_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	CompletedAt       pgtype.Timestamptz `json:"completed_at"`
	CancelledAt       pgtype.Timestamptz `json:"cancelled_at"`
}

type OrderItem struct {
	ID            uuid.UUID          `json:"id"`
	OrderID       uuid.UUID          `json:"order_id"`
	ProductID     uuid.UUID          `json:"product_id"`
	ProductName   string             `json:"product_name"`
	PriceCents    int64              `json:"price_cents"`
	Quantity      int32              `json:"quantity"`
	SubtotalCents *int64             `json:"subtotal_cents"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

type PasswordResetToken struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	Token     string             `json:"token"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type Product struct {
	ID               uuid.UUID          `json:"id"`
	CategoryID       uuid.UUID          `json:"category_id"`
	Name             string             `json:"name"`
	Slug             string             `json:"slug"`
	Description      *string            `json:"description"`
	ShortDescription *string            `json:"short_description"`
	PriceCents       int64              `json:"price_cents"`
	StockQuantity    int32              `json:"stock_quantity"`
	Status           string             `json:"status"`
	Brand            string             `json:"brand"`
	AvgRating        pgtype.Numeric     `json:"avg_rating"`
	NumRatings       *int32             `json:"num_ratings"`
	ImageUrls        []byte             `json:"image_urls"`
	SpecHighlights   []byte             `json:"spec_highlights"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
}

type ProductDiscount struct {
	ID         uuid.UUID          `json:"id"`
	ProductID  uuid.UUID          `json:"product_id"`
	DiscountID uuid.UUID          `json:"discount_id"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

type RefreshToken struct {
	ID        int32              `json:"id"`
	Jti       string             `json:"jti"`
	UserID    uuid.UUID          `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	RevokedAt pgtype.Timestamptz `json:"revoked_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type Review struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	ProductID uuid.UUID          `json:"product_id"`
	Rating    int32              `json:"rating"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

type SchemaMigration struct {
	Version   int64              `json:"version"`
	IsApplied bool               `json:"is_applied"`
	AppliedAt pgtype.Timestamptz `json:"applied_at"`
}

type User struct {
	ID           uuid.UUID          `json:"id"`
	Email        string             `json:"email"`
	PasswordHash []byte             `json:"password_hash"`
	FullName     *string            `json:"full_name"`
	IsAdmin      bool               `json:"is_admin"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
}

type VProductsWithCalculatedDiscount struct {
	ProductID                      uuid.UUID   `json:"product_id"`
	TotalFixedDiscountCents        interface{} `json:"total_fixed_discount_cents"`
	CombinedPercentageFactor       interface{} `json:"combined_percentage_factor"`
	CalculatedDiscountedPriceCents int64       `json:"calculated_discounted_price_cents"`
	HasActiveDiscount              bool        `json:"has_active_discount"`
}

type VProductsWithCurrentDiscount struct {
	ProductID               uuid.UUID          `json:"product_id"`
	CategoryID              uuid.UUID          `json:"category_id"`
	ProductName             string             `json:"product_name"`
	ProductSlug             string             `json:"product_slug"`
	ProductDescription      *string            `json:"product_description"`
	ProductShortDescription *string            `json:"product_short_description"`
	OriginalPriceCents      int64              `json:"original_price_cents"`
	ProductStockQuantity    int32              `json:"product_stock_quantity"`
	ProductStatus           string             `json:"product_status"`
	ProductBrand            string             `json:"product_brand"`
	ProductImageUrls        []byte             `json:"product_image_urls"`
	ProductSpecHighlights   []byte             `json:"product_spec_highlights"`
	ProductCreatedAt        pgtype.Timestamptz `json:"product_created_at"`
	ProductUpdatedAt        pgtype.Timestamptz `json:"product_updated_at"`
	ProductDeletedAt        pgtype.Timestamptz `json:"product_deleted_at"`
	AvgRating               pgtype.Numeric     `json:"avg_rating"`
	NumRatings              *int32             `json:"num_ratings"`
	DiscountedPriceCents    int64              `json:"discounted_price_cents"`
	ActiveDiscountCode      *string            `json:"active_discount_code"`
	ActiveDiscountType      *string            `json:"active_discount_type"`
	ActiveDiscountValue     *int64             `json:"active_discount_value"`
	HasActiveDiscount       bool               `json:"has_active_discount"`
}


File: internal/db/querier.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"context"

	"github.com/google/uuid"
)

type Querier interface {
	// Removes the soft-delete marker by setting deleted_at to NULL.
	ActivateUser(ctx context.Context, userID uuid.UUID) error
	// Include deleted_at to see if undeletion happened
	// Adds multiple items to a cart, handling upserts and soft deletes.
	// Checks stock availability for each item during the insert/update process.
	// Join with products table to validate existence, status, deletion, and stock for the INSERT
	AddCartItemsBulk(ctx context.Context, arg AddCartItemsBulkParams) (int64, error)
	// Gets a specific user by ID, regardless of soft-delete status.
	// Useful for admin to see any user, active or inactive.
	AdminGetUser(ctx context.Context, userID uuid.UUID) (User, error)
	// Associates a discount with a specific category (simplified version, might need more checks).
	ApplyDiscountToCategory(ctx context.Context, arg ApplyDiscountToCategoryParams) error
	// Include usage limit check
	// Associates a discount with a specific product (simplified version, might need more checks).
	ApplyDiscountToProduct(ctx context.Context, arg ApplyDiscountToProductParams) error
	// Calculates the average rating and count of non-deleted reviews for a specific product.
	// Used to update the products table.
	CalculateReviewStatsForProduct(ctx context.Context, productID uuid.UUID) (CalculateReviewStatsForProductRow, error)
	// Order items consistently
	// Updates the status of an order to 'cancelled' and sets the cancelled_at and completed_at timestamps.
	// This is a soft cancellation.
	CancelOrder(ctx context.Context, orderID uuid.UUID) (Order, error)
	CheckCategorySlugExists(ctx context.Context, slug string) (bool, error)
	// Checks if a product slug already exists (excluding soft-deleted products).
	CheckSlugExists(ctx context.Context, slug string) (bool, error)
	CleanupExpiredRefreshTokens(ctx context.Context) error
	ClearCart(ctx context.Context, cartID uuid.UUID) error
	// Nullable status filter
	// Counts all orders based on optional user and status filters.
	CountAllOrders(ctx context.Context, arg CountAllOrdersParams) (int64, error)
	CountAllProducts(ctx context.Context) (int64, error)
	CountCategories(ctx context.Context) (int64, error)
	// Counts discounts based on the same filters as ListDiscounts.
	CountDiscounts(ctx context.Context, arg CountDiscountsParams) (int64, error)
	CountProducts(ctx context.Context, arg CountProductsParams) (int64, error)
	// Counts users matching the search term, optionally filtered by active status.
	// Useful for pagination metadata with search.
	CountSearchUsers(ctx context.Context, arg CountSearchUsersParams) (int64, error)
	// Only include items not marked as deleted in the cart
	// Counts orders for a specific user based on optional status filter.
	// NOTE: UserID is a specific user to count for, FilterStatus is optional.
	CountUserOrders(ctx context.Context, arg CountUserOrdersParams) (int64, error)
	// Counts total users, optionally filtered by active status (soft-deleted).
	// Useful for pagination metadata.
	CountUsers(ctx context.Context, activeOnly bool) (int64, error)
	// Cart Item Management
	CreateCartItem(ctx context.Context, arg CreateCartItemParams) (CartItem, error)
	CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error)
	CreateDeliveryService(ctx context.Context, arg CreateDeliveryServiceParams) (DeliveryService, error)
	// Inserts a new discount record.
	CreateDiscount(ctx context.Context, arg CreateDiscountParams) (Discount, error)
	CreateGuestCart(ctx context.Context, sessionID *string) (Cart, error)
	// Creates a new order with denormalized address fields and returns its details.
	CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error)
	// --- Password Reset Tokens ---
	// Inserts a new password reset token record.
	CreatePasswordResetToken(ctx context.Context, arg CreatePasswordResetTokenParams) error
	CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error)
	CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error
	// Inserts a new review and returns its details.
	// NOTE: This query alone does not update the product's avg_rating/num_ratings.
	CreateReview(ctx context.Context, arg CreateReviewParams) (CreateReviewRow, error)
	CreateUser(ctx context.Context, arg CreateUserParams) (User, error)
	// Cart Management
	CreateUserCart(ctx context.Context, userID uuid.UUID) (Cart, error)
	// Attempts to decrement the stock_quantity for a product by a given amount.
	// Succeeds only if the resulting stock_quantity would be >= 0.
	// Returns the updated product row if successful, or an error if insufficient stock.
	// Note: The RETURNING clause might not be strictly necessary if we only care about RowsAffected.
	// If RETURNING is omitted, the querier function will likely return sql.Result.
	// Let's include RETURNING to get the updated stock if needed for debugging/logging.
	DecrementStockIfSufficient(ctx context.Context, arg DecrementStockIfSufficientParams) (DecrementStockIfSufficientRow, error)
	DeleteCart(ctx context.Context, cartID uuid.UUID) error
	// Cart Cleanup
	DeleteCartItem(ctx context.Context, itemID uuid.UUID) error
	DeleteCategory(ctx context.Context, id uuid.UUID) error
	// Soft delete could be achieved by updating is_active to FALSE
	// For hard delete:
	DeleteDeliveryService(ctx context.Context, id uuid.UUID) error
	// Deletes a discount record (and associated links via CASCADE).
	DeleteDiscount(ctx context.Context, id uuid.UUID) error
	// $1=token_string
	// Deletes all password reset tokens that have expired.
	DeleteExpiredPasswordResetTokens(ctx context.Context) error
	// Ensure token hasn't expired
	// Deletes a specific password reset token record by its token string.
	DeletePasswordResetToken(ctx context.Context, token string) error
	DeleteProduct(ctx context.Context, productID uuid.UUID) error
	// Soft deletes a review by setting deleted_at.
	// NOTE: This query alone does not update the product's avg_rating/num_ratings.
	DeleteReview(ctx context.Context, arg DeleteReviewParams) (DeleteReviewRow, error)
	// Retrieves all delivery services that are currently active.
	// Suitable for user-facing contexts like checkout.
	GetActiveDeliveryServices(ctx context.Context) ([]DeliveryService, error)
	// Check usage limit
	// Fetches all currently active discounts (within date range and usage limits).
	GetActiveDiscounts(ctx context.Context) ([]Discount, error)
	// Calculates the average time between order confirmation and shipment/delivery completion.
	// Assumes 'confirmed' status is the start and 'shipped' or 'delivered' is the end.
	GetAverageFulfillmentTime(ctx context.Context, arg GetAverageFulfillmentTimeParams) (float64, error)
	// @start_date = start_date, @start_date = end_date
	// Calculates the average order value (AOV) for delivered orders within a given time range.
	GetAverageOrderValue(ctx context.Context, arg GetAverageOrderValueParams) (float64, error)
	GetCartByID(ctx context.Context, cartID uuid.UUID) (GetCartByIDRow, error)
	GetCartBySessionID(ctx context.Context, sessionID *string) (GetCartBySessionIDRow, error)
	GetCartByUserID(ctx context.Context, userID uuid.UUID) (GetCartByUserIDRow, error)
	GetCartItemByCartAndProduct(ctx context.Context, arg GetCartItemByCartAndProductParams) (GetCartItemByCartAndProductRow, error)
	GetCartItemByID(ctx context.Context, itemID uuid.UUID) (GetCartItemByIDRow, error)
	// Update the timestamp
	// Counts the number of active (non-deleted) items in a specific cart.
	GetCartItemsCount(ctx context.Context, cartID uuid.UUID) (int64, error)
	// Enhanced Cart Data Retrieval
	GetCartItemsWithProductDetails(ctx context.Context, cartID uuid.UUID) ([]GetCartItemsWithProductDetailsRow, error)
	GetCartStats(ctx context.Context, cartID uuid.UUID) (GetCartStatsRow, error)
	GetCartWithItemsAndProducts(ctx context.Context, cartID uuid.UUID) ([]GetCartWithItemsAndProductsRow, error)
	// $1 = page_limit, $2 = page_offset
	// Assuming this returns one cart object with many items
	GetCartWithItemsAndProductsWithDiscounts(ctx context.Context, id uuid.UUID) ([]GetCartWithItemsAndProductsWithDiscountsRow, error)
	GetCategory(ctx context.Context, id uuid.UUID) (Category, error)
	GetCategoryBySlug(ctx context.Context, slug string) (Category, error)
	GetDeliveryService(ctx context.Context, arg GetDeliveryServiceParams) (DeliveryService, error)
	// Retrieves a delivery service by its ID, regardless of its active status.
	// Suitable for admin operations.
	GetDeliveryServiceByID(ctx context.Context, id uuid.UUID) (DeliveryService, error)
	// Allow filtering by active status
	GetDeliveryServiceByName(ctx context.Context, arg GetDeliveryServiceByNameParams) (DeliveryService, error)
	// Fetches a discount by its unique code.
	GetDiscountByCode(ctx context.Context, code string) (Discount, error)
	// Fetches a discount by its ID.
	GetDiscountByID(ctx context.Context, id uuid.UUID) (Discount, error)
	// --- Discount Effectiveness ---
	// Retrieves usage count and revenue attributed to specific discount codes within a time range.
	GetDiscountUsage(ctx context.Context, arg GetDiscountUsageParams) ([]GetDiscountUsageRow, error)
	// Fetches active discounts applicable to a specific category.
	GetDiscountsByCategoryID(ctx context.Context, categoryID uuid.UUID) ([]Discount, error)
	// Fetches active discounts applicable to a specific product.
	GetDiscountsByProductID(ctx context.Context, productID uuid.UUID) ([]Discount, error)
	// $3 = number of top products to return (N)
	// --- Product Performance ---
	// Retrieves products with stock quantity below a specified threshold.
	GetLowStockProducts(ctx context.Context, stockQuantity int32) ([]GetLowStockProductsRow, error)
	// --- Customer Insights ---
	// Counts the number of new customers registered within a given time range.
	GetNewCustomersCount(ctx context.Context, arg GetNewCustomersCountParams) (int64, error)
	// Array of quantities
	// Retrieves an order by its ID with denormalized address fields.
	GetOrder(ctx context.Context, orderID uuid.UUID) (Order, error)
	// Retrieves all items for a specific order ID.
	GetOrderItemsByOrderID(ctx context.Context, orderID uuid.UUID) ([]OrderItem, error)
	// Exclude soft-deleted users
	// --- Order Metrics ---
	// Counts the number of orders in each status (pending, confirmed, shipped, delivered, cancelled).
	GetOrderStatusCounts(ctx context.Context, arg GetOrderStatusCountsParams) ([]GetOrderStatusCountsRow, error)
	// Retrieves an order by its ID along with all its items, including denormalized address fields.
	// This query uses a join and might return multiple rows if there are items.
	// The service layer needs to aggregate these rows into a single Order object with a slice of OrderItems.
	GetOrderWithItems(ctx context.Context, orderID uuid.UUID) ([]GetOrderWithItemsRow, error)
	// $1 = start_date, $2 = end_date
	// Note: This query is complex because order status updates modify the same row.
	// A more robust approach might involve an order_status_history table or window functions.
	// Simplified version assuming statuses are updated sequentially and we just compare timestamps.
	// A better way might be to track status change events explicitly.
	// For now, let's simplify the logic assuming we just want the difference between created_at and updated_at
	// for 'shipped' or 'delivered' orders, IF created_at represents the time it became confirmed.
	// This might not be accurate depending on how status transitions are handled.
	// Let's revise:
	// Assume 'confirmed' status sets confirmed_at, 'shipped' sets shipped_at, 'delivered' sets delivered_at.
	// Add these timestamp fields to the orders table if they don't exist.
	// ALTER TABLE orders ADD COLUMN confirmed_at TIMESTAMPTZ, shipped_at TIMESTAMPTZ, delivered_at TIMESTAMPTZ;
	// Then update these timestamps in the service layer upon status changes.
	// Query would then be:
	// SELECT AVG(EXTRACT(EPOCH FROM (delivered_at - confirmed_at))) FROM orders WHERE status = 'delivered' AND ...;
	// For now, acknowledging this complexity, we'll note it and move on, assuming status timestamps exist or are derivable.
	// This query might need adjustment based on how status changes are tracked in the DB.
	// Let's add a simpler one based on status counts for now.
	// Counts orders by status within a time range.
	// This is similar to GetOrderStatusCounts but with a time filter.
	GetOrdersByStatusWithinTimeRange(ctx context.Context, arg GetOrdersByStatusWithinTimeRangeParams) ([]GetOrdersByStatusWithinTimeRangeRow, error)
	GetProduct(ctx context.Context, productID uuid.UUID) (Product, error)
	GetProductBySlug(ctx context.Context, slug string) (Product, error)
	// Retrieves average rating and number of ratings for a specific product.
	// (This might already be covered by the existing product queries selecting avg_rating, num_ratings)
	// But here's a dedicated query if needed:
	GetProductReviewStats(ctx context.Context, id uuid.UUID) (GetProductReviewStatsRow, error)
	GetProductWithDiscountInfo(ctx context.Context, id uuid.UUID) (GetProductWithDiscountInfoRow, error)
	// Query: GetProductWithDiscountInfoBySlug
	// Retrieves a specific product by slug along with its calculated discount information using the pre-calculated view.
	GetProductWithDiscountInfoBySlug(ctx context.Context, slug string) (GetProductWithDiscountInfoBySlugRow, error)
	// Fetches a product and its active product-specific discounts.
	// This might return multiple rows if there are multiple discounts.
	// Aggregation into a list happens in Go.
	GetProductWithMultiDiscountDetails(ctx context.Context, id uuid.UUID) (GetProductWithMultiDiscountDetailsRow, error)
	GetProductsWithDiscountInfo(ctx context.Context, arg GetProductsWithDiscountInfoParams) ([]GetProductsWithDiscountInfoRow, error)
	GetProductsWithDiscountInfoView(ctx context.Context) ([]VProductsWithCurrentDiscount, error)
	// $1=user_id, $2=token_string, $3=expiry_time
	// Fetches a password reset token record by its token string.
	GetResetToken(ctx context.Context, token string) (PasswordResetToken, error)
	// Retrieves a specific review by its ID and verifies the user owns it.
	GetReviewByIDAndUser(ctx context.Context, arg GetReviewByIDAndUserParams) (GetReviewByIDAndUserRow, error)
	// Retrieves a review by a specific user for a specific product.
	GetReviewByUserAndProduct(ctx context.Context, arg GetReviewByUserAndProductParams) (GetReviewByUserAndProductRow, error)
	// Retrieves all reviews for a specific product, including the reviewer's name, potentially paginated.
	GetReviewsByProductID(ctx context.Context, arg GetReviewsByProductIDParams) ([]GetReviewsByProductIDRow, error)
	// Retrieves all reviews submitted by a specific user, including the product name, potentially paginated.
	GetReviewsByUserID(ctx context.Context, arg GetReviewsByUserIDParams) ([]GetReviewsByUserIDRow, error)
	// $1 = start_date, $2 = end_date
	// Counts the total number of delivered orders within a given time range.
	GetSalesVolume(ctx context.Context, arg GetSalesVolumeParams) (int64, error)
	// $3 = number of top products to return (N)
	// Retrieves the top N selling categories (by quantity sold) within a given time range.
	GetTopSellingCategories(ctx context.Context, arg GetTopSellingCategoriesParams) ([]GetTopSellingCategoriesRow, error)
	// $1 = start_date, $2 = end_date
	// Retrieves the top N selling products (by quantity sold) within a given time range.
	GetTopSellingProducts(ctx context.Context, arg GetTopSellingProductsParams) ([]GetTopSellingProductsRow, error)
	// --- Sales Performance ---
	// Calculates the total revenue from all delivered orders within a given time range.
	GetTotalRevenue(ctx context.Context, arg GetTotalRevenueParams) (int64, error)
	GetUser(ctx context.Context, id uuid.UUID) (User, error)
	GetUserByEmail(ctx context.Context, email string) (User, error)
	// $1=token_string
	// Fetches the user associated with a valid, non-expired reset token.
	GetUserByResetToken(ctx context.Context, token string) (GetUserByResetTokenRow, error)
	// Fetches a specific user by ID along with order count and last order date.
	// Joins with the orders table to get aggregated details.
	// Includes soft-deleted users as well.
	GetUserWithDetails(ctx context.Context, userID uuid.UUID) (GetUserWithDetailsRow, error)
	GetValidRefreshTokenRecord(ctx context.Context, jti string) (RefreshToken, error)
	// Pagination using limit and offset
	// Increments the current_uses count for a specific discount.
	// This should ideally be called within a transaction when applying the discount.
	IncrementDiscountUsage(ctx context.Context, id uuid.UUID) error
	// Increments the stock_quantity for a product by a given amount.
	// Suitable for releasing stock back when cancelling an order.
	IncrementStock(ctx context.Context, arg IncrementStockParams) (IncrementStockRow, error)
	// Inserts multiple order items efficiently in a single query.
	// Requires arrays of equal length for product_ids, quantities, names, and prices_cents.
	InsertOrderItemsBulk(ctx context.Context, arg InsertOrderItemsBulkParams) error
	// Inserts order items into the order_items table by copying them from the user's current cart.
	// This ensures the item details (product, name, price, quantity) reflect the exact state of the cart at order creation time.
	// It fetches the final price (including discounts) from the cart_items joined with the calculated discount view.
	InsertOrderItemsFromCart(ctx context.Context, arg InsertOrderItemsFromCartParams) error
	// Check usage limit
	// Associates a category with a discount.
	LinkCategoryToDiscount(ctx context.Context, arg LinkCategoryToDiscountParams) error
	// Prevent exceeding max_uses
	// --- Link/Unlink Queries ---
	// Associates a product with a discount.
	LinkProductToDiscount(ctx context.Context, arg LinkProductToDiscountParams) error
	// Retrieves delivery services, optionally filtered by active status.
	// Suitable for admin operations.
	ListAllDeliveryServices(ctx context.Context, arg ListAllDeliveryServicesParams) ([]DeliveryService, error)
	// Page limit and offset
	// Retrieves a paginated list of all orders with denormalized address fields, optionally filtered by status or user_id.
	// Intended for admin use. Includes cancelled orders.
	// If filter_user_id is the zero UUID ('00000000-0000-0000-0000-000000000000'), it retrieves orders for all users.
	// If filter_status is an empty string (''), it retrieves orders of all statuses.
	ListAllOrders(ctx context.Context, arg ListAllOrdersParams) ([]Order, error)
	ListCategories(ctx context.Context, arg ListCategoriesParams) ([]Category, error)
	// Fetches a list of discounts, potentially with filters and pagination.
	ListDiscounts(ctx context.Context, arg ListDiscountsParams) ([]Discount, error)
	ListProducts(ctx context.Context, arg ListProductsParams) ([]Product, error)
	ListProductsByCategory(ctx context.Context, arg ListProductsByCategoryParams) ([]Product, error)
	ListProductsWithCategory(ctx context.Context, arg ListProductsWithCategoryParams) ([]ListProductsWithCategoryRow, error)
	ListProductsWithCategoryDetail(ctx context.Context, arg ListProductsWithCategoryDetailParams) ([]ListProductsWithCategoryDetailRow, error)
	// Order items consistently
	// Retrieves a paginated list of orders for a specific user with denormalized address fields, optionally filtered by status.
	// Excludes cancelled orders by default. Admins should use ListAllOrders.
	ListUserOrders(ctx context.Context, arg ListUserOrdersParams) ([]Order, error)
	// Lists users, optionally filtered by active status (soft-deleted).
	// Paginated using LIMIT and OFFSET.
	ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error)
	// Lists users with essential details for admin list view (name, email, registration date, last order date, order count, status).
	// Optionally filter by active status.
	// Paginated using LIMIT and OFFSET.
	ListUsersWithListDetails(ctx context.Context, arg ListUsersWithListDetailsParams) ([]ListUsersWithListDetailsRow, error)
	// Lists users with their total order counts.
	// Optionally filter by active status.
	// Paginated using LIMIT and OFFSET.
	ListUsersWithOrderCounts(ctx context.Context, arg ListUsersWithOrderCountsParams) ([]ListUsersWithOrderCountsRow, error)
	// Revokes all refresh tokens for a specific user.
	RevokeAllRefreshTokensByUserID(ctx context.Context, userID uuid.UUID) error
	RevokeRefreshTokenByJTI(ctx context.Context, jti string) error
	SearchProductsWithCategory(ctx context.Context, arg SearchProductsWithCategoryParams) ([]SearchProductsWithCategoryRow, error)
	// Searches for products and includes pre-calculated discount information using the view.
	// Includes a flexible spec highlight filter for partial matching within values.
	SearchProductsWithDiscounts(ctx context.Context, arg SearchProductsWithDiscountsParams) ([]SearchProductsWithDiscountsRow, error)
	// Searches users by email or full_name, optionally filtered by active status.
	// Paginated using LIMIT and OFFSET.
	SearchUsers(ctx context.Context, arg SearchUsersParams) ([]User, error)
	// Marks a user as soft-deleted by setting deleted_at to NOW().
	SoftDeleteUser(ctx context.Context, userID uuid.UUID) error
	// Merges items from a guest cart into a user's cart using upsert logic.
	// Handles quantity updates, stock checks, and soft-delete state transitions (undeletion).
	// This query performs the core merge operation efficiently in a single statement.
	SyncGuestCartItemsToUserCart(ctx context.Context, arg SyncGuestCartItemsToUserCartParams) error
	// Removes association between a category and a discount.
	UnlinkCategoryFromDiscount(ctx context.Context, arg UnlinkCategoryFromDiscountParams) error
	// Removes association between a product and a discount.
	UnlinkProductFromDiscount(ctx context.Context, arg UnlinkProductFromDiscountParams) error
	UpdateCartItemQuantity(ctx context.Context, arg UpdateCartItemQuantityParams) (UpdateCartItemQuantityRow, error)
	UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error)
	// Allow filtering by active status
	UpdateDeliveryService(ctx context.Context, arg UpdateDeliveryServiceParams) (DeliveryService, error)
	// Updates an existing discount record.
	UpdateDiscount(ctx context.Context, arg UpdateDiscountParams) (Discount, error)
	// Page limit and offset
	// Updates other details of an order (notes, timestamps).
	// Address fields are denormalized and set during creation.
	UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error)
	// Updates the status of an order and manages completion/cancellation timestamps.
	UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error)
	UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error)
	// Updates the avg_rating and num_ratings fields in the products table for a specific product.
	UpdateProductReviewStats(ctx context.Context, arg UpdateProductReviewStatsParams) error
	// Updates the rating of an existing review.
	// NOTE: This query alone does not update the product's avg_rating/num_ratings.
	UpdateReview(ctx context.Context, arg UpdateReviewParams) (UpdateReviewRow, error)
	// Updates the user's email address.
	UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) (UpdateUserEmailRow, error)
	// --- Profile & Password Management ---
	// Updates the user's full name.
	UpdateUserFullName(ctx context.Context, arg UpdateUserFullNameParams) (UpdateUserFullNameRow, error)
	// Updates the user's hashed password.
	UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (UpdateUserPasswordRow, error)
}

var _ Querier = (*Queries)(nil)


File: internal/db/profile.sql.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: profile.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createPasswordResetToken = `-- name: CreatePasswordResetToken :exec

INSERT INTO password_reset_tokens (user_id, token, expires_at)
VALUES ($1, $2, $3)
`

type CreatePasswordResetTokenParams struct {
	UserID    uuid.UUID          `json:"user_id"`
	Token     string             `json:"token"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

// --- Password Reset Tokens ---
// Inserts a new password reset token record.
func (q *Queries) CreatePasswordResetToken(ctx context.Context, arg CreatePasswordResetTokenParams) error {
	_, err := q.db.Exec(ctx, createPasswordResetToken, arg.UserID, arg.Token, arg.ExpiresAt)
	return err
}

const deleteExpiredPasswordResetTokens = `-- name: DeleteExpiredPasswordResetTokens :exec

DELETE FROM password_reset_tokens
WHERE expires_at <= NOW()
`

// $1=token_string
// Deletes all password reset tokens that have expired.
func (q *Queries) DeleteExpiredPasswordResetTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredPasswordResetTokens)
	return err
}

const deletePasswordResetToken = `-- name: DeletePasswordResetToken :exec

DELETE FROM password_reset_tokens
WHERE token = $1
`

// Ensure token hasn't expired
// Deletes a specific password reset token record by its token string.
func (q *Queries) DeletePasswordResetToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, deletePasswordResetToken, token)
	return err
}

const getResetToken = `-- name: GetResetToken :one

SELECT id, user_id, token, expires_at, created_at
FROM password_reset_tokens
WHERE token = $1
`

// $1=user_id, $2=token_string, $3=expiry_time
// Fetches a password reset token record by its token string.
func (q *Queries) GetResetToken(ctx context.Context, token string) (PasswordResetToken, error) {
	row := q.db.QueryRow(ctx, getResetToken, token)
	var i PasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByResetToken = `-- name: GetUserByResetToken :one

SELECT u.id, u.email, u.full_name, u.password_hash, u.is_admin, u.created_at, u.updated_at, u.deleted_at
FROM users u
JOIN password_reset_tokens prt ON u.id = prt.user_id
WHERE prt.token = $1 -- $1=token_string
  AND prt.expires_at > NOW()
`

type GetUserByResetTokenRow struct {
	ID           uuid.UUID          `json:"id"`
	Email        string             `json:"email"`
	FullName     *string            `json:"full_name"`
	PasswordHash []byte             `json:"password_hash"`
	IsAdmin      bool               `json:"is_admin"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
}

// $1=token_string
// Fetches the user associated with a valid, non-expired reset token.
func (q *Queries) GetUserByResetToken(ctx context.Context, token string) (GetUserByResetTokenRow, error) {
	row := q.db.QueryRow(ctx, getUserByResetToken, token)
	var i GetUserByResetTokenRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.PasswordHash,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateUserEmail = `-- name: UpdateUserEmail :one
UPDATE users
SET email = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, email, full_name, is_admin, created_at, updated_at, deleted_at
`

type UpdateUserEmailParams struct {
	Email string    `json:"email"`
	ID    uuid.UUID `json:"id"`
}

type UpdateUserEmailRow struct {
	ID        uuid.UUID          `json:"id"`
	Email     string             `json:"email"`
	FullName  *string            `json:"full_name"`
	IsAdmin   bool               `json:"is_admin"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

// Updates the user's email address.
func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) (UpdateUserEmailRow, error) {
	row := q.db.QueryRow(ctx, updateUserEmail, arg.Email, arg.ID)
	var i UpdateUserEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateUserFullName = `-- name: UpdateUserFullName :one

UPDATE users
SET full_name = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, email, full_name, is_admin, created_at, updated_at, deleted_at
`

type UpdateUserFullNameParams struct {
	FullName *string   `json:"full_name"`
	ID       uuid.UUID `json:"id"`
}

type UpdateUserFullNameRow struct {
	ID        uuid.UUID          `json:"id"`
	Email     string             `json:"email"`
	FullName  *string            `json:"full_name"`
	IsAdmin   bool               `json:"is_admin"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

// --- Profile & Password Management ---
// Updates the user's full name.
func (q *Queries) UpdateUserFullName(ctx context.Context, arg UpdateUserFullNameParams) (UpdateUserFullNameRow, error) {
	row := q.db.QueryRow(ctx, updateUserFullName, arg.FullName, arg.ID)
	var i UpdateUserFullNameRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users
SET password_hash = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, email, full_name, is_admin, created_at, updated_at, deleted_at
`

type UpdateUserPasswordParams struct {
	PasswordHash []byte    `json:"password_hash"`
	ID           uuid.UUID `json:"id"`
}

type UpdateUserPasswordRow struct {
	ID        uuid.UUID          `json:"id"`
	Email     string             `json:"email"`
	FullName  *string            `json:"full_name"`
	IsAdmin   bool               `json:"is_admin"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

// Updates the user's hashed password.
func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (UpdateUserPasswordRow, error) {
	row := q.db.QueryRow(ctx, updateUserPassword, arg.PasswordHash, arg.ID)
	var i UpdateUserPasswordRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}


File: internal/db/queries/discounts.sql
================================================
-- name: CreateDiscount :one
-- Inserts a new discount record.
INSERT INTO discounts (
    code, description, discount_type, discount_value,
    min_order_value_cents, max_uses, valid_from, valid_until, is_active
) VALUES (
    $1, $2, $3, $4,
    $5, $6, $7, $8, $9
) RETURNING *;

-- name: GetDiscountByCode :one
-- Fetches a discount by its unique code.
SELECT * FROM discounts WHERE code = $1 AND is_active = TRUE AND valid_from <= NOW() AND valid_until >= NOW();

-- name: GetDiscountByID :one
-- Fetches a discount by its ID.
SELECT * FROM discounts WHERE id = $1;

-- name: UpdateDiscount :one
-- Updates an existing discount record.
UPDATE discounts
SET code = $2,
    description = $3,
    discount_type = $4,
    discount_value = $5,
    min_order_value_cents = $6,
    max_uses = $7,
    valid_from = $8,
    valid_until = $9,
    is_active = $10,
    updated_at = NOW()
WHERE id = $1
RETURNING *;

-- name: DeleteDiscount :exec
-- Deletes a discount record (and associated links via CASCADE).
DELETE FROM discounts WHERE id = $1;

-- name: ListDiscounts :many
-- Fetches a list of discounts, potentially with filters and pagination.
SELECT * FROM discounts
WHERE (@is_active::boolean IS NULL OR is_active = @is_active) -- Filter by active status if provided
  AND (@from_date::timestamptz IS NULL OR valid_from <= @from_date) -- Filter by valid from date if provided
  AND (@until_date::timestamptz IS NULL OR valid_until >= @until_date) -- Filter by valid until date if provided
ORDER BY created_at DESC -- Or another default order
LIMIT @page_limit OFFSET @page_offset; -- Pagination using limit and offset

-- name: IncrementDiscountUsage :exec
-- Increments the current_uses count for a specific discount.
-- This should ideally be called within a transaction when applying the discount.
UPDATE discounts
SET current_uses = current_uses + 1, updated_at = NOW()
WHERE id = $1 AND (max_uses IS NULL OR current_uses < max_uses); -- Prevent exceeding max_uses

-- --- Link/Unlink Queries ---

-- name: LinkProductToDiscount :exec
-- Associates a product with a discount.
INSERT INTO product_discounts (product_id, discount_id) VALUES ($1, $2);

-- name: UnlinkProductFromDiscount :exec
-- Removes association between a product and a discount.
DELETE FROM product_discounts WHERE product_id = $1 AND discount_id = $2;

-- name: GetDiscountsByProductID :many
-- Fetches active discounts applicable to a specific product.
SELECT d.* FROM discounts d
JOIN product_discounts pd ON d.id = pd.discount_id
WHERE pd.product_id = $1
  AND d.is_active = TRUE
  AND d.valid_from <= NOW()
  AND d.valid_until >= NOW()
  AND (d.max_uses IS NULL OR d.current_uses < d.max_uses); -- Check usage limit

-- name: LinkCategoryToDiscount :exec
-- Associates a category with a discount.
INSERT INTO category_discounts (category_id, discount_id) VALUES ($1, $2);

-- name: UnlinkCategoryFromDiscount :exec
-- Removes association between a category and a discount.
DELETE FROM category_discounts WHERE category_id = $1 AND discount_id = $2;

-- name: GetDiscountsByCategoryID :many
-- Fetches active discounts applicable to a specific category.
SELECT d.* FROM discounts d
JOIN category_discounts cd ON d.id = cd.discount_id
WHERE cd.category_id = $1
  AND d.is_active = TRUE
  AND d.valid_from <= NOW()
  AND d.valid_until >= NOW()
  AND (d.max_uses IS NULL OR d.current_uses < d.max_uses); -- Check usage limit

-- name: GetActiveDiscounts :many
-- Fetches all currently active discounts (within date range and usage limits).
SELECT
    d.id,
    d.code,
    d.description,
    d.discount_type,
    d.discount_value,
    d.min_order_value_cents,
    d.max_uses,
    d.current_uses,
    d.valid_from,
    d.valid_until,
    d.is_active,
    d.created_at,
    d.updated_at
FROM
    discounts d
WHERE
    d.is_active = TRUE AND NOW() BETWEEN d.valid_from AND d.valid_until
    AND (d.max_uses IS NULL OR d.current_uses < d.max_uses); -- Include usage limit check

-- name: ApplyDiscountToProduct :exec
-- Associates a discount with a specific product (simplified version, might need more checks).
INSERT INTO product_discounts (product_id, discount_id)
VALUES ($1, $2);

-- name: ApplyDiscountToCategory :exec
-- Associates a discount with a specific category (simplified version, might need more checks).
INSERT INTO category_discounts (category_id, discount_id)
VALUES ($1, $2);

-- name: CountDiscounts :one
-- Counts discounts based on the same filters as ListDiscounts.
SELECT COUNT(*) FROM discounts
WHERE (@is_active::boolean IS NULL OR is_active = @is_active) -- Filter by active status if provided
  AND (@from_date::timestamptz IS NULL OR valid_from <= @from_date) -- Filter by valid from date if provided
  AND (@until_date::timestamptz IS NULL OR valid_until >= @until_date) ;-- Filter by valid until date if provided


File: internal/db/queries/user.sql
================================================
-- name: GetUserByEmail :one
SELECT id, email, password_hash, full_name, is_admin, created_at, updated_at, deleted_at
FROM users
WHERE email = $1 AND deleted_at IS NULL;

-- name: CreateUser :one
INSERT INTO users (
    email, password_hash, full_name, is_admin, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, email, password_hash, full_name, is_admin, created_at, updated_at, deleted_at;

-- name: GetUser :one
SELECT id, email, password_hash, full_name, is_admin, created_at, updated_at, deleted_at
FROM users
WHERE id = $1 AND deleted_at IS NULL;

-- name: ListUsers :many
-- Lists users, optionally filtered by active status (soft-deleted).
-- Paginated using LIMIT and OFFSET.
SELECT id, email, password_hash, full_name, is_admin, created_at, updated_at, deleted_at
FROM users
WHERE 
    is_admin = false
    AND
  -- Filter by active status (NULL means active, NOT NULL means soft-deleted/inactive)
  CASE 
    WHEN @active_only::boolean THEN deleted_at IS NULL 
    WHEN NOT @active_only::boolean THEN TRUE -- Include both active and inactive
    ELSE TRUE -- Default if active_only is NULL (list all)
  END
ORDER BY created_at DESC -- Or another relevant order
LIMIT @page_limit::int4 OFFSET @page_offset::int4;

-- name: CountUsers :one
-- Counts total users, optionally filtered by active status (soft-deleted).
-- Useful for pagination metadata.
SELECT COUNT(*) AS total_users
FROM users
WHERE 
    is_admin = false
    AND
  -- Filter by active status (NULL means active, NOT NULL means soft-deleted/inactive)
  CASE 
    WHEN @active_only::boolean THEN deleted_at IS NULL 
    WHEN NOT @active_only::boolean THEN TRUE -- Include both active and inactive
    ELSE TRUE -- Default if active_only is NULL (count all)
  END;

-- name: SearchUsers :many
-- Searches users by email or full_name, optionally filtered by active status.
-- Paginated using LIMIT and OFFSET.
SELECT id, email, password_hash, full_name, is_admin, created_at, updated_at, deleted_at
FROM users
WHERE 
  (LOWER(email) LIKE LOWER(@search_term::text || '%') OR LOWER(full_name) LIKE LOWER(@search_term::text || '%'))
  AND
  -- Filter by active status (NULL means active, NOT NULL means soft-deleted/inactive)
  CASE 
    WHEN @active_only::boolean THEN deleted_at IS NULL 
    WHEN NOT @active_only::boolean THEN TRUE -- Include both active and inactive
    ELSE TRUE -- Default if active_only is NULL (list all matching)
  END
ORDER BY created_at DESC -- Or relevance if using full-text search
LIMIT @page_limit::int4 OFFSET @page_offset::int4;

-- name: CountSearchUsers :one
-- Counts users matching the search term, optionally filtered by active status.
-- Useful for pagination metadata with search.
SELECT COUNT(*) AS total_matching_users
FROM users
WHERE 
  (LOWER(email) LIKE LOWER(@search_term::text || '%') OR LOWER(full_name) LIKE LOWER(@search_term::text || '%'))
  AND
  -- Filter by active status (NULL means active, NOT NULL means soft-deleted/inactive)
  CASE 
    WHEN @active_only::boolean THEN deleted_at IS NULL 
    WHEN NOT @active_only::boolean THEN TRUE -- Include both active and inactive
    ELSE TRUE -- Default if active_only is NULL (count all matching)
  END;

-- name: AdminGetUser :one
-- Gets a specific user by ID, regardless of soft-delete status.
-- Useful for admin to see any user, active or inactive.
SELECT id, email, password_hash, full_name, is_admin, created_at, updated_at, deleted_at
FROM users
WHERE id = @user_id::uuid;

-- name: GetUserWithDetails :one
-- Fetches a specific user by ID along with order count and last order date.
-- Joins with the orders table to get aggregated details.
-- Includes soft-deleted users as well.
SELECT 
    u.id, 
    u.email, 
    u.full_name, 
    u.created_at AS registration_date, -- User registration date
    u.deleted_at, -- Needed to determine activity status
    COUNT(o.id) AS total_order_count,
    MAX(o.created_at) AS last_order_date -- Get the latest order date
FROM 
    users u
LEFT JOIN 
    orders o ON u.id = o.user_id
WHERE 
    u.id = @user_id::uuid
GROUP BY 
    u.id;

-- name: ListUsersWithOrderCounts :many
-- Lists users with their total order counts.
-- Optionally filter by active status.
-- Paginated using LIMIT and OFFSET.
SELECT 
    u.id, 
    u.email, 
    u.full_name, 
    u.is_admin, 
    u.created_at, 
    u.updated_at, 
    u.deleted_at,
    COUNT(o.id) AS total_order_count
FROM 
    users u
LEFT JOIN 
    orders o ON u.id = o.user_id
WHERE 
  CASE 
    WHEN @active_only::boolean THEN u.deleted_at IS NULL 
    WHEN NOT @active_only::boolean THEN TRUE 
    ELSE TRUE 
  END
GROUP BY 
    u.id
ORDER BY 
    u.created_at DESC -- Or another relevant order
LIMIT @page_limit::int4 OFFSET @page_offset::int4;

-- name: ListUsersWithListDetails :many
-- Lists users with essential details for admin list view (name, email, registration date, last order date, order count, status).
-- Optionally filter by active status.
-- Paginated using LIMIT and OFFSET.
SELECT
    u.id,
    u.email,
    u.full_name,
    u.created_at AS registration_date, -- User's registration date
    MAX(o.created_at) AS last_order_date, -- Latest order date for the user (will be NULL if no orders)
    COUNT(o.id) AS total_order_count,
    u.deleted_at -- Needed for determining activity status
FROM
    users u
LEFT JOIN
    orders o ON u.id = o.user_id
WHERE
is_admin = false
AND
  CASE
    WHEN @active_only::boolean THEN u.deleted_at IS NULL
    WHEN NOT @active_only::boolean THEN TRUE
    ELSE TRUE
  END
GROUP BY
    u.id
ORDER BY
    u.created_at DESC -- Or another relevant order
LIMIT @page_limit::int4 OFFSET @page_offset::int4;

-- name: SoftDeleteUser :exec
-- Marks a user as soft-deleted by setting deleted_at to NOW().
UPDATE users
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = @user_id::uuid;

-- name: ActivateUser :exec
-- Removes the soft-delete marker by setting deleted_at to NULL.
UPDATE users
SET deleted_at = NULL, updated_at = NOW()
WHERE id = @user_id::uuid;


File: internal/models/product.go
================================================
package models

import (
	"time"

	"github.com/google/uuid"
)

// Product represents a product in the store.
type Product struct {
	ID                                 uuid.UUID              `json:"id"`
	CategoryID                         uuid.UUID              `json:"category_id"`
	CategoryName                       *string                `json:"category_name,omitempty"`
	Name                               string                 `json:"name"`
	Slug                               string                 `json:"slug"`
	Description                        *string                `json:"description,omitempty"`
	ShortDescription                   *string                `json:"short_description,omitempty"`
	PriceCents                         int64                  `json:"price_cents"`           // Represents OriginalPriceCents from the query
	StockQuantity                      int                    `json:"stock_quantity"`        // Different type
	AvgRating                          float64                `json:"avg_rating,omitempty"`  // Nullable, calculated from reviews
	NumRatings                         *int32                 `json:"num_ratings,omitempty"` // Nullable, count of reviews
	Status                             string                 `json:"status"`
	Brand                              string                 `json:"brand"`
	ImageURLs                          []string               `json:"image_urls"`           // Different type
	SpecHighlights                     map[string]interface{} `json:"spec_highlights"`      // Different type
	CreatedAt                          time.Time              `json:"created_at"`           // Different type
	UpdatedAt                          time.Time              `json:"updated_at"`           // Different type
	DeletedAt                          *time.Time             `json:"deleted_at,omitempty"` // Different type
	DiscountedPriceCents               *int64                 `json:"discounted_price_cents,omitempty"`
	DiscountCode                       *string                `json:"discount_code,omitempty"`  // Kept as nil
	DiscountType                       *string                `json:"discount_type,omitempty"`  // Kept as nil
	DiscountValue                      *int64                 `json:"discount_value,omitempty"` // Kept as nil
	HasActiveDiscount                  bool                   `json:"has_active_discount"`
	TotalCalculatedFixedDiscountCents  *int64                 `json:"total_calculated_fixed_discount_cents,omitempty"`
	CalculatedCombinedPercentageFactor *float64               `json:"calculated_combined_percentage_factor,omitempty"`
	EffectiveDiscountPercentage        *float64               `json:"effective_discount_percentage,omitempty"` // e.g., 20.5%
}

type CreateProductRequest struct {
	CategoryID       uuid.UUID      `json:"category_id" validate:"required,uuid"`
	Name             string         `json:"name" validate:"required,max=255"`
	Description      *string        `json:"description,omitempty"`
	ShortDescription *string        `json:"short_description,omitempty"`
	PriceCents       int64          `json:"price_cents" validate:"required,min=0"`
	StockQuantity    int            `json:"stock_quantity" validate:"min=0"`
	Status           string         `json:"status" validate:"required,oneof=draft active discontinued"`
	Brand            string         `json:"brand" validate:"required,max=100"`
	ImageUrls        []string       `json:"image_urls" validate:"max=10"`
	SpecHighlights   map[string]any `json:"spec_highlights"`
}

type ProductFilter struct {
	Query                 string    `json:"query,omitempty"`
	CategoryID            uuid.UUID `json:"category_id,omitempty"`
	Brand                 string    `json:"brand,omitempty"`
	MinPrice              *int64    `json:"min_price,omitempty"`
	MaxPrice              *int64    `json:"max_price,omitempty"`
	InStockOnly           *bool     `json:"in_stock_only,omitempty"`
	IncludeDiscountedOnly *bool     `json:"include_discounted_only,omitempty"`
	SpecFilter            *string   `json:"spec_filter,omitempty"`
	Page                  int       `json:"page"`
	Limit                 int       `json:"limit"`
}

type PaginatedResponse struct {
	Data       any   `json:"data"`
	Page       int   `json:"page"`
	Limit      int   `json:"limit"`
	Total      int64 `json:"total"`
	TotalPages int   `json:"total_pages"`
}

type UpdateProductRequest struct {
	CategoryID       *uuid.UUID      `json:"category_id,omitempty" validate:"omitempty,uuid"`
	Name             *string         `json:"name,omitempty" validate:"omitempty,max=255"`
	Description      *string         `json:"description,omitempty"`
	ShortDescription *string         `json:"short_description,omitempty"`
	PriceCents       *int64          `json:"price_cents,omitempty" validate:"omitempty,min=0"`
	StockQuantity    *int            `json:"stock_quantity,omitempty" validate:"omitempty,min=0"`
	Status           *string         `json:"status,omitempty" validate:"omitempty,oneof=draft active discontinued"`
	Brand            *string         `json:"brand,omitempty" validate:"omitempty,max=100"`
	ImageUrls        *[]string       `json:"image_urls,omitempty" validate:"omitempty,max=10"`
	SpecHighlights   *map[string]any `json:"spec_highlights,omitempty"`
}

func (r *CreateProductRequest) Validate() error {
	return Validate.Struct(r)
}

func (upr *UpdateProductRequest) Validate() error {
	return Validate.Struct(upr)
}


File: internal/models/user_profile.go
================================================
package models

import (
	"time"

	"github.com/google/uuid"
)

// UpdateProfileRequest holds the data for updating a user's profile information.
type UpdateProfileRequest struct {
	FullName *string `json:"full_name,omitempty" validate:"omitempty,max=255"` // Optional: New full name (up to 255 chars)
	Email    *string `json:"email,omitempty" validate:"omitempty,email"`       // Optional: New email address
}

// Validate implements custom validation logic if needed beyond struct tags.
// This is a placeholder, assuming you use a library like github.com/go-playground/validator/v10
// which primarily uses struct tags. You might add checks here if needed.
func (u *UpdateProfileRequest) Validate() error {
	return Validate.Struct(u)
}

// ChangePasswordRequest holds the data for changing a user's password.
type ChangePasswordRequest struct {
	CurrentPassword string `json:"current_password" validate:"required"`                     // Required: Current password for verification
	NewPassword     string `json:"new_password" validate:"required,min=8"`                   // Required: New password (minimum 8 chars)
	ConfirmPassword string `json:"confirm_password" validate:"required,eqfield=NewPassword"` // Required: Confirmation of new password
}

// Validate implements custom validation logic if needed beyond struct tags.
func (c *ChangePasswordRequest) Validate() error {
	return Validate.Struct(c)
}

// ForgotPasswordRequest holds the data for initiating a password reset.
type ForgotPasswordRequest struct {
	Email string `json:"email" validate:"required,email"` // Required: Email address of the user requesting reset
}

// Validate implements custom validation logic if needed beyond struct tags.
func (f *ForgotPasswordRequest) Validate() error {
	return Validate.Struct(f)
}

// ResetPasswordRequest holds the data for completing a password reset.
type ResetPasswordRequest struct {
	Token           string `json:"token" validate:"required"`                                // Required: The reset token received via email
	NewPassword     string `json:"new_password" validate:"required,min=8"`                   // Required: New password (minimum 8 chars)
	ConfirmPassword string `json:"confirm_password" validate:"required,eqfield=NewPassword"` // Required: Confirmation of new password
}

// Validate implements custom validation logic if needed beyond struct tags.
func (r *ResetPasswordRequest) Validate() error {
	return Validate.Struct(r)
}

// UserProfileResponse represents the user's profile information returned after an update.
type UserProfileResponse struct {
	ID        uuid.UUID `json:"id"`         // Unique identifier for the user
	Email     string    `json:"email"`      // User's email address
	FullName  *string   `json:"full_name"`  // User's full name (can be null)
	CreatedAt time.Time `json:"created_at"` // Timestamp when the user account was created
	UpdatedAt time.Time `json:"updated_at"` // Timestamp when the user account was last updated
}

// PasswordChangeResponse represents the outcome of a password change request.
// Often, a simple success message is sufficient.
type PasswordChangeResponse struct {
	Message string `json:"message"` // Success message (e.g., "Password updated successfully")
}

// ForgotPasswordResponse represents the outcome of a forgot password request.
// Usually, a generic message is returned to avoid revealing user existence.
type ForgotPasswordResponse struct {
	Message string `json:"message"` // Message (e.g., "If your email exists in our system, a password reset link has been sent.")
}

// ResetPasswordResponse represents the outcome of a password reset request.
// Often, a success message is sufficient, potentially redirecting the user.
type ResetPasswordResponse struct {
	Message string `json:"message"` // Success message (e.g., "Password reset successfully. Please log in.")
}


File: internal/config/config.go
================================================
package config

import (
	"log"
	"log/slog"
	"os"
	"strconv"
)

type SMTP struct {
	Host     string `mapstructure:"SMTP_HOST"`
	Port     int    `mapstructure:"SMTP_PORT"`
	Username string `mapstructure:"SMTP_USERNAME"`
	Password string `mapstructure:"SMTP_PASSWORD"`
	Sender   string `mapstructure:"SMTP_SENDER"`
}

type Config struct {
	ServerPort    string
	DBURL         string
	JWTSecret     string
	RedisHost     string
	RedisPort     string
	RedisPassword string
	RedisDB       int
	SMTP          SMTP   `mapstructure:"smtp"`
	BaseURL       string `mapstructure:"SERVER_BASE_URL"` // Add this field with the correct mapstructure tag
}

func LoadConfig() *Config {
	cfg := &Config{
		ServerPort:    getEnvOrDefault("PORT", "8080"),
		DBURL:         getEnvOrDefault("DATABASE_URL", ""),
		JWTSecret:     getEnvOrDefault("JWT_SECRET", ""),
		RedisHost:     getEnvOrDefault("REDIS_HOST", "localhost"),
		RedisPort:     getEnvOrDefault("REDIS_PORT", "6379"),
		RedisPassword: getEnvOrDefault("REDIS_PASSWORD", ""),
		RedisDB:       getEnvAsInt("REDIS_DB", 0),
		BaseURL:       getEnvOrDefault("SERVER_BASE_URL", "http://localhost:3000"), // Provide a default value like localhost for dev
		// Load SMTP configuration
		SMTP: SMTP{
			Host:     getEnvOrDefault("SMTP_HOST", ""), // Provide a default if needed, maybe empty string
			Port:     getEnvAsInt("SMTP_PORT", 0),      // Provide a default if needed, maybe 0
			Username: getEnvOrDefault("SMTP_USERNAME", ""),
			Password: getEnvOrDefault("SMTP_PASSWORD", ""),
			Sender:   getEnvOrDefault("SMTP_SENDER", ""),
		},
	}

	if cfg.JWTSecret == "" {
		slog.Error("JWT_SECRET environment variable is required")
		panic("JWT_SECRET environment variable is required")
	}

	return cfg
}

func getEnvOrDefault(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

func getEnvAsInt(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		intValue, err := strconv.Atoi(value)
		if err != nil {
			log.Printf("Warning: Could not parse environment variable %s as integer, using default %d", key, defaultValue)
			return defaultValue
		}
		return intValue
	}
	return defaultValue
}


File: internal/handlers/review.go
================================================
package handlers

import (
	"encoding/json"
	"log/slog"
	"net/http"
	"strconv"

	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/MihoZaki/DzTech/internal/services"
	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
)

type ReviewHandler struct {
	service *services.ReviewService
	logger  *slog.Logger
}

func NewReviewHandler(service *services.ReviewService, logger *slog.Logger) *ReviewHandler {
	return &ReviewHandler{
		service: service,
		logger:  logger,
	}
}

// RegisterRoutes registers the review-related routes.
func (h *ReviewHandler) RegisterRoutes(r chi.Router) {
	r.Get("/product/{product_id}", h.GetReviewsByProductID) // GET /api/v1/reviews/product/{product_id}?page=&limit=

	r.Group(func(r chi.Router) {
		r.Post("/", h.CreateReview)              // POST /api/v1/reviews
		r.Put("/{review_id}", h.UpdateReview)    // PUT /api/v1/reviews/{review_id}
		r.Delete("/{review_id}", h.DeleteReview) // DELETE /api/v1/reviews/{review_id}
		// r.Get("/user", h.GetReviewsByCurrentUser) // GET /api/v1/reviews/user?page=&limit=
	})

	// r.Get("/user/{user_id}", h.GetReviewsByUserID) // GET /api/v1/reviews/user/{user_id}?page=&limit=
}

// CreateReview handles creating a new review.
func (h *ReviewHandler) CreateReview(w http.ResponseWriter, r *http.Request) {
	user, ok := models.GetUserFromContext(r.Context())
	if !ok || user.ID == uuid.Nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	var req models.CreateReviewRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Error("Failed to decode CreateReview request", "error", err)
		http.Error(w, "Invalid JSON in request body: "+err.Error(), http.StatusBadRequest)
		return
	}

	if err := req.Validate(); err != nil {
		h.logger.Warn("Validation error in CreateReview", "error", err)
		http.Error(w, "Validation error: "+err.Error(), http.StatusBadRequest)
		return
	}

	review, err := h.service.CreateReview(r.Context(), user.ID, req)
	if err != nil {
		h.logger.Error("Failed to create review", "error", err, "user_id", user.ID, "product_id", req.ProductID)

		if err.Error() == "user has already reviewed this product" {
			http.Error(w, err.Error(), http.StatusConflict)
			return
		}
		http.Error(w, "Failed to create review", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	if err := json.NewEncoder(w).Encode(review); err != nil {
		h.logger.Error("Failed to encode CreateReview response", "error", err)
	}
}

// UpdateReview handles updating an existing review.
func (h *ReviewHandler) UpdateReview(w http.ResponseWriter, r *http.Request) {
	user, ok := models.GetUserFromContext(r.Context())
	if !ok || user.ID == uuid.Nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	reviewIDStr := chi.URLParam(r, "review_id")
	reviewID, err := uuid.Parse(reviewIDStr)
	if err != nil {
		h.logger.Warn("Invalid review ID format in UpdateReview", "review_id_str", reviewIDStr, "error", err)
		http.Error(w, "Invalid review ID format", http.StatusBadRequest)
		return
	}

	var req models.UpdateReviewRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Error("Failed to decode UpdateReview request", "error", err)
		http.Error(w, "Invalid JSON in request body: "+err.Error(), http.StatusBadRequest)
		return
	}

	if err := req.Validate(); err != nil {
		h.logger.Warn("Validation error in UpdateReview", "error", err)
		http.Error(w, "Validation error: "+err.Error(), http.StatusBadRequest)
		return
	}

	review, err := h.service.UpdateReview(r.Context(), reviewID, user.ID, req)
	if err != nil {
		h.logger.Error("Failed to update review", "error", err, "user_id", user.ID, "review_id", reviewID)

		if err.Error() == "review not found or does not belong to user" {
			http.Error(w, err.Error(), http.StatusNotFound)
			return
		}

		http.Error(w, "Failed to update review", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(review); err != nil {
		h.logger.Error("Failed to encode UpdateReview response", "error", err)
	}
}

// DeleteReview handles deleting an existing review.
func (h *ReviewHandler) DeleteReview(w http.ResponseWriter, r *http.Request) {
	user, ok := models.GetUserFromContext(r.Context())
	if !ok || user.ID == uuid.Nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	reviewIDStr := chi.URLParam(r, "review_id")
	reviewID, err := uuid.Parse(reviewIDStr)
	if err != nil {
		h.logger.Warn("Invalid review ID format in DeleteReview", "review_id_str", reviewIDStr, "error", err)
		http.Error(w, "Invalid review ID format", http.StatusBadRequest)
		return
	}

	err = h.service.DeleteReview(r.Context(), reviewID, user.ID)
	if err != nil {
		h.logger.Error("Failed to delete review", "error", err, "user_id", user.ID, "review_id", reviewID)

		if err.Error() == "review not found or does not belong to user" {
			http.Error(w, err.Error(), http.StatusNotFound)
			return
		}

		http.Error(w, "Failed to delete review", http.StatusInternalServerError)
		return
	}

	// 204 No Content on successful deletion
	w.WriteHeader(http.StatusNoContent)
}

// GetReviewsByProductID handles fetching reviews for a specific product.
func (h *ReviewHandler) GetReviewsByProductID(w http.ResponseWriter, r *http.Request) {
	productIDStr := chi.URLParam(r, "product_id")
	productID, err := uuid.Parse(productIDStr)
	if err != nil {
		h.logger.Warn("Invalid product ID format in GetReviewsByProductID", "product_id_str", productIDStr, "error", err)
		http.Error(w, "Invalid product ID format", http.StatusBadRequest)
		return
	}

	pageStr := r.URL.Query().Get("page")
	limitStr := r.URL.Query().Get("limit")

	page := 1
	if pageStr != "" {
		if p, err := strconv.Atoi(pageStr); err == nil && p > 0 {
			page = p
		}

	}

	limit := 20
	if limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 {
			limit = l
		}

	}

	resp, err := h.service.GetReviewsByProductID(r.Context(), productID, page, limit)
	if err != nil {
		h.logger.Error("Failed to get reviews for product", "error", err, "product_id", productID)
		http.Error(w, "Failed to retrieve reviews", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(resp); err != nil {
		h.logger.Error("Failed to encode GetReviewsByProductID response", "error", err)
	}
}

// GetReviewsByCurrentUser handles fetching reviews submitted by the currently authenticated user.
func (h *ReviewHandler) GetReviewsByCurrentUser(w http.ResponseWriter, r *http.Request) {
	user, ok := models.GetUserFromContext(r.Context())
	if !ok || user.ID == uuid.Nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	pageStr := r.URL.Query().Get("page")
	limitStr := r.URL.Query().Get("limit")

	page := 1
	if pageStr != "" {
		if p, err := strconv.Atoi(pageStr); err == nil && p > 0 {
			page = p
		}
	}

	limit := 20
	if limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 {
			limit = l
		}
	}

	resp, err := h.service.GetReviewsByUserID(r.Context(), user.ID, page, limit)
	if err != nil {
		h.logger.Error("Failed to get reviews by current user", "error", err, "user_id", user.ID)
		http.Error(w, "Failed to retrieve reviews", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(resp); err != nil {
		h.logger.Error("Failed to encode GetReviewsByCurrentUser response", "error", err)
	}
}

// GetReviewsByUserID handles fetching reviews submitted by a specific user.
func (h *ReviewHandler) GetReviewsByUserID(w http.ResponseWriter, r *http.Request) {
	userIDStr := chi.URLParam(r, "user_id")
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		h.logger.Warn("Invalid user ID format in GetReviewsByUserID", "user_id_str", userIDStr, "error", err)
		http.Error(w, "Invalid user ID format", http.StatusBadRequest)
		return
	}
	h.logger.Info("the user id", "id", userID)
}


File: internal/utils/roundup.go
================================================
package utils

import "math"

func RoundToDinarCents(cents int64) int64 {
	return int64(math.Round(float64(cents)/100.0)) * 100
}


File: internal/services/errors.go
================================================
package services

import "errors"

// Sentinel errors for ProductService
var (
	ErrProductNotFound   = errors.New("product not found")
	ErrCategoryNotFound  = errors.New("category not found")
	ErrInsufficientStock = errors.New("insufficient stock")
	// Add more as needed, e.g., ErrUserNotFound, ErrInsufficientStock, etc.
)

// Custom error types can also carry more context if needed
type NotFoundError struct {
	Entity string
	ID     string // Or uuid.UUID, depending on context
}

func (e NotFoundError) Error() string {
	return e.Entity + " not found with ID: " + e.ID
}

func IsNotFoundError(err error) bool {
	var target NotFoundError
	return errors.As(err, &target)
}

// Or use errors.Is with sentinel errors
func IsProductNotFound(err error) bool {
	return errors.Is(err, ErrProductNotFound)
}

func IsCategoryNotFound(err error) bool {
	return errors.Is(err, ErrCategoryNotFound)
}


File: migrations/00011_create_views_table.sql
================================================
-- +goose Up
-- +goose StatementBegin
CREATE OR REPLACE VIEW v_products_with_current_discounts AS
SELECT
    p.id AS product_id,
    p.category_id,
    p.name AS product_name,
    p.slug AS product_slug,
    p.description AS product_description,
    p.short_description AS product_short_description,
    p.price_cents AS original_price_cents,
    p.stock_quantity AS product_stock_quantity,
    p.status AS product_status,
    p.brand AS product_brand,
    p.image_urls AS product_image_urls,
    p.spec_highlights AS product_spec_highlights,
    p.created_at AS product_created_at,
    p.updated_at AS product_updated_at,
    p.deleted_at AS product_deleted_at,
    p.avg_rating,
    p.num_ratings,
    -- Calculate the discounted price based on active discounts
    CASE
        WHEN pd.discount_id IS NOT NULL THEN
            CASE
                WHEN d.discount_type = 'percentage' THEN (p.price_cents * (100 - d.discount_value) / 100)::BIGINT
                ELSE (p.price_cents - d.discount_value)::BIGINT
            END
        ELSE p.price_cents -- No discount, use original price
    END::BIGINT AS discounted_price_cents,
    d.code AS active_discount_code,
    d.discount_type AS active_discount_type,
    d.discount_value AS active_discount_value,
    pd.discount_id IS NOT NULL::BOOLEAN AS has_active_discount
FROM
    products p
LEFT JOIN
    product_discounts pd ON p.id = pd.product_id
LEFT JOIN
    discounts d ON pd.discount_id = d.id AND d.is_active = TRUE AND NOW() BETWEEN d.valid_from AND d.valid_until;

CREATE OR REPLACE VIEW v_products_with_calculated_discounts AS
WITH discount_calculations AS (
    SELECT
        p.id,
        p.price_cents,
        -- Total fixed discount
        COALESCE(
            SUM(
                CASE WHEN d.discount_type = 'fixed' THEN d.discount_value ELSE 0 END
            ) FILTER (WHERE d.is_active AND NOW() BETWEEN d.valid_from AND d.valid_until),
            0
        ) AS total_fixed_discount_cents,
        -- Combined percentage factor
        COALESCE(
            EXP(
                SUM(
                    CASE
                        WHEN d.discount_type = 'percentage' AND d.discount_value < 100
                        THEN LN(1 - d.discount_value / 100.0)
                        ELSE 0
                    END
                ) FILTER (WHERE d.is_active AND NOW() BETWEEN d.valid_from AND d.valid_until)
            ),
            1.0
        ) AS combined_percentage_factor
    FROM
        products p
        LEFT JOIN product_discounts pd ON p.id = pd.product_id
        LEFT JOIN discounts d ON pd.discount_id = d.id
    GROUP BY
        p.id, p.price_cents
)
SELECT
    dc.id AS product_id,
    dc.total_fixed_discount_cents,
    dc.combined_percentage_factor,
    -- Apply discounts once using precomputed values
    ((dc.price_cents - dc.total_fixed_discount_cents) * dc.combined_percentage_factor)::BIGINT AS calculated_discounted_price_cents,
    -- Flag if discount is actually applied
    CASE 
        WHEN ((dc.price_cents - dc.total_fixed_discount_cents) * dc.combined_percentage_factor)::BIGINT < dc.price_cents 
        THEN TRUE 
        ELSE FALSE 
    END AS has_active_discount
FROM
    discount_calculations dc;
-- +goose StatementEnd
-- +goose Down
-- +goose StatementBegin
DROP VIEW IF EXISTS v_products_with_current_discounts ;
DROP VIEW IF EXISTS v_products_with_calculated_discounts;
-- +goose StatementEnd


File: migrations/00007_create_refresh_token_table.sql
================================================
-- +goose Up
-- Refresh Tokens Table
CREATE TABLE refresh_tokens (
    id SERIAL PRIMARY KEY,
    jti VARCHAR(255) UNIQUE NOT NULL,      -- Unique JWT ID from the token
    user_id UUID NOT NULL,                 -- Reference to the user
    token_hash CHAR(64) NOT NULL,          -- Hash of the *entire signed refresh token string* (SHA-256 produces 64 hex chars)
    expires_at TIMESTAMPTZ NOT NULL,       -- Expiration time
    revoked_at TIMESTAMPTZ DEFAULT NULL,   -- Track revocation (e.g., on logout)
    created_at TIMESTAMPTZ DEFAULT NOW(),  -- When it was issued
    updated_at TIMESTAMPTZ DEFAULT NOW()   -- When it was last updated
);

-- Indexes
CREATE INDEX idx_refresh_tokens_jti ON refresh_tokens(jti);
CREATE INDEX idx_refresh_tokens_user_id ON refresh_tokens(user_id);
CREATE INDEX idx_refresh_tokens_expires_at ON refresh_tokens(expires_at);
CREATE INDEX idx_refresh_tokens_revoked_at ON refresh_tokens(revoked_at);
CREATE INDEX idx_refresh_tokens_active_lookup ON refresh_tokens(jti, expires_at, revoked_at);

ALTER TABLE refresh_tokens ADD CONSTRAINT fk_refresh_tokens_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;
-- +goose Down
DROP TABLE IF EXISTS refresh_token;


File: website/tailwind.config.js
================================================
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [require("daisyui")],
  daisyui: {
    themes: [
      "night", // Dracula theme
      "fantasy", // Light theme
    ],
  },
};


File: website/src/components/ProductCard.jsx
================================================
import React, { useState } from "react";
import { Link, useNavigate } from "react-router-dom";
import { toast } from "sonner";
import {
  CheckCircleIcon,
  EyeIcon,
  ShoppingCartIcon,
  StarIcon,
} from "@heroicons/react/24/solid";
import { useCart } from "../contexts/CartContext"; // Still need this to sync local cart
// REMOVED: import { addItemToCart } from "../services/api"; // No longer needed

const BACKEND_BASE_URL = import.meta.env.VITE_BACKEND_BASE_URL ||
  "http://localhost:8080";

const ProductCard = ({ product }) => {
  const navigation = useNavigate();
  const savedTheme = localStorage.getItem("theme");
  const { addToCart } = useCart(); // Use the context function directly
  const [isAdded, setIsAdded] = useState(false);
  const [isAdding, setIsAdding] = useState(false);

  // Function to construct full image URL
  const constructImageUrl = (imageUrl) => {
    if (!imageUrl) return "";

    // If it's already a full URL, return as is
    if (imageUrl.startsWith("http://") || imageUrl.startsWith("https://")) {
      return imageUrl;
    }

    // Otherwise, prepend the backend base URL
    return `${BACKEND_BASE_URL}${imageUrl}`;
  };

  const handleQuickAdd = async () => {
    if (isAdding) return;
    setIsAdding(true);
    setIsAdded(false);

    try {
      // Prepare the product object to pass to the context function
      // The context function will handle the API call via TanStack Query
      const productToAdd = {
        ...product,
        quantity: 1,
        image: product.image_urls && product.image_urls.length > 0
          ? constructImageUrl(product.image_urls[0])
          : "", // Use the constructed image URL
        // The context will handle price calculation internally based on the product object
      };

      // Call the context function which uses TanStack Query
      await addToCart(productToAdd);

      setIsAdded(true);
      toast.success(`"${product.name}" added to cart!`); // Use product.name
      setTimeout(() => {
        setIsAdded(false);
      }, 1500);
    } catch (error) {
      // Errors are now handled within the CartContext mutation
      // But we can still catch here if needed for UI-specific logic
      console.error("Failed to add item to cart:", error);
      toast.error("Failed to add item to cart. Please try again.");
    } finally {
      setIsAdding(false);
    }
  };

  const handleCardPress = () => {
    navigation(`/product/${product.id}`);
  };

  // Function to get display image URL
  const displayImage = product.image_urls && product.image_urls.length > 0
    ? constructImageUrl(product.image_urls[0])
    : ""; // Fallback to empty string if no image_urls

  // --- Determine Pricing Information (using new field names) ---
  const hasDiscount = product.has_active_discount &&
    product.discounted_price_cents !== undefined;
  const currentPrice = hasDiscount
    ? product.discounted_price_cents / 100
    : product.price_cents / 100; // Convert cents to dollars
  const originalPrice = hasDiscount ? product.price_cents / 100 : null; // Convert cents to dollars
  const discountPercentage = hasDiscount
    ? product.effective_discount_percentage
    : 0;
  // --- End of Determination ---

  // --- Determine Rating Information ---
  const hasRatings = product.num_ratings && product.num_ratings > 0;
  const avgRating = hasRatings ? (product.avg_rating || 0) : 0;
  const numRatings = product.num_ratings || 0;
  // --- End of Determination ---

  return (
    <div
      className={`card bg-base-100 shadow-sm hover:shadow-2xl transition-shadow duration-300 relative border rounded-lg border-info`}
    >
      <figure
        className="h-48 overflow-hidden cursor-pointer relative" // Added 'relative' for badge positioning
        onClick={handleCardPress}
      >
        <img
          src={displayImage}
          alt={product.name} // Use product.name
          className="w-full h-full object-fill rounded-t-lg hover:scale-105 transition-transform duration-300"
        />
        {/* Discount Badge */}
        {hasDiscount && discountPercentage > 0 && (
          <div className="absolute top-2 left-2 bg-info text-white text-s font-bold px-2 py-1 rounded-lg z-10">
            -{discountPercentage}%
          </div>
        )}
      </figure>
      <div className="card-body p-4 relative">
        {/* Added 'relative' for absolute positioning of button */}
        <h2 className="card-title text-m line-clamp-2">{product.name}</h2>{" "}
        {/* Use product.name */}
        <div className="flex items-center gap-1">
          <StarIcon className="h-4 w-4 text-yellow-400 fill-current" />
          <span className="text-xs">
            {hasRatings ? avgRating.toFixed(2) : "N/A"} ({numRatings} reviews)
          </span>
        </div>
        <p className="text-sm text-gray-600 line-clamp-2">
          {product.short_description || product.description}{" "}
          {/* Use short_description, fallback to description */}
        </p>
        {/* Price Display Container */}
        <div className="mt-2">
          {/* Price Display */}
          <div className="flex flex-col">
            <p className="text-lg font-bold text-base-content mb-0">
              {/* mb-0 removes default bottom margin */}
              DA {currentPrice.toFixed(2)}
            </p>
            {hasDiscount && originalPrice && (
              <p className="text-xs font-medium text-gray-400 line-through mt-0">
                DA {originalPrice.toFixed(2)}
              </p>
            )}
          </div>
        </div>

        {/* Add to Cart Button - Positioned absolutely at the bottom right */}
        <button
          className={`absolute bottom-4 right-4 btn btn-sm ${
            isAdded ? "btn-success " : "btn-primary"
          } z-50`}
          onClick={handleQuickAdd}
          title={isAdded ? "Added to Cart!" : "Add to Cart"}
          disabled={isAdded || isAdding}
        >
          {isAdding
            ? <span className="loading loading-spinner loading-xs"></span>
            : isAdded
            ? (
              <>
                <CheckCircleIcon className="h-4 w-4 mr-1 text-base-content" />
                <span className="text-base-content">Added!</span>
              </>
            )
            : (
              <>
                <ShoppingCartIcon className="h-4 w-4 text-secondary-content mr-1" />
                Add to cart
              </>
            )}
        </button>
      </div>
    </div>
  );
};

export default ProductCard;


File: website/src/pages/Products.jsx
================================================
// src/pages/Products.jsx
import React, { useCallback, useMemo, useState } from "react";
import { Link, useSearchParams } from "react-router-dom";
import { useQuery } from "@tanstack/react-query";
import ProductCard from "../components/ProductCard";
import FilterPanel from "../components/FilterPanel";
import {
  fetchCategories,
  searchProducts, // Keep using searchProducts
} from "../services/api";
import { toast } from "sonner";

// Mapping between URL-friendly names and actual category names from backend
const CATEGORY_URL_TO_NAME = {
  cpus: "CPU",
  gpus: "GPU",
  ram: "RAM",
  storage: "Storage",
  motherboards: "Motherboard",
  cases: "Case",
  psus: "Power Supply",
  peripherals: "Accessories",
  coolers: "Cooler",
  laptops: "Laptop",
};

const Products = () => {
  const [searchParams, setSearchParams] = useSearchParams();

  // State for filters (managed locally or could be derived from URL params)
  const [tempFilters, setTempFilters] = useState({
    category: searchParams.get("category") || "",
    query: searchParams.get("q") || "", // Add this line for search query
    minPrice: searchParams.get("minPrice") || "",
    maxPrice: searchParams.get("maxPrice") || "",
    brand: searchParams.get("brand") || "",
    inStockOnly: searchParams.get("inStockOnly") === "true" || false,
    includeDiscountedOnly:
      searchParams.get("includeDiscountedOnly") === "true" || false,
    specFilter: searchParams.get("specFilter") || "",
  }); // State to track the current applied filters
  const [appliedFilters, setAppliedFilters] = useState(tempFilters);

  // Fetch categories using useQuery
  const {
    data: categories = [], // Default to empty array
    isLoading: categoriesLoading,
    isError: categoriesError,
    error: categoriesApiError,
  } = useQuery({
    queryKey: ["categories"],
    queryFn: fetchCategories, // Direct function call
    staleTime: 15 * 60 * 1000, // Cache for 15 minutes
  });

  // Map category name to ID using the fetched categories list
  // We need this mapping to convert the filter name (e.g., "GPU") to the required category_id for the API
  const categoryNameToIdMap = useMemo(() => {
    if (!categories || !Array.isArray(categories)) return {};
    const map = {};
    categories.forEach((cat) => {
      map[cat.name] = cat.id;
    });
    return map;
  }, [categories]); // Recalculate map when categories change

  // Build search parameters object based on current filters
  // This function is memoized to avoid unnecessary recalculations on every render
  const buildSearchParams = useMemo(() => {
    // This inner function will be called inside the queryFn
    return () => {
      const params = {
        page: 1, // Default page
        limit: 50, // Default limit
      };

      // Apply category filter - Convert URL-friendly name to actual category name then to ID
      let actualCategoryName = appliedFilters.category;

      // Check if the filter category is a URL-friendly name that needs conversion
      if (CATEGORY_URL_TO_NAME[appliedFilters.category]) {
        actualCategoryName = CATEGORY_URL_TO_NAME[appliedFilters.category];
      } else if (appliedFilters.category) {
        // If no direct mapping found, try to convert the URL parameter to title case
        // For example: "cpu-cooler" becomes "Cpu Cooler", "power-supply" becomes "Power Supply"
        const convertedName = appliedFilters.category
          .split("-")
          .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
          .join(" ");

        // Check if the converted name exists in the category map
        if (categoryNameToIdMap[convertedName]) {
          actualCategoryName = convertedName;
        } else {
          // As a last resort, check if the original URL parameter exists in the category map
          // This handles cases where the URL parameter matches the actual category name
          if (categoryNameToIdMap[appliedFilters.category]) {
            actualCategoryName = appliedFilters.category;
          }
        }
      }

      // Check if the actual category name exists in our map
      if (actualCategoryName && categoryNameToIdMap[actualCategoryName]) {
        params.category_id = categoryNameToIdMap[actualCategoryName];
      }
      // If the selected category name is not found in the map, the filter is ignored
      // This can happen if categories change or the filter name is invalid

      // Apply price range filter - Convert DZD to cents
      if (appliedFilters.minPrice) {
        const minPriceCents = parseFloat(appliedFilters.minPrice) * 100; // Assuming input is in DZD
        // Validate conversion
        if (!isNaN(minPriceCents) && minPriceCents > 0) {
          params.min_price = Math.round(minPriceCents); // Round to nearest cent
        }
      }
      if (appliedFilters.maxPrice) {
        const maxPriceCents = parseFloat(appliedFilters.maxPrice) * 100; // Assuming input is in DZD
        // Validate conversion
        if (!isNaN(maxPriceCents) && maxPriceCents > 0) {
          params.max_price = Math.round(maxPriceCents); // Round to nearest cent
        }
      }
      // Apply search query filter
      if (appliedFilters.query) {
        params.q = appliedFilters.query;
      }
      // Apply brand filter
      if (appliedFilters.brand) {
        params.brand = appliedFilters.brand;
      }

      // Apply in stock only filter
      if (appliedFilters.inStockOnly) {
        params.in_stock_only = true;
      }

      // Apply include discounted only filter
      if (appliedFilters.includeDiscountedOnly) {
        params.include_discounted_only = true;
      }

      // Apply spec filter
      if (appliedFilters.specFilter) {
        params.spec_filter = appliedFilters.specFilter;
      }

      return params;
    };
  }, [appliedFilters, categoryNameToIdMap, CATEGORY_URL_TO_NAME]); // Dependency on appliedFilters and the name-to-id map

  // Fetch products using searchProducts and current filters via useQuery
  // The queryKey now includes the filters state, ensuring a new request when filters change
  const {
    data: productsData = {
      data: [],
      page: 1,
      limit: 20,
      total: 0,
      total_pages: 1,
    }, // Provide a default structure
    isLoading: productsLoading,
    isError: productsError,
    error: productsApiError,
    refetch: refetchProducts, // Function to manually refetch if needed
  } = useQuery({
    queryKey: ["searchProducts", appliedFilters, categories], // Include applied filters and categories (for mapping) in key
    queryFn: async () => {
      // Get the current parameters based on the latest filters and category map
      const currentParams = buildSearchParams();
      // Call searchProducts with the constructed parameters
      const result = await searchProducts(currentParams);
      return result; // Return the API response object
    },
    staleTime: 10 * 60 * 1000, // Cache for 10 minutes based on filters
    enabled: categories.length > 0, // Only run the search query once categories are loaded (for mapping)
  });

  // Destructure products array and pagination info from productsData
  const { data: products = [] } = productsData; // Destructure the 'data' key

  // Combine loading states if needed for a single spinner covering both products and categories
  const overallLoading = productsLoading || categoriesLoading;

  // Combine error states if needed
  const overallError = productsError || categoriesError;
  const overallErrorMessage = productsApiError?.message ||
    categoriesApiError?.message || "An unknown error occurred";

  // Memoize filtered products - now it's just the products returned by the API based on filters
  // We rely on the backend filtering via searchProducts
  const filteredProducts = useMemo(() => {
    return products;
  }, [products]); // Dependency on products from the query result

  // Handle filter changes (update temp filters, not applied filters)
  const handleFilterChange = (key, value) => {
    setTempFilters((prev) => ({ ...prev, [key]: value }));
  };

  // Apply filters function
  const applyFilters = useCallback(() => {
    setAppliedFilters(tempFilters);

    // Update URL search params based on applied filters
    const newParams = {};
    if (tempFilters.category) newParams.category = tempFilters.category;
    if (tempFilters.query) newParams.q = tempFilters.query;
    if (tempFilters.minPrice) newParams.minPrice = tempFilters.minPrice;
    if (tempFilters.maxPrice) newParams.maxPrice = tempFilters.maxPrice;
    if (tempFilters.brand) newParams.brand = tempFilters.brand;
    if (tempFilters.inStockOnly) {
      newParams.inStockOnly = tempFilters.inStockOnly.toString();
    }
    if (tempFilters.includeDiscountedOnly) {
      newParams.includeDiscountedOnly = tempFilters.includeDiscountedOnly
        .toString();
    }
    if (tempFilters.specFilter) newParams.specFilter = tempFilters.specFilter;

    setSearchParams(newParams);
  }, [tempFilters, setSearchParams]);

  // Reset filters function
  const resetFilters = useCallback(() => {
    const resetValues = {
      category: "",
      query: "",
      minPrice: "",
      maxPrice: "",
      brand: "",
      inStockOnly: false,
      includeDiscountedOnly: false,
      specFilter: "",
    };
    setTempFilters(resetValues);
    setAppliedFilters(resetValues);
    setSearchParams({});
  }, [setSearchParams]);

  // Handle loading states (both products and categories)
  if (overallLoading) {
    return (
      <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
        <h1 className="text-3xl font-bold mb-8 ">Products</h1>
        <div className="grid grid-cols-1 lg:grid-cols-4 gap-8">
          {/* Filter Panel Skeleton */}
          <div className="lg:col-span-1">
            <div className="bg-base-100 p-4 rounded-lg shadow-md border border-neutral-content">
              <div className="skeleton h-4 w-1/4 mb-4"></div>
              <div className="skeleton h-10 w-full mb-4"></div>
              <div className="skeleton h-10 w-full mb-4"></div>
              <div className="skeleton h-10 w-full mb-4"></div>
              <div className="skeleton h-8 w-full"></div>
            </div>
          </div>
          {/* Product Grid Skeleton */}
          <div className="lg:col-span-3">
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
              {[...Array(6)].map((_, i) => (
                <div key={i} className="card bg-inherit shadow-xl">
                  <div className="skeleton h-48 w-full bg-gray-700/50"></div>
                  <div className="card-body">
                    <div className="skeleton h-4 w-3/4 mb-2 bg-gray-700/50">
                    </div>
                    <div className="skeleton h-4 w-full mb-2 bg-gray-700/50">
                    </div>
                    <div className="skeleton h-4 w-1/2 mb-4 bg-gray-700/50">
                    </div>
                    <div className="skeleton h-8 w-full bg-gray-700/50"></div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Handle error states (either products or categories)
  if (overallError) {
    return (
      <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
        <h1 className="text-3xl font-bold mb-8 ">Products</h1>
        <div className="text-center py-12">
          <p className="text-xl mb-4 text-error">
            Error loading {overallErrorMessage}
          </p>
          <button
            className="btn btn-primary"
            onClick={() => {
              refetchProducts(); /* Add refetch for categories if needed */
            }}
          >
            Retry
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
      <h1 className="text-3xl font-bold mb-8 ">Products</h1>

      <div className="grid grid-cols-1 lg:grid-cols-4 gap-8">
        {/* Filter Panel - Pass categories and loading state if needed */}
        <div className="lg:col-span-1">
          <FilterPanel
            filters={tempFilters}
            onFilterChange={handleFilterChange}
            onApplyFilters={applyFilters}
            onResetFilters={resetFilters}
            categories={categories} // Pass the categories fetched by useQuery
            loading={categoriesLoading} // Pass loading state if FilterPanel needs it
          />
        </div>

        {/* Product Grid */}
        <div className="lg:col-span-3">
          {filteredProducts.length === 0
            ? (
              <div className="text-center py-12">
                <p className="text-xl mb-4 ">
                  No products found matching your criteria.
                </p>
                <button
                  className="btn btn-secondary bg-gray-700 hover:bg-gray-600 "
                  onClick={resetFilters}
                >
                  Clear Filters
                </button>
              </div>
            )
            : (
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                {filteredProducts.map((product) => (
                  <ProductCard key={product.id} product={product} />
                ))}
              </div>
            )}
        </div>
      </div>
    </div>
  );
};

export default Products;


File: website/src/index.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;


File: internal/services/category_service.go
================================================
package services

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"math"

	"github.com/MihoZaki/DzTech/internal/db"
	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/MihoZaki/DzTech/internal/utils"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/redis/go-redis/v9"
)

// CategoryService handles business logic for categories.
type CategoryService struct {
	querier db.Querier
	cache   *redis.Client // Optional, if you want to cache categories later
	logger  *slog.Logger
}

// NewCategoryService creates a new instance of CategoryService.
func NewCategoryService(querier db.Querier, cache *redis.Client, logger *slog.Logger) *CategoryService {
	return &CategoryService{
		querier: querier,
		cache:   cache,
		logger:  logger,
	}
}

// CreateCategory creates a new category, generating a unique slug.
func (s *CategoryService) CreateCategory(ctx context.Context, req models.CreateCategoryRequest) (*models.Category, error) {

	// --- Generate Slug ---
	baseSlug := utils.GenerateSlug(req.Name)
	finalSlug := s.ensureUniqueSlug(ctx, baseSlug)
	// ---

	// Prepare parameters for the query
	params := db.CreateCategoryParams{
		Name: req.Name,
		Slug: finalSlug, // Use the generated slug
		Type: req.Type,
	}

	// Execute the query to create the category
	dbCategory, err := s.querier.CreateCategory(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to create category in database: %w", err)
	}

	// Map the created database category to the application model
	createdCategory := s.toCategoryModel(dbCategory)

	s.logger.Info("Category created successfully", "category_id", createdCategory.ID, "name", createdCategory.Name, "slug", createdCategory.Slug)
	return createdCategory, nil
}

// GetCategory retrieves a category by its ID.
func (s *CategoryService) GetCategory(ctx context.Context, id uuid.UUID) (*models.Category, error) {
	dbCategory, err := s.querier.GetCategory(ctx, id)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("category not found")
		}
		return nil, fmt.Errorf("failed to fetch category: %w", err)
	}

	category := s.toCategoryModel(dbCategory)

	return category, nil
}

// GetCategoryBySlug retrieves a category by its slug.
func (s *CategoryService) GetCategoryBySlug(ctx context.Context, slug string) (*models.Category, error) {
	dbCategory, err := s.querier.GetCategoryBySlug(ctx, slug)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("category not found")
		}
		return nil, fmt.Errorf("failed to fetch category: %w", err)
	}

	category := s.toCategoryModel(dbCategory)

	return category, nil
}

// ListCategories retrieves a paginated list of categories.
func (s *CategoryService) ListCategories(ctx context.Context, page, limit int) (*models.PaginatedResponse, error) {
	if page == 0 {
		page = 1
	}
	if limit == 0 {
		limit = 20
	}
	if limit > 100 {
		limit = 100 // Enforce a maximum limit
	}
	offset := (page - 1) * limit

	// Prepare query parameters
	params := db.ListCategoriesParams{
		Limit:  int32(limit),
		Offset: int32(offset),
	}

	dbCategories, err := s.querier.ListCategories(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to list categories from database: %w", err)
	}

	// Map database results to application models
	result := make([]*models.Category, len(dbCategories))
	for i, dbCat := range dbCategories {
		result[i] = s.toCategoryModel(dbCat)
	}

	// Get total count for pagination (you'll need a count query)
	total, err := s.getCountForList(ctx) // Placeholder function, implement count query
	if err != nil {
		return nil, fmt.Errorf("failed to count categories for pagination: %w", err)
	}

	totalPages := int(math.Ceil(float64(total) / float64(limit)))

	response := &models.PaginatedResponse{
		Data:       result,
		Page:       page,
		Limit:      limit,
		Total:      total,
		TotalPages: totalPages,
	}

	return response, nil
}

// getCountForList is a helper to get the total count matching ListCategories filters.
func (s *CategoryService) getCountForList(ctx context.Context) (int64, error) {
	count, err := s.querier.CountCategories(ctx)
	if err != nil {
		return 0, fmt.Errorf("failed to count categories: %w", err)
	}
	return count, nil

}

// UpdateCategory updates an existing category, regenerating slug if name changes.
func (s *CategoryService) UpdateCategory(ctx context.Context, id uuid.UUID, req models.UpdateCategoryRequest) (*models.Category, error) {
	// Fetch the existing category to validate and get current values (including current slug)
	existingDBCat, err := s.querier.GetCategory(ctx, id)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("category not found")
		}
		return nil, fmt.Errorf("failed to fetch existing category: %w", err)
	}

	// Prepare update parameters, using existing values if not provided in request
	name := CoalesceString(req.Name, existingDBCat.Name)
	categoryType := CoalesceString(req.Type, existingDBCat.Type)

	// --- Handle Slug Regeneration if Name Changes ---
	slug := existingDBCat.Slug                              // Default to existing slug
	if req.Name != nil && *req.Name != existingDBCat.Name { // Check if name actually changed
		newBaseSlug := utils.GenerateSlug(*req.Name)
		newFinalSlug := s.ensureUniqueSlug(ctx, newBaseSlug) // Use the helper again
		slug = newFinalSlug                                  // Update the slug in params
	}
	// ---

	// Prepare the query parameters
	params := db.UpdateCategoryParams{
		ID:   id, // The ID of the category to update
		Name: name,
		Slug: slug, // Use the potentially new slug or the old one
		Type: categoryType,
	}

	// Execute the update query
	updatedDBCat, err := s.querier.UpdateCategory(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to update category in database: %w", err)
	}

	// Map the updated database category to the application model
	updatedCategory := s.toCategoryModel(updatedDBCat)

	s.logger.Info("Category updated successfully", "category_id", updatedCategory.ID, "name", updatedCategory.Name, "slug", updatedCategory.Slug)
	return updatedCategory, nil
}

// DeleteCategory soft-deletes a category by its ID.
func (s *CategoryService) DeleteCategory(ctx context.Context, id uuid.UUID) error {
	// Execute the delete query (soft delete)
	err := s.querier.DeleteCategory(ctx, id)
	if err != nil {
		return fmt.Errorf("failed to delete category from database: %w", err)
	}

	s.logger.Info("Category soft-deleted successfully", "category_id", id)
	return nil
}

// --- Helper Functions ---

// Add the Category model conversion function
func (s *CategoryService) toCategoryModel(dbCategory db.Category) *models.Category {
	category := &models.Category{
		ID:        dbCategory.ID, // uuid.UUID
		Name:      dbCategory.Name,
		Slug:      dbCategory.Slug,
		Type:      dbCategory.Type,
		CreatedAt: dbCategory.CreatedAt.Time,
	}

	// Handle nullable ParentID - now correctly as *uuid.UUID
	if dbCategory.ParentID != uuid.Nil {
		category.ParentID = &dbCategory.ParentID
	}

	return category
}

func CoalesceUUIDPtr(a *uuid.UUID, b uuid.UUID) uuid.UUID {
	if a != nil {
		return *a
	}
	return b
}

// ensureUniqueSlug generates a unique slug based on the base slug.
// It checks the database and appends a suffix if necessary.
func (s *CategoryService) ensureUniqueSlug(ctx context.Context, baseSlug string) string {
	slugToTry := baseSlug
	counter := 0

	for {
		// Check if the slug already exists for categories
		exists, err := s.checkSlugExists(ctx, slugToTry)
		if err != nil {
			s.logger.Error("Error checking slug existence for category", "slug", slugToTry, "error", err)
			panic(err) // Or return "", err if you want to handle it upstream
		}

		if !exists {
			return slugToTry // Found a unique slug
		}

		// Slug exists, increment counter and try again
		counter++
		slugToTry = fmt.Sprintf("%s-%d", baseSlug, counter)
	}
}

// checkSlugExists checks if a slug already exists for a category (excluding the current one if updating).
func (s *CategoryService) checkSlugExists(ctx context.Context, slug string) (bool, error) {
	// Assumes CheckCategorySlugExists is generated in db.Querier
	exists, err := s.querier.CheckCategorySlugExists(ctx, slug)
	if err != nil {
		return false, err
	}
	return exists, nil
}


File: migrations/00003_create_products_and_categories_tables.sql
================================================
-- +goose Up
-- Create categories table
CREATE TABLE categories (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL,
    slug VARCHAR(100) UNIQUE NOT NULL,
    type VARCHAR(50) NOT NULL, -- 'component', 'laptop', 'accessory'
    parent_id UUID REFERENCES categories(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create products table
CREATE TABLE products (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    category_id UUID NOT NULL REFERENCES categories(id) ON DELETE RESTRICT,
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    short_description VARCHAR(255),
    price_cents BIGINT NOT NULL CHECK (price_cents >= 0), -- e.g., $199.99 → 19999
    stock_quantity INT NOT NULL DEFAULT 0 CHECK (stock_quantity >= 0),
    status VARCHAR(20) NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'active', 'discontinued')),
    brand VARCHAR(100) NOT NULL,
    avg_rating NUMERIC(3,2) DEFAULT NULL,
    num_ratings INTEGER DEFAULT 0,
    image_urls JSONB NOT NULL DEFAULT '[]'::JSONB,
    spec_highlights JSONB NOT NULL DEFAULT '{}'::JSONB, -- { "cores": 16, "base_clock_ghz": 4.5 }
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- Create indexes
CREATE INDEX idx_products_category ON products(category_id);
CREATE INDEX idx_products_category_created ON products(category_id, created_at);
CREATE INDEX idx_products_slug ON products(slug);
CREATE INDEX idx_products_active ON products(id) WHERE status = 'active' AND deleted_at IS NULL;
CREATE INDEX idx_products_search ON products USING GIN (
    to_tsvector('english', name || ' ' || COALESCE(short_description, ''))
);
CREATE INDEX idx_products_spec_highlights ON products USING GIN (spec_highlights);
CREATE INDEX idx_categories_slug ON categories(slug);
CREATE INDEX idx_categories_parent ON categories(parent_id);
CREATE INDEX idx_products_brand ON products(brand);
CREATE INDEX idx_products_price ON products(price_cents);
CREATE INDEX idx_products_stock ON products(stock_quantity);

-- Insert default categories
INSERT INTO categories (name, slug, type) VALUES
('CPU', 'cpu', 'component'),
('GPU', 'gpu', 'component'),
('Motherboard', 'motherboard', 'component'),
('RAM', 'ram', 'component'),
('Storage', 'storage', 'component'),
('Power Supply', 'psu', 'component'),
('Case', 'case', 'component'),
('Cooler', 'cpu-cooler', 'component'),
('Laptop', 'laptop', 'laptop'),
('Accessories', 'accessories', 'accessory');

-- +goose Down
DROP TABLE IF EXISTS products;
DROP TABLE IF EXISTS categories;


File: website/package-lock.json
================================================
{
  "name": "frontend-user",
  "version": "0.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "frontend-user",
      "version": "0.0.0",
      "dependencies": {
        "@headlessui/react": "^2.2.9",
        "@heroicons/react": "^2.2.0",
        "@hookform/resolvers": "^5.2.2",
        "@tanstack/react-query": "^5.90.21",
        "@uidotdev/usehooks": "^2.4.1",
        "axios": "^1.13.4",
        "react": "^19.2.0",
        "react-dom": "^19.2.0",
        "react-hook-form": "^7.71.1",
        "react-router-dom": "^7.13.0",
        "sonner": "^2.0.7",
        "zod": "^4.3.6",
        "zustand": "^5.0.10"
      },
      "devDependencies": {
        "@eslint/js": "^9.39.1",
        "@types/react": "^19.2.5",
        "@types/react-dom": "^19.2.3",
        "@vitejs/plugin-react": "^5.1.1",
        "autoprefixer": "^10.4.23",
        "daisyui": "^4",
        "eslint": "^9.39.1",
        "eslint-plugin-react-hooks": "^7.0.1",
        "eslint-plugin-react-refresh": "^0.4.24",
        "globals": "^16.5.0",
        "postcss": "^8.5.6",
        "sharp": "^0.34.5",
        "svgo": "^4.0.0",
        "tailwindcss": "^3.4.19",
        "vite": "^7.2.4",
        "vite-plugin-image-optimizer": "^2.0.3"
      }
    },
    "node_modules/@alloc/quick-lru": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@alloc/quick-lru/-/quick-lru-5.2.0.tgz",
      "integrity": "sha512-UrcABB+4bUrFABwbluTIBErXwvbsU/V7TZWfmbgJfbkwiBuziS9gxdODUyuiecfdGQ85jglMW6juS3+z5TsKLw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@babel/code-frame": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.29.0.tgz",
      "integrity": "sha512-9NhCeYjq9+3uxgdtp20LSiJXJvN0FeCtNGpJxuMFZ1Kv3cWUNb6DOhJwUvcVCzKGR66cw4njwM6hrJLqgOwbcw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.28.5",
        "js-tokens": "^4.0.0",
        "picocolors": "^1.1.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/compat-data": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.29.0.tgz",
      "integrity": "sha512-T1NCJqT/j9+cn8fvkt7jtwbLBfLC/1y1c7NtCeXFRgzGTsafi68MRv8yzkYSapBnFA6L3U2VSc02ciDzoAJhJg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/core": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.29.0.tgz",
      "integrity": "sha512-CGOfOJqWjg2qW/Mb6zNsDm+u5vFQ8DxXfbM09z69p5Z6+mE1ikP2jUXw+j42Pf1XTYED2Rni5f95npYeuwMDQA==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "@babel/code-frame": "^7.29.0",
        "@babel/generator": "^7.29.0",
        "@babel/helper-compilation-targets": "^7.28.6",
        "@babel/helper-module-transforms": "^7.28.6",
        "@babel/helpers": "^7.28.6",
        "@babel/parser": "^7.29.0",
        "@babel/template": "^7.28.6",
        "@babel/traverse": "^7.29.0",
        "@babel/types": "^7.29.0",
        "@jridgewell/remapping": "^2.3.5",
        "convert-source-map": "^2.0.0",
        "debug": "^4.1.0",
        "gensync": "^1.0.0-beta.2",
        "json5": "^2.2.3",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/babel"
      }
    },
    "node_modules/@babel/generator": {
      "version": "7.29.1",
      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.29.1.tgz",
      "integrity": "sha512-qsaF+9Qcm2Qv8SRIMMscAvG4O3lJ0F1GuMo5HR/Bp02LopNgnZBC/EkbevHFeGs4ls/oPz9v+Bsmzbkbe+0dUw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.29.0",
        "@babel/types": "^7.29.0",
        "@jridgewell/gen-mapping": "^0.3.12",
        "@jridgewell/trace-mapping": "^0.3.28",
        "jsesc": "^3.0.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-compilation-targets": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.28.6.tgz",
      "integrity": "sha512-JYtls3hqi15fcx5GaSNL7SCTJ2MNmjrkHXg4FSpOA/grxK8KwyZ5bubHsCq8FXCkua6xhuaaBit+3b7+VZRfcA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.28.6",
        "@babel/helper-validator-option": "^7.27.1",
        "browserslist": "^4.24.0",
        "lru-cache": "^5.1.1",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-globals": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-globals/-/helper-globals-7.28.0.tgz",
      "integrity": "sha512-+W6cISkXFa1jXsDEdYA8HeevQT/FULhxzR99pxphltZcVaugps53THCeiWA8SguxxpSp3gKPiuYfSWopkLQ4hw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-imports": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.28.6.tgz",
      "integrity": "sha512-l5XkZK7r7wa9LucGw9LwZyyCUscb4x37JWTPz7swwFE/0FMQAGpiWUZn8u9DzkSBWEcK25jmvubfpw2dnAMdbw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.28.6",
        "@babel/types": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-transforms": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.28.6.tgz",
      "integrity": "sha512-67oXFAYr2cDLDVGLXTEABjdBJZ6drElUSI7WKp70NrpyISso3plG9SAGEF6y7zbha/wOzUByWWTJvEDVNIUGcA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.28.6",
        "@babel/helper-validator-identifier": "^7.28.5",
        "@babel/traverse": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-plugin-utils": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.28.6.tgz",
      "integrity": "sha512-S9gzZ/bz83GRysI7gAD4wPT/AI3uCnY+9xn+Mx/KPs2JwHJIz1W8PZkg2cqyt3RNOBM8ejcXhV6y8Og7ly/Dug==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-option": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.27.1.tgz",
      "integrity": "sha512-YvjJow9FxbhFFKDSuFnVCe2WxXk1zWc22fFePVNEaWJEu8IrZVlda6N0uHwzZrUM1il7NC9Mlp4MaJYbYd9JSg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helpers": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.28.6.tgz",
      "integrity": "sha512-xOBvwq86HHdB7WUDTfKfT/Vuxh7gElQ+Sfti2Cy6yIWNW05P8iUslOVcZ4/sKbE+/jQaukQAdz/gf3724kYdqw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.28.6",
        "@babel/types": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.29.0"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-self": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-self/-/plugin-transform-react-jsx-self-7.27.1.tgz",
      "integrity": "sha512-6UzkCs+ejGdZ5mFFC/OCUrv028ab2fp1znZmCZjAOBKiBK2jXD1O+BPSfX8X2qjJ75fZBMSnQn3Rq2mrBJK2mw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-source": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-source/-/plugin-transform-react-jsx-source-7.27.1.tgz",
      "integrity": "sha512-zbwoTsBruTeKB9hSq73ha66iFeJHuaFkUbwvqElnygoNbj/jHRsSeokowZFN3CZ64IvEqcmmkVe89OPXc7ldAw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/template": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.28.6.tgz",
      "integrity": "sha512-YA6Ma2KsCdGb+WC6UpBVFJGXL58MDA6oyONbjyF/+5sBgxY/dwkhLogbMT2GXXyU84/IhRw/2D1Os1B/giz+BQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.28.6",
        "@babel/parser": "^7.28.6",
        "@babel/types": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.29.0.tgz",
      "integrity": "sha512-4HPiQr0X7+waHfyXPZpWPfWL/J7dcN1mx9gL6WdQVMbPnF3+ZhSMs8tCxN7oHddJE9fhNE7+lxdnlyemKfJRuA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.29.0",
        "@babel/generator": "^7.29.0",
        "@babel/helper-globals": "^7.28.0",
        "@babel/parser": "^7.29.0",
        "@babel/template": "^7.28.6",
        "@babel/types": "^7.29.0",
        "debug": "^4.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.28.5"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@emnapi/runtime": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/@emnapi/runtime/-/runtime-1.8.1.tgz",
      "integrity": "sha512-mehfKSMWjjNol8659Z8KxEMrdSJDDot5SXMq00dM8BN4o+CLNXQ0xH2V7EchNHV4RmbZLmmPdEaXZc5H2FXmDg==",
      "dev": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "tslib": "^2.4.0"
      }
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.27.3.tgz",
      "integrity": "sha512-9fJMTNFTWZMh5qwrBItuziu834eOCUcEqymSH7pY+zoMVEZg3gcPuBNxH1EvfVYe9h0x/Ptw8KBzv7qxb7l8dg==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.27.3.tgz",
      "integrity": "sha512-i5D1hPY7GIQmXlXhs2w8AWHhenb00+GxjxRncS2ZM7YNVGNfaMxgzSGuO8o8SJzRc/oZwU2bcScvVERk03QhzA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.27.3.tgz",
      "integrity": "sha512-YdghPYUmj/FX2SYKJ0OZxf+iaKgMsKHVPF1MAq/P8WirnSpCStzKJFjOjzsW0QQ7oIAiccHdcqjbHmJxRb/dmg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.27.3.tgz",
      "integrity": "sha512-IN/0BNTkHtk8lkOM8JWAYFg4ORxBkZQf9zXiEOfERX/CzxW3Vg1ewAhU7QSWQpVIzTW+b8Xy+lGzdYXV6UZObQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.27.3.tgz",
      "integrity": "sha512-Re491k7ByTVRy0t3EKWajdLIr0gz2kKKfzafkth4Q8A5n1xTHrkqZgLLjFEHVD+AXdUGgQMq+Godfq45mGpCKg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.27.3.tgz",
      "integrity": "sha512-vHk/hA7/1AckjGzRqi6wbo+jaShzRowYip6rt6q7VYEDX4LEy1pZfDpdxCBnGtl+A5zq8iXDcyuxwtv3hNtHFg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.27.3.tgz",
      "integrity": "sha512-ipTYM2fjt3kQAYOvo6vcxJx3nBYAzPjgTCk7QEgZG8AUO3ydUhvelmhrbOheMnGOlaSFUoHXB6un+A7q4ygY9w==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.27.3.tgz",
      "integrity": "sha512-dDk0X87T7mI6U3K9VjWtHOXqwAMJBNN2r7bejDsc+j03SEjtD9HrOl8gVFByeM0aJksoUuUVU9TBaZa2rgj0oA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.27.3.tgz",
      "integrity": "sha512-s6nPv2QkSupJwLYyfS+gwdirm0ukyTFNl3KTgZEAiJDd+iHZcbTPPcWCcRYH+WlNbwChgH2QkE9NSlNrMT8Gfw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.27.3.tgz",
      "integrity": "sha512-sZOuFz/xWnZ4KH3YfFrKCf1WyPZHakVzTiqji3WDc0BCl2kBwiJLCXpzLzUBLgmp4veFZdvN5ChW4Eq/8Fc2Fg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.27.3.tgz",
      "integrity": "sha512-yGlQYjdxtLdh0a3jHjuwOrxQjOZYD/C9PfdbgJJF3TIZWnm/tMd/RcNiLngiu4iwcBAOezdnSLAwQDPqTmtTYg==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.27.3.tgz",
      "integrity": "sha512-WO60Sn8ly3gtzhyjATDgieJNet/KqsDlX5nRC5Y3oTFcS1l0KWba+SEa9Ja1GfDqSF1z6hif/SkpQJbL63cgOA==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.27.3.tgz",
      "integrity": "sha512-APsymYA6sGcZ4pD6k+UxbDjOFSvPWyZhjaiPyl/f79xKxwTnrn5QUnXR5prvetuaSMsb4jgeHewIDCIWljrSxw==",
      "cpu": [
        "mips64el"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.27.3.tgz",
      "integrity": "sha512-eizBnTeBefojtDb9nSh4vvVQ3V9Qf9Df01PfawPcRzJH4gFSgrObw+LveUyDoKU3kxi5+9RJTCWlj4FjYXVPEA==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.27.3.tgz",
      "integrity": "sha512-3Emwh0r5wmfm3ssTWRQSyVhbOHvqegUDRd0WhmXKX2mkHJe1SFCMJhagUleMq+Uci34wLSipf8Lagt4LlpRFWQ==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.27.3.tgz",
      "integrity": "sha512-pBHUx9LzXWBc7MFIEEL0yD/ZVtNgLytvx60gES28GcWMqil8ElCYR4kvbV2BDqsHOvVDRrOxGySBM9Fcv744hw==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.27.3.tgz",
      "integrity": "sha512-Czi8yzXUWIQYAtL/2y6vogER8pvcsOsk5cpwL4Gk5nJqH5UZiVByIY8Eorm5R13gq+DQKYg0+JyQoytLQas4dA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-arm64/-/netbsd-arm64-0.27.3.tgz",
      "integrity": "sha512-sDpk0RgmTCR/5HguIZa9n9u+HVKf40fbEUt+iTzSnCaGvY9kFP0YKBWZtJaraonFnqef5SlJ8/TiPAxzyS+UoA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.27.3.tgz",
      "integrity": "sha512-P14lFKJl/DdaE00LItAukUdZO5iqNH7+PjoBm+fLQjtxfcfFE20Xf5CrLsmZdq5LFFZzb5JMZ9grUwvtVYzjiA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.27.3.tgz",
      "integrity": "sha512-AIcMP77AvirGbRl/UZFTq5hjXK+2wC7qFRGoHSDrZ5v5b8DK/GYpXW3CPRL53NkvDqb9D+alBiC/dV0Fb7eJcw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.27.3.tgz",
      "integrity": "sha512-DnW2sRrBzA+YnE70LKqnM3P+z8vehfJWHXECbwBmH/CU51z6FiqTQTHFenPlHmo3a8UgpLyH3PT+87OViOh1AQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openharmony-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/openharmony-arm64/-/openharmony-arm64-0.27.3.tgz",
      "integrity": "sha512-NinAEgr/etERPTsZJ7aEZQvvg/A6IsZG/LgZy+81wON2huV7SrK3e63dU0XhyZP4RKGyTm7aOgmQk0bGp0fy2g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.27.3.tgz",
      "integrity": "sha512-PanZ+nEz+eWoBJ8/f8HKxTTD172SKwdXebZ0ndd953gt1HRBbhMsaNqjTyYLGLPdoWHy4zLU7bDVJztF5f3BHA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.27.3.tgz",
      "integrity": "sha512-B2t59lWWYrbRDw/tjiWOuzSsFh1Y/E95ofKz7rIVYSQkUYBjfSgf6oeYPNWHToFRr2zx52JKApIcAS/D5TUBnA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.27.3.tgz",
      "integrity": "sha512-QLKSFeXNS8+tHW7tZpMtjlNb7HKau0QDpwm49u0vUp9y1WOF+PEzkU84y9GqYaAVW8aH8f3GcBck26jh54cX4Q==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.27.3.tgz",
      "integrity": "sha512-4uJGhsxuptu3OcpVAzli+/gWusVGwZZHTlS63hh++ehExkVT8SgiEf7/uC/PclrPPkLhZqGgCTjd0VWLo6xMqA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@eslint-community/eslint-utils": {
      "version": "4.9.1",
      "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.9.1.tgz",
      "integrity": "sha512-phrYmNiYppR7znFEdqgfWHXR6NCkZEK7hwWDHZUjit/2/U0r6XvkDl0SYnoM51Hq7FhCGdLDT6zxCCOY1hexsQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "eslint-visitor-keys": "^3.4.3"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      },
      "peerDependencies": {
        "eslint": "^6.0.0 || ^7.0.0 || >=8.0.0"
      }
    },
    "node_modules/@eslint-community/eslint-utils/node_modules/eslint-visitor-keys": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz",
      "integrity": "sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint-community/regexpp": {
      "version": "4.12.2",
      "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.12.2.tgz",
      "integrity": "sha512-EriSTlt5OC9/7SXkRSCAhfSxxoSUgBm33OH+IkwbdpgoqsSsUg7y3uh+IICI/Qg4BBWr3U2i39RpmycbxMq4ew==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
      }
    },
    "node_modules/@eslint/config-array": {
      "version": "0.21.1",
      "resolved": "https://registry.npmjs.org/@eslint/config-array/-/config-array-0.21.1.tgz",
      "integrity": "sha512-aw1gNayWpdI/jSYVgzN5pL0cfzU02GT3NBpeT/DXbx1/1x7ZKxFPd9bwrzygx/qiwIQiJ1sw/zD8qY/kRvlGHA==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/object-schema": "^2.1.7",
        "debug": "^4.3.1",
        "minimatch": "^3.1.2"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/config-helpers": {
      "version": "0.4.2",
      "resolved": "https://registry.npmjs.org/@eslint/config-helpers/-/config-helpers-0.4.2.tgz",
      "integrity": "sha512-gBrxN88gOIf3R7ja5K9slwNayVcZgK6SOUORm2uBzTeIEfeVaIhOpCtTox3P6R7o2jLFwLFTLnC7kU/RGcYEgw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/core": "^0.17.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/core": {
      "version": "0.17.0",
      "resolved": "https://registry.npmjs.org/@eslint/core/-/core-0.17.0.tgz",
      "integrity": "sha512-yL/sLrpmtDaFEiUj1osRP4TI2MDz1AddJL+jZ7KSqvBuliN4xqYY54IfdN8qD8Toa6g1iloph1fxQNkjOxrrpQ==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@types/json-schema": "^7.0.15"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/eslintrc": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-3.3.3.tgz",
      "integrity": "sha512-Kr+LPIUVKz2qkx1HAMH8q1q6azbqBAsXJUxBl/ODDuVPX45Z9DfwB8tPjTi6nNZ8BuM3nbJxC5zCAg5elnBUTQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ajv": "^6.12.4",
        "debug": "^4.3.2",
        "espree": "^10.0.1",
        "globals": "^14.0.0",
        "ignore": "^5.2.0",
        "import-fresh": "^3.2.1",
        "js-yaml": "^4.1.1",
        "minimatch": "^3.1.2",
        "strip-json-comments": "^3.1.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/globals": {
      "version": "14.0.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-14.0.0.tgz",
      "integrity": "sha512-oahGvuMGQlPw/ivIYBjVSrWAfWLBeku5tpPE2fOPLi+WHffIWbuh2tCjhyQhTBPMf5E9jDEH4FOmTYgYwbKwtQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@eslint/js": {
      "version": "9.39.3",
      "resolved": "https://registry.npmjs.org/@eslint/js/-/js-9.39.3.tgz",
      "integrity": "sha512-1B1VkCq6FuUNlQvlBYb+1jDu/gV297TIs/OeiaSR9l1H27SVW55ONE1e1Vp16NqP683+xEGzxYtv4XCiDPaQiw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      }
    },
    "node_modules/@eslint/object-schema": {
      "version": "2.1.7",
      "resolved": "https://registry.npmjs.org/@eslint/object-schema/-/object-schema-2.1.7.tgz",
      "integrity": "sha512-VtAOaymWVfZcmZbp6E2mympDIHvyjXs/12LqWYjVw6qjrfF+VK+fyG33kChz3nnK+SU5/NeHOqrTEHS8sXO3OA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/plugin-kit": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/@eslint/plugin-kit/-/plugin-kit-0.4.1.tgz",
      "integrity": "sha512-43/qtrDUokr7LJqoF2c3+RInu/t4zfrpYdoSDfYyhg52rwLV6TnOvdG4fXm7IkSB3wErkcmJS9iEhjVtOSEjjA==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/core": "^0.17.0",
        "levn": "^0.4.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@floating-ui/core": {
      "version": "1.7.4",
      "resolved": "https://registry.npmjs.org/@floating-ui/core/-/core-1.7.4.tgz",
      "integrity": "sha512-C3HlIdsBxszvm5McXlB8PeOEWfBhcGBTZGkGlWc2U0KFY5IwG5OQEuQ8rq52DZmcHDlPLd+YFBK+cZcytwIFWg==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/utils": "^0.2.10"
      }
    },
    "node_modules/@floating-ui/dom": {
      "version": "1.7.5",
      "resolved": "https://registry.npmjs.org/@floating-ui/dom/-/dom-1.7.5.tgz",
      "integrity": "sha512-N0bD2kIPInNHUHehXhMke1rBGs1dwqvC9O9KYMyyjK7iXt7GAhnro7UlcuYcGdS/yYOlq0MAVgrow8IbWJwyqg==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/core": "^1.7.4",
        "@floating-ui/utils": "^0.2.10"
      }
    },
    "node_modules/@floating-ui/react": {
      "version": "0.26.28",
      "resolved": "https://registry.npmjs.org/@floating-ui/react/-/react-0.26.28.tgz",
      "integrity": "sha512-yORQuuAtVpiRjpMhdc0wJj06b9JFjrYF4qp96j++v2NBpbi6SEGF7donUJ3TMieerQ6qVkAv1tgr7L4r5roTqw==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/react-dom": "^2.1.2",
        "@floating-ui/utils": "^0.2.8",
        "tabbable": "^6.0.0"
      },
      "peerDependencies": {
        "react": ">=16.8.0",
        "react-dom": ">=16.8.0"
      }
    },
    "node_modules/@floating-ui/react-dom": {
      "version": "2.1.7",
      "resolved": "https://registry.npmjs.org/@floating-ui/react-dom/-/react-dom-2.1.7.tgz",
      "integrity": "sha512-0tLRojf/1Go2JgEVm+3Frg9A3IW8bJgKgdO0BN5RkF//ufuz2joZM63Npau2ff3J6lUVYgDSNzNkR+aH3IVfjg==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/dom": "^1.7.5"
      },
      "peerDependencies": {
        "react": ">=16.8.0",
        "react-dom": ">=16.8.0"
      }
    },
    "node_modules/@floating-ui/utils": {
      "version": "0.2.10",
      "resolved": "https://registry.npmjs.org/@floating-ui/utils/-/utils-0.2.10.tgz",
      "integrity": "sha512-aGTxbpbg8/b5JfU1HXSrbH3wXZuLPJcNEcZQFMxLs3oSzgtVu6nFPkbbGGUvBcUjKV2YyB9Wxxabo+HEH9tcRQ==",
      "license": "MIT"
    },
    "node_modules/@headlessui/react": {
      "version": "2.2.9",
      "resolved": "https://registry.npmjs.org/@headlessui/react/-/react-2.2.9.tgz",
      "integrity": "sha512-Mb+Un58gwBn0/yWZfyrCh0TJyurtT+dETj7YHleylHk5od3dv2XqETPGWMyQ5/7sYN7oWdyM1u9MvC0OC8UmzQ==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/react": "^0.26.16",
        "@react-aria/focus": "^3.20.2",
        "@react-aria/interactions": "^3.25.0",
        "@tanstack/react-virtual": "^3.13.9",
        "use-sync-external-store": "^1.5.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "react": "^18 || ^19 || ^19.0.0-rc",
        "react-dom": "^18 || ^19 || ^19.0.0-rc"
      }
    },
    "node_modules/@heroicons/react": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/@heroicons/react/-/react-2.2.0.tgz",
      "integrity": "sha512-LMcepvRaS9LYHJGsF0zzmgKCUim/X3N/DQKc4jepAXJ7l8QxJ1PmxJzqplF2Z3FE4PqBAIGyJAQ/w4B5dsqbtQ==",
      "license": "MIT",
      "peerDependencies": {
        "react": ">= 16 || ^19.0.0-rc"
      }
    },
    "node_modules/@hookform/resolvers": {
      "version": "5.2.2",
      "resolved": "https://registry.npmjs.org/@hookform/resolvers/-/resolvers-5.2.2.tgz",
      "integrity": "sha512-A/IxlMLShx3KjV/HeTcTfaMxdwy690+L/ZADoeaTltLx+CVuzkeVIPuybK3jrRfw7YZnmdKsVVHAlEPIAEUNlA==",
      "license": "MIT",
      "dependencies": {
        "@standard-schema/utils": "^0.3.0"
      },
      "peerDependencies": {
        "react-hook-form": "^7.55.0"
      }
    },
    "node_modules/@humanfs/core": {
      "version": "0.19.1",
      "resolved": "https://registry.npmjs.org/@humanfs/core/-/core-0.19.1.tgz",
      "integrity": "sha512-5DyQ4+1JEUzejeK1JGICcideyfUbGixgS9jNgex5nqkW+cY7WZhxBigmieN5Qnw9ZosSNVC9KQKyb+GUaGyKUA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanfs/node": {
      "version": "0.16.7",
      "resolved": "https://registry.npmjs.org/@humanfs/node/-/node-0.16.7.tgz",
      "integrity": "sha512-/zUx+yOsIrG4Y43Eh2peDeKCxlRt/gET6aHfaKpuq267qXdYDFViVHfMaLyygZOnl0kGWxFIgsBy8QFuTLUXEQ==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@humanfs/core": "^0.19.1",
        "@humanwhocodes/retry": "^0.4.0"
      },
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanwhocodes/module-importer": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
      "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=12.22"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@humanwhocodes/retry": {
      "version": "0.4.3",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/retry/-/retry-0.4.3.tgz",
      "integrity": "sha512-bV0Tgo9K4hfPCek+aMAn81RppFKv2ySDQeMoSZuvTASywNTnVJCArCZE2FWqpvIatKu7VMRLWlR1EazvVhDyhQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@img/colour": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/@img/colour/-/colour-1.0.0.tgz",
      "integrity": "sha512-A5P/LfWGFSl6nsckYtjw9da+19jB8hkJ6ACTGcDfEJ0aE+l2n2El7dsVM7UVHZQ9s2lmYMWlrS21YLy2IR1LUw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@img/sharp-darwin-arm64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-darwin-arm64/-/sharp-darwin-arm64-0.34.5.tgz",
      "integrity": "sha512-imtQ3WMJXbMY4fxb/Ndp6HBTNVtWCUI0WdobyheGf5+ad6xX8VIDO8u2xE4qc/fr08CKG/7dDseFtn6M6g/r3w==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-darwin-arm64": "1.2.4"
      }
    },
    "node_modules/@img/sharp-darwin-x64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-darwin-x64/-/sharp-darwin-x64-0.34.5.tgz",
      "integrity": "sha512-YNEFAF/4KQ/PeW0N+r+aVVsoIY0/qxxikF2SWdp+NRkmMB7y9LBZAVqQ4yhGCm/H3H270OSykqmQMKLBhBJDEw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-darwin-x64": "1.2.4"
      }
    },
    "node_modules/@img/sharp-libvips-darwin-arm64": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-darwin-arm64/-/sharp-libvips-darwin-arm64-1.2.4.tgz",
      "integrity": "sha512-zqjjo7RatFfFoP0MkQ51jfuFZBnVE2pRiaydKJ1G/rHZvnsrHAOcQALIi9sA5co5xenQdTugCvtb1cuf78Vf4g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "darwin"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-darwin-x64": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-darwin-x64/-/sharp-libvips-darwin-x64-1.2.4.tgz",
      "integrity": "sha512-1IOd5xfVhlGwX+zXv2N93k0yMONvUlANylbJw1eTah8K/Jtpi15KC+WSiaX/nBmbm2HxRM1gZ0nSdjSsrZbGKg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "darwin"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-arm": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-arm/-/sharp-libvips-linux-arm-1.2.4.tgz",
      "integrity": "sha512-bFI7xcKFELdiNCVov8e44Ia4u2byA+l3XtsAj+Q8tfCwO6BQ8iDojYdvoPMqsKDkuoOo+X6HZA0s0q11ANMQ8A==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-arm64": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-arm64/-/sharp-libvips-linux-arm64-1.2.4.tgz",
      "integrity": "sha512-excjX8DfsIcJ10x1Kzr4RcWe1edC9PquDRRPx3YVCvQv+U5p7Yin2s32ftzikXojb1PIFc/9Mt28/y+iRklkrw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-ppc64": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-ppc64/-/sharp-libvips-linux-ppc64-1.2.4.tgz",
      "integrity": "sha512-FMuvGijLDYG6lW+b/UvyilUWu5Ayu+3r2d1S8notiGCIyYU/76eig1UfMmkZ7vwgOrzKzlQbFSuQfgm7GYUPpA==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-riscv64": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-riscv64/-/sharp-libvips-linux-riscv64-1.2.4.tgz",
      "integrity": "sha512-oVDbcR4zUC0ce82teubSm+x6ETixtKZBh/qbREIOcI3cULzDyb18Sr/Wcyx7NRQeQzOiHTNbZFF1UwPS2scyGA==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-s390x": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-s390x/-/sharp-libvips-linux-s390x-1.2.4.tgz",
      "integrity": "sha512-qmp9VrzgPgMoGZyPvrQHqk02uyjA0/QrTO26Tqk6l4ZV0MPWIW6LTkqOIov+J1yEu7MbFQaDpwdwJKhbJvuRxQ==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-x64": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-x64/-/sharp-libvips-linux-x64-1.2.4.tgz",
      "integrity": "sha512-tJxiiLsmHc9Ax1bz3oaOYBURTXGIRDODBqhveVHonrHJ9/+k89qbLl0bcJns+e4t4rvaNBxaEZsFtSfAdquPrw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linuxmusl-arm64": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linuxmusl-arm64/-/sharp-libvips-linuxmusl-arm64-1.2.4.tgz",
      "integrity": "sha512-FVQHuwx1IIuNow9QAbYUzJ+En8KcVm9Lk5+uGUQJHaZmMECZmOlix9HnH7n1TRkXMS0pGxIJokIVB9SuqZGGXw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linuxmusl-x64": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linuxmusl-x64/-/sharp-libvips-linuxmusl-x64-1.2.4.tgz",
      "integrity": "sha512-+LpyBk7L44ZIXwz/VYfglaX/okxezESc6UxDSoyo2Ks6Jxc4Y7sGjpgU9s4PMgqgjj1gZCylTieNamqA1MF7Dg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-linux-arm": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-arm/-/sharp-linux-arm-0.34.5.tgz",
      "integrity": "sha512-9dLqsvwtg1uuXBGZKsxem9595+ujv0sJ6Vi8wcTANSFpwV/GONat5eCkzQo/1O6zRIkh0m/8+5BjrRr7jDUSZw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-arm": "1.2.4"
      }
    },
    "node_modules/@img/sharp-linux-arm64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-arm64/-/sharp-linux-arm64-0.34.5.tgz",
      "integrity": "sha512-bKQzaJRY/bkPOXyKx5EVup7qkaojECG6NLYswgktOZjaXecSAeCWiZwwiFf3/Y+O1HrauiE3FVsGxFg8c24rZg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-arm64": "1.2.4"
      }
    },
    "node_modules/@img/sharp-linux-ppc64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-ppc64/-/sharp-linux-ppc64-0.34.5.tgz",
      "integrity": "sha512-7zznwNaqW6YtsfrGGDA6BRkISKAAE1Jo0QdpNYXNMHu2+0dTrPflTLNkpc8l7MUP5M16ZJcUvysVWWrMefZquA==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-ppc64": "1.2.4"
      }
    },
    "node_modules/@img/sharp-linux-riscv64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-riscv64/-/sharp-linux-riscv64-0.34.5.tgz",
      "integrity": "sha512-51gJuLPTKa7piYPaVs8GmByo7/U7/7TZOq+cnXJIHZKavIRHAP77e3N2HEl3dgiqdD/w0yUfiJnII77PuDDFdw==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-riscv64": "1.2.4"
      }
    },
    "node_modules/@img/sharp-linux-s390x": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-s390x/-/sharp-linux-s390x-0.34.5.tgz",
      "integrity": "sha512-nQtCk0PdKfho3eC5MrbQoigJ2gd1CgddUMkabUj+rBevs8tZ2cULOx46E7oyX+04WGfABgIwmMC0VqieTiR4jg==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-s390x": "1.2.4"
      }
    },
    "node_modules/@img/sharp-linux-x64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-x64/-/sharp-linux-x64-0.34.5.tgz",
      "integrity": "sha512-MEzd8HPKxVxVenwAa+JRPwEC7QFjoPWuS5NZnBt6B3pu7EG2Ge0id1oLHZpPJdn3OQK+BQDiw9zStiHBTJQQQQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-x64": "1.2.4"
      }
    },
    "node_modules/@img/sharp-linuxmusl-arm64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-linuxmusl-arm64/-/sharp-linuxmusl-arm64-0.34.5.tgz",
      "integrity": "sha512-fprJR6GtRsMt6Kyfq44IsChVZeGN97gTD331weR1ex1c1rypDEABN6Tm2xa1wE6lYb5DdEnk03NZPqA7Id21yg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linuxmusl-arm64": "1.2.4"
      }
    },
    "node_modules/@img/sharp-linuxmusl-x64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-linuxmusl-x64/-/sharp-linuxmusl-x64-0.34.5.tgz",
      "integrity": "sha512-Jg8wNT1MUzIvhBFxViqrEhWDGzqymo3sV7z7ZsaWbZNDLXRJZoRGrjulp60YYtV4wfY8VIKcWidjojlLcWrd8Q==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linuxmusl-x64": "1.2.4"
      }
    },
    "node_modules/@img/sharp-wasm32": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-wasm32/-/sharp-wasm32-0.34.5.tgz",
      "integrity": "sha512-OdWTEiVkY2PHwqkbBI8frFxQQFekHaSSkUIJkwzclWZe64O1X4UlUjqqqLaPbUpMOQk6FBu/HtlGXNblIs0huw==",
      "cpu": [
        "wasm32"
      ],
      "dev": true,
      "license": "Apache-2.0 AND LGPL-3.0-or-later AND MIT",
      "optional": true,
      "dependencies": {
        "@emnapi/runtime": "^1.7.0"
      },
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-win32-arm64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-win32-arm64/-/sharp-win32-arm64-0.34.5.tgz",
      "integrity": "sha512-WQ3AgWCWYSb2yt+IG8mnC6Jdk9Whs7O0gxphblsLvdhSpSTtmu69ZG1Gkb6NuvxsNACwiPV6cNSZNzt0KPsw7g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "Apache-2.0 AND LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-win32-ia32": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-win32-ia32/-/sharp-win32-ia32-0.34.5.tgz",
      "integrity": "sha512-FV9m/7NmeCmSHDD5j4+4pNI8Cp3aW+JvLoXcTUo0IqyjSfAZJ8dIUmijx1qaJsIiU+Hosw6xM5KijAWRJCSgNg==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "Apache-2.0 AND LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-win32-x64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-win32-x64/-/sharp-win32-x64-0.34.5.tgz",
      "integrity": "sha512-+29YMsqY2/9eFEiW93eqWnuLcWcufowXewwSNIT6UwZdUUCrM3oFjMWH/Z6/TMmb4hlFenmfAVbpWeup2jryCw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "Apache-2.0 AND LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.13",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.0",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/remapping": {
      "version": "2.3.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/remapping/-/remapping-2.3.5.tgz",
      "integrity": "sha512-LI9u/+laYG4Ds1TDKSJW2YPrIlcVYOwi2fUC6xB43lueCjgxV4lffOCZCtYFiH6TNOX+tQKXx97T4IKHbhyHEQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.31",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@nodelib/fs.scandir": {
      "version": "2.1.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
      "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "2.0.5",
        "run-parallel": "^1.1.9"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.stat": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz",
      "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.walk": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz",
      "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.scandir": "2.1.5",
        "fastq": "^1.6.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@react-aria/focus": {
      "version": "3.21.4",
      "resolved": "https://registry.npmjs.org/@react-aria/focus/-/focus-3.21.4.tgz",
      "integrity": "sha512-6gz+j9ip0/vFRTKJMl3R30MHopn4i19HqqLfSQfElxJD+r9hBnYG1Q6Wd/kl/WRR1+CALn2F+rn06jUnf5sT8Q==",
      "license": "Apache-2.0",
      "dependencies": {
        "@react-aria/interactions": "^3.27.0",
        "@react-aria/utils": "^3.33.0",
        "@react-types/shared": "^3.33.0",
        "@swc/helpers": "^0.5.0",
        "clsx": "^2.0.0"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1",
        "react-dom": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@react-aria/interactions": {
      "version": "3.27.0",
      "resolved": "https://registry.npmjs.org/@react-aria/interactions/-/interactions-3.27.0.tgz",
      "integrity": "sha512-D27pOy+0jIfHK60BB26AgqjjRFOYdvVSkwC31b2LicIzRCSPOSP06V4gMHuGmkhNTF4+YWDi1HHYjxIvMeiSlA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@react-aria/ssr": "^3.9.10",
        "@react-aria/utils": "^3.33.0",
        "@react-stately/flags": "^3.1.2",
        "@react-types/shared": "^3.33.0",
        "@swc/helpers": "^0.5.0"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1",
        "react-dom": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@react-aria/ssr": {
      "version": "3.9.10",
      "resolved": "https://registry.npmjs.org/@react-aria/ssr/-/ssr-3.9.10.tgz",
      "integrity": "sha512-hvTm77Pf+pMBhuBm760Li0BVIO38jv1IBws1xFm1NoL26PU+fe+FMW5+VZWyANR6nYL65joaJKZqOdTQMkO9IQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@swc/helpers": "^0.5.0"
      },
      "engines": {
        "node": ">= 12"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@react-aria/utils": {
      "version": "3.33.0",
      "resolved": "https://registry.npmjs.org/@react-aria/utils/-/utils-3.33.0.tgz",
      "integrity": "sha512-yvz7CMH8d2VjwbSa5nGXqjU031tYhD8ddax95VzJsHSPyqHDEGfxul8RkhGV6oO7bVqZxVs6xY66NIgae+FHjw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@react-aria/ssr": "^3.9.10",
        "@react-stately/flags": "^3.1.2",
        "@react-stately/utils": "^3.11.0",
        "@react-types/shared": "^3.33.0",
        "@swc/helpers": "^0.5.0",
        "clsx": "^2.0.0"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1",
        "react-dom": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@react-stately/flags": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@react-stately/flags/-/flags-3.1.2.tgz",
      "integrity": "sha512-2HjFcZx1MyQXoPqcBGALwWWmgFVUk2TuKVIQxCbRq7fPyWXIl6VHcakCLurdtYC2Iks7zizvz0Idv48MQ38DWg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@swc/helpers": "^0.5.0"
      }
    },
    "node_modules/@react-stately/utils": {
      "version": "3.11.0",
      "resolved": "https://registry.npmjs.org/@react-stately/utils/-/utils-3.11.0.tgz",
      "integrity": "sha512-8LZpYowJ9eZmmYLpudbo/eclIRnbhWIJZ994ncmlKlouNzKohtM8qTC6B1w1pwUbiwGdUoyzLuQbeaIor5Dvcw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@swc/helpers": "^0.5.0"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@react-types/shared": {
      "version": "3.33.0",
      "resolved": "https://registry.npmjs.org/@react-types/shared/-/shared-3.33.0.tgz",
      "integrity": "sha512-xuUpP6MyuPmJtzNOqF5pzFUIHH2YogyOQfUQHag54PRmWB7AbjuGWBUv0l1UDmz6+AbzAYGmDVAzcRDOu2PFpw==",
      "license": "Apache-2.0",
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@rolldown/pluginutils": {
      "version": "1.0.0-rc.3",
      "resolved": "https://registry.npmjs.org/@rolldown/pluginutils/-/pluginutils-1.0.0-rc.3.tgz",
      "integrity": "sha512-eybk3TjzzzV97Dlj5c+XrBFW57eTNhzod66y9HrBlzJ6NsCrWCp/2kaPS3K9wJmurBC0Tdw4yPjXKZqlznim3Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.58.0.tgz",
      "integrity": "sha512-mr0tmS/4FoVk1cnaeN244A/wjvGDNItZKR8hRhnmCzygyRXYtKF5jVDSIILR1U97CTzAYmbgIj/Dukg62ggG5w==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.58.0.tgz",
      "integrity": "sha512-+s++dbp+/RTte62mQD9wLSbiMTV+xr/PeRJEc/sFZFSBRlHPNPVaf5FXlzAL77Mr8FtSfQqCN+I598M8U41ccQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.58.0.tgz",
      "integrity": "sha512-MFWBwTcYs0jZbINQBXHfSrpSQJq3IUOakcKPzfeSznONop14Pxuqa0Kg19GD0rNBMPQI2tFtu3UzapZpH0Uc1Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.58.0.tgz",
      "integrity": "sha512-yiKJY7pj9c9JwzuKYLFaDZw5gma3fI9bkPEIyofvVfsPqjCWPglSHdpdwXpKGvDeYDms3Qal8qGMEHZ1M/4Udg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.58.0.tgz",
      "integrity": "sha512-x97kCoBh5MOevpn/CNK9W1x8BEzO238541BGWBc315uOlN0AD/ifZ1msg+ZQB05Ux+VF6EcYqpiagfLJ8U3LvQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.58.0.tgz",
      "integrity": "sha512-Aa8jPoZ6IQAG2eIrcXPpjRcMjROMFxCt1UYPZZtCxRV68WkuSigYtQ/7Zwrcr2IvtNJo7T2JfDXyMLxq5L4Jlg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.58.0.tgz",
      "integrity": "sha512-Ob8YgT5kD/lSIYW2Rcngs5kNB/44Q2RzBSPz9brf2WEtcGR7/f/E9HeHn1wYaAwKBni+bdXEwgHvUd0x12lQSA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.58.0.tgz",
      "integrity": "sha512-K+RI5oP1ceqoadvNt1FecL17Qtw/n9BgRSzxif3rTL2QlIu88ccvY+Y9nnHe/cmT5zbH9+bpiJuG1mGHRVwF4Q==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.58.0.tgz",
      "integrity": "sha512-T+17JAsCKUjmbopcKepJjHWHXSjeW7O5PL7lEFaeQmiVyw4kkc5/lyYKzrv6ElWRX/MrEWfPiJWqbTvfIvjM1Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.58.0.tgz",
      "integrity": "sha512-cCePktb9+6R9itIJdeCFF9txPU7pQeEHB5AbHu/MKsfH/k70ZtOeq1k4YAtBv9Z7mmKI5/wOLYjQ+B9QdxR6LA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-gnu/-/rollup-linux-loong64-gnu-4.58.0.tgz",
      "integrity": "sha512-iekUaLkfliAsDl4/xSdoCJ1gnnIXvoNz85C8U8+ZxknM5pBStfZjeXgB8lXobDQvvPRCN8FPmmuTtH+z95HTmg==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-musl": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-musl/-/rollup-linux-loong64-musl-4.58.0.tgz",
      "integrity": "sha512-68ofRgJNl/jYJbxFjCKE7IwhbfxOl1muPN4KbIqAIe32lm22KmU7E8OPvyy68HTNkI2iV/c8y2kSPSm2mW/Q9Q==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.58.0.tgz",
      "integrity": "sha512-dpz8vT0i+JqUKuSNPCP5SYyIV2Lh0sNL1+FhM7eLC457d5B9/BC3kDPp5BBftMmTNsBarcPcoz5UGSsnCiw4XQ==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-musl": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-musl/-/rollup-linux-ppc64-musl-4.58.0.tgz",
      "integrity": "sha512-4gdkkf9UJ7tafnweBCR/mk4jf3Jfl0cKX9Np80t5i78kjIH0ZdezUv/JDI2VtruE5lunfACqftJ8dIMGN4oHew==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.58.0.tgz",
      "integrity": "sha512-YFS4vPnOkDTD/JriUeeZurFYoJhPf9GQQEF/v4lltp3mVcBmnsAdjEWhr2cjUCZzZNzxCG0HZOvJU44UGHSdzw==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.58.0.tgz",
      "integrity": "sha512-x2xgZlFne+QVNKV8b4wwaCS8pwq3y14zedZ5DqLzjdRITvreBk//4Knbcvm7+lWmms9V9qFp60MtUd0/t/PXPw==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.58.0.tgz",
      "integrity": "sha512-jIhrujyn4UnWF8S+DHSkAkDEO3hLX0cjzxJZPLF80xFyzyUIYgSMRcYQ3+uqEoyDD2beGq7Dj7edi8OnJcS/hg==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.58.0.tgz",
      "integrity": "sha512-+410Srdoh78MKSJxTQ+hZ/Mx+ajd6RjjPwBPNd0R3J9FtL6ZA0GqiiyNjCO9In0IzZkCNrpGymSfn+kgyPQocg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.58.0.tgz",
      "integrity": "sha512-ZjMyby5SICi227y1MTR3VYBpFTdZs823Rs/hpakufleBoufoOIB6jtm9FEoxn/cgO7l6PM2rCEl5Kre5vX0QrQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-openbsd-x64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openbsd-x64/-/rollup-openbsd-x64-4.58.0.tgz",
      "integrity": "sha512-ds4iwfYkSQ0k1nb8LTcyXw//ToHOnNTJtceySpL3fa7tc/AsE+UpUFphW126A6fKBGJD5dhRvg8zw1rvoGFxmw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ]
    },
    "node_modules/@rollup/rollup-openharmony-arm64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openharmony-arm64/-/rollup-openharmony-arm64-4.58.0.tgz",
      "integrity": "sha512-fd/zpJniln4ICdPkjWFhZYeY/bpnaN9pGa6ko+5WD38I0tTqk9lXMgXZg09MNdhpARngmxiCg0B0XUamNw/5BQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.58.0.tgz",
      "integrity": "sha512-YpG8dUOip7DCz3nr/JUfPbIUo+2d/dy++5bFzgi4ugOGBIox+qMbbqt/JoORwvI/C9Kn2tz6+Bieoqd5+B1CjA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.58.0.tgz",
      "integrity": "sha512-b9DI8jpFQVh4hIXFr0/+N/TzLdpBIoPzjt0Rt4xJbW3mzguV3mduR9cNgiuFcuL/TeORejJhCWiAXe3E/6PxWA==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-gnu/-/rollup-win32-x64-gnu-4.58.0.tgz",
      "integrity": "sha512-CSrVpmoRJFN06LL9xhkitkwUcTZtIotYAF5p6XOR2zW0Zz5mzb3IPpcoPhB02frzMHFNo1reQ9xSF5fFm3hUsQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.58.0.tgz",
      "integrity": "sha512-QFsBgQNTnh5K0t/sBsjJLq24YVqEIVkGpfN2VHsnN90soZyhaiA9UUHufcctVNL4ypJY0wrwad0wslx2KJQ1/w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@standard-schema/utils": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/@standard-schema/utils/-/utils-0.3.0.tgz",
      "integrity": "sha512-e7Mew686owMaPJVNNLs55PUvgz371nKgwsc4vxE49zsODpJEnxgxRo2y/OKrqueavXgZNMDVj3DdHFlaSAeU8g==",
      "license": "MIT"
    },
    "node_modules/@swc/helpers": {
      "version": "0.5.18",
      "resolved": "https://registry.npmjs.org/@swc/helpers/-/helpers-0.5.18.tgz",
      "integrity": "sha512-TXTnIcNJQEKwThMMqBXsZ4VGAza6bvN4pa41Rkqoio6QBKMvo+5lexeTMScGCIxtzgQJzElcvIltani+adC5PQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.8.0"
      }
    },
    "node_modules/@tanstack/query-core": {
      "version": "5.90.20",
      "resolved": "https://registry.npmjs.org/@tanstack/query-core/-/query-core-5.90.20.tgz",
      "integrity": "sha512-OMD2HLpNouXEfZJWcKeVKUgQ5n+n3A2JFmBaScpNDUqSrQSjiveC7dKMe53uJUg1nDG16ttFPz2xfilz6i2uVg==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/tannerlinsley"
      }
    },
    "node_modules/@tanstack/react-query": {
      "version": "5.90.21",
      "resolved": "https://registry.npmjs.org/@tanstack/react-query/-/react-query-5.90.21.tgz",
      "integrity": "sha512-0Lu6y5t+tvlTJMTO7oh5NSpJfpg/5D41LlThfepTixPYkJ0sE2Jj0m0f6yYqujBwIXlId87e234+MxG3D3g7kg==",
      "license": "MIT",
      "dependencies": {
        "@tanstack/query-core": "5.90.20"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/tannerlinsley"
      },
      "peerDependencies": {
        "react": "^18 || ^19"
      }
    },
    "node_modules/@tanstack/react-virtual": {
      "version": "3.13.18",
      "resolved": "https://registry.npmjs.org/@tanstack/react-virtual/-/react-virtual-3.13.18.tgz",
      "integrity": "sha512-dZkhyfahpvlaV0rIKnvQiVoWPyURppl6w4m9IwMDpuIjcJ1sD9YGWrt0wISvgU7ewACXx2Ct46WPgI6qAD4v6A==",
      "license": "MIT",
      "dependencies": {
        "@tanstack/virtual-core": "3.13.18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/tannerlinsley"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0",
        "react-dom": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/@tanstack/virtual-core": {
      "version": "3.13.18",
      "resolved": "https://registry.npmjs.org/@tanstack/virtual-core/-/virtual-core-3.13.18.tgz",
      "integrity": "sha512-Mx86Hqu1k39icq2Zusq+Ey2J6dDWTjDvEv43PJtRCoEYTLyfaPnxIQ6iy7YAOK0NV/qOEmZQ/uCufrppZxTgcg==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/tannerlinsley"
      }
    },
    "node_modules/@types/babel__core": {
      "version": "7.20.5",
      "resolved": "https://registry.npmjs.org/@types/babel__core/-/babel__core-7.20.5.tgz",
      "integrity": "sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.20.7",
        "@babel/types": "^7.20.7",
        "@types/babel__generator": "*",
        "@types/babel__template": "*",
        "@types/babel__traverse": "*"
      }
    },
    "node_modules/@types/babel__generator": {
      "version": "7.27.0",
      "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.27.0.tgz",
      "integrity": "sha512-ufFd2Xi92OAVPYsy+P4n7/U7e68fex0+Ee8gSG9KX7eo084CWiQ4sdxktvdl0bOPupXtVJPY19zk6EwWqUQ8lg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__template": {
      "version": "7.4.4",
      "resolved": "https://registry.npmjs.org/@types/babel__template/-/babel__template-7.4.4.tgz",
      "integrity": "sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__traverse": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.28.0.tgz",
      "integrity": "sha512-8PvcXf70gTDZBgt9ptxJ8elBeBjcLOAcOtoO/mPJjtji1+CdGbHgm77om1GrsPxsiE+uXIpNSK64UYaIwQXd4Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.28.2"
      }
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz",
      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/json-schema": {
      "version": "7.0.15",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz",
      "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/react": {
      "version": "19.2.14",
      "resolved": "https://registry.npmjs.org/@types/react/-/react-19.2.14.tgz",
      "integrity": "sha512-ilcTH/UniCkMdtexkoCN0bI7pMcJDvmQFPvuPvmEaYA/NSfFTAgdUSLAoVjaRJm7+6PvcM+q1zYOwS4wTYMF9w==",
      "devOptional": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "csstype": "^3.2.2"
      }
    },
    "node_modules/@types/react-dom": {
      "version": "19.2.3",
      "resolved": "https://registry.npmjs.org/@types/react-dom/-/react-dom-19.2.3.tgz",
      "integrity": "sha512-jp2L/eY6fn+KgVVQAOqYItbF0VY/YApe5Mz2F0aykSO8gx31bYCZyvSeYxCHKvzHG5eZjc+zyaS5BrBWya2+kQ==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "^19.2.0"
      }
    },
    "node_modules/@uidotdev/usehooks": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/@uidotdev/usehooks/-/usehooks-2.4.1.tgz",
      "integrity": "sha512-1I+RwWyS+kdv3Mv0Vmc+p0dPYH0DTRAo04HLyXReYBL9AeseDWUJyi4THuksBJcu9F0Pih69Ak150VDnqbVnXg==",
      "license": "MIT",
      "engines": {
        "node": ">=16"
      },
      "peerDependencies": {
        "react": ">=18.0.0",
        "react-dom": ">=18.0.0"
      }
    },
    "node_modules/@vitejs/plugin-react": {
      "version": "5.1.4",
      "resolved": "https://registry.npmjs.org/@vitejs/plugin-react/-/plugin-react-5.1.4.tgz",
      "integrity": "sha512-VIcFLdRi/VYRU8OL/puL7QXMYafHmqOnwTZY50U1JPlCNj30PxCMx65c494b1K9be9hX83KVt0+gTEwTWLqToA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.29.0",
        "@babel/plugin-transform-react-jsx-self": "^7.27.1",
        "@babel/plugin-transform-react-jsx-source": "^7.27.1",
        "@rolldown/pluginutils": "1.0.0-rc.3",
        "@types/babel__core": "^7.20.5",
        "react-refresh": "^0.18.0"
      },
      "engines": {
        "node": "^20.19.0 || >=22.12.0"
      },
      "peerDependencies": {
        "vite": "^4.2.0 || ^5.0.0 || ^6.0.0 || ^7.0.0"
      }
    },
    "node_modules/acorn": {
      "version": "8.16.0",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.16.0.tgz",
      "integrity": "sha512-UVJyE9MttOsBQIDKw1skb9nAwQuR5wuGD3+82K6JgJlm/Y+KI92oNsMNGZCYdDsVtRHSak0pcV5Dno5+4jh9sw==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-jsx": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz",
      "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/ajv": {
      "version": "6.12.6",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/epoberezkin"
      }
    },
    "node_modules/ansi-colors": {
      "version": "4.1.3",
      "resolved": "https://registry.npmjs.org/ansi-colors/-/ansi-colors-4.1.3.tgz",
      "integrity": "sha512-/6w/C21Pm1A7aZitlI5Ni/2J6FFQN8i1Cvz3kHABAAbw93v/NlvKdVOqz7CCWz/3iv/JplRSEEZ83XION15ovw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/any-promise": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/any-promise/-/any-promise-1.3.0.tgz",
      "integrity": "sha512-7UvmKalWRt1wgjL1RrGxoSJW/0QZFIegpeGvZG9kjp8vrRu55XTHbwnqq2GpXm9uLbcuhxm3IqX9OB4MZR1b2A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/anymatch": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/arg": {
      "version": "5.0.2",
      "resolved": "https://registry.npmjs.org/arg/-/arg-5.0.2.tgz",
      "integrity": "sha512-PYjyFOLKQ9y57JvQ6QLo8dAgNqswh8M1RMJYdQduT6xbWSgK36P/Z/v+p888pM69jMMfS8Xd8F6I1kQ/I9HUGg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "dev": true,
      "license": "Python-2.0"
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==",
      "license": "MIT"
    },
    "node_modules/autoprefixer": {
      "version": "10.4.24",
      "resolved": "https://registry.npmjs.org/autoprefixer/-/autoprefixer-10.4.24.tgz",
      "integrity": "sha512-uHZg7N9ULTVbutaIsDRoUkoS8/h3bdsmVJYZ5l3wv8Cp/6UIIoRDm90hZ+BwxUj/hGBEzLxdHNSKuFpn8WOyZw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/autoprefixer"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "browserslist": "^4.28.1",
        "caniuse-lite": "^1.0.30001766",
        "fraction.js": "^5.3.4",
        "picocolors": "^1.1.1",
        "postcss-value-parser": "^4.2.0"
      },
      "bin": {
        "autoprefixer": "bin/autoprefixer"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      },
      "peerDependencies": {
        "postcss": "^8.1.0"
      }
    },
    "node_modules/axios": {
      "version": "1.13.5",
      "resolved": "https://registry.npmjs.org/axios/-/axios-1.13.5.tgz",
      "integrity": "sha512-cz4ur7Vb0xS4/KUN0tPWe44eqxrIu31me+fbang3ijiNscE129POzipJJA6zniq2C/Z6sJCjMimjS8Lc/GAs8Q==",
      "license": "MIT",
      "dependencies": {
        "follow-redirects": "^1.15.11",
        "form-data": "^4.0.5",
        "proxy-from-env": "^1.1.0"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/baseline-browser-mapping": {
      "version": "2.10.0",
      "resolved": "https://registry.npmjs.org/baseline-browser-mapping/-/baseline-browser-mapping-2.10.0.tgz",
      "integrity": "sha512-lIyg0szRfYbiy67j9KN8IyeD7q7hcmqnJ1ddWmNt19ItGpNN64mnllmxUNFIOdOm6by97jlL6wfpTTJrmnjWAA==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "baseline-browser-mapping": "dist/cli.cjs"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/binary-extensions": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.3.0.tgz",
      "integrity": "sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/boolbase": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/boolbase/-/boolbase-1.0.0.tgz",
      "integrity": "sha512-JZOSA7Mo9sNGB8+UjSgzdLtokWAky1zbztM3WRLCbZ70/3cTANmQmOdR7y2g+J0e2WXywy1yS468tY+IruqEww==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/browserslist": {
      "version": "4.28.1",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.28.1.tgz",
      "integrity": "sha512-ZC5Bd0LgJXgwGqUknZY/vkUQ04r8NXnJZ3yYi4vDmSiZmC/pdSN0NbNRPxZpbtO4uAfDUAFffO8IZoM3Gj8IkA==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "baseline-browser-mapping": "^2.9.0",
        "caniuse-lite": "^1.0.30001759",
        "electron-to-chromium": "^1.5.263",
        "node-releases": "^2.0.27",
        "update-browserslist-db": "^1.2.0"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/camelcase-css": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/camelcase-css/-/camelcase-css-2.0.1.tgz",
      "integrity": "sha512-QOSvevhslijgYwRx6Rv7zKdMF8lbRmx+uQGx2+vDc+KI/eBnsy9kit5aj23AgGu3pa4t9AgwbnXWqS+iOY+2aA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001770",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001770.tgz",
      "integrity": "sha512-x/2CLQ1jHENRbHg5PSId2sXq1CIO1CISvwWAj027ltMVG2UNgW+w9oH2+HzgEIRFembL8bUlXtfbBHR1fCg2xw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/chalk": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/chokidar": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.6.0.tgz",
      "integrity": "sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "anymatch": "~3.1.2",
        "braces": "~3.0.2",
        "glob-parent": "~5.1.2",
        "is-binary-path": "~2.1.0",
        "is-glob": "~4.0.1",
        "normalize-path": "~3.0.0",
        "readdirp": "~3.6.0"
      },
      "engines": {
        "node": ">= 8.10.0"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/chokidar/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/clsx": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/clsx/-/clsx-2.1.1.tgz",
      "integrity": "sha512-eYm0QWBtUrBWZWG0d386OGAw16Z995PiOVo2B7bjWSbHedGl5e0ZWaq65kOGgUSNesEIDkB9ISbTg/JK9dhCZA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "license": "MIT",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/commander": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/commander/-/commander-4.1.1.tgz",
      "integrity": "sha512-NOKm8xhkzAjzFx8B2v5OAHT+u5pRQc2UCa2Vq9jYL/31o2wi9mxBA7LIFs3sV5VSC49z6pEhfbMULvShKj26WA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/convert-source-map": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz",
      "integrity": "sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cookie": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-1.1.1.tgz",
      "integrity": "sha512-ei8Aos7ja0weRpFzJnEA9UHJ/7XQmqglbRwnf2ATjcB9Wq874VKH9kfjjirM6UhU2/E5fFYadylyhFldcqSidQ==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/css-select": {
      "version": "5.2.2",
      "resolved": "https://registry.npmjs.org/css-select/-/css-select-5.2.2.tgz",
      "integrity": "sha512-TizTzUddG/xYLA3NXodFM0fSbNizXjOKhqiQQwvhlspadZokn1KDy0NZFS0wuEubIYAV5/c1/lAr0TaaFXEXzw==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "boolbase": "^1.0.0",
        "css-what": "^6.1.0",
        "domhandler": "^5.0.2",
        "domutils": "^3.0.1",
        "nth-check": "^2.0.1"
      },
      "funding": {
        "url": "https://github.com/sponsors/fb55"
      }
    },
    "node_modules/css-selector-tokenizer": {
      "version": "0.8.0",
      "resolved": "https://registry.npmjs.org/css-selector-tokenizer/-/css-selector-tokenizer-0.8.0.tgz",
      "integrity": "sha512-Jd6Ig3/pe62/qe5SBPTN8h8LeUg/pT4lLgtavPf7updwwHpvFzxvOQBHYj2LZDMjUnBzgvIUSjRcf6oT5HzHFg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cssesc": "^3.0.0",
        "fastparse": "^1.1.2"
      }
    },
    "node_modules/css-tree": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/css-tree/-/css-tree-3.1.0.tgz",
      "integrity": "sha512-0eW44TGN5SQXU1mWSkKwFstI/22X2bG1nYzZTYMAWjylYURhse752YgbE4Cx46AC+bAvI+/dYTPRk1LqSUnu6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "mdn-data": "2.12.2",
        "source-map-js": "^1.0.1"
      },
      "engines": {
        "node": "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0"
      }
    },
    "node_modules/css-what": {
      "version": "6.2.2",
      "resolved": "https://registry.npmjs.org/css-what/-/css-what-6.2.2.tgz",
      "integrity": "sha512-u/O3vwbptzhMs3L1fQE82ZSLHQQfto5gyZzwteVIEyeaY5Fc7R4dapF/BvRoSYFeqfBk4m0V1Vafq5Pjv25wvA==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">= 6"
      },
      "funding": {
        "url": "https://github.com/sponsors/fb55"
      }
    },
    "node_modules/cssesc": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/cssesc/-/cssesc-3.0.0.tgz",
      "integrity": "sha512-/Tb/JcjK111nNScGob5MNtsntNM1aCNUDipB/TkwZFhyDrrE47SOx/18wF2bbjgc3ZzCSKW1T5nt5EbFoAz/Vg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "cssesc": "bin/cssesc"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/csso": {
      "version": "5.0.5",
      "resolved": "https://registry.npmjs.org/csso/-/csso-5.0.5.tgz",
      "integrity": "sha512-0LrrStPOdJj+SPCCrGhzryycLjwcgUSHBtxNA8aIDxf0GLsRh1cKYhB00Gd1lDOS4yGH69+SNn13+TWbVHETFQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "css-tree": "~2.2.0"
      },
      "engines": {
        "node": "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0",
        "npm": ">=7.0.0"
      }
    },
    "node_modules/csso/node_modules/css-tree": {
      "version": "2.2.1",
      "resolved": "https://registry.npmjs.org/css-tree/-/css-tree-2.2.1.tgz",
      "integrity": "sha512-OA0mILzGc1kCOCSJerOeqDxDQ4HOh+G8NbOJFOTgOCzpw7fCBubk0fEyxp8AgOL/jvLgYA/uV0cMbe43ElF1JA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "mdn-data": "2.0.28",
        "source-map-js": "^1.0.1"
      },
      "engines": {
        "node": "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0",
        "npm": ">=7.0.0"
      }
    },
    "node_modules/csso/node_modules/mdn-data": {
      "version": "2.0.28",
      "resolved": "https://registry.npmjs.org/mdn-data/-/mdn-data-2.0.28.tgz",
      "integrity": "sha512-aylIc7Z9y4yzHYAJNuESG3hfhC+0Ibp/MAMiaOZgNv4pmEdFyfZhhhny4MNiAfWdBQ1RQ2mfDWmM1x8SvGyp8g==",
      "dev": true,
      "license": "CC0-1.0"
    },
    "node_modules/csstype": {
      "version": "3.2.3",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.2.3.tgz",
      "integrity": "sha512-z1HGKcYy2xA8AGQfwrn0PAy+PB7X/GSj3UVJW9qKyn43xWa+gl5nXmU4qqLMRzWVLFC8KusUX8T/0kCiOYpAIQ==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/culori": {
      "version": "3.3.0",
      "resolved": "https://registry.npmjs.org/culori/-/culori-3.3.0.tgz",
      "integrity": "sha512-pHJg+jbuFsCjz9iclQBqyL3B2HLCBF71BwVNujUYEvCeQMvV97R59MNK3R2+jgJ3a1fcZgI9B3vYgz8lzr/BFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
      }
    },
    "node_modules/daisyui": {
      "version": "4.12.24",
      "resolved": "https://registry.npmjs.org/daisyui/-/daisyui-4.12.24.tgz",
      "integrity": "sha512-JYg9fhQHOfXyLadrBrEqCDM6D5dWCSSiM6eTNCRrBRzx/VlOCrLS8eDfIw9RVvs64v2mJdLooKXY8EwQzoszAA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "css-selector-tokenizer": "^0.8",
        "culori": "^3",
        "picocolors": "^1",
        "postcss-js": "^4"
      },
      "engines": {
        "node": ">=16.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/daisyui"
      }
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/deep-is": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz",
      "integrity": "sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/detect-libc": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/detect-libc/-/detect-libc-2.1.2.tgz",
      "integrity": "sha512-Btj2BOOO83o3WyH59e8MgXsxEQVcarkUOpEYrubB0urwnN10yQ364rsiByU11nZlqWYZm05i/of7io4mzihBtQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/didyoumean": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/didyoumean/-/didyoumean-1.2.2.tgz",
      "integrity": "sha512-gxtyfqMg7GKyhQmb056K7M3xszy/myH8w+B4RT+QXBQsvAOdc3XymqDDPHx1BgPgsdAA5SIifona89YtRATDzw==",
      "dev": true,
      "license": "Apache-2.0"
    },
    "node_modules/dlv": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/dlv/-/dlv-1.1.3.tgz",
      "integrity": "sha512-+HlytyjlPKnIG8XuRG8WvmBP8xs8P71y+SKKS6ZXWoEgLuePxtDoUEiH7WkdePWrQ5JBpE6aoVqfZfJUQkjXwA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/dom-serializer": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/dom-serializer/-/dom-serializer-2.0.0.tgz",
      "integrity": "sha512-wIkAryiqt/nV5EQKqQpo3SToSOV9J0DnbJqwK7Wv/Trc92zIAYZ4FlMu+JPFW1DfGFt81ZTCGgDEabffXeLyJg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "domelementtype": "^2.3.0",
        "domhandler": "^5.0.2",
        "entities": "^4.2.0"
      },
      "funding": {
        "url": "https://github.com/cheeriojs/dom-serializer?sponsor=1"
      }
    },
    "node_modules/domelementtype": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/domelementtype/-/domelementtype-2.3.0.tgz",
      "integrity": "sha512-OLETBj6w0OsagBwdXnPdN0cnMfF9opN69co+7ZrbfPGrdpPVNBUj02spi6B1N7wChLQiPn4CSH/zJvXw56gmHw==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/fb55"
        }
      ],
      "license": "BSD-2-Clause"
    },
    "node_modules/domhandler": {
      "version": "5.0.3",
      "resolved": "https://registry.npmjs.org/domhandler/-/domhandler-5.0.3.tgz",
      "integrity": "sha512-cgwlv/1iFQiFnU96XXgROh8xTeetsnJiDsTc7TYCLFd9+/WNkIqPTxiM/8pSd8VIrhXGTf1Ny1q1hquVqDJB5w==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "domelementtype": "^2.3.0"
      },
      "engines": {
        "node": ">= 4"
      },
      "funding": {
        "url": "https://github.com/fb55/domhandler?sponsor=1"
      }
    },
    "node_modules/domutils": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/domutils/-/domutils-3.2.2.tgz",
      "integrity": "sha512-6kZKyUajlDuqlHKVX1w7gyslj9MPIXzIFiz/rGu35uC1wMi+kMhQwGhl4lt9unC9Vb9INnY9Z3/ZA3+FhASLaw==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "dom-serializer": "^2.0.0",
        "domelementtype": "^2.3.0",
        "domhandler": "^5.0.3"
      },
      "funding": {
        "url": "https://github.com/fb55/domutils?sponsor=1"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/electron-to-chromium": {
      "version": "1.5.302",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.302.tgz",
      "integrity": "sha512-sM6HAN2LyK82IyPBpznDRqlTQAtuSaO+ShzFiWTvoMJLHyZ+Y39r8VMfHzwbU8MVBzQ4Wdn85+wlZl2TLGIlwg==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/entities": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/entities/-/entities-4.5.0.tgz",
      "integrity": "sha512-V0hjH4dGPh9Ao5p0MoRY6BVqtwCjhz6vI5LT8AJ55H+4g9/4vbHx1I54fS0XuclLhDHArPQCiMjDxjaL8fPxhw==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.12"
      },
      "funding": {
        "url": "https://github.com/fb55/entities?sponsor=1"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/esbuild": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.27.3.tgz",
      "integrity": "sha512-8VwMnyGCONIs6cWue2IdpHxHnAjzxnw2Zr7MkVxB2vjmQ2ivqGFb4LEG3SMnv0Gb2F/G/2yA8zUaiL1gywDCCg==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=18"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.27.3",
        "@esbuild/android-arm": "0.27.3",
        "@esbuild/android-arm64": "0.27.3",
        "@esbuild/android-x64": "0.27.3",
        "@esbuild/darwin-arm64": "0.27.3",
        "@esbuild/darwin-x64": "0.27.3",
        "@esbuild/freebsd-arm64": "0.27.3",
        "@esbuild/freebsd-x64": "0.27.3",
        "@esbuild/linux-arm": "0.27.3",
        "@esbuild/linux-arm64": "0.27.3",
        "@esbuild/linux-ia32": "0.27.3",
        "@esbuild/linux-loong64": "0.27.3",
        "@esbuild/linux-mips64el": "0.27.3",
        "@esbuild/linux-ppc64": "0.27.3",
        "@esbuild/linux-riscv64": "0.27.3",
        "@esbuild/linux-s390x": "0.27.3",
        "@esbuild/linux-x64": "0.27.3",
        "@esbuild/netbsd-arm64": "0.27.3",
        "@esbuild/netbsd-x64": "0.27.3",
        "@esbuild/openbsd-arm64": "0.27.3",
        "@esbuild/openbsd-x64": "0.27.3",
        "@esbuild/openharmony-arm64": "0.27.3",
        "@esbuild/sunos-x64": "0.27.3",
        "@esbuild/win32-arm64": "0.27.3",
        "@esbuild/win32-ia32": "0.27.3",
        "@esbuild/win32-x64": "0.27.3"
      }
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/escape-string-regexp": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint": {
      "version": "9.39.3",
      "resolved": "https://registry.npmjs.org/eslint/-/eslint-9.39.3.tgz",
      "integrity": "sha512-VmQ+sifHUbI/IcSopBCF/HO3YiHQx/AVd3UVyYL6weuwW+HvON9VYn5l6Zl1WZzPWXPNZrSQpxwkkZ/VuvJZzg==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.8.0",
        "@eslint-community/regexpp": "^4.12.1",
        "@eslint/config-array": "^0.21.1",
        "@eslint/config-helpers": "^0.4.2",
        "@eslint/core": "^0.17.0",
        "@eslint/eslintrc": "^3.3.1",
        "@eslint/js": "9.39.3",
        "@eslint/plugin-kit": "^0.4.1",
        "@humanfs/node": "^0.16.6",
        "@humanwhocodes/module-importer": "^1.0.1",
        "@humanwhocodes/retry": "^0.4.2",
        "@types/estree": "^1.0.6",
        "ajv": "^6.12.4",
        "chalk": "^4.0.0",
        "cross-spawn": "^7.0.6",
        "debug": "^4.3.2",
        "escape-string-regexp": "^4.0.0",
        "eslint-scope": "^8.4.0",
        "eslint-visitor-keys": "^4.2.1",
        "espree": "^10.4.0",
        "esquery": "^1.5.0",
        "esutils": "^2.0.2",
        "fast-deep-equal": "^3.1.3",
        "file-entry-cache": "^8.0.0",
        "find-up": "^5.0.0",
        "glob-parent": "^6.0.2",
        "ignore": "^5.2.0",
        "imurmurhash": "^0.1.4",
        "is-glob": "^4.0.0",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        "lodash.merge": "^4.6.2",
        "minimatch": "^3.1.2",
        "natural-compare": "^1.4.0",
        "optionator": "^0.9.3"
      },
      "bin": {
        "eslint": "bin/eslint.js"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      },
      "peerDependencies": {
        "jiti": "*"
      },
      "peerDependenciesMeta": {
        "jiti": {
          "optional": true
        }
      }
    },
    "node_modules/eslint-plugin-react-hooks": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/eslint-plugin-react-hooks/-/eslint-plugin-react-hooks-7.0.1.tgz",
      "integrity": "sha512-O0d0m04evaNzEPoSW+59Mezf8Qt0InfgGIBJnpC0h3NH/WjUAR7BIKUfysC6todmtiZ/A0oUVS8Gce0WhBrHsA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.24.4",
        "@babel/parser": "^7.24.4",
        "hermes-parser": "^0.25.1",
        "zod": "^3.25.0 || ^4.0.0",
        "zod-validation-error": "^3.5.0 || ^4.0.0"
      },
      "engines": {
        "node": ">=18"
      },
      "peerDependencies": {
        "eslint": "^3.0.0 || ^4.0.0 || ^5.0.0 || ^6.0.0 || ^7.0.0 || ^8.0.0-0 || ^9.0.0"
      }
    },
    "node_modules/eslint-plugin-react-refresh": {
      "version": "0.4.26",
      "resolved": "https://registry.npmjs.org/eslint-plugin-react-refresh/-/eslint-plugin-react-refresh-0.4.26.tgz",
      "integrity": "sha512-1RETEylht2O6FM/MvgnyvT+8K21wLqDNg4qD51Zj3guhjt433XbnnkVttHMyaVyAFD03QSV4LPS5iE3VQmO7XQ==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "eslint": ">=8.40"
      }
    },
    "node_modules/eslint-scope": {
      "version": "8.4.0",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-8.4.0.tgz",
      "integrity": "sha512-sNXOfKCn74rt8RICKMvJS7XKV/Xk9kA7DyJr8mJik3S7Cwgy3qlkkmyS2uQB3jiJg6VNdZd/pDBJu0nvG2NlTg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "esrecurse": "^4.3.0",
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint-visitor-keys": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-4.2.1.tgz",
      "integrity": "sha512-Uhdk5sfqcee/9H/rCOJikYz67o0a2Tw2hGRPOG2Y1R2dg7brRe1uG0yaNQDHu+TO/uQPF/5eCapvYSmHUjt7JQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/espree": {
      "version": "10.4.0",
      "resolved": "https://registry.npmjs.org/espree/-/espree-10.4.0.tgz",
      "integrity": "sha512-j6PAQ2uUr79PZhBjP5C5fhl8e39FmRnOjsD5lGnWrFU8i2G776tBK7+nP8KuQUTTyAZUwfQqXAgrVH5MbH9CYQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "acorn": "^8.15.0",
        "acorn-jsx": "^5.3.2",
        "eslint-visitor-keys": "^4.2.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/esquery": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.7.0.tgz",
      "integrity": "sha512-Ap6G0WQwcU/LHsvLwON1fAQX9Zp0A2Y6Y/cJBl9r/JbW90Zyg4/zbG6zzKa2OTALELarYHmKu0GhpM5EO+7T0g==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "estraverse": "^5.1.0"
      },
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/esrecurse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estraverse": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-glob": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.3.3.tgz",
      "integrity": "sha512-7MptL8U0cqcFdzIzwOTHoilX9x5BrNqye7Z/LuC7kCMRio1EMSyqRK3BEAUD7sXRq4iT4AzTVuZdhgQ2TCvYLg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "^2.0.2",
        "@nodelib/fs.walk": "^1.2.3",
        "glob-parent": "^5.1.2",
        "merge2": "^1.3.0",
        "micromatch": "^4.0.8"
      },
      "engines": {
        "node": ">=8.6.0"
      }
    },
    "node_modules/fast-glob/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fastparse": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/fastparse/-/fastparse-1.1.2.tgz",
      "integrity": "sha512-483XLLxTVIwWK3QTrMGRqUfUpoOs/0hbQrl2oz4J0pAcm3A3bu84wxTFqGqkJzewCLdME38xJLJAxBABfQT8sQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fastq": {
      "version": "1.20.1",
      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.20.1.tgz",
      "integrity": "sha512-GGToxJ/w1x32s/D2EKND7kTil4n8OVk/9mycTc4VDza13lOvpUZTGX3mFSCtV9ksdGBVzvsyAVLM6mHFThxXxw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "reusify": "^1.0.4"
      }
    },
    "node_modules/file-entry-cache": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-8.0.0.tgz",
      "integrity": "sha512-XXTUwCvisa5oacNGRP9SfNtYBNAMi+RPwBFmblZEF7N7swHYQS6/Zfk7SRwx4D5j3CH211YNRco1DEMNVfZCnQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flat-cache": "^4.0.0"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/find-up": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
      "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "locate-path": "^6.0.0",
        "path-exists": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/flat-cache": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-4.0.1.tgz",
      "integrity": "sha512-f7ccFPK3SXFHpx15UIGyRJ/FJQctuKZ0zVuN3frBo4HnK3cay9VEW0R6yPYFHC0AgqhukPzKjq22t5DmAyqGyw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flatted": "^3.2.9",
        "keyv": "^4.5.4"
      },
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/flatted": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.3.3.tgz",
      "integrity": "sha512-GX+ysw4PBCz0PzosHDepZGANEuFCMLrnRTiEy9McGjmkCQYwRq4A/X786G/fjM/+OjsWSU1ZrY5qyARZmO/uwg==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/follow-redirects": {
      "version": "1.15.11",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.11.tgz",
      "integrity": "sha512-deG2P0JfjrTxl50XGCDyfI97ZGVCxIpfKYmfyrQ54n5FO/0gfIES8C/Psl6kWVDolizcaaxZJnTS0QSMxvnsBQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/RubenVerborgh"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=4.0"
      },
      "peerDependenciesMeta": {
        "debug": {
          "optional": true
        }
      }
    },
    "node_modules/form-data": {
      "version": "4.0.5",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.5.tgz",
      "integrity": "sha512-8RipRLol37bNs2bhoV67fiTEvdTrbMUYcFTiy3+wuuOnUog2QBHCZWXDRijWQfAkhBj2Uf5UnVaiWwA5vdd82w==",
      "license": "MIT",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "es-set-tostringtag": "^2.1.0",
        "hasown": "^2.0.2",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fraction.js": {
      "version": "5.3.4",
      "resolved": "https://registry.npmjs.org/fraction.js/-/fraction.js-5.3.4.tgz",
      "integrity": "sha512-1X1NTtiJphryn/uLQz3whtY6jK3fTqoE3ohKs0tT+Ujr1W59oopxmoEh7Lu5p6vBaPbgoM0bzveAW4Qi5RyWDQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "*"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/rawify"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gensync": {
      "version": "1.0.0-beta.2",
      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
      "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/glob-parent": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
      "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.3"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/globals": {
      "version": "16.5.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-16.5.0.tgz",
      "integrity": "sha512-c/c15i26VrJ4IRt5Z89DnIzCGDn9EcebibhAOjw5ibqEHsE1wLUgkPn9RDmNcUKyU87GeaL633nyJ+pplFR2ZQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/hermes-estree": {
      "version": "0.25.1",
      "resolved": "https://registry.npmjs.org/hermes-estree/-/hermes-estree-0.25.1.tgz",
      "integrity": "sha512-0wUoCcLp+5Ev5pDW2OriHC2MJCbwLwuRx+gAqMTOkGKJJiBCLjtrvy4PWUGn6MIVefecRpzoOZ/UV6iGdOr+Cw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/hermes-parser": {
      "version": "0.25.1",
      "resolved": "https://registry.npmjs.org/hermes-parser/-/hermes-parser-0.25.1.tgz",
      "integrity": "sha512-6pEjquH3rqaI6cYAXYPcz9MS4rY6R4ngRgrgfDshRptUZIc3lw0MCIJIGDj9++mfySOuPTHB4nrSW99BCvOPIA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hermes-estree": "0.25.1"
      }
    },
    "node_modules/ignore": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
      "integrity": "sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/import-fresh": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.1.tgz",
      "integrity": "sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/imurmurhash": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
      "integrity": "sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.8.19"
      }
    },
    "node_modules/is-binary-path": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "binary-extensions": "^2.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-core-module": {
      "version": "2.16.1",
      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz",
      "integrity": "sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/jiti": {
      "version": "1.21.7",
      "resolved": "https://registry.npmjs.org/jiti/-/jiti-1.21.7.tgz",
      "integrity": "sha512-/imKNG4EbWNrVjoNC/1H5/9GFy+tqjGBHCaSsN+P2RnPqjsLmv6UD3Ej+Kj8nBWaRAwyk7kK5ZUc+OEatnTR3A==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "bin": {
        "jiti": "bin/jiti.js"
      }
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/js-yaml": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
      "integrity": "sha512-qQKT4zQxXl8lLwBtHMWwaTcGfFOZviOJet3Oy/xmGk2gZH677CJM9EvtfdSkgWcATZhj/55JZ0rmy3myCT5lsA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/jsesc": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-3.1.0.tgz",
      "integrity": "sha512-/sM3dO2FOzXjKQhJuo0Q173wf2KOo8t4I8vHy6lF9poUp7bKT0/NHE8fPX23PwfhnykfqnC2xRxOnVw5XuGIaA==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "jsesc": "bin/jsesc"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/json-buffer": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/json-buffer/-/json-buffer-3.0.1.tgz",
      "integrity": "sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-stable-stringify-without-jsonify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
      "integrity": "sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json5": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
      "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "json5": "lib/cli.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/keyv": {
      "version": "4.5.4",
      "resolved": "https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz",
      "integrity": "sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "json-buffer": "3.0.1"
      }
    },
    "node_modules/levn": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1",
        "type-check": "~0.4.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/lilconfig": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/lilconfig/-/lilconfig-3.1.3.tgz",
      "integrity": "sha512-/vlFKAoH5Cgt3Ie+JLhRbwOsCQePABiU3tJ1egGvyQ+33R/vcwM2Zl2QR/LzjsBeItPt3oSVXapn+m4nQDvpzw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/antonk52"
      }
    },
    "node_modules/lines-and-columns": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz",
      "integrity": "sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/locate-path": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
      "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-locate": "^5.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lodash.merge": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/lru-cache": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
      "integrity": "sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "yallist": "^3.0.2"
      }
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/mdn-data": {
      "version": "2.12.2",
      "resolved": "https://registry.npmjs.org/mdn-data/-/mdn-data-2.12.2.tgz",
      "integrity": "sha512-IEn+pegP1aManZuckezWCO+XZQDplx1366JoVhTpMpBB1sPey/SbveZQUosKiKiGYjg1wH4pMlNgXbCiYgihQA==",
      "dev": true,
      "license": "CC0-1.0"
    },
    "node_modules/merge2": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/micromatch": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz",
      "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "braces": "^3.0.3",
        "picomatch": "^2.3.1"
      },
      "engines": {
        "node": ">=8.6"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/mz": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/mz/-/mz-2.7.0.tgz",
      "integrity": "sha512-z81GNO7nnYMEhrGh9LeymoE4+Yr0Wn5McHIZMK5cfQCl+NDX08sCZgUc9/6MHni9IWuFLm1Z3HTCXu2z9fN62Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "any-promise": "^1.0.0",
        "object-assign": "^4.0.1",
        "thenify-all": "^1.0.0"
      }
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/natural-compare": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
      "integrity": "sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/node-releases": {
      "version": "2.0.27",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.27.tgz",
      "integrity": "sha512-nmh3lCkYZ3grZvqcCH+fjmQ7X+H0OeZgP40OierEaAptX4XofMh5kwNbWh7lBduUzCcV/8kZ+NDLCwm2iorIlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/nth-check": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/nth-check/-/nth-check-2.1.1.tgz",
      "integrity": "sha512-lqjrjmaOoAnWfMmBPL+XNnynZh2+swxiX3WUE0s4yEHI6m+AwrK2UZOimIRl3X/4QctVqS8AiZjFqyOGrMXb/w==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "boolbase": "^1.0.0"
      },
      "funding": {
        "url": "https://github.com/fb55/nth-check?sponsor=1"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-hash": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/object-hash/-/object-hash-3.0.0.tgz",
      "integrity": "sha512-RSn9F68PjH9HqtltsSnqYC1XXoWe9Bju5+213R98cNGttag9q9yAOTzdbsqvIa7aNm5WffBZFpWYr2aWrklWAw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/optionator": {
      "version": "0.9.4",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.4.tgz",
      "integrity": "sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "deep-is": "^0.1.3",
        "fast-levenshtein": "^2.0.6",
        "levn": "^0.4.1",
        "prelude-ls": "^1.2.1",
        "type-check": "^0.4.0",
        "word-wrap": "^1.2.5"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/p-limit": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "yocto-queue": "^0.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-locate": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
      "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-limit": "^3.0.2"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "callsites": "^3.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/path-exists": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/pathe": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/pathe/-/pathe-2.0.3.tgz",
      "integrity": "sha512-WUjGcAqP1gQacoQe+OBJsFA7Ld4DyXuUIjZ5cc75cLHvJ7dtNsTugphxIADwspS+AraAUePCKrSVtPLFj/F88w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/pify": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/pify/-/pify-2.3.0.tgz",
      "integrity": "sha512-udgsAY+fTnvv7kI7aaxbqwWNb0AHiB0qBO89PZKPkoTmGOgdbrHDKD+0B2X4uTfJ/FT1R09r9gTsjUjNJotuog==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/pirates": {
      "version": "4.0.7",
      "resolved": "https://registry.npmjs.org/pirates/-/pirates-4.0.7.tgz",
      "integrity": "sha512-TfySrs/5nm8fQJDcBDuUng3VOUKsd7S+zqvbOTiGXHfxX4wK31ard+hoNuvkicM/2YFzlpDgABOevKSsB4G/FA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/postcss-import": {
      "version": "15.1.0",
      "resolved": "https://registry.npmjs.org/postcss-import/-/postcss-import-15.1.0.tgz",
      "integrity": "sha512-hpr+J05B2FVYUAXHeK1YyI267J/dDDhMU6B6civm8hSY1jYJnBXxzKDKDswzJmtLHryrjhnDjqqp/49t8FALew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "postcss-value-parser": "^4.0.0",
        "read-cache": "^1.0.0",
        "resolve": "^1.1.7"
      },
      "engines": {
        "node": ">=14.0.0"
      },
      "peerDependencies": {
        "postcss": "^8.0.0"
      }
    },
    "node_modules/postcss-js": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/postcss-js/-/postcss-js-4.1.0.tgz",
      "integrity": "sha512-oIAOTqgIo7q2EOwbhb8UalYePMvYoIeRY2YKntdpFQXNosSu3vLrniGgmH9OKs/qAkfoj5oB3le/7mINW1LCfw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "camelcase-css": "^2.0.1"
      },
      "engines": {
        "node": "^12 || ^14 || >= 16"
      },
      "peerDependencies": {
        "postcss": "^8.4.21"
      }
    },
    "node_modules/postcss-load-config": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/postcss-load-config/-/postcss-load-config-6.0.1.tgz",
      "integrity": "sha512-oPtTM4oerL+UXmx+93ytZVN82RrlY/wPUV8IeDxFrzIjXOLF1pN+EmKPLbubvKHT2HC20xXsCAH2Z+CKV6Oz/g==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "lilconfig": "^3.1.1"
      },
      "engines": {
        "node": ">= 18"
      },
      "peerDependencies": {
        "jiti": ">=1.21.0",
        "postcss": ">=8.0.9",
        "tsx": "^4.8.1",
        "yaml": "^2.4.2"
      },
      "peerDependenciesMeta": {
        "jiti": {
          "optional": true
        },
        "postcss": {
          "optional": true
        },
        "tsx": {
          "optional": true
        },
        "yaml": {
          "optional": true
        }
      }
    },
    "node_modules/postcss-nested": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/postcss-nested/-/postcss-nested-6.2.0.tgz",
      "integrity": "sha512-HQbt28KulC5AJzG+cZtj9kvKB93CFCdLvog1WFLf1D+xmMvPGlBstkpTEZfK5+AN9hfJocyBFCNiqyS48bpgzQ==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "postcss-selector-parser": "^6.1.1"
      },
      "engines": {
        "node": ">=12.0"
      },
      "peerDependencies": {
        "postcss": "^8.2.14"
      }
    },
    "node_modules/postcss-selector-parser": {
      "version": "6.1.2",
      "resolved": "https://registry.npmjs.org/postcss-selector-parser/-/postcss-selector-parser-6.1.2.tgz",
      "integrity": "sha512-Q8qQfPiZ+THO/3ZrOrO0cJJKfpYCagtMUkXbnEfmgUjwXg6z/WBeOyS9APBBPCTSiDV+s4SwQGu8yFsiMRIudg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cssesc": "^3.0.0",
        "util-deprecate": "^1.0.2"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/postcss-value-parser": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-4.2.0.tgz",
      "integrity": "sha512-1NNCs6uurfkVbeXG4S8JFT9t19m45ICnif8zWLd5oPSZ50QnwMfK+H3jv408d4jw/7Bttv5axS5IiHoLaVNHeQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/prelude-ls": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/proxy-from-env": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/proxy-from-env/-/proxy-from-env-1.1.0.tgz",
      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==",
      "license": "MIT"
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/queue-microtask": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
      "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/react": {
      "version": "19.2.4",
      "resolved": "https://registry.npmjs.org/react/-/react-19.2.4.tgz",
      "integrity": "sha512-9nfp2hYpCwOjAN+8TZFGhtWEwgvWHXqESH8qT89AT/lWklpLON22Lc8pEtnpsZz7VmawabSU0gCjnj8aC0euHQ==",
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-dom": {
      "version": "19.2.4",
      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-19.2.4.tgz",
      "integrity": "sha512-AXJdLo8kgMbimY95O2aKQqsz2iWi9jMgKJhRBAxECE4IFxfcazB2LmzloIoibJI3C12IlY20+KFaLv+71bUJeQ==",
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "scheduler": "^0.27.0"
      },
      "peerDependencies": {
        "react": "^19.2.4"
      }
    },
    "node_modules/react-hook-form": {
      "version": "7.71.1",
      "resolved": "https://registry.npmjs.org/react-hook-form/-/react-hook-form-7.71.1.tgz",
      "integrity": "sha512-9SUJKCGKo8HUSsCO+y0CtqkqI5nNuaDqTxyqPsZPqIwudpj4rCrAz/jZV+jn57bx5gtZKOh3neQu94DXMc+w5w==",
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/react-hook-form"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17 || ^18 || ^19"
      }
    },
    "node_modules/react-refresh": {
      "version": "0.18.0",
      "resolved": "https://registry.npmjs.org/react-refresh/-/react-refresh-0.18.0.tgz",
      "integrity": "sha512-QgT5//D3jfjJb6Gsjxv0Slpj23ip+HtOpnNgnb2S5zU3CB26G/IDPGoy4RJB42wzFE46DRsstbW6tKHoKbhAxw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-router": {
      "version": "7.13.0",
      "resolved": "https://registry.npmjs.org/react-router/-/react-router-7.13.0.tgz",
      "integrity": "sha512-PZgus8ETambRT17BUm/LL8lX3Of+oiLaPuVTRH3l1eLvSPpKO3AvhAEb5N7ihAFZQrYDqkvvWfFh9p0z9VsjLw==",
      "license": "MIT",
      "dependencies": {
        "cookie": "^1.0.1",
        "set-cookie-parser": "^2.6.0"
      },
      "engines": {
        "node": ">=20.0.0"
      },
      "peerDependencies": {
        "react": ">=18",
        "react-dom": ">=18"
      },
      "peerDependenciesMeta": {
        "react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/react-router-dom": {
      "version": "7.13.0",
      "resolved": "https://registry.npmjs.org/react-router-dom/-/react-router-dom-7.13.0.tgz",
      "integrity": "sha512-5CO/l5Yahi2SKC6rGZ+HDEjpjkGaG/ncEP7eWFTvFxbHP8yeeI0PxTDjimtpXYlR3b3i9/WIL4VJttPrESIf2g==",
      "license": "MIT",
      "dependencies": {
        "react-router": "7.13.0"
      },
      "engines": {
        "node": ">=20.0.0"
      },
      "peerDependencies": {
        "react": ">=18",
        "react-dom": ">=18"
      }
    },
    "node_modules/read-cache": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/read-cache/-/read-cache-1.0.0.tgz",
      "integrity": "sha512-Owdv/Ft7IjOgm/i0xvNDZ1LrRANRfew4b2prF3OWMQLxLfu3bS8FVhCsrSCMK4lR56Y9ya+AThoTpDCTxCmpRA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "pify": "^2.3.0"
      }
    },
    "node_modules/readdirp": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "picomatch": "^2.2.1"
      },
      "engines": {
        "node": ">=8.10.0"
      }
    },
    "node_modules/resolve": {
      "version": "1.22.11",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.11.tgz",
      "integrity": "sha512-RfqAvLnMl313r7c9oclB1HhUEAezcpLjz95wFH4LVuhk9JF/r22qmVP9AMmOU4vMX7Q8pN8jwNg/CSpdFnMjTQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.16.1",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/reusify": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.1.0.tgz",
      "integrity": "sha512-g6QUff04oZpHs0eG5p83rFLhHeV00ug/Yf9nZM6fLeUrPguBTkTQOdpAWWspMh55TZfVQDPaN3NQJfbVRAxdIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "iojs": ">=1.0.0",
        "node": ">=0.10.0"
      }
    },
    "node_modules/rollup": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.58.0.tgz",
      "integrity": "sha512-wbT0mBmWbIvvq8NeEYWWvevvxnOyhKChir47S66WCxw1SXqhw7ssIYejnQEVt7XYQpsj2y8F9PM+Cr3SNEa0gw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.58.0",
        "@rollup/rollup-android-arm64": "4.58.0",
        "@rollup/rollup-darwin-arm64": "4.58.0",
        "@rollup/rollup-darwin-x64": "4.58.0",
        "@rollup/rollup-freebsd-arm64": "4.58.0",
        "@rollup/rollup-freebsd-x64": "4.58.0",
        "@rollup/rollup-linux-arm-gnueabihf": "4.58.0",
        "@rollup/rollup-linux-arm-musleabihf": "4.58.0",
        "@rollup/rollup-linux-arm64-gnu": "4.58.0",
        "@rollup/rollup-linux-arm64-musl": "4.58.0",
        "@rollup/rollup-linux-loong64-gnu": "4.58.0",
        "@rollup/rollup-linux-loong64-musl": "4.58.0",
        "@rollup/rollup-linux-ppc64-gnu": "4.58.0",
        "@rollup/rollup-linux-ppc64-musl": "4.58.0",
        "@rollup/rollup-linux-riscv64-gnu": "4.58.0",
        "@rollup/rollup-linux-riscv64-musl": "4.58.0",
        "@rollup/rollup-linux-s390x-gnu": "4.58.0",
        "@rollup/rollup-linux-x64-gnu": "4.58.0",
        "@rollup/rollup-linux-x64-musl": "4.58.0",
        "@rollup/rollup-openbsd-x64": "4.58.0",
        "@rollup/rollup-openharmony-arm64": "4.58.0",
        "@rollup/rollup-win32-arm64-msvc": "4.58.0",
        "@rollup/rollup-win32-ia32-msvc": "4.58.0",
        "@rollup/rollup-win32-x64-gnu": "4.58.0",
        "@rollup/rollup-win32-x64-msvc": "4.58.0",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/run-parallel": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
      "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "queue-microtask": "^1.2.2"
      }
    },
    "node_modules/sax": {
      "version": "1.4.4",
      "resolved": "https://registry.npmjs.org/sax/-/sax-1.4.4.tgz",
      "integrity": "sha512-1n3r/tGXO6b6VXMdFT54SHzT9ytu9yr7TaELowdYpMqY/Ao7EnlQGmAQ1+RatX7Tkkdm6hONI2owqNx2aZj5Sw==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "engines": {
        "node": ">=11.0.0"
      }
    },
    "node_modules/scheduler": {
      "version": "0.27.0",
      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.27.0.tgz",
      "integrity": "sha512-eNv+WrVbKu1f3vbYJT/xtiF5syA5HPIMtf9IgY/nKg0sWqzAUEvqY/xm7OcZc/qafLx/iO9FgOmeSAp4v5ti/Q==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/set-cookie-parser": {
      "version": "2.7.2",
      "resolved": "https://registry.npmjs.org/set-cookie-parser/-/set-cookie-parser-2.7.2.tgz",
      "integrity": "sha512-oeM1lpU/UvhTxw+g3cIfxXHyJRc/uidd3yK1P242gzHds0udQBYzs3y8j4gCCW+ZJ7ad0yctld8RYO+bdurlvw==",
      "license": "MIT"
    },
    "node_modules/sharp": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/sharp/-/sharp-0.34.5.tgz",
      "integrity": "sha512-Ou9I5Ft9WNcCbXrU9cMgPBcCK8LiwLqcbywW3t4oDV37n1pzpuNLsYiAV8eODnjbtQlSDwZ2cUEeQz4E54Hltg==",
      "dev": true,
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "peer": true,
      "dependencies": {
        "@img/colour": "^1.0.0",
        "detect-libc": "^2.1.2",
        "semver": "^7.7.3"
      },
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-darwin-arm64": "0.34.5",
        "@img/sharp-darwin-x64": "0.34.5",
        "@img/sharp-libvips-darwin-arm64": "1.2.4",
        "@img/sharp-libvips-darwin-x64": "1.2.4",
        "@img/sharp-libvips-linux-arm": "1.2.4",
        "@img/sharp-libvips-linux-arm64": "1.2.4",
        "@img/sharp-libvips-linux-ppc64": "1.2.4",
        "@img/sharp-libvips-linux-riscv64": "1.2.4",
        "@img/sharp-libvips-linux-s390x": "1.2.4",
        "@img/sharp-libvips-linux-x64": "1.2.4",
        "@img/sharp-libvips-linuxmusl-arm64": "1.2.4",
        "@img/sharp-libvips-linuxmusl-x64": "1.2.4",
        "@img/sharp-linux-arm": "0.34.5",
        "@img/sharp-linux-arm64": "0.34.5",
        "@img/sharp-linux-ppc64": "0.34.5",
        "@img/sharp-linux-riscv64": "0.34.5",
        "@img/sharp-linux-s390x": "0.34.5",
        "@img/sharp-linux-x64": "0.34.5",
        "@img/sharp-linuxmusl-arm64": "0.34.5",
        "@img/sharp-linuxmusl-x64": "0.34.5",
        "@img/sharp-wasm32": "0.34.5",
        "@img/sharp-win32-arm64": "0.34.5",
        "@img/sharp-win32-ia32": "0.34.5",
        "@img/sharp-win32-x64": "0.34.5"
      }
    },
    "node_modules/sharp/node_modules/semver": {
      "version": "7.7.4",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.4.tgz",
      "integrity": "sha512-vFKC2IEtQnVhpT78h1Yp8wzwrf8CM+MzKMHGJZfBtzhZNycRFnXsHk6E5TxIkkMsgNS7mdX3AGB7x2QM2di4lA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/sonner": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/sonner/-/sonner-2.0.7.tgz",
      "integrity": "sha512-W6ZN4p58k8aDKA4XPcx2hpIQXBRAgyiWVkYhT7CvK6D3iAu7xjvVyhQHg2/iaKJZ1XVJ4r7XuwGL+WGEK37i9w==",
      "license": "MIT",
      "peerDependencies": {
        "react": "^18.0.0 || ^19.0.0 || ^19.0.0-rc",
        "react-dom": "^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/sucrase": {
      "version": "3.35.1",
      "resolved": "https://registry.npmjs.org/sucrase/-/sucrase-3.35.1.tgz",
      "integrity": "sha512-DhuTmvZWux4H1UOnWMB3sk0sbaCVOoQZjv8u1rDoTV0HTdGem9hkAZtl4JZy8P2z4Bg0nT+YMeOFyVr4zcG5Tw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.2",
        "commander": "^4.0.0",
        "lines-and-columns": "^1.1.6",
        "mz": "^2.7.0",
        "pirates": "^4.0.1",
        "tinyglobby": "^0.2.11",
        "ts-interface-checker": "^0.1.9"
      },
      "bin": {
        "sucrase": "bin/sucrase",
        "sucrase-node": "bin/sucrase-node"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      }
    },
    "node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/supports-preserve-symlinks-flag": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/svgo": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/svgo/-/svgo-4.0.0.tgz",
      "integrity": "sha512-VvrHQ+9uniE+Mvx3+C9IEe/lWasXCU0nXMY2kZeLrHNICuRiC8uMPyM14UEaMOFA5mhyQqEkB02VoQ16n3DLaw==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "commander": "^11.1.0",
        "css-select": "^5.1.0",
        "css-tree": "^3.0.1",
        "css-what": "^6.1.0",
        "csso": "^5.0.5",
        "picocolors": "^1.1.1",
        "sax": "^1.4.1"
      },
      "bin": {
        "svgo": "bin/svgo.js"
      },
      "engines": {
        "node": ">=16"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/svgo"
      }
    },
    "node_modules/svgo/node_modules/commander": {
      "version": "11.1.0",
      "resolved": "https://registry.npmjs.org/commander/-/commander-11.1.0.tgz",
      "integrity": "sha512-yPVavfyCcRhmorC7rWlkHn15b4wDVgVmBA7kV4QVBsF7kv/9TKJAbAXVTxvTnwP8HHKjRCJDClKbciiYS7p0DQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/tabbable": {
      "version": "6.4.0",
      "resolved": "https://registry.npmjs.org/tabbable/-/tabbable-6.4.0.tgz",
      "integrity": "sha512-05PUHKSNE8ou2dwIxTngl4EzcnsCDZGJ/iCLtDflR/SHB/ny14rXc+qU5P4mG9JkusiV7EivzY9Mhm55AzAvCg==",
      "license": "MIT"
    },
    "node_modules/tailwindcss": {
      "version": "3.4.19",
      "resolved": "https://registry.npmjs.org/tailwindcss/-/tailwindcss-3.4.19.tgz",
      "integrity": "sha512-3ofp+LL8E+pK/JuPLPggVAIaEuhvIz4qNcf3nA1Xn2o/7fb7s/TYpHhwGDv1ZU3PkBluUVaF8PyCHcm48cKLWQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@alloc/quick-lru": "^5.2.0",
        "arg": "^5.0.2",
        "chokidar": "^3.6.0",
        "didyoumean": "^1.2.2",
        "dlv": "^1.1.3",
        "fast-glob": "^3.3.2",
        "glob-parent": "^6.0.2",
        "is-glob": "^4.0.3",
        "jiti": "^1.21.7",
        "lilconfig": "^3.1.3",
        "micromatch": "^4.0.8",
        "normalize-path": "^3.0.0",
        "object-hash": "^3.0.0",
        "picocolors": "^1.1.1",
        "postcss": "^8.4.47",
        "postcss-import": "^15.1.0",
        "postcss-js": "^4.0.1",
        "postcss-load-config": "^4.0.2 || ^5.0 || ^6.0",
        "postcss-nested": "^6.2.0",
        "postcss-selector-parser": "^6.1.2",
        "resolve": "^1.22.8",
        "sucrase": "^3.35.0"
      },
      "bin": {
        "tailwind": "lib/cli.js",
        "tailwindcss": "lib/cli.js"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/thenify": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/thenify/-/thenify-3.3.1.tgz",
      "integrity": "sha512-RVZSIV5IG10Hk3enotrhvz0T9em6cyHBLkH/YAZuKqd8hRkKhSfCGIcP2KUY0EPxndzANBmNllzWPwak+bheSw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "any-promise": "^1.0.0"
      }
    },
    "node_modules/thenify-all": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/thenify-all/-/thenify-all-1.6.0.tgz",
      "integrity": "sha512-RNxQH/qI8/t3thXJDwcstUO4zeqo64+Uy/+sNVRBx4Xn2OX+OZ9oP+iJnNFqplFra2ZUVeKCSa2oVWi3T4uVmA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "thenify": ">= 3.1.0 < 4"
      },
      "engines": {
        "node": ">=0.8"
      }
    },
    "node_modules/tinyglobby": {
      "version": "0.2.15",
      "resolved": "https://registry.npmjs.org/tinyglobby/-/tinyglobby-0.2.15.tgz",
      "integrity": "sha512-j2Zq4NyQYG5XMST4cbs02Ak8iJUdxRM0XI5QyxXuZOzKOINmWurp3smXu3y5wDcJrptwpSjgXHzIQxR0omXljQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fdir": "^6.5.0",
        "picomatch": "^4.0.3"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/SuperchupuDev"
      }
    },
    "node_modules/tinyglobby/node_modules/fdir": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/tinyglobby/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/ts-interface-checker": {
      "version": "0.1.13",
      "resolved": "https://registry.npmjs.org/ts-interface-checker/-/ts-interface-checker-0.1.13.tgz",
      "integrity": "sha512-Y/arvbn+rrz3JCKl9C4kVNfTfSm2/mEp5FSz5EsZSANGPSlQrpRI5M4PKF+mJnE52jOO90PnPSc3Ur3bTQw0gA==",
      "dev": true,
      "license": "Apache-2.0"
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/type-check": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/update-browserslist-db": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.2.3.tgz",
      "integrity": "sha512-Js0m9cx+qOgDxo0eMiFGEueWztz+d4+M3rGlmKPT+T4IS/jP4ylw3Nwpu6cpTTP8R1MAC1kF4VbdLt3ARf209w==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "escalade": "^3.2.0",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "update-browserslist-db": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/uri-js": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "punycode": "^2.1.0"
      }
    },
    "node_modules/use-sync-external-store": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/use-sync-external-store/-/use-sync-external-store-1.6.0.tgz",
      "integrity": "sha512-Pp6GSwGP/NrPIrxVFAIkOQeyw8lFenOHijQWkUTrDvrF4ALqylP2C/KCkeS9dpUM3KvYRQhna5vt7IL95+ZQ9w==",
      "license": "MIT",
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/vite": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/vite/-/vite-7.3.1.tgz",
      "integrity": "sha512-w+N7Hifpc3gRjZ63vYBXA56dvvRlNWRczTdmCBBa+CotUzAPf5b7YMdMR/8CQoeYE5LX3W4wj6RYTgonm1b9DA==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "esbuild": "^0.27.0",
        "fdir": "^6.5.0",
        "picomatch": "^4.0.3",
        "postcss": "^8.5.6",
        "rollup": "^4.43.0",
        "tinyglobby": "^0.2.15"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^20.19.0 || >=22.12.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^20.19.0 || >=22.12.0",
        "jiti": ">=1.21.0",
        "less": "^4.0.0",
        "lightningcss": "^1.21.0",
        "sass": "^1.70.0",
        "sass-embedded": "^1.70.0",
        "stylus": ">=0.54.8",
        "sugarss": "^5.0.0",
        "terser": "^5.16.0",
        "tsx": "^4.8.1",
        "yaml": "^2.4.2"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "jiti": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        },
        "tsx": {
          "optional": true
        },
        "yaml": {
          "optional": true
        }
      }
    },
    "node_modules/vite-plugin-image-optimizer": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/vite-plugin-image-optimizer/-/vite-plugin-image-optimizer-2.0.3.tgz",
      "integrity": "sha512-1vrFOTcpSvv6DCY7h8UXab4wqMAjTJB/ndOzG/Kmj1oDOuPF6mbjkNQoGzzCEYeWGe7qU93jc8oQqvoJ57al3A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-colors": "^4.1.3",
        "pathe": "^2.0.3"
      },
      "engines": {
        "node": ">=18.17.0"
      },
      "peerDependencies": {
        "sharp": ">=0.34.0",
        "svgo": ">=4",
        "vite": ">=5"
      },
      "peerDependenciesMeta": {
        "sharp": {
          "optional": true
        },
        "svgo": {
          "optional": true
        }
      }
    },
    "node_modules/vite/node_modules/fdir": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/vite/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/word-wrap": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz",
      "integrity": "sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/yallist": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
      "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/yocto-queue": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/zod": {
      "version": "4.3.6",
      "resolved": "https://registry.npmjs.org/zod/-/zod-4.3.6.tgz",
      "integrity": "sha512-rftlrkhHZOcjDwkGlnUtZZkvaPHCsDATp4pGpuOOMDaTdDDXF91wuVDJoWoPsKX/3YPQ5fHuF3STjcYyKr+Qhg==",
      "license": "MIT",
      "peer": true,
      "funding": {
        "url": "https://github.com/sponsors/colinhacks"
      }
    },
    "node_modules/zod-validation-error": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/zod-validation-error/-/zod-validation-error-4.0.2.tgz",
      "integrity": "sha512-Q6/nZLe6jxuU80qb/4uJ4t5v2VEZ44lzQjPDhYJNztRQ4wyWc6VF3D3Kb/fAuPetZQnhS3hnajCf9CsWesghLQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18.0.0"
      },
      "peerDependencies": {
        "zod": "^3.25.0 || ^4.0.0"
      }
    },
    "node_modules/zustand": {
      "version": "5.0.11",
      "resolved": "https://registry.npmjs.org/zustand/-/zustand-5.0.11.tgz",
      "integrity": "sha512-fdZY+dk7zn/vbWNCYmzZULHRrss0jx5pPFiOuMZ/5HJN6Yv3u+1Wswy/4MpZEkEGhtNH+pwxZB8OKgUBPzYAGg==",
      "license": "MIT",
      "engines": {
        "node": ">=12.20.0"
      },
      "peerDependencies": {
        "@types/react": ">=18.0.0",
        "immer": ">=9.0.6",
        "react": ">=18.0.0",
        "use-sync-external-store": ">=1.2.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "immer": {
          "optional": true
        },
        "react": {
          "optional": true
        },
        "use-sync-external-store": {
          "optional": true
        }
      }
    }
  }
}


File: website/src/pages/MyOrders.jsx
================================================
import React from "react";
import { Link, useSearchParams } from "react-router-dom";
import { useQuery } from "@tanstack/react-query";
import { useAuth } from "../contexts/AuthContext"; // Import useAuth to get user
import { fetchUserOrders } from "../services/api"; // Import the API function
import { toast } from "sonner"; // Import toast for error messages

const MyOrders = () => {
  const { user } = useAuth(); // Get the authenticated user
  const [searchParams, setSearchParams] = useSearchParams(); // For pagination

  // Pagination constants
  const DEFAULT_PAGE = 1;
  const DEFAULT_LIMIT = 10; // Number of orders per page

  // Get current page from URL params, default to 1
  const currentPage = parseInt(searchParams.get("page")) || DEFAULT_PAGE;
  // Get current limit from URL params, default to 10
  const currentLimit = parseInt(searchParams.get("limit")) || DEFAULT_LIMIT;

  // Define the query key with pagination parameters
  const queryKey = ["user-orders", user?.id, currentPage, currentLimit];

  // Use TanStack Query to fetch orders
  const {
    data: ordersData,
    isLoading,
    isError,
    error,
    refetch,
  } = useQuery({
    queryKey,
    queryFn: () => fetchUserOrders(currentPage, currentLimit),
    enabled: !!user, // Only run query if user exists
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
    cacheTime: 10 * 60 * 1000, // Cache for 10 minutes
    onError: (err) => {
      console.error("Error fetching user orders:", err);
      toast.error("Failed to load orders. Please try again later.");
    },
  });

  // Extract data from the query result using the correct structure from your working version
  const orders = ordersData?.data || []; // Use ordersData.data as the array of orders
  const totalPages = ordersData?.total_pages || 1;
  const totalOrders = ordersData?.total || 0;

  // Helper function to truncate UUID
  const truncateUuid = (uuid) => {
    if (!uuid || typeof uuid !== "string") return "N/A";
    return `${uuid.substring(0, 8)}...`;
  };

  // Handler for changing pages
  const goToPage = (page) => {
    if (page >= 1 && page <= totalPages) {
      setSearchParams({
        page: page.toString(),
        limit: currentLimit.toString(),
      }); // Update URL params
    }
  };

  // Handler for changing page size
  const changePageSize = (newLimit) => {
    setSearchParams({ page: "1", limit: newLimit.toString() }); // Reset to page 1 when changing limit
  };

  // Generate page number buttons
  const renderPageNumbers = () => {
    const pageButtons = [];
    const maxVisiblePages = 5; // Maximum number of page buttons to show at once

    let startPage = Math.max(
      1,
      currentPage - Math.floor(maxVisiblePages / 2),
    );
    let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);

    // Adjust startPage if the range is too small
    if (endPage - startPage + 1 < maxVisiblePages) {
      startPage = Math.max(1, endPage - maxVisiblePages + 1);
    }

    for (let i = startPage; i <= endPage; i++) {
      pageButtons.push(
        <button
          key={i}
          onClick={() => goToPage(i)}
          className={`btn btn-sm mx-1 ${
            currentPage === i ? "btn-primary" : "btn-ghost"
          }`}
        >
          {i}
        </button>,
      );
    }

    return pageButtons;
  };

  // Format date helper function
  const formatDate = (dateString) => {
    if (!dateString) return "";
    const date = new Date(dateString);
    return date.toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
    });
  };

  // Format currency helper function
  const formatCurrency = (cents) => {
    if (!cents) return "DZD 0.00";
    return `DZD ${(cents / 100).toFixed(2)}`;
  };

  return (
    <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
      <h1 className="text-3xl font-bold mb-8">My Orders</h1>

      {/* Back Button */}
      <div className="mb-6">
        <Link to="/account" className="btn btn-sm btn-ghost">
          &larr; Back to Account
        </Link>
      </div>

      {/* Loading State */}
      {isLoading && (
        <div className="flex justify-center items-center min-h-[200px]">
          <span className="loading loading-spinner loading-lg"></span>
        </div>
      )}

      {/* Error State */}
      {isError && !isLoading && (
        <div className="alert alert-error">
          <p>
            {error.message || "Failed to load orders. Please try again later."}
          </p>
          <button
            onClick={() => refetch()}
            className="btn btn-sm"
          >
            Retry
          </button>
        </div>
      )}

      {/* Orders List */}
      {!isLoading && !isError && (
        <>
          {orders.length === 0
            ? (
              <div className="text-center py-12">
                <p className="text-lg">You have no orders yet.</p>
                <Link to="/" className="btn btn-primary mt-4">
                  Start Shopping
                </Link>
              </div>
            )
            : (
              <>
                {/* Pagination Controls Above Table */}
                {totalPages > 1 && (
                  <div className="flex flex-wrap items-center justify-between mb-4 gap-2">
                    <div className="flex items-center gap-2">
                      <span className="text-sm">Show:</span>
                      <select
                        value={currentLimit}
                        onChange={(e) => changePageSize(Number(e.target.value))}
                        className="select select-sm select-bordered"
                      >
                        <option value="5">5</option>
                        <option value="10">10</option>
                        <option value="20">20</option>
                        <option value="50">50</option>
                      </select>
                      <span className="text-sm ml-2">
                        Page {currentPage} of {totalPages} ({totalOrders}{" "}
                        total orders)
                      </span>
                    </div>
                    <div className="flex items-center">
                      <button
                        className="btn btn-sm btn-ghost"
                        onClick={() => goToPage(currentPage - 1)}
                        disabled={currentPage === 1}
                      >
                        Previous
                      </button>
                      <div className="flex items-center mx-2">
                        {renderPageNumbers()}
                      </div>
                      <button
                        className="btn btn-sm btn-ghost"
                        onClick={() => goToPage(currentPage + 1)}
                        disabled={currentPage === totalPages}
                      >
                        Next
                      </button>
                    </div>
                  </div>
                )}

                {/* Orders Table */}
                <div className="card bg-base-100 shadow-lg border border-secondary-content">
                  <div className="card-body p-0">
                    <div className="overflow-x-auto">
                      <table className="table">
                        <thead>
                          <tr>
                            <th className="font-bold">Order #</th>
                            <th className="font-bold">Date</th>
                            <th className="font-bold">Phone Number</th>
                            <th className="font-bold">Status</th>
                            <th className="font-bold">Total</th>
                            <th className="font-bold">Actions</th>
                          </tr>
                        </thead>
                        <tbody>
                          {orders.map((order) => (
                            <tr key={order.id}>
                              <td>{truncateUuid(order.id)}</td>
                              <td>{formatDate(order.created_at)}</td>
                              <td>
                                {order.phone_number_1 || order.phone_number_2 ||
                                  "N/A"}
                              </td>
                              <td>
                                <span
                                  className={`badge ${
                                    order.status.toLowerCase() ===
                                        "delivered" ||
                                      order.status.toLowerCase() === "completed"
                                      ? "badge-success"
                                      : order.status.toLowerCase() === "shipped"
                                      ? "badge-info"
                                      : order.status.toLowerCase() ===
                                          "processing"
                                      ? "badge-warning"
                                      : "badge-neutral" // Default for other statuses
                                  }`}
                                >
                                  {order.status.charAt(0).toUpperCase() +
                                    order.status.slice(1)}{" "}
                                  {/* Capitalize status */}
                                </span>
                              </td>
                              <td>
                                {formatCurrency(order.total_amount_cents)}
                              </td>
                              <td>
                                <Link
                                  to={`/account/order/${order.id}`} // Link to order details page
                                  className="btn btn-xs btn-outline"
                                >
                                  View Details
                                </Link>
                              </td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                  </div>
                </div>

                {/* Pagination Controls Below Table */}
                {totalPages > 1 && (
                  <div className="flex flex-wrap items-center justify-between mt-4 gap-2">
                    <div className="text-sm">
                      Showing {(currentPage - 1) * currentLimit + 1} to{" "}
                      {Math.min(currentPage * currentLimit, totalOrders)} of
                      {" "}
                      {totalOrders} orders
                    </div>
                    <div className="flex items-center">
                      <button
                        className="btn btn-sm btn-ghost"
                        onClick={() => goToPage(currentPage - 1)}
                        disabled={currentPage === 1}
                      >
                        Previous
                      </button>
                      <div className="flex items-center mx-2">
                        {renderPageNumbers()}
                      </div>
                      <button
                        className="btn btn-sm btn-ghost"
                        onClick={() => goToPage(currentPage + 1)}
                        disabled={currentPage === totalPages}
                      >
                        Next
                      </button>
                    </div>
                  </div>
                )}
              </>
            )}
        </>
      )}
    </div>
  );
};

export default MyOrders;


File: website/src/pages/AccountSettings.jsx
================================================
// src/pages/AccountSettings.jsx
import React from "react";
import { Link } from "react-router-dom"; // Import Link
import { useAuth } from "../contexts/AuthContext"; // Import useAuth
import { toast } from "sonner"; // Import toast for notifications
import { useForm } from "react-hook-form"; // Import react-hook-form for form handling
import { zodResolver } from "@hookform/resolvers/zod"; // Import zodResolver
import { z } from "zod"; // Import zod
import { useMutation } from "@tanstack/react-query"; // Import useMutation
import {
  changeUserPassword, // API function to change password - needs to be implemented
  updateUserProfile, // API function to update profile - needs to be implemented
} from "../services/api"; // Import the API functions

// Define Zod Schemas for validation
const profileSchema = z.object({
  name: z.string().min(1, { message: "Name is required" }),
  email: z.string().email({ message: "Invalid email address" }),
});

const passwordSchema = z.object({
  oldPassword: z.string().min(1, { message: "Current password is required" }),
  newPassword: z
    .string()
    .min(8, { message: "New password must be at least 8 characters long" }),
  // Add more complex password requirements if needed
  // .regex(/[A-Z]/, { message: "Must contain an uppercase letter" })
  // .regex(/[a-z]/, { message: "Must contain a lowercase letter" })
  // .regex(/[0-9]/, { message: "Must contain a number" })
  // .regex(/[^A-Za-z0-9]/, { message: "Must contain a special character" }),
  confirmPassword: z.string().min(1, {
    message: "Please confirm your new password",
  }),
}).refine((data) => data.newPassword === data.confirmPassword, {
  message: "Passwords do not match",
  path: ["confirmPassword"], // Path of error
});

const AccountSettings = () => {
  const { user, setUser } = useAuth(); // Get user from context and potentially setUser to update context after mutation
  // Note: Depending on your AuthContext implementation,
  // you might update the user context after a successful profile update
  // or rely on localStorage being updated by the API call/response.

  // --- PROFILE FORM SETUP ---
  const {
    register: registerProfile,
    handleSubmit: handleSubmitProfile,
    formState: { errors: profileErrors },
    reset: resetProfileForm, // To reset form after successful submission
    setValue, // Allows programmatic setting of field values
    watch, // Allows watching field values
    control: controlProfile, // Needed for Controller if using controlled inputs
  } = useForm({
    resolver: zodResolver(profileSchema), // Use zodResolver with the profile schema
    defaultValues: { // Set default values from the user object (from localStorage via AuthContext)
      name: user?.full_name || "",
      email: user?.email || "",
    },
  });

  // Watch for changes in the user object to update the form fields if necessary
  // (e.g., if another part of the app updates the user context)
  React.useEffect(() => {
    if (user) {
      // Only update if the current form values are the same as the initial ones
      // to avoid overriding user edits if the user object changes externally
      const currentValues = { name: watch("name"), email: watch("email") };
      const initialValues = {
        name: user.full_name || "",
        email: user.email || "",
      };
      if (
        JSON.stringify(currentValues) === JSON.stringify(initialValues)
      ) {
        setValue("name", user.full_name || "");
        setValue("email", user.email || "");
      }
    }
  }, [user, watch, setValue]);

  // --- PROFILE MUTATION ---
  const updateProfileMutation = useMutation({
    mutationFn: (variables) => { // variables type inferred implicitly
      // Prepare the payload (adjust field names if necessary)
      const payload = {
        full_name: variables.name,
        email: variables.email,
      };
      // Call the API function
      return updateUserProfile(payload); // Must be implemented in api.js
    },
    onSuccess: (data, variables) => {
      // Update the localStorage with the new profile data
      // Assumes the API returns the updated user object in 'data'
      // If the API returns minimal data, construct the object from variables:
      // const updatedUserData = { ...user, full_name: variables.name, email: variables.email };

      const updatedUserData = data ||
        { ...user, full_name: variables.name, email: variables.email };
      localStorage.setItem("userData", JSON.stringify(updatedUserData));

      // Optionally update the auth context if your context provider exposes a function to do so
      // For example, if your AuthContext has a function like setUser:
      // setUser(updatedUserData); // This depends on your AuthContext implementation

      toast.success("Profile updated successfully!");
      // Reset form to the submitted values
      resetProfileForm(variables);
    },
    onError: (error) => { // error type inferred implicitly
      console.error("Error updating profile:", error);
      // Try to get a user-friendly message from the backend response
      const errorMessage = error?.response?.data?.message || error.message ||
        "Failed to update profile. Please try again.";
      toast.error(errorMessage);
    },
  });
  // Handle Profile Form Submission
  const onSubmitProfile = (formData) => { // formData type inferred implicitly
    // Trigger the mutation
    updateProfileMutation.mutate(formData);
  };

  // --- PASSWORD FORM SETUP ---
  const {
    register: registerPassword,
    handleSubmit: handleSubmitPassword,
    formState: { errors: passwordErrors },
    reset: resetPasswordForm, // To reset form after successful submission
    watch: watchPassword, // To watch password fields for confirmation
    control: controlPassword, // Needed for Controller if using controlled inputs
  } = useForm({
    resolver: zodResolver(passwordSchema), // Use zodResolver with the password schema
  });

  // Watch the new password field for confirmation validation
  const newPassword = watchPassword("newPassword", ""); // Default to empty string

  // --- PASSWORD MUTATION ---
  const changePasswordMutation = useMutation({
    mutationFn: (variables) => { // variables type inferred implicitly
      // Prepare the payload (adjust field names if necessary)
      const payload = {
        old_password: variables.oldPassword, // Match backend field names
        new_password: variables.newPassword, // Match backend field names
      };
      // Call the API function
      return changeUserPassword(payload); // Must be implemented in api.js
    },
    onSuccess: (data) => {
      toast.success("Password changed successfully!");
      resetPasswordForm(); // Reset the password form after successful submission
      // Optionally, log the user out or handle token renewal here
      // depending on your backend's session management policy after password change.
    },
    onError: (error) => { // error type inferred implicitly
      console.error("Error changing password:", error);
      // Try to get a user-friendly message from the backend response
      const errorMessage = error?.response?.data?.message || error.message ||
        "Failed to change password. Please try again.";
      toast.error(errorMessage);
    },
  });

  // Handle Password Form Submission
  const onSubmitPassword = (formData) => { // formData type inferred implicitly
    // Trigger the mutation
    changePasswordMutation.mutate(formData);
  };

  if (!user) {
    // Optional: Handle case where user is not logged in
    return (
      <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
        <p>You are not logged in.</p>
        <Link to="/auth" className="btn btn-primary">Go to Login</Link>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
      <h1 className="text-3xl font-bold mb-8">Account Settings</h1>

      {/* Back Button */}
      <div className="mb-6">
        <Link to="/account" className="btn btn-sm btn-ghost">
          &larr; Back to Account
        </Link>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        {/* Profile Settings Card */}
        <div className="card bg-base-100 shadow-lg border border-secondary-content">
          <div className="card-body">
            <h2 className="card-title text-2xl mb-6">Profile Information</h2>
            <form onSubmit={handleSubmitProfile(onSubmitProfile)}>
              <div className="space-y-4">
                <div>
                  <label htmlFor="profile-name" className="label">
                    <span className="label-text">Full Name</span>
                  </label>
                  <input
                    id="profile-name"
                    type="text"
                    className={`input input-bordered w-full ${
                      profileErrors.name ? "input-error" : ""
                    }`}
                    {...registerProfile("name")}
                    disabled={updateProfileMutation.isPending} // Disable while submitting
                  />
                  {profileErrors.name && (
                    <p className="text-error text-sm mt-1">
                      {profileErrors.name.message}
                    </p>
                  )}
                </div>

                <div>
                  <label htmlFor="profile-email" className="label">
                    <span className="label-text">Email Address</span>
                  </label>
                  <input
                    id="profile-email"
                    type="email"
                    className={`input input-bordered w-full ${
                      profileErrors.email ? "input-error" : ""
                    }`}
                    {...registerProfile("email")}
                    disabled={updateProfileMutation.isPending} // Disable while submitting
                  />
                  {profileErrors.email && (
                    <p className="text-error text-sm mt-1">
                      {profileErrors.email.message}
                    </p>
                  )}
                </div>
              </div>

              <div className="card-actions justify-end mt-6">
                <button
                  type="submit"
                  className="btn btn-primary"
                  disabled={updateProfileMutation.isPending} // Use mutation's loading state
                >
                  {updateProfileMutation.isPending
                    ? (
                      <>
                        <span className="loading loading-spinner loading-xs mr-2">
                        </span>
                        Saving...
                      </>
                    )
                    : "Save Changes"}
                </button>
              </div>
            </form>
          </div>
        </div>

        {/* Password Change Card */}
        <div className="card bg-base-100 shadow-lg border border-secondary-content">
          <div className="card-body">
            <h2 className="card-title text-2xl mb-6">Change Password</h2>
            <form onSubmit={handleSubmitPassword(onSubmitPassword)}>
              <div className="space-y-4">
                <div>
                  <label htmlFor="password-old" className="label">
                    <span className="label-text">Current Password</span>
                  </label>
                  <input
                    id="password-old"
                    type="password"
                    className={`input input-bordered w-full ${
                      passwordErrors.oldPassword ? "input-error" : ""
                    }`}
                    {...registerPassword("oldPassword")}
                    disabled={changePasswordMutation.isPending} // Disable while submitting
                  />
                  {passwordErrors.oldPassword && (
                    <p className="text-error text-sm mt-1">
                      {passwordErrors.oldPassword.message}
                    </p>
                  )}
                </div>

                <div>
                  <label htmlFor="password-new" className="label">
                    <span className="label-text">New Password</span>
                  </label>
                  <input
                    id="password-new"
                    type="password"
                    className={`input input-bordered w-full ${
                      passwordErrors.newPassword ? "input-error" : ""
                    }`}
                    {...registerPassword("newPassword")}
                    disabled={changePasswordMutation.isPending} // Disable while submitting
                  />
                  {passwordErrors.newPassword && (
                    <p className="text-error text-sm mt-1">
                      {passwordErrors.newPassword.message}
                    </p>
                  )}
                </div>

                <div>
                  <label htmlFor="password-confirm" className="label">
                    <span className="label-text">Confirm New Password</span>
                  </label>
                  <input
                    id="password-confirm"
                    type="password"
                    className={`input input-bordered w-full ${
                      passwordErrors.confirmPassword ? "input-error" : ""
                    }`}
                    {...registerPassword("confirmPassword")}
                    disabled={changePasswordMutation.isPending} // Disable while submitting
                  />
                  {passwordErrors.confirmPassword && (
                    <p className="text-error text-sm mt-1">
                      {passwordErrors.confirmPassword.message}
                    </p>
                  )}
                </div>
              </div>

              <div className="card-actions justify-end mt-6">
                <button
                  type="submit"
                  className="btn btn-primary"
                  disabled={changePasswordMutation.isPending} // Use mutation's loading state
                >
                  {changePasswordMutation.isPending
                    ? (
                      <>
                        <span className="loading loading-spinner loading-xs mr-2">
                        </span>
                        Changing...
                      </>
                    )
                    : "Change Password"}
                </button>
              </div>
            </form>
          </div>
        </div>
      </div>
    </div>
  );
};

export default AccountSettings;


File: website/src/App.jsx
================================================
import React from "react";
import { BrowserRouter as Router, Route, Routes } from "react-router-dom";
import { CartProvider } from "./contexts/CartContext";
import { AuthProvider } from "./contexts/AuthContext";
import { Toaster } from "sonner";
import Navbar from "./components/NavBar";
import Footer from "./components/Footer";
import Home from "./pages/Home";
import Products from "./pages/Products";
import ProductDetail from "./pages/ProductDetail";
import BuildPC from "./pages/BuildPC";
import Cart from "./pages/Cart";
import Checkout from "./pages/Checkout";
import Account from "./pages/Account";
import AccountSettings from "./pages/AccountSettings";
import MyOrders from "./pages/MyOrders";
import OrderDetails from "./pages/OrderDetails";
import AuthPage from "./pages/Auth";

function App() {
  return (
    <AuthProvider>
      <CartProvider>
        <Router>
          <div className="min-h-screen flex flex-col">
            <Navbar />
            <main className="flex-grow">
              <Routes>
                <Route path="/" element={<Home />} />
                <Route path="/products" element={<Products />} />
                <Route path="/product/:id" element={<ProductDetail />} />
                <Route path="/build-pc" element={<BuildPC />} />
                <Route path="/cart" element={<Cart />} />
                <Route path="/checkout" element={<Checkout />} />{" "}
                <Route path="/account" element={<Account />} />{" "}
                <Route path="/account/settings" element={<AccountSettings />} />
                {" "}
                <Route path="/account/orders" element={<MyOrders />} />{" "}
                <Route
                  path="/account/order/:orderId"
                  element={<OrderDetails />}
                />{" "}
                <Route path="/auth" element={<AuthPage />} />
              </Routes>
            </main>
            <div className="border-t border-base-300 my-8"></div>
            <Footer />
          </div>
          <Toaster position="top-left" richColors />
        </Router>
      </CartProvider>
    </AuthProvider>
  );
}

export default App;


File: website/postcss.config.js
================================================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


File: db/database.go
================================================
package db

import (
	"context"
	"fmt"
	"log/slog"
	"os"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/joho/godotenv"
)

var (
	Conn *pgxpool.Pool // Use only the pool, not single connection
)

func Init() error {
	// Load .env file
	if err := godotenv.Load(); err != nil {
		slog.Info("No .env file found, using environment variables")
	}

	dbURL := os.Getenv("DATABASE_URL")
	if dbURL == "" {
		return fmt.Errorf("DATABASE_URL environment variable is required")
	}

	// Create a connection pool for concurrent operations
	pool, err := pgxpool.New(context.Background(), dbURL)
	if err != nil {
		return fmt.Errorf("failed to create connection pool: %w", err)
	}

	// Test the pool connection
	if err = pool.Ping(context.Background()); err != nil {
		pool.Close()
		return fmt.Errorf("failed to ping database: %w", err)
	}

	Conn = pool

	slog.Info("Connected to database successfully with native pgx pool")
	return nil
}

func Close() {
	if Conn != nil {
		Conn.Close()
	}
	slog.Info("Database connection pool closed")
}

// GetPool returns the database connection pool
func GetPool() *pgxpool.Pool {
	return Conn
}


File: dashboard/package-lock.json
================================================
{
  "name": "yc-admin-dashboard",
  "version": "0.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "yc-admin-dashboard",
      "version": "0.0.0",
      "dependencies": {
        "@headlessui/react": "^2.2.9",
        "@heroicons/react": "^2.2.0",
        "@hookform/resolvers": "^5.2.2",
        "@tanstack/react-query": "^5.90.21",
        "axios": "^1.13.5",
        "react": "^19.2.0",
        "react-dom": "^19.2.0",
        "react-hook-form": "^7.71.1",
        "react-router-dom": "^7.13.0",
        "sonner": "^2.0.7",
        "use-debounce": "^10.1.0",
        "zod": "^4.3.6",
        "zustand": "^5.0.11"
      },
      "devDependencies": {
        "@eslint/js": "^9.39.1",
        "@types/react": "^19.2.7",
        "@types/react-dom": "^19.2.3",
        "@vitejs/plugin-react": "^5.1.1",
        "autoprefixer": "^10.4.24",
        "daisyui": "^4",
        "eslint": "^9.39.1",
        "eslint-plugin-react-hooks": "^7.0.1",
        "eslint-plugin-react-refresh": "^0.4.24",
        "globals": "^16.5.0",
        "postcss": "^8.5.6",
        "tailwindcss": "^3.4.19",
        "vite": "^7.3.1"
      }
    },
    "node_modules/@alloc/quick-lru": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@alloc/quick-lru/-/quick-lru-5.2.0.tgz",
      "integrity": "sha512-UrcABB+4bUrFABwbluTIBErXwvbsU/V7TZWfmbgJfbkwiBuziS9gxdODUyuiecfdGQ85jglMW6juS3+z5TsKLw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@babel/code-frame": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.29.0.tgz",
      "integrity": "sha512-9NhCeYjq9+3uxgdtp20LSiJXJvN0FeCtNGpJxuMFZ1Kv3cWUNb6DOhJwUvcVCzKGR66cw4njwM6hrJLqgOwbcw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.28.5",
        "js-tokens": "^4.0.0",
        "picocolors": "^1.1.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/compat-data": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.29.0.tgz",
      "integrity": "sha512-T1NCJqT/j9+cn8fvkt7jtwbLBfLC/1y1c7NtCeXFRgzGTsafi68MRv8yzkYSapBnFA6L3U2VSc02ciDzoAJhJg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/core": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.29.0.tgz",
      "integrity": "sha512-CGOfOJqWjg2qW/Mb6zNsDm+u5vFQ8DxXfbM09z69p5Z6+mE1ikP2jUXw+j42Pf1XTYED2Rni5f95npYeuwMDQA==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "@babel/code-frame": "^7.29.0",
        "@babel/generator": "^7.29.0",
        "@babel/helper-compilation-targets": "^7.28.6",
        "@babel/helper-module-transforms": "^7.28.6",
        "@babel/helpers": "^7.28.6",
        "@babel/parser": "^7.29.0",
        "@babel/template": "^7.28.6",
        "@babel/traverse": "^7.29.0",
        "@babel/types": "^7.29.0",
        "@jridgewell/remapping": "^2.3.5",
        "convert-source-map": "^2.0.0",
        "debug": "^4.1.0",
        "gensync": "^1.0.0-beta.2",
        "json5": "^2.2.3",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/babel"
      }
    },
    "node_modules/@babel/generator": {
      "version": "7.29.1",
      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.29.1.tgz",
      "integrity": "sha512-qsaF+9Qcm2Qv8SRIMMscAvG4O3lJ0F1GuMo5HR/Bp02LopNgnZBC/EkbevHFeGs4ls/oPz9v+Bsmzbkbe+0dUw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.29.0",
        "@babel/types": "^7.29.0",
        "@jridgewell/gen-mapping": "^0.3.12",
        "@jridgewell/trace-mapping": "^0.3.28",
        "jsesc": "^3.0.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-compilation-targets": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.28.6.tgz",
      "integrity": "sha512-JYtls3hqi15fcx5GaSNL7SCTJ2MNmjrkHXg4FSpOA/grxK8KwyZ5bubHsCq8FXCkua6xhuaaBit+3b7+VZRfcA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.28.6",
        "@babel/helper-validator-option": "^7.27.1",
        "browserslist": "^4.24.0",
        "lru-cache": "^5.1.1",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-globals": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-globals/-/helper-globals-7.28.0.tgz",
      "integrity": "sha512-+W6cISkXFa1jXsDEdYA8HeevQT/FULhxzR99pxphltZcVaugps53THCeiWA8SguxxpSp3gKPiuYfSWopkLQ4hw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-imports": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.28.6.tgz",
      "integrity": "sha512-l5XkZK7r7wa9LucGw9LwZyyCUscb4x37JWTPz7swwFE/0FMQAGpiWUZn8u9DzkSBWEcK25jmvubfpw2dnAMdbw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.28.6",
        "@babel/types": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-transforms": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.28.6.tgz",
      "integrity": "sha512-67oXFAYr2cDLDVGLXTEABjdBJZ6drElUSI7WKp70NrpyISso3plG9SAGEF6y7zbha/wOzUByWWTJvEDVNIUGcA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.28.6",
        "@babel/helper-validator-identifier": "^7.28.5",
        "@babel/traverse": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-plugin-utils": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.28.6.tgz",
      "integrity": "sha512-S9gzZ/bz83GRysI7gAD4wPT/AI3uCnY+9xn+Mx/KPs2JwHJIz1W8PZkg2cqyt3RNOBM8ejcXhV6y8Og7ly/Dug==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-option": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.27.1.tgz",
      "integrity": "sha512-YvjJow9FxbhFFKDSuFnVCe2WxXk1zWc22fFePVNEaWJEu8IrZVlda6N0uHwzZrUM1il7NC9Mlp4MaJYbYd9JSg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helpers": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.28.6.tgz",
      "integrity": "sha512-xOBvwq86HHdB7WUDTfKfT/Vuxh7gElQ+Sfti2Cy6yIWNW05P8iUslOVcZ4/sKbE+/jQaukQAdz/gf3724kYdqw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.28.6",
        "@babel/types": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.29.0"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-self": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-self/-/plugin-transform-react-jsx-self-7.27.1.tgz",
      "integrity": "sha512-6UzkCs+ejGdZ5mFFC/OCUrv028ab2fp1znZmCZjAOBKiBK2jXD1O+BPSfX8X2qjJ75fZBMSnQn3Rq2mrBJK2mw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-source": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-source/-/plugin-transform-react-jsx-source-7.27.1.tgz",
      "integrity": "sha512-zbwoTsBruTeKB9hSq73ha66iFeJHuaFkUbwvqElnygoNbj/jHRsSeokowZFN3CZ64IvEqcmmkVe89OPXc7ldAw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/template": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.28.6.tgz",
      "integrity": "sha512-YA6Ma2KsCdGb+WC6UpBVFJGXL58MDA6oyONbjyF/+5sBgxY/dwkhLogbMT2GXXyU84/IhRw/2D1Os1B/giz+BQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.28.6",
        "@babel/parser": "^7.28.6",
        "@babel/types": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.29.0.tgz",
      "integrity": "sha512-4HPiQr0X7+waHfyXPZpWPfWL/J7dcN1mx9gL6WdQVMbPnF3+ZhSMs8tCxN7oHddJE9fhNE7+lxdnlyemKfJRuA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.29.0",
        "@babel/generator": "^7.29.0",
        "@babel/helper-globals": "^7.28.0",
        "@babel/parser": "^7.29.0",
        "@babel/template": "^7.28.6",
        "@babel/types": "^7.29.0",
        "debug": "^4.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.28.5"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.27.3.tgz",
      "integrity": "sha512-9fJMTNFTWZMh5qwrBItuziu834eOCUcEqymSH7pY+zoMVEZg3gcPuBNxH1EvfVYe9h0x/Ptw8KBzv7qxb7l8dg==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.27.3.tgz",
      "integrity": "sha512-i5D1hPY7GIQmXlXhs2w8AWHhenb00+GxjxRncS2ZM7YNVGNfaMxgzSGuO8o8SJzRc/oZwU2bcScvVERk03QhzA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.27.3.tgz",
      "integrity": "sha512-YdghPYUmj/FX2SYKJ0OZxf+iaKgMsKHVPF1MAq/P8WirnSpCStzKJFjOjzsW0QQ7oIAiccHdcqjbHmJxRb/dmg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.27.3.tgz",
      "integrity": "sha512-IN/0BNTkHtk8lkOM8JWAYFg4ORxBkZQf9zXiEOfERX/CzxW3Vg1ewAhU7QSWQpVIzTW+b8Xy+lGzdYXV6UZObQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.27.3.tgz",
      "integrity": "sha512-Re491k7ByTVRy0t3EKWajdLIr0gz2kKKfzafkth4Q8A5n1xTHrkqZgLLjFEHVD+AXdUGgQMq+Godfq45mGpCKg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.27.3.tgz",
      "integrity": "sha512-vHk/hA7/1AckjGzRqi6wbo+jaShzRowYip6rt6q7VYEDX4LEy1pZfDpdxCBnGtl+A5zq8iXDcyuxwtv3hNtHFg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.27.3.tgz",
      "integrity": "sha512-ipTYM2fjt3kQAYOvo6vcxJx3nBYAzPjgTCk7QEgZG8AUO3ydUhvelmhrbOheMnGOlaSFUoHXB6un+A7q4ygY9w==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.27.3.tgz",
      "integrity": "sha512-dDk0X87T7mI6U3K9VjWtHOXqwAMJBNN2r7bejDsc+j03SEjtD9HrOl8gVFByeM0aJksoUuUVU9TBaZa2rgj0oA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.27.3.tgz",
      "integrity": "sha512-s6nPv2QkSupJwLYyfS+gwdirm0ukyTFNl3KTgZEAiJDd+iHZcbTPPcWCcRYH+WlNbwChgH2QkE9NSlNrMT8Gfw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.27.3.tgz",
      "integrity": "sha512-sZOuFz/xWnZ4KH3YfFrKCf1WyPZHakVzTiqji3WDc0BCl2kBwiJLCXpzLzUBLgmp4veFZdvN5ChW4Eq/8Fc2Fg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.27.3.tgz",
      "integrity": "sha512-yGlQYjdxtLdh0a3jHjuwOrxQjOZYD/C9PfdbgJJF3TIZWnm/tMd/RcNiLngiu4iwcBAOezdnSLAwQDPqTmtTYg==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.27.3.tgz",
      "integrity": "sha512-WO60Sn8ly3gtzhyjATDgieJNet/KqsDlX5nRC5Y3oTFcS1l0KWba+SEa9Ja1GfDqSF1z6hif/SkpQJbL63cgOA==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.27.3.tgz",
      "integrity": "sha512-APsymYA6sGcZ4pD6k+UxbDjOFSvPWyZhjaiPyl/f79xKxwTnrn5QUnXR5prvetuaSMsb4jgeHewIDCIWljrSxw==",
      "cpu": [
        "mips64el"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.27.3.tgz",
      "integrity": "sha512-eizBnTeBefojtDb9nSh4vvVQ3V9Qf9Df01PfawPcRzJH4gFSgrObw+LveUyDoKU3kxi5+9RJTCWlj4FjYXVPEA==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.27.3.tgz",
      "integrity": "sha512-3Emwh0r5wmfm3ssTWRQSyVhbOHvqegUDRd0WhmXKX2mkHJe1SFCMJhagUleMq+Uci34wLSipf8Lagt4LlpRFWQ==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.27.3.tgz",
      "integrity": "sha512-pBHUx9LzXWBc7MFIEEL0yD/ZVtNgLytvx60gES28GcWMqil8ElCYR4kvbV2BDqsHOvVDRrOxGySBM9Fcv744hw==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.27.3.tgz",
      "integrity": "sha512-Czi8yzXUWIQYAtL/2y6vogER8pvcsOsk5cpwL4Gk5nJqH5UZiVByIY8Eorm5R13gq+DQKYg0+JyQoytLQas4dA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-arm64/-/netbsd-arm64-0.27.3.tgz",
      "integrity": "sha512-sDpk0RgmTCR/5HguIZa9n9u+HVKf40fbEUt+iTzSnCaGvY9kFP0YKBWZtJaraonFnqef5SlJ8/TiPAxzyS+UoA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.27.3.tgz",
      "integrity": "sha512-P14lFKJl/DdaE00LItAukUdZO5iqNH7+PjoBm+fLQjtxfcfFE20Xf5CrLsmZdq5LFFZzb5JMZ9grUwvtVYzjiA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.27.3.tgz",
      "integrity": "sha512-AIcMP77AvirGbRl/UZFTq5hjXK+2wC7qFRGoHSDrZ5v5b8DK/GYpXW3CPRL53NkvDqb9D+alBiC/dV0Fb7eJcw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.27.3.tgz",
      "integrity": "sha512-DnW2sRrBzA+YnE70LKqnM3P+z8vehfJWHXECbwBmH/CU51z6FiqTQTHFenPlHmo3a8UgpLyH3PT+87OViOh1AQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openharmony-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/openharmony-arm64/-/openharmony-arm64-0.27.3.tgz",
      "integrity": "sha512-NinAEgr/etERPTsZJ7aEZQvvg/A6IsZG/LgZy+81wON2huV7SrK3e63dU0XhyZP4RKGyTm7aOgmQk0bGp0fy2g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.27.3.tgz",
      "integrity": "sha512-PanZ+nEz+eWoBJ8/f8HKxTTD172SKwdXebZ0ndd953gt1HRBbhMsaNqjTyYLGLPdoWHy4zLU7bDVJztF5f3BHA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.27.3.tgz",
      "integrity": "sha512-B2t59lWWYrbRDw/tjiWOuzSsFh1Y/E95ofKz7rIVYSQkUYBjfSgf6oeYPNWHToFRr2zx52JKApIcAS/D5TUBnA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.27.3.tgz",
      "integrity": "sha512-QLKSFeXNS8+tHW7tZpMtjlNb7HKau0QDpwm49u0vUp9y1WOF+PEzkU84y9GqYaAVW8aH8f3GcBck26jh54cX4Q==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.27.3.tgz",
      "integrity": "sha512-4uJGhsxuptu3OcpVAzli+/gWusVGwZZHTlS63hh++ehExkVT8SgiEf7/uC/PclrPPkLhZqGgCTjd0VWLo6xMqA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@eslint-community/eslint-utils": {
      "version": "4.9.1",
      "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.9.1.tgz",
      "integrity": "sha512-phrYmNiYppR7znFEdqgfWHXR6NCkZEK7hwWDHZUjit/2/U0r6XvkDl0SYnoM51Hq7FhCGdLDT6zxCCOY1hexsQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "eslint-visitor-keys": "^3.4.3"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      },
      "peerDependencies": {
        "eslint": "^6.0.0 || ^7.0.0 || >=8.0.0"
      }
    },
    "node_modules/@eslint-community/eslint-utils/node_modules/eslint-visitor-keys": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz",
      "integrity": "sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint-community/regexpp": {
      "version": "4.12.2",
      "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.12.2.tgz",
      "integrity": "sha512-EriSTlt5OC9/7SXkRSCAhfSxxoSUgBm33OH+IkwbdpgoqsSsUg7y3uh+IICI/Qg4BBWr3U2i39RpmycbxMq4ew==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
      }
    },
    "node_modules/@eslint/config-array": {
      "version": "0.21.1",
      "resolved": "https://registry.npmjs.org/@eslint/config-array/-/config-array-0.21.1.tgz",
      "integrity": "sha512-aw1gNayWpdI/jSYVgzN5pL0cfzU02GT3NBpeT/DXbx1/1x7ZKxFPd9bwrzygx/qiwIQiJ1sw/zD8qY/kRvlGHA==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/object-schema": "^2.1.7",
        "debug": "^4.3.1",
        "minimatch": "^3.1.2"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/config-helpers": {
      "version": "0.4.2",
      "resolved": "https://registry.npmjs.org/@eslint/config-helpers/-/config-helpers-0.4.2.tgz",
      "integrity": "sha512-gBrxN88gOIf3R7ja5K9slwNayVcZgK6SOUORm2uBzTeIEfeVaIhOpCtTox3P6R7o2jLFwLFTLnC7kU/RGcYEgw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/core": "^0.17.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/core": {
      "version": "0.17.0",
      "resolved": "https://registry.npmjs.org/@eslint/core/-/core-0.17.0.tgz",
      "integrity": "sha512-yL/sLrpmtDaFEiUj1osRP4TI2MDz1AddJL+jZ7KSqvBuliN4xqYY54IfdN8qD8Toa6g1iloph1fxQNkjOxrrpQ==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@types/json-schema": "^7.0.15"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/eslintrc": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-3.3.3.tgz",
      "integrity": "sha512-Kr+LPIUVKz2qkx1HAMH8q1q6azbqBAsXJUxBl/ODDuVPX45Z9DfwB8tPjTi6nNZ8BuM3nbJxC5zCAg5elnBUTQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ajv": "^6.12.4",
        "debug": "^4.3.2",
        "espree": "^10.0.1",
        "globals": "^14.0.0",
        "ignore": "^5.2.0",
        "import-fresh": "^3.2.1",
        "js-yaml": "^4.1.1",
        "minimatch": "^3.1.2",
        "strip-json-comments": "^3.1.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/globals": {
      "version": "14.0.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-14.0.0.tgz",
      "integrity": "sha512-oahGvuMGQlPw/ivIYBjVSrWAfWLBeku5tpPE2fOPLi+WHffIWbuh2tCjhyQhTBPMf5E9jDEH4FOmTYgYwbKwtQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@eslint/js": {
      "version": "9.39.3",
      "resolved": "https://registry.npmjs.org/@eslint/js/-/js-9.39.3.tgz",
      "integrity": "sha512-1B1VkCq6FuUNlQvlBYb+1jDu/gV297TIs/OeiaSR9l1H27SVW55ONE1e1Vp16NqP683+xEGzxYtv4XCiDPaQiw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      }
    },
    "node_modules/@eslint/object-schema": {
      "version": "2.1.7",
      "resolved": "https://registry.npmjs.org/@eslint/object-schema/-/object-schema-2.1.7.tgz",
      "integrity": "sha512-VtAOaymWVfZcmZbp6E2mympDIHvyjXs/12LqWYjVw6qjrfF+VK+fyG33kChz3nnK+SU5/NeHOqrTEHS8sXO3OA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/plugin-kit": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/@eslint/plugin-kit/-/plugin-kit-0.4.1.tgz",
      "integrity": "sha512-43/qtrDUokr7LJqoF2c3+RInu/t4zfrpYdoSDfYyhg52rwLV6TnOvdG4fXm7IkSB3wErkcmJS9iEhjVtOSEjjA==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/core": "^0.17.0",
        "levn": "^0.4.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@floating-ui/core": {
      "version": "1.7.4",
      "resolved": "https://registry.npmjs.org/@floating-ui/core/-/core-1.7.4.tgz",
      "integrity": "sha512-C3HlIdsBxszvm5McXlB8PeOEWfBhcGBTZGkGlWc2U0KFY5IwG5OQEuQ8rq52DZmcHDlPLd+YFBK+cZcytwIFWg==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/utils": "^0.2.10"
      }
    },
    "node_modules/@floating-ui/dom": {
      "version": "1.7.5",
      "resolved": "https://registry.npmjs.org/@floating-ui/dom/-/dom-1.7.5.tgz",
      "integrity": "sha512-N0bD2kIPInNHUHehXhMke1rBGs1dwqvC9O9KYMyyjK7iXt7GAhnro7UlcuYcGdS/yYOlq0MAVgrow8IbWJwyqg==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/core": "^1.7.4",
        "@floating-ui/utils": "^0.2.10"
      }
    },
    "node_modules/@floating-ui/react": {
      "version": "0.26.28",
      "resolved": "https://registry.npmjs.org/@floating-ui/react/-/react-0.26.28.tgz",
      "integrity": "sha512-yORQuuAtVpiRjpMhdc0wJj06b9JFjrYF4qp96j++v2NBpbi6SEGF7donUJ3TMieerQ6qVkAv1tgr7L4r5roTqw==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/react-dom": "^2.1.2",
        "@floating-ui/utils": "^0.2.8",
        "tabbable": "^6.0.0"
      },
      "peerDependencies": {
        "react": ">=16.8.0",
        "react-dom": ">=16.8.0"
      }
    },
    "node_modules/@floating-ui/react-dom": {
      "version": "2.1.7",
      "resolved": "https://registry.npmjs.org/@floating-ui/react-dom/-/react-dom-2.1.7.tgz",
      "integrity": "sha512-0tLRojf/1Go2JgEVm+3Frg9A3IW8bJgKgdO0BN5RkF//ufuz2joZM63Npau2ff3J6lUVYgDSNzNkR+aH3IVfjg==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/dom": "^1.7.5"
      },
      "peerDependencies": {
        "react": ">=16.8.0",
        "react-dom": ">=16.8.0"
      }
    },
    "node_modules/@floating-ui/utils": {
      "version": "0.2.10",
      "resolved": "https://registry.npmjs.org/@floating-ui/utils/-/utils-0.2.10.tgz",
      "integrity": "sha512-aGTxbpbg8/b5JfU1HXSrbH3wXZuLPJcNEcZQFMxLs3oSzgtVu6nFPkbbGGUvBcUjKV2YyB9Wxxabo+HEH9tcRQ==",
      "license": "MIT"
    },
    "node_modules/@headlessui/react": {
      "version": "2.2.9",
      "resolved": "https://registry.npmjs.org/@headlessui/react/-/react-2.2.9.tgz",
      "integrity": "sha512-Mb+Un58gwBn0/yWZfyrCh0TJyurtT+dETj7YHleylHk5od3dv2XqETPGWMyQ5/7sYN7oWdyM1u9MvC0OC8UmzQ==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/react": "^0.26.16",
        "@react-aria/focus": "^3.20.2",
        "@react-aria/interactions": "^3.25.0",
        "@tanstack/react-virtual": "^3.13.9",
        "use-sync-external-store": "^1.5.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "react": "^18 || ^19 || ^19.0.0-rc",
        "react-dom": "^18 || ^19 || ^19.0.0-rc"
      }
    },
    "node_modules/@heroicons/react": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/@heroicons/react/-/react-2.2.0.tgz",
      "integrity": "sha512-LMcepvRaS9LYHJGsF0zzmgKCUim/X3N/DQKc4jepAXJ7l8QxJ1PmxJzqplF2Z3FE4PqBAIGyJAQ/w4B5dsqbtQ==",
      "license": "MIT",
      "peerDependencies": {
        "react": ">= 16 || ^19.0.0-rc"
      }
    },
    "node_modules/@hookform/resolvers": {
      "version": "5.2.2",
      "resolved": "https://registry.npmjs.org/@hookform/resolvers/-/resolvers-5.2.2.tgz",
      "integrity": "sha512-A/IxlMLShx3KjV/HeTcTfaMxdwy690+L/ZADoeaTltLx+CVuzkeVIPuybK3jrRfw7YZnmdKsVVHAlEPIAEUNlA==",
      "license": "MIT",
      "dependencies": {
        "@standard-schema/utils": "^0.3.0"
      },
      "peerDependencies": {
        "react-hook-form": "^7.55.0"
      }
    },
    "node_modules/@humanfs/core": {
      "version": "0.19.1",
      "resolved": "https://registry.npmjs.org/@humanfs/core/-/core-0.19.1.tgz",
      "integrity": "sha512-5DyQ4+1JEUzejeK1JGICcideyfUbGixgS9jNgex5nqkW+cY7WZhxBigmieN5Qnw9ZosSNVC9KQKyb+GUaGyKUA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanfs/node": {
      "version": "0.16.7",
      "resolved": "https://registry.npmjs.org/@humanfs/node/-/node-0.16.7.tgz",
      "integrity": "sha512-/zUx+yOsIrG4Y43Eh2peDeKCxlRt/gET6aHfaKpuq267qXdYDFViVHfMaLyygZOnl0kGWxFIgsBy8QFuTLUXEQ==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@humanfs/core": "^0.19.1",
        "@humanwhocodes/retry": "^0.4.0"
      },
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanwhocodes/module-importer": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
      "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=12.22"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@humanwhocodes/retry": {
      "version": "0.4.3",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/retry/-/retry-0.4.3.tgz",
      "integrity": "sha512-bV0Tgo9K4hfPCek+aMAn81RppFKv2ySDQeMoSZuvTASywNTnVJCArCZE2FWqpvIatKu7VMRLWlR1EazvVhDyhQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.13",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.0",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/remapping": {
      "version": "2.3.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/remapping/-/remapping-2.3.5.tgz",
      "integrity": "sha512-LI9u/+laYG4Ds1TDKSJW2YPrIlcVYOwi2fUC6xB43lueCjgxV4lffOCZCtYFiH6TNOX+tQKXx97T4IKHbhyHEQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.31",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@nodelib/fs.scandir": {
      "version": "2.1.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
      "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "2.0.5",
        "run-parallel": "^1.1.9"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.stat": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz",
      "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.walk": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz",
      "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.scandir": "2.1.5",
        "fastq": "^1.6.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@react-aria/focus": {
      "version": "3.21.4",
      "resolved": "https://registry.npmjs.org/@react-aria/focus/-/focus-3.21.4.tgz",
      "integrity": "sha512-6gz+j9ip0/vFRTKJMl3R30MHopn4i19HqqLfSQfElxJD+r9hBnYG1Q6Wd/kl/WRR1+CALn2F+rn06jUnf5sT8Q==",
      "license": "Apache-2.0",
      "dependencies": {
        "@react-aria/interactions": "^3.27.0",
        "@react-aria/utils": "^3.33.0",
        "@react-types/shared": "^3.33.0",
        "@swc/helpers": "^0.5.0",
        "clsx": "^2.0.0"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1",
        "react-dom": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@react-aria/interactions": {
      "version": "3.27.0",
      "resolved": "https://registry.npmjs.org/@react-aria/interactions/-/interactions-3.27.0.tgz",
      "integrity": "sha512-D27pOy+0jIfHK60BB26AgqjjRFOYdvVSkwC31b2LicIzRCSPOSP06V4gMHuGmkhNTF4+YWDi1HHYjxIvMeiSlA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@react-aria/ssr": "^3.9.10",
        "@react-aria/utils": "^3.33.0",
        "@react-stately/flags": "^3.1.2",
        "@react-types/shared": "^3.33.0",
        "@swc/helpers": "^0.5.0"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1",
        "react-dom": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@react-aria/ssr": {
      "version": "3.9.10",
      "resolved": "https://registry.npmjs.org/@react-aria/ssr/-/ssr-3.9.10.tgz",
      "integrity": "sha512-hvTm77Pf+pMBhuBm760Li0BVIO38jv1IBws1xFm1NoL26PU+fe+FMW5+VZWyANR6nYL65joaJKZqOdTQMkO9IQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@swc/helpers": "^0.5.0"
      },
      "engines": {
        "node": ">= 12"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@react-aria/utils": {
      "version": "3.33.0",
      "resolved": "https://registry.npmjs.org/@react-aria/utils/-/utils-3.33.0.tgz",
      "integrity": "sha512-yvz7CMH8d2VjwbSa5nGXqjU031tYhD8ddax95VzJsHSPyqHDEGfxul8RkhGV6oO7bVqZxVs6xY66NIgae+FHjw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@react-aria/ssr": "^3.9.10",
        "@react-stately/flags": "^3.1.2",
        "@react-stately/utils": "^3.11.0",
        "@react-types/shared": "^3.33.0",
        "@swc/helpers": "^0.5.0",
        "clsx": "^2.0.0"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1",
        "react-dom": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@react-stately/flags": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@react-stately/flags/-/flags-3.1.2.tgz",
      "integrity": "sha512-2HjFcZx1MyQXoPqcBGALwWWmgFVUk2TuKVIQxCbRq7fPyWXIl6VHcakCLurdtYC2Iks7zizvz0Idv48MQ38DWg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@swc/helpers": "^0.5.0"
      }
    },
    "node_modules/@react-stately/utils": {
      "version": "3.11.0",
      "resolved": "https://registry.npmjs.org/@react-stately/utils/-/utils-3.11.0.tgz",
      "integrity": "sha512-8LZpYowJ9eZmmYLpudbo/eclIRnbhWIJZ994ncmlKlouNzKohtM8qTC6B1w1pwUbiwGdUoyzLuQbeaIor5Dvcw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@swc/helpers": "^0.5.0"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@react-types/shared": {
      "version": "3.33.0",
      "resolved": "https://registry.npmjs.org/@react-types/shared/-/shared-3.33.0.tgz",
      "integrity": "sha512-xuUpP6MyuPmJtzNOqF5pzFUIHH2YogyOQfUQHag54PRmWB7AbjuGWBUv0l1UDmz6+AbzAYGmDVAzcRDOu2PFpw==",
      "license": "Apache-2.0",
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@rolldown/pluginutils": {
      "version": "1.0.0-rc.3",
      "resolved": "https://registry.npmjs.org/@rolldown/pluginutils/-/pluginutils-1.0.0-rc.3.tgz",
      "integrity": "sha512-eybk3TjzzzV97Dlj5c+XrBFW57eTNhzod66y9HrBlzJ6NsCrWCp/2kaPS3K9wJmurBC0Tdw4yPjXKZqlznim3Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.58.0.tgz",
      "integrity": "sha512-mr0tmS/4FoVk1cnaeN244A/wjvGDNItZKR8hRhnmCzygyRXYtKF5jVDSIILR1U97CTzAYmbgIj/Dukg62ggG5w==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.58.0.tgz",
      "integrity": "sha512-+s++dbp+/RTte62mQD9wLSbiMTV+xr/PeRJEc/sFZFSBRlHPNPVaf5FXlzAL77Mr8FtSfQqCN+I598M8U41ccQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.58.0.tgz",
      "integrity": "sha512-MFWBwTcYs0jZbINQBXHfSrpSQJq3IUOakcKPzfeSznONop14Pxuqa0Kg19GD0rNBMPQI2tFtu3UzapZpH0Uc1Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.58.0.tgz",
      "integrity": "sha512-yiKJY7pj9c9JwzuKYLFaDZw5gma3fI9bkPEIyofvVfsPqjCWPglSHdpdwXpKGvDeYDms3Qal8qGMEHZ1M/4Udg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.58.0.tgz",
      "integrity": "sha512-x97kCoBh5MOevpn/CNK9W1x8BEzO238541BGWBc315uOlN0AD/ifZ1msg+ZQB05Ux+VF6EcYqpiagfLJ8U3LvQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.58.0.tgz",
      "integrity": "sha512-Aa8jPoZ6IQAG2eIrcXPpjRcMjROMFxCt1UYPZZtCxRV68WkuSigYtQ/7Zwrcr2IvtNJo7T2JfDXyMLxq5L4Jlg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.58.0.tgz",
      "integrity": "sha512-Ob8YgT5kD/lSIYW2Rcngs5kNB/44Q2RzBSPz9brf2WEtcGR7/f/E9HeHn1wYaAwKBni+bdXEwgHvUd0x12lQSA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.58.0.tgz",
      "integrity": "sha512-K+RI5oP1ceqoadvNt1FecL17Qtw/n9BgRSzxif3rTL2QlIu88ccvY+Y9nnHe/cmT5zbH9+bpiJuG1mGHRVwF4Q==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.58.0.tgz",
      "integrity": "sha512-T+17JAsCKUjmbopcKepJjHWHXSjeW7O5PL7lEFaeQmiVyw4kkc5/lyYKzrv6ElWRX/MrEWfPiJWqbTvfIvjM1Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.58.0.tgz",
      "integrity": "sha512-cCePktb9+6R9itIJdeCFF9txPU7pQeEHB5AbHu/MKsfH/k70ZtOeq1k4YAtBv9Z7mmKI5/wOLYjQ+B9QdxR6LA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-gnu/-/rollup-linux-loong64-gnu-4.58.0.tgz",
      "integrity": "sha512-iekUaLkfliAsDl4/xSdoCJ1gnnIXvoNz85C8U8+ZxknM5pBStfZjeXgB8lXobDQvvPRCN8FPmmuTtH+z95HTmg==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-musl": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-musl/-/rollup-linux-loong64-musl-4.58.0.tgz",
      "integrity": "sha512-68ofRgJNl/jYJbxFjCKE7IwhbfxOl1muPN4KbIqAIe32lm22KmU7E8OPvyy68HTNkI2iV/c8y2kSPSm2mW/Q9Q==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.58.0.tgz",
      "integrity": "sha512-dpz8vT0i+JqUKuSNPCP5SYyIV2Lh0sNL1+FhM7eLC457d5B9/BC3kDPp5BBftMmTNsBarcPcoz5UGSsnCiw4XQ==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-musl": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-musl/-/rollup-linux-ppc64-musl-4.58.0.tgz",
      "integrity": "sha512-4gdkkf9UJ7tafnweBCR/mk4jf3Jfl0cKX9Np80t5i78kjIH0ZdezUv/JDI2VtruE5lunfACqftJ8dIMGN4oHew==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.58.0.tgz",
      "integrity": "sha512-YFS4vPnOkDTD/JriUeeZurFYoJhPf9GQQEF/v4lltp3mVcBmnsAdjEWhr2cjUCZzZNzxCG0HZOvJU44UGHSdzw==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.58.0.tgz",
      "integrity": "sha512-x2xgZlFne+QVNKV8b4wwaCS8pwq3y14zedZ5DqLzjdRITvreBk//4Knbcvm7+lWmms9V9qFp60MtUd0/t/PXPw==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.58.0.tgz",
      "integrity": "sha512-jIhrujyn4UnWF8S+DHSkAkDEO3hLX0cjzxJZPLF80xFyzyUIYgSMRcYQ3+uqEoyDD2beGq7Dj7edi8OnJcS/hg==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.58.0.tgz",
      "integrity": "sha512-+410Srdoh78MKSJxTQ+hZ/Mx+ajd6RjjPwBPNd0R3J9FtL6ZA0GqiiyNjCO9In0IzZkCNrpGymSfn+kgyPQocg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.58.0.tgz",
      "integrity": "sha512-ZjMyby5SICi227y1MTR3VYBpFTdZs823Rs/hpakufleBoufoOIB6jtm9FEoxn/cgO7l6PM2rCEl5Kre5vX0QrQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-openbsd-x64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openbsd-x64/-/rollup-openbsd-x64-4.58.0.tgz",
      "integrity": "sha512-ds4iwfYkSQ0k1nb8LTcyXw//ToHOnNTJtceySpL3fa7tc/AsE+UpUFphW126A6fKBGJD5dhRvg8zw1rvoGFxmw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ]
    },
    "node_modules/@rollup/rollup-openharmony-arm64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openharmony-arm64/-/rollup-openharmony-arm64-4.58.0.tgz",
      "integrity": "sha512-fd/zpJniln4ICdPkjWFhZYeY/bpnaN9pGa6ko+5WD38I0tTqk9lXMgXZg09MNdhpARngmxiCg0B0XUamNw/5BQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.58.0.tgz",
      "integrity": "sha512-YpG8dUOip7DCz3nr/JUfPbIUo+2d/dy++5bFzgi4ugOGBIox+qMbbqt/JoORwvI/C9Kn2tz6+Bieoqd5+B1CjA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.58.0.tgz",
      "integrity": "sha512-b9DI8jpFQVh4hIXFr0/+N/TzLdpBIoPzjt0Rt4xJbW3mzguV3mduR9cNgiuFcuL/TeORejJhCWiAXe3E/6PxWA==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-gnu/-/rollup-win32-x64-gnu-4.58.0.tgz",
      "integrity": "sha512-CSrVpmoRJFN06LL9xhkitkwUcTZtIotYAF5p6XOR2zW0Zz5mzb3IPpcoPhB02frzMHFNo1reQ9xSF5fFm3hUsQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.58.0.tgz",
      "integrity": "sha512-QFsBgQNTnh5K0t/sBsjJLq24YVqEIVkGpfN2VHsnN90soZyhaiA9UUHufcctVNL4ypJY0wrwad0wslx2KJQ1/w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@standard-schema/utils": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/@standard-schema/utils/-/utils-0.3.0.tgz",
      "integrity": "sha512-e7Mew686owMaPJVNNLs55PUvgz371nKgwsc4vxE49zsODpJEnxgxRo2y/OKrqueavXgZNMDVj3DdHFlaSAeU8g==",
      "license": "MIT"
    },
    "node_modules/@swc/helpers": {
      "version": "0.5.18",
      "resolved": "https://registry.npmjs.org/@swc/helpers/-/helpers-0.5.18.tgz",
      "integrity": "sha512-TXTnIcNJQEKwThMMqBXsZ4VGAza6bvN4pa41Rkqoio6QBKMvo+5lexeTMScGCIxtzgQJzElcvIltani+adC5PQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.8.0"
      }
    },
    "node_modules/@tanstack/query-core": {
      "version": "5.90.20",
      "resolved": "https://registry.npmjs.org/@tanstack/query-core/-/query-core-5.90.20.tgz",
      "integrity": "sha512-OMD2HLpNouXEfZJWcKeVKUgQ5n+n3A2JFmBaScpNDUqSrQSjiveC7dKMe53uJUg1nDG16ttFPz2xfilz6i2uVg==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/tannerlinsley"
      }
    },
    "node_modules/@tanstack/react-query": {
      "version": "5.90.21",
      "resolved": "https://registry.npmjs.org/@tanstack/react-query/-/react-query-5.90.21.tgz",
      "integrity": "sha512-0Lu6y5t+tvlTJMTO7oh5NSpJfpg/5D41LlThfepTixPYkJ0sE2Jj0m0f6yYqujBwIXlId87e234+MxG3D3g7kg==",
      "license": "MIT",
      "dependencies": {
        "@tanstack/query-core": "5.90.20"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/tannerlinsley"
      },
      "peerDependencies": {
        "react": "^18 || ^19"
      }
    },
    "node_modules/@tanstack/react-virtual": {
      "version": "3.13.18",
      "resolved": "https://registry.npmjs.org/@tanstack/react-virtual/-/react-virtual-3.13.18.tgz",
      "integrity": "sha512-dZkhyfahpvlaV0rIKnvQiVoWPyURppl6w4m9IwMDpuIjcJ1sD9YGWrt0wISvgU7ewACXx2Ct46WPgI6qAD4v6A==",
      "license": "MIT",
      "dependencies": {
        "@tanstack/virtual-core": "3.13.18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/tannerlinsley"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0",
        "react-dom": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/@tanstack/virtual-core": {
      "version": "3.13.18",
      "resolved": "https://registry.npmjs.org/@tanstack/virtual-core/-/virtual-core-3.13.18.tgz",
      "integrity": "sha512-Mx86Hqu1k39icq2Zusq+Ey2J6dDWTjDvEv43PJtRCoEYTLyfaPnxIQ6iy7YAOK0NV/qOEmZQ/uCufrppZxTgcg==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/tannerlinsley"
      }
    },
    "node_modules/@types/babel__core": {
      "version": "7.20.5",
      "resolved": "https://registry.npmjs.org/@types/babel__core/-/babel__core-7.20.5.tgz",
      "integrity": "sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.20.7",
        "@babel/types": "^7.20.7",
        "@types/babel__generator": "*",
        "@types/babel__template": "*",
        "@types/babel__traverse": "*"
      }
    },
    "node_modules/@types/babel__generator": {
      "version": "7.27.0",
      "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.27.0.tgz",
      "integrity": "sha512-ufFd2Xi92OAVPYsy+P4n7/U7e68fex0+Ee8gSG9KX7eo084CWiQ4sdxktvdl0bOPupXtVJPY19zk6EwWqUQ8lg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__template": {
      "version": "7.4.4",
      "resolved": "https://registry.npmjs.org/@types/babel__template/-/babel__template-7.4.4.tgz",
      "integrity": "sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__traverse": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.28.0.tgz",
      "integrity": "sha512-8PvcXf70gTDZBgt9ptxJ8elBeBjcLOAcOtoO/mPJjtji1+CdGbHgm77om1GrsPxsiE+uXIpNSK64UYaIwQXd4Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.28.2"
      }
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz",
      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/json-schema": {
      "version": "7.0.15",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz",
      "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/react": {
      "version": "19.2.14",
      "resolved": "https://registry.npmjs.org/@types/react/-/react-19.2.14.tgz",
      "integrity": "sha512-ilcTH/UniCkMdtexkoCN0bI7pMcJDvmQFPvuPvmEaYA/NSfFTAgdUSLAoVjaRJm7+6PvcM+q1zYOwS4wTYMF9w==",
      "devOptional": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "csstype": "^3.2.2"
      }
    },
    "node_modules/@types/react-dom": {
      "version": "19.2.3",
      "resolved": "https://registry.npmjs.org/@types/react-dom/-/react-dom-19.2.3.tgz",
      "integrity": "sha512-jp2L/eY6fn+KgVVQAOqYItbF0VY/YApe5Mz2F0aykSO8gx31bYCZyvSeYxCHKvzHG5eZjc+zyaS5BrBWya2+kQ==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "^19.2.0"
      }
    },
    "node_modules/@vitejs/plugin-react": {
      "version": "5.1.4",
      "resolved": "https://registry.npmjs.org/@vitejs/plugin-react/-/plugin-react-5.1.4.tgz",
      "integrity": "sha512-VIcFLdRi/VYRU8OL/puL7QXMYafHmqOnwTZY50U1JPlCNj30PxCMx65c494b1K9be9hX83KVt0+gTEwTWLqToA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.29.0",
        "@babel/plugin-transform-react-jsx-self": "^7.27.1",
        "@babel/plugin-transform-react-jsx-source": "^7.27.1",
        "@rolldown/pluginutils": "1.0.0-rc.3",
        "@types/babel__core": "^7.20.5",
        "react-refresh": "^0.18.0"
      },
      "engines": {
        "node": "^20.19.0 || >=22.12.0"
      },
      "peerDependencies": {
        "vite": "^4.2.0 || ^5.0.0 || ^6.0.0 || ^7.0.0"
      }
    },
    "node_modules/acorn": {
      "version": "8.16.0",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.16.0.tgz",
      "integrity": "sha512-UVJyE9MttOsBQIDKw1skb9nAwQuR5wuGD3+82K6JgJlm/Y+KI92oNsMNGZCYdDsVtRHSak0pcV5Dno5+4jh9sw==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-jsx": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz",
      "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/ajv": {
      "version": "6.12.6",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/epoberezkin"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/any-promise": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/any-promise/-/any-promise-1.3.0.tgz",
      "integrity": "sha512-7UvmKalWRt1wgjL1RrGxoSJW/0QZFIegpeGvZG9kjp8vrRu55XTHbwnqq2GpXm9uLbcuhxm3IqX9OB4MZR1b2A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/anymatch": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/arg": {
      "version": "5.0.2",
      "resolved": "https://registry.npmjs.org/arg/-/arg-5.0.2.tgz",
      "integrity": "sha512-PYjyFOLKQ9y57JvQ6QLo8dAgNqswh8M1RMJYdQduT6xbWSgK36P/Z/v+p888pM69jMMfS8Xd8F6I1kQ/I9HUGg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "dev": true,
      "license": "Python-2.0"
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==",
      "license": "MIT"
    },
    "node_modules/autoprefixer": {
      "version": "10.4.24",
      "resolved": "https://registry.npmjs.org/autoprefixer/-/autoprefixer-10.4.24.tgz",
      "integrity": "sha512-uHZg7N9ULTVbutaIsDRoUkoS8/h3bdsmVJYZ5l3wv8Cp/6UIIoRDm90hZ+BwxUj/hGBEzLxdHNSKuFpn8WOyZw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/autoprefixer"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "browserslist": "^4.28.1",
        "caniuse-lite": "^1.0.30001766",
        "fraction.js": "^5.3.4",
        "picocolors": "^1.1.1",
        "postcss-value-parser": "^4.2.0"
      },
      "bin": {
        "autoprefixer": "bin/autoprefixer"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      },
      "peerDependencies": {
        "postcss": "^8.1.0"
      }
    },
    "node_modules/axios": {
      "version": "1.13.5",
      "resolved": "https://registry.npmjs.org/axios/-/axios-1.13.5.tgz",
      "integrity": "sha512-cz4ur7Vb0xS4/KUN0tPWe44eqxrIu31me+fbang3ijiNscE129POzipJJA6zniq2C/Z6sJCjMimjS8Lc/GAs8Q==",
      "license": "MIT",
      "dependencies": {
        "follow-redirects": "^1.15.11",
        "form-data": "^4.0.5",
        "proxy-from-env": "^1.1.0"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/baseline-browser-mapping": {
      "version": "2.10.0",
      "resolved": "https://registry.npmjs.org/baseline-browser-mapping/-/baseline-browser-mapping-2.10.0.tgz",
      "integrity": "sha512-lIyg0szRfYbiy67j9KN8IyeD7q7hcmqnJ1ddWmNt19ItGpNN64mnllmxUNFIOdOm6by97jlL6wfpTTJrmnjWAA==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "baseline-browser-mapping": "dist/cli.cjs"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/binary-extensions": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.3.0.tgz",
      "integrity": "sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/browserslist": {
      "version": "4.28.1",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.28.1.tgz",
      "integrity": "sha512-ZC5Bd0LgJXgwGqUknZY/vkUQ04r8NXnJZ3yYi4vDmSiZmC/pdSN0NbNRPxZpbtO4uAfDUAFffO8IZoM3Gj8IkA==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "baseline-browser-mapping": "^2.9.0",
        "caniuse-lite": "^1.0.30001759",
        "electron-to-chromium": "^1.5.263",
        "node-releases": "^2.0.27",
        "update-browserslist-db": "^1.2.0"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/camelcase-css": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/camelcase-css/-/camelcase-css-2.0.1.tgz",
      "integrity": "sha512-QOSvevhslijgYwRx6Rv7zKdMF8lbRmx+uQGx2+vDc+KI/eBnsy9kit5aj23AgGu3pa4t9AgwbnXWqS+iOY+2aA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001770",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001770.tgz",
      "integrity": "sha512-x/2CLQ1jHENRbHg5PSId2sXq1CIO1CISvwWAj027ltMVG2UNgW+w9oH2+HzgEIRFembL8bUlXtfbBHR1fCg2xw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/chalk": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/chokidar": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.6.0.tgz",
      "integrity": "sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "anymatch": "~3.1.2",
        "braces": "~3.0.2",
        "glob-parent": "~5.1.2",
        "is-binary-path": "~2.1.0",
        "is-glob": "~4.0.1",
        "normalize-path": "~3.0.0",
        "readdirp": "~3.6.0"
      },
      "engines": {
        "node": ">= 8.10.0"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/chokidar/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/clsx": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/clsx/-/clsx-2.1.1.tgz",
      "integrity": "sha512-eYm0QWBtUrBWZWG0d386OGAw16Z995PiOVo2B7bjWSbHedGl5e0ZWaq65kOGgUSNesEIDkB9ISbTg/JK9dhCZA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "license": "MIT",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/commander": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/commander/-/commander-4.1.1.tgz",
      "integrity": "sha512-NOKm8xhkzAjzFx8B2v5OAHT+u5pRQc2UCa2Vq9jYL/31o2wi9mxBA7LIFs3sV5VSC49z6pEhfbMULvShKj26WA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/convert-source-map": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz",
      "integrity": "sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cookie": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-1.1.1.tgz",
      "integrity": "sha512-ei8Aos7ja0weRpFzJnEA9UHJ/7XQmqglbRwnf2ATjcB9Wq874VKH9kfjjirM6UhU2/E5fFYadylyhFldcqSidQ==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/css-selector-tokenizer": {
      "version": "0.8.0",
      "resolved": "https://registry.npmjs.org/css-selector-tokenizer/-/css-selector-tokenizer-0.8.0.tgz",
      "integrity": "sha512-Jd6Ig3/pe62/qe5SBPTN8h8LeUg/pT4lLgtavPf7updwwHpvFzxvOQBHYj2LZDMjUnBzgvIUSjRcf6oT5HzHFg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cssesc": "^3.0.0",
        "fastparse": "^1.1.2"
      }
    },
    "node_modules/cssesc": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/cssesc/-/cssesc-3.0.0.tgz",
      "integrity": "sha512-/Tb/JcjK111nNScGob5MNtsntNM1aCNUDipB/TkwZFhyDrrE47SOx/18wF2bbjgc3ZzCSKW1T5nt5EbFoAz/Vg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "cssesc": "bin/cssesc"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/csstype": {
      "version": "3.2.3",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.2.3.tgz",
      "integrity": "sha512-z1HGKcYy2xA8AGQfwrn0PAy+PB7X/GSj3UVJW9qKyn43xWa+gl5nXmU4qqLMRzWVLFC8KusUX8T/0kCiOYpAIQ==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/culori": {
      "version": "3.3.0",
      "resolved": "https://registry.npmjs.org/culori/-/culori-3.3.0.tgz",
      "integrity": "sha512-pHJg+jbuFsCjz9iclQBqyL3B2HLCBF71BwVNujUYEvCeQMvV97R59MNK3R2+jgJ3a1fcZgI9B3vYgz8lzr/BFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
      }
    },
    "node_modules/daisyui": {
      "version": "4.12.24",
      "resolved": "https://registry.npmjs.org/daisyui/-/daisyui-4.12.24.tgz",
      "integrity": "sha512-JYg9fhQHOfXyLadrBrEqCDM6D5dWCSSiM6eTNCRrBRzx/VlOCrLS8eDfIw9RVvs64v2mJdLooKXY8EwQzoszAA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "css-selector-tokenizer": "^0.8",
        "culori": "^3",
        "picocolors": "^1",
        "postcss-js": "^4"
      },
      "engines": {
        "node": ">=16.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/daisyui"
      }
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/deep-is": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz",
      "integrity": "sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/didyoumean": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/didyoumean/-/didyoumean-1.2.2.tgz",
      "integrity": "sha512-gxtyfqMg7GKyhQmb056K7M3xszy/myH8w+B4RT+QXBQsvAOdc3XymqDDPHx1BgPgsdAA5SIifona89YtRATDzw==",
      "dev": true,
      "license": "Apache-2.0"
    },
    "node_modules/dlv": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/dlv/-/dlv-1.1.3.tgz",
      "integrity": "sha512-+HlytyjlPKnIG8XuRG8WvmBP8xs8P71y+SKKS6ZXWoEgLuePxtDoUEiH7WkdePWrQ5JBpE6aoVqfZfJUQkjXwA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/electron-to-chromium": {
      "version": "1.5.302",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.302.tgz",
      "integrity": "sha512-sM6HAN2LyK82IyPBpznDRqlTQAtuSaO+ShzFiWTvoMJLHyZ+Y39r8VMfHzwbU8MVBzQ4Wdn85+wlZl2TLGIlwg==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/esbuild": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.27.3.tgz",
      "integrity": "sha512-8VwMnyGCONIs6cWue2IdpHxHnAjzxnw2Zr7MkVxB2vjmQ2ivqGFb4LEG3SMnv0Gb2F/G/2yA8zUaiL1gywDCCg==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=18"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.27.3",
        "@esbuild/android-arm": "0.27.3",
        "@esbuild/android-arm64": "0.27.3",
        "@esbuild/android-x64": "0.27.3",
        "@esbuild/darwin-arm64": "0.27.3",
        "@esbuild/darwin-x64": "0.27.3",
        "@esbuild/freebsd-arm64": "0.27.3",
        "@esbuild/freebsd-x64": "0.27.3",
        "@esbuild/linux-arm": "0.27.3",
        "@esbuild/linux-arm64": "0.27.3",
        "@esbuild/linux-ia32": "0.27.3",
        "@esbuild/linux-loong64": "0.27.3",
        "@esbuild/linux-mips64el": "0.27.3",
        "@esbuild/linux-ppc64": "0.27.3",
        "@esbuild/linux-riscv64": "0.27.3",
        "@esbuild/linux-s390x": "0.27.3",
        "@esbuild/linux-x64": "0.27.3",
        "@esbuild/netbsd-arm64": "0.27.3",
        "@esbuild/netbsd-x64": "0.27.3",
        "@esbuild/openbsd-arm64": "0.27.3",
        "@esbuild/openbsd-x64": "0.27.3",
        "@esbuild/openharmony-arm64": "0.27.3",
        "@esbuild/sunos-x64": "0.27.3",
        "@esbuild/win32-arm64": "0.27.3",
        "@esbuild/win32-ia32": "0.27.3",
        "@esbuild/win32-x64": "0.27.3"
      }
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/escape-string-regexp": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint": {
      "version": "9.39.3",
      "resolved": "https://registry.npmjs.org/eslint/-/eslint-9.39.3.tgz",
      "integrity": "sha512-VmQ+sifHUbI/IcSopBCF/HO3YiHQx/AVd3UVyYL6weuwW+HvON9VYn5l6Zl1WZzPWXPNZrSQpxwkkZ/VuvJZzg==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.8.0",
        "@eslint-community/regexpp": "^4.12.1",
        "@eslint/config-array": "^0.21.1",
        "@eslint/config-helpers": "^0.4.2",
        "@eslint/core": "^0.17.0",
        "@eslint/eslintrc": "^3.3.1",
        "@eslint/js": "9.39.3",
        "@eslint/plugin-kit": "^0.4.1",
        "@humanfs/node": "^0.16.6",
        "@humanwhocodes/module-importer": "^1.0.1",
        "@humanwhocodes/retry": "^0.4.2",
        "@types/estree": "^1.0.6",
        "ajv": "^6.12.4",
        "chalk": "^4.0.0",
        "cross-spawn": "^7.0.6",
        "debug": "^4.3.2",
        "escape-string-regexp": "^4.0.0",
        "eslint-scope": "^8.4.0",
        "eslint-visitor-keys": "^4.2.1",
        "espree": "^10.4.0",
        "esquery": "^1.5.0",
        "esutils": "^2.0.2",
        "fast-deep-equal": "^3.1.3",
        "file-entry-cache": "^8.0.0",
        "find-up": "^5.0.0",
        "glob-parent": "^6.0.2",
        "ignore": "^5.2.0",
        "imurmurhash": "^0.1.4",
        "is-glob": "^4.0.0",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        "lodash.merge": "^4.6.2",
        "minimatch": "^3.1.2",
        "natural-compare": "^1.4.0",
        "optionator": "^0.9.3"
      },
      "bin": {
        "eslint": "bin/eslint.js"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      },
      "peerDependencies": {
        "jiti": "*"
      },
      "peerDependenciesMeta": {
        "jiti": {
          "optional": true
        }
      }
    },
    "node_modules/eslint-plugin-react-hooks": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/eslint-plugin-react-hooks/-/eslint-plugin-react-hooks-7.0.1.tgz",
      "integrity": "sha512-O0d0m04evaNzEPoSW+59Mezf8Qt0InfgGIBJnpC0h3NH/WjUAR7BIKUfysC6todmtiZ/A0oUVS8Gce0WhBrHsA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.24.4",
        "@babel/parser": "^7.24.4",
        "hermes-parser": "^0.25.1",
        "zod": "^3.25.0 || ^4.0.0",
        "zod-validation-error": "^3.5.0 || ^4.0.0"
      },
      "engines": {
        "node": ">=18"
      },
      "peerDependencies": {
        "eslint": "^3.0.0 || ^4.0.0 || ^5.0.0 || ^6.0.0 || ^7.0.0 || ^8.0.0-0 || ^9.0.0"
      }
    },
    "node_modules/eslint-plugin-react-refresh": {
      "version": "0.4.26",
      "resolved": "https://registry.npmjs.org/eslint-plugin-react-refresh/-/eslint-plugin-react-refresh-0.4.26.tgz",
      "integrity": "sha512-1RETEylht2O6FM/MvgnyvT+8K21wLqDNg4qD51Zj3guhjt433XbnnkVttHMyaVyAFD03QSV4LPS5iE3VQmO7XQ==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "eslint": ">=8.40"
      }
    },
    "node_modules/eslint-scope": {
      "version": "8.4.0",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-8.4.0.tgz",
      "integrity": "sha512-sNXOfKCn74rt8RICKMvJS7XKV/Xk9kA7DyJr8mJik3S7Cwgy3qlkkmyS2uQB3jiJg6VNdZd/pDBJu0nvG2NlTg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "esrecurse": "^4.3.0",
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint-visitor-keys": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-4.2.1.tgz",
      "integrity": "sha512-Uhdk5sfqcee/9H/rCOJikYz67o0a2Tw2hGRPOG2Y1R2dg7brRe1uG0yaNQDHu+TO/uQPF/5eCapvYSmHUjt7JQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/espree": {
      "version": "10.4.0",
      "resolved": "https://registry.npmjs.org/espree/-/espree-10.4.0.tgz",
      "integrity": "sha512-j6PAQ2uUr79PZhBjP5C5fhl8e39FmRnOjsD5lGnWrFU8i2G776tBK7+nP8KuQUTTyAZUwfQqXAgrVH5MbH9CYQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "acorn": "^8.15.0",
        "acorn-jsx": "^5.3.2",
        "eslint-visitor-keys": "^4.2.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/esquery": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.7.0.tgz",
      "integrity": "sha512-Ap6G0WQwcU/LHsvLwON1fAQX9Zp0A2Y6Y/cJBl9r/JbW90Zyg4/zbG6zzKa2OTALELarYHmKu0GhpM5EO+7T0g==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "estraverse": "^5.1.0"
      },
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/esrecurse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estraverse": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-glob": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.3.3.tgz",
      "integrity": "sha512-7MptL8U0cqcFdzIzwOTHoilX9x5BrNqye7Z/LuC7kCMRio1EMSyqRK3BEAUD7sXRq4iT4AzTVuZdhgQ2TCvYLg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "^2.0.2",
        "@nodelib/fs.walk": "^1.2.3",
        "glob-parent": "^5.1.2",
        "merge2": "^1.3.0",
        "micromatch": "^4.0.8"
      },
      "engines": {
        "node": ">=8.6.0"
      }
    },
    "node_modules/fast-glob/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fastparse": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/fastparse/-/fastparse-1.1.2.tgz",
      "integrity": "sha512-483XLLxTVIwWK3QTrMGRqUfUpoOs/0hbQrl2oz4J0pAcm3A3bu84wxTFqGqkJzewCLdME38xJLJAxBABfQT8sQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fastq": {
      "version": "1.20.1",
      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.20.1.tgz",
      "integrity": "sha512-GGToxJ/w1x32s/D2EKND7kTil4n8OVk/9mycTc4VDza13lOvpUZTGX3mFSCtV9ksdGBVzvsyAVLM6mHFThxXxw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "reusify": "^1.0.4"
      }
    },
    "node_modules/file-entry-cache": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-8.0.0.tgz",
      "integrity": "sha512-XXTUwCvisa5oacNGRP9SfNtYBNAMi+RPwBFmblZEF7N7swHYQS6/Zfk7SRwx4D5j3CH211YNRco1DEMNVfZCnQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flat-cache": "^4.0.0"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/find-up": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
      "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "locate-path": "^6.0.0",
        "path-exists": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/flat-cache": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-4.0.1.tgz",
      "integrity": "sha512-f7ccFPK3SXFHpx15UIGyRJ/FJQctuKZ0zVuN3frBo4HnK3cay9VEW0R6yPYFHC0AgqhukPzKjq22t5DmAyqGyw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flatted": "^3.2.9",
        "keyv": "^4.5.4"
      },
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/flatted": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.3.3.tgz",
      "integrity": "sha512-GX+ysw4PBCz0PzosHDepZGANEuFCMLrnRTiEy9McGjmkCQYwRq4A/X786G/fjM/+OjsWSU1ZrY5qyARZmO/uwg==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/follow-redirects": {
      "version": "1.15.11",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.11.tgz",
      "integrity": "sha512-deG2P0JfjrTxl50XGCDyfI97ZGVCxIpfKYmfyrQ54n5FO/0gfIES8C/Psl6kWVDolizcaaxZJnTS0QSMxvnsBQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/RubenVerborgh"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=4.0"
      },
      "peerDependenciesMeta": {
        "debug": {
          "optional": true
        }
      }
    },
    "node_modules/form-data": {
      "version": "4.0.5",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.5.tgz",
      "integrity": "sha512-8RipRLol37bNs2bhoV67fiTEvdTrbMUYcFTiy3+wuuOnUog2QBHCZWXDRijWQfAkhBj2Uf5UnVaiWwA5vdd82w==",
      "license": "MIT",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "es-set-tostringtag": "^2.1.0",
        "hasown": "^2.0.2",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fraction.js": {
      "version": "5.3.4",
      "resolved": "https://registry.npmjs.org/fraction.js/-/fraction.js-5.3.4.tgz",
      "integrity": "sha512-1X1NTtiJphryn/uLQz3whtY6jK3fTqoE3ohKs0tT+Ujr1W59oopxmoEh7Lu5p6vBaPbgoM0bzveAW4Qi5RyWDQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "*"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/rawify"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gensync": {
      "version": "1.0.0-beta.2",
      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
      "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/glob-parent": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
      "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.3"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/globals": {
      "version": "16.5.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-16.5.0.tgz",
      "integrity": "sha512-c/c15i26VrJ4IRt5Z89DnIzCGDn9EcebibhAOjw5ibqEHsE1wLUgkPn9RDmNcUKyU87GeaL633nyJ+pplFR2ZQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/hermes-estree": {
      "version": "0.25.1",
      "resolved": "https://registry.npmjs.org/hermes-estree/-/hermes-estree-0.25.1.tgz",
      "integrity": "sha512-0wUoCcLp+5Ev5pDW2OriHC2MJCbwLwuRx+gAqMTOkGKJJiBCLjtrvy4PWUGn6MIVefecRpzoOZ/UV6iGdOr+Cw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/hermes-parser": {
      "version": "0.25.1",
      "resolved": "https://registry.npmjs.org/hermes-parser/-/hermes-parser-0.25.1.tgz",
      "integrity": "sha512-6pEjquH3rqaI6cYAXYPcz9MS4rY6R4ngRgrgfDshRptUZIc3lw0MCIJIGDj9++mfySOuPTHB4nrSW99BCvOPIA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hermes-estree": "0.25.1"
      }
    },
    "node_modules/ignore": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
      "integrity": "sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/import-fresh": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.1.tgz",
      "integrity": "sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/imurmurhash": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
      "integrity": "sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.8.19"
      }
    },
    "node_modules/is-binary-path": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "binary-extensions": "^2.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-core-module": {
      "version": "2.16.1",
      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz",
      "integrity": "sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/jiti": {
      "version": "1.21.7",
      "resolved": "https://registry.npmjs.org/jiti/-/jiti-1.21.7.tgz",
      "integrity": "sha512-/imKNG4EbWNrVjoNC/1H5/9GFy+tqjGBHCaSsN+P2RnPqjsLmv6UD3Ej+Kj8nBWaRAwyk7kK5ZUc+OEatnTR3A==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "bin": {
        "jiti": "bin/jiti.js"
      }
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/js-yaml": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
      "integrity": "sha512-qQKT4zQxXl8lLwBtHMWwaTcGfFOZviOJet3Oy/xmGk2gZH677CJM9EvtfdSkgWcATZhj/55JZ0rmy3myCT5lsA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/jsesc": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-3.1.0.tgz",
      "integrity": "sha512-/sM3dO2FOzXjKQhJuo0Q173wf2KOo8t4I8vHy6lF9poUp7bKT0/NHE8fPX23PwfhnykfqnC2xRxOnVw5XuGIaA==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "jsesc": "bin/jsesc"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/json-buffer": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/json-buffer/-/json-buffer-3.0.1.tgz",
      "integrity": "sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-stable-stringify-without-jsonify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
      "integrity": "sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json5": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
      "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "json5": "lib/cli.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/keyv": {
      "version": "4.5.4",
      "resolved": "https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz",
      "integrity": "sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "json-buffer": "3.0.1"
      }
    },
    "node_modules/levn": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1",
        "type-check": "~0.4.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/lilconfig": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/lilconfig/-/lilconfig-3.1.3.tgz",
      "integrity": "sha512-/vlFKAoH5Cgt3Ie+JLhRbwOsCQePABiU3tJ1egGvyQ+33R/vcwM2Zl2QR/LzjsBeItPt3oSVXapn+m4nQDvpzw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/antonk52"
      }
    },
    "node_modules/lines-and-columns": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz",
      "integrity": "sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/locate-path": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
      "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-locate": "^5.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lodash.merge": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/lru-cache": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
      "integrity": "sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "yallist": "^3.0.2"
      }
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/merge2": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/micromatch": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz",
      "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "braces": "^3.0.3",
        "picomatch": "^2.3.1"
      },
      "engines": {
        "node": ">=8.6"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/mz": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/mz/-/mz-2.7.0.tgz",
      "integrity": "sha512-z81GNO7nnYMEhrGh9LeymoE4+Yr0Wn5McHIZMK5cfQCl+NDX08sCZgUc9/6MHni9IWuFLm1Z3HTCXu2z9fN62Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "any-promise": "^1.0.0",
        "object-assign": "^4.0.1",
        "thenify-all": "^1.0.0"
      }
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/natural-compare": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
      "integrity": "sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/node-releases": {
      "version": "2.0.27",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.27.tgz",
      "integrity": "sha512-nmh3lCkYZ3grZvqcCH+fjmQ7X+H0OeZgP40OierEaAptX4XofMh5kwNbWh7lBduUzCcV/8kZ+NDLCwm2iorIlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-hash": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/object-hash/-/object-hash-3.0.0.tgz",
      "integrity": "sha512-RSn9F68PjH9HqtltsSnqYC1XXoWe9Bju5+213R98cNGttag9q9yAOTzdbsqvIa7aNm5WffBZFpWYr2aWrklWAw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/optionator": {
      "version": "0.9.4",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.4.tgz",
      "integrity": "sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "deep-is": "^0.1.3",
        "fast-levenshtein": "^2.0.6",
        "levn": "^0.4.1",
        "prelude-ls": "^1.2.1",
        "type-check": "^0.4.0",
        "word-wrap": "^1.2.5"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/p-limit": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "yocto-queue": "^0.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-locate": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
      "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-limit": "^3.0.2"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "callsites": "^3.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/path-exists": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/pify": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/pify/-/pify-2.3.0.tgz",
      "integrity": "sha512-udgsAY+fTnvv7kI7aaxbqwWNb0AHiB0qBO89PZKPkoTmGOgdbrHDKD+0B2X4uTfJ/FT1R09r9gTsjUjNJotuog==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/pirates": {
      "version": "4.0.7",
      "resolved": "https://registry.npmjs.org/pirates/-/pirates-4.0.7.tgz",
      "integrity": "sha512-TfySrs/5nm8fQJDcBDuUng3VOUKsd7S+zqvbOTiGXHfxX4wK31ard+hoNuvkicM/2YFzlpDgABOevKSsB4G/FA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/postcss-import": {
      "version": "15.1.0",
      "resolved": "https://registry.npmjs.org/postcss-import/-/postcss-import-15.1.0.tgz",
      "integrity": "sha512-hpr+J05B2FVYUAXHeK1YyI267J/dDDhMU6B6civm8hSY1jYJnBXxzKDKDswzJmtLHryrjhnDjqqp/49t8FALew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "postcss-value-parser": "^4.0.0",
        "read-cache": "^1.0.0",
        "resolve": "^1.1.7"
      },
      "engines": {
        "node": ">=14.0.0"
      },
      "peerDependencies": {
        "postcss": "^8.0.0"
      }
    },
    "node_modules/postcss-js": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/postcss-js/-/postcss-js-4.1.0.tgz",
      "integrity": "sha512-oIAOTqgIo7q2EOwbhb8UalYePMvYoIeRY2YKntdpFQXNosSu3vLrniGgmH9OKs/qAkfoj5oB3le/7mINW1LCfw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "camelcase-css": "^2.0.1"
      },
      "engines": {
        "node": "^12 || ^14 || >= 16"
      },
      "peerDependencies": {
        "postcss": "^8.4.21"
      }
    },
    "node_modules/postcss-load-config": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/postcss-load-config/-/postcss-load-config-6.0.1.tgz",
      "integrity": "sha512-oPtTM4oerL+UXmx+93ytZVN82RrlY/wPUV8IeDxFrzIjXOLF1pN+EmKPLbubvKHT2HC20xXsCAH2Z+CKV6Oz/g==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "lilconfig": "^3.1.1"
      },
      "engines": {
        "node": ">= 18"
      },
      "peerDependencies": {
        "jiti": ">=1.21.0",
        "postcss": ">=8.0.9",
        "tsx": "^4.8.1",
        "yaml": "^2.4.2"
      },
      "peerDependenciesMeta": {
        "jiti": {
          "optional": true
        },
        "postcss": {
          "optional": true
        },
        "tsx": {
          "optional": true
        },
        "yaml": {
          "optional": true
        }
      }
    },
    "node_modules/postcss-nested": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/postcss-nested/-/postcss-nested-6.2.0.tgz",
      "integrity": "sha512-HQbt28KulC5AJzG+cZtj9kvKB93CFCdLvog1WFLf1D+xmMvPGlBstkpTEZfK5+AN9hfJocyBFCNiqyS48bpgzQ==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "postcss-selector-parser": "^6.1.1"
      },
      "engines": {
        "node": ">=12.0"
      },
      "peerDependencies": {
        "postcss": "^8.2.14"
      }
    },
    "node_modules/postcss-selector-parser": {
      "version": "6.1.2",
      "resolved": "https://registry.npmjs.org/postcss-selector-parser/-/postcss-selector-parser-6.1.2.tgz",
      "integrity": "sha512-Q8qQfPiZ+THO/3ZrOrO0cJJKfpYCagtMUkXbnEfmgUjwXg6z/WBeOyS9APBBPCTSiDV+s4SwQGu8yFsiMRIudg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cssesc": "^3.0.0",
        "util-deprecate": "^1.0.2"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/postcss-value-parser": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-4.2.0.tgz",
      "integrity": "sha512-1NNCs6uurfkVbeXG4S8JFT9t19m45ICnif8zWLd5oPSZ50QnwMfK+H3jv408d4jw/7Bttv5axS5IiHoLaVNHeQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/prelude-ls": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/proxy-from-env": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/proxy-from-env/-/proxy-from-env-1.1.0.tgz",
      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==",
      "license": "MIT"
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/queue-microtask": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
      "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/react": {
      "version": "19.2.4",
      "resolved": "https://registry.npmjs.org/react/-/react-19.2.4.tgz",
      "integrity": "sha512-9nfp2hYpCwOjAN+8TZFGhtWEwgvWHXqESH8qT89AT/lWklpLON22Lc8pEtnpsZz7VmawabSU0gCjnj8aC0euHQ==",
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-dom": {
      "version": "19.2.4",
      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-19.2.4.tgz",
      "integrity": "sha512-AXJdLo8kgMbimY95O2aKQqsz2iWi9jMgKJhRBAxECE4IFxfcazB2LmzloIoibJI3C12IlY20+KFaLv+71bUJeQ==",
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "scheduler": "^0.27.0"
      },
      "peerDependencies": {
        "react": "^19.2.4"
      }
    },
    "node_modules/react-hook-form": {
      "version": "7.71.1",
      "resolved": "https://registry.npmjs.org/react-hook-form/-/react-hook-form-7.71.1.tgz",
      "integrity": "sha512-9SUJKCGKo8HUSsCO+y0CtqkqI5nNuaDqTxyqPsZPqIwudpj4rCrAz/jZV+jn57bx5gtZKOh3neQu94DXMc+w5w==",
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/react-hook-form"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17 || ^18 || ^19"
      }
    },
    "node_modules/react-refresh": {
      "version": "0.18.0",
      "resolved": "https://registry.npmjs.org/react-refresh/-/react-refresh-0.18.0.tgz",
      "integrity": "sha512-QgT5//D3jfjJb6Gsjxv0Slpj23ip+HtOpnNgnb2S5zU3CB26G/IDPGoy4RJB42wzFE46DRsstbW6tKHoKbhAxw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-router": {
      "version": "7.13.0",
      "resolved": "https://registry.npmjs.org/react-router/-/react-router-7.13.0.tgz",
      "integrity": "sha512-PZgus8ETambRT17BUm/LL8lX3Of+oiLaPuVTRH3l1eLvSPpKO3AvhAEb5N7ihAFZQrYDqkvvWfFh9p0z9VsjLw==",
      "license": "MIT",
      "dependencies": {
        "cookie": "^1.0.1",
        "set-cookie-parser": "^2.6.0"
      },
      "engines": {
        "node": ">=20.0.0"
      },
      "peerDependencies": {
        "react": ">=18",
        "react-dom": ">=18"
      },
      "peerDependenciesMeta": {
        "react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/react-router-dom": {
      "version": "7.13.0",
      "resolved": "https://registry.npmjs.org/react-router-dom/-/react-router-dom-7.13.0.tgz",
      "integrity": "sha512-5CO/l5Yahi2SKC6rGZ+HDEjpjkGaG/ncEP7eWFTvFxbHP8yeeI0PxTDjimtpXYlR3b3i9/WIL4VJttPrESIf2g==",
      "license": "MIT",
      "dependencies": {
        "react-router": "7.13.0"
      },
      "engines": {
        "node": ">=20.0.0"
      },
      "peerDependencies": {
        "react": ">=18",
        "react-dom": ">=18"
      }
    },
    "node_modules/read-cache": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/read-cache/-/read-cache-1.0.0.tgz",
      "integrity": "sha512-Owdv/Ft7IjOgm/i0xvNDZ1LrRANRfew4b2prF3OWMQLxLfu3bS8FVhCsrSCMK4lR56Y9ya+AThoTpDCTxCmpRA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "pify": "^2.3.0"
      }
    },
    "node_modules/readdirp": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "picomatch": "^2.2.1"
      },
      "engines": {
        "node": ">=8.10.0"
      }
    },
    "node_modules/resolve": {
      "version": "1.22.11",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.11.tgz",
      "integrity": "sha512-RfqAvLnMl313r7c9oclB1HhUEAezcpLjz95wFH4LVuhk9JF/r22qmVP9AMmOU4vMX7Q8pN8jwNg/CSpdFnMjTQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.16.1",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/reusify": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.1.0.tgz",
      "integrity": "sha512-g6QUff04oZpHs0eG5p83rFLhHeV00ug/Yf9nZM6fLeUrPguBTkTQOdpAWWspMh55TZfVQDPaN3NQJfbVRAxdIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "iojs": ">=1.0.0",
        "node": ">=0.10.0"
      }
    },
    "node_modules/rollup": {
      "version": "4.58.0",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.58.0.tgz",
      "integrity": "sha512-wbT0mBmWbIvvq8NeEYWWvevvxnOyhKChir47S66WCxw1SXqhw7ssIYejnQEVt7XYQpsj2y8F9PM+Cr3SNEa0gw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.58.0",
        "@rollup/rollup-android-arm64": "4.58.0",
        "@rollup/rollup-darwin-arm64": "4.58.0",
        "@rollup/rollup-darwin-x64": "4.58.0",
        "@rollup/rollup-freebsd-arm64": "4.58.0",
        "@rollup/rollup-freebsd-x64": "4.58.0",
        "@rollup/rollup-linux-arm-gnueabihf": "4.58.0",
        "@rollup/rollup-linux-arm-musleabihf": "4.58.0",
        "@rollup/rollup-linux-arm64-gnu": "4.58.0",
        "@rollup/rollup-linux-arm64-musl": "4.58.0",
        "@rollup/rollup-linux-loong64-gnu": "4.58.0",
        "@rollup/rollup-linux-loong64-musl": "4.58.0",
        "@rollup/rollup-linux-ppc64-gnu": "4.58.0",
        "@rollup/rollup-linux-ppc64-musl": "4.58.0",
        "@rollup/rollup-linux-riscv64-gnu": "4.58.0",
        "@rollup/rollup-linux-riscv64-musl": "4.58.0",
        "@rollup/rollup-linux-s390x-gnu": "4.58.0",
        "@rollup/rollup-linux-x64-gnu": "4.58.0",
        "@rollup/rollup-linux-x64-musl": "4.58.0",
        "@rollup/rollup-openbsd-x64": "4.58.0",
        "@rollup/rollup-openharmony-arm64": "4.58.0",
        "@rollup/rollup-win32-arm64-msvc": "4.58.0",
        "@rollup/rollup-win32-ia32-msvc": "4.58.0",
        "@rollup/rollup-win32-x64-gnu": "4.58.0",
        "@rollup/rollup-win32-x64-msvc": "4.58.0",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/run-parallel": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
      "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "queue-microtask": "^1.2.2"
      }
    },
    "node_modules/scheduler": {
      "version": "0.27.0",
      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.27.0.tgz",
      "integrity": "sha512-eNv+WrVbKu1f3vbYJT/xtiF5syA5HPIMtf9IgY/nKg0sWqzAUEvqY/xm7OcZc/qafLx/iO9FgOmeSAp4v5ti/Q==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/set-cookie-parser": {
      "version": "2.7.2",
      "resolved": "https://registry.npmjs.org/set-cookie-parser/-/set-cookie-parser-2.7.2.tgz",
      "integrity": "sha512-oeM1lpU/UvhTxw+g3cIfxXHyJRc/uidd3yK1P242gzHds0udQBYzs3y8j4gCCW+ZJ7ad0yctld8RYO+bdurlvw==",
      "license": "MIT"
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/sonner": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/sonner/-/sonner-2.0.7.tgz",
      "integrity": "sha512-W6ZN4p58k8aDKA4XPcx2hpIQXBRAgyiWVkYhT7CvK6D3iAu7xjvVyhQHg2/iaKJZ1XVJ4r7XuwGL+WGEK37i9w==",
      "license": "MIT",
      "peerDependencies": {
        "react": "^18.0.0 || ^19.0.0 || ^19.0.0-rc",
        "react-dom": "^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/sucrase": {
      "version": "3.35.1",
      "resolved": "https://registry.npmjs.org/sucrase/-/sucrase-3.35.1.tgz",
      "integrity": "sha512-DhuTmvZWux4H1UOnWMB3sk0sbaCVOoQZjv8u1rDoTV0HTdGem9hkAZtl4JZy8P2z4Bg0nT+YMeOFyVr4zcG5Tw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.2",
        "commander": "^4.0.0",
        "lines-and-columns": "^1.1.6",
        "mz": "^2.7.0",
        "pirates": "^4.0.1",
        "tinyglobby": "^0.2.11",
        "ts-interface-checker": "^0.1.9"
      },
      "bin": {
        "sucrase": "bin/sucrase",
        "sucrase-node": "bin/sucrase-node"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      }
    },
    "node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/supports-preserve-symlinks-flag": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/tabbable": {
      "version": "6.4.0",
      "resolved": "https://registry.npmjs.org/tabbable/-/tabbable-6.4.0.tgz",
      "integrity": "sha512-05PUHKSNE8ou2dwIxTngl4EzcnsCDZGJ/iCLtDflR/SHB/ny14rXc+qU5P4mG9JkusiV7EivzY9Mhm55AzAvCg==",
      "license": "MIT"
    },
    "node_modules/tailwindcss": {
      "version": "3.4.19",
      "resolved": "https://registry.npmjs.org/tailwindcss/-/tailwindcss-3.4.19.tgz",
      "integrity": "sha512-3ofp+LL8E+pK/JuPLPggVAIaEuhvIz4qNcf3nA1Xn2o/7fb7s/TYpHhwGDv1ZU3PkBluUVaF8PyCHcm48cKLWQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@alloc/quick-lru": "^5.2.0",
        "arg": "^5.0.2",
        "chokidar": "^3.6.0",
        "didyoumean": "^1.2.2",
        "dlv": "^1.1.3",
        "fast-glob": "^3.3.2",
        "glob-parent": "^6.0.2",
        "is-glob": "^4.0.3",
        "jiti": "^1.21.7",
        "lilconfig": "^3.1.3",
        "micromatch": "^4.0.8",
        "normalize-path": "^3.0.0",
        "object-hash": "^3.0.0",
        "picocolors": "^1.1.1",
        "postcss": "^8.4.47",
        "postcss-import": "^15.1.0",
        "postcss-js": "^4.0.1",
        "postcss-load-config": "^4.0.2 || ^5.0 || ^6.0",
        "postcss-nested": "^6.2.0",
        "postcss-selector-parser": "^6.1.2",
        "resolve": "^1.22.8",
        "sucrase": "^3.35.0"
      },
      "bin": {
        "tailwind": "lib/cli.js",
        "tailwindcss": "lib/cli.js"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/thenify": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/thenify/-/thenify-3.3.1.tgz",
      "integrity": "sha512-RVZSIV5IG10Hk3enotrhvz0T9em6cyHBLkH/YAZuKqd8hRkKhSfCGIcP2KUY0EPxndzANBmNllzWPwak+bheSw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "any-promise": "^1.0.0"
      }
    },
    "node_modules/thenify-all": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/thenify-all/-/thenify-all-1.6.0.tgz",
      "integrity": "sha512-RNxQH/qI8/t3thXJDwcstUO4zeqo64+Uy/+sNVRBx4Xn2OX+OZ9oP+iJnNFqplFra2ZUVeKCSa2oVWi3T4uVmA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "thenify": ">= 3.1.0 < 4"
      },
      "engines": {
        "node": ">=0.8"
      }
    },
    "node_modules/tinyglobby": {
      "version": "0.2.15",
      "resolved": "https://registry.npmjs.org/tinyglobby/-/tinyglobby-0.2.15.tgz",
      "integrity": "sha512-j2Zq4NyQYG5XMST4cbs02Ak8iJUdxRM0XI5QyxXuZOzKOINmWurp3smXu3y5wDcJrptwpSjgXHzIQxR0omXljQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fdir": "^6.5.0",
        "picomatch": "^4.0.3"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/SuperchupuDev"
      }
    },
    "node_modules/tinyglobby/node_modules/fdir": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/tinyglobby/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/ts-interface-checker": {
      "version": "0.1.13",
      "resolved": "https://registry.npmjs.org/ts-interface-checker/-/ts-interface-checker-0.1.13.tgz",
      "integrity": "sha512-Y/arvbn+rrz3JCKl9C4kVNfTfSm2/mEp5FSz5EsZSANGPSlQrpRI5M4PKF+mJnE52jOO90PnPSc3Ur3bTQw0gA==",
      "dev": true,
      "license": "Apache-2.0"
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/type-check": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/update-browserslist-db": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.2.3.tgz",
      "integrity": "sha512-Js0m9cx+qOgDxo0eMiFGEueWztz+d4+M3rGlmKPT+T4IS/jP4ylw3Nwpu6cpTTP8R1MAC1kF4VbdLt3ARf209w==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "escalade": "^3.2.0",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "update-browserslist-db": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/uri-js": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "punycode": "^2.1.0"
      }
    },
    "node_modules/use-debounce": {
      "version": "10.1.0",
      "resolved": "https://registry.npmjs.org/use-debounce/-/use-debounce-10.1.0.tgz",
      "integrity": "sha512-lu87Za35V3n/MyMoEpD5zJv0k7hCn0p+V/fK2kWD+3k2u3kOCwO593UArbczg1fhfs2rqPEnHpULJ3KmGdDzvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 16.0.0"
      },
      "peerDependencies": {
        "react": "*"
      }
    },
    "node_modules/use-sync-external-store": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/use-sync-external-store/-/use-sync-external-store-1.6.0.tgz",
      "integrity": "sha512-Pp6GSwGP/NrPIrxVFAIkOQeyw8lFenOHijQWkUTrDvrF4ALqylP2C/KCkeS9dpUM3KvYRQhna5vt7IL95+ZQ9w==",
      "license": "MIT",
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/vite": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/vite/-/vite-7.3.1.tgz",
      "integrity": "sha512-w+N7Hifpc3gRjZ63vYBXA56dvvRlNWRczTdmCBBa+CotUzAPf5b7YMdMR/8CQoeYE5LX3W4wj6RYTgonm1b9DA==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "esbuild": "^0.27.0",
        "fdir": "^6.5.0",
        "picomatch": "^4.0.3",
        "postcss": "^8.5.6",
        "rollup": "^4.43.0",
        "tinyglobby": "^0.2.15"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^20.19.0 || >=22.12.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^20.19.0 || >=22.12.0",
        "jiti": ">=1.21.0",
        "less": "^4.0.0",
        "lightningcss": "^1.21.0",
        "sass": "^1.70.0",
        "sass-embedded": "^1.70.0",
        "stylus": ">=0.54.8",
        "sugarss": "^5.0.0",
        "terser": "^5.16.0",
        "tsx": "^4.8.1",
        "yaml": "^2.4.2"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "jiti": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        },
        "tsx": {
          "optional": true
        },
        "yaml": {
          "optional": true
        }
      }
    },
    "node_modules/vite/node_modules/fdir": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/vite/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/word-wrap": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz",
      "integrity": "sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/yallist": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
      "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/yocto-queue": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/zod": {
      "version": "4.3.6",
      "resolved": "https://registry.npmjs.org/zod/-/zod-4.3.6.tgz",
      "integrity": "sha512-rftlrkhHZOcjDwkGlnUtZZkvaPHCsDATp4pGpuOOMDaTdDDXF91wuVDJoWoPsKX/3YPQ5fHuF3STjcYyKr+Qhg==",
      "license": "MIT",
      "peer": true,
      "funding": {
        "url": "https://github.com/sponsors/colinhacks"
      }
    },
    "node_modules/zod-validation-error": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/zod-validation-error/-/zod-validation-error-4.0.2.tgz",
      "integrity": "sha512-Q6/nZLe6jxuU80qb/4uJ4t5v2VEZ44lzQjPDhYJNztRQ4wyWc6VF3D3Kb/fAuPetZQnhS3hnajCf9CsWesghLQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18.0.0"
      },
      "peerDependencies": {
        "zod": "^3.25.0 || ^4.0.0"
      }
    },
    "node_modules/zustand": {
      "version": "5.0.11",
      "resolved": "https://registry.npmjs.org/zustand/-/zustand-5.0.11.tgz",
      "integrity": "sha512-fdZY+dk7zn/vbWNCYmzZULHRrss0jx5pPFiOuMZ/5HJN6Yv3u+1Wswy/4MpZEkEGhtNH+pwxZB8OKgUBPzYAGg==",
      "license": "MIT",
      "engines": {
        "node": ">=12.20.0"
      },
      "peerDependencies": {
        "@types/react": ">=18.0.0",
        "immer": ">=9.0.6",
        "react": ">=18.0.0",
        "use-sync-external-store": ">=1.2.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "immer": {
          "optional": true
        },
        "react": {
          "optional": true
        },
        "use-sync-external-store": {
          "optional": true
        }
      }
    }
  }
}


File: dashboard/src/components/AdminHeader.jsx
================================================
// src/components/AdminHeader.jsx
import React from "react";
import { Link, useNavigate } from "react-router-dom";
import { useAuthStore } from "../stores/authStore"; // Import the store
import { logout as logoutApiCall } from "../services/api"; // Import the logout API function
import { ArrowRightStartOnRectangleIcon } from "@heroicons/react/24/outline"; // Import logout icon
import Logo from "../assets/admin.png";

const AdminHeader = () => {
  const navigate = useNavigate(); // Hook for programmatic navigation
  const { logout: logoutAction } = useAuthStore(); // Get the Zustand logout action

  const handleLogout = async () => { // Make function async
    try {
      // Call the API endpoint to revoke the refresh token (uses cookie automatically)
      await logoutApiCall();
    } catch (err) {
      console.error("Logout API call failed:", err);
      // Even if API call fails, clear local state to log user out locally
    } finally {
      // Clear Zustand state and localStorage regardless of API call outcome
      logoutAction();
      // Navigate to login page
      navigate("/auth/login", { replace: true }); // Adjust route as needed
    }
  };

  return (
    <header className="navbar bg-secondary-content border-b border-accent">
      <div className="navbar-start">
        <label
          htmlFor="sidebar-drawer"
          className="btn btn-square btn-ghost lg:hidden"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            className="inline-block w-6 h-6 stroke-current"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              d="M4 6h16M4 12h16M4 18h16"
            >
            </path>
          </svg>
        </label>
      </div>
      <div className="navbar-center">
        <Link
          to="/admin/dashboard"
          className="btn btn-ghost text-xl normal-case"
        >
          YC-Informatique Admin
        </Link>
      </div>
      <div className="navbar-end">
        <div className="dropdown avatar dropdown-end">
          <label tabIndex={0} className="btn btn-secondary btn-circle avatar">
            <div className="w-24 rounded-full">
              <img src={Logo} />
            </div>
          </label>
          <ul
            tabIndex={0}
            className="menu menu-sm dropdown-content mt-3 z-[1] p-2 shadow bg-neutral rounded-box w-52"
          >
            <li>
              <a onClick={handleLogout} className="flex items-center gap-2">
                {/* Add onClick handler */}
                <ArrowRightStartOnRectangleIcon className="w-4 h-4" /> Logout
                {" "}
                {/* Add icon */}
              </a>
            </li>
          </ul>
        </div>
      </div>
    </header>
  );
};

export default AdminHeader;


File: dashboard/src/pages/orders/OrderDetails.jsx
================================================
// src/pages/orders/OrderDetails.jsx
import React, { useState } from "react";
import { Link, useParams } from "react-router-dom";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import {
  cancelOrder,
  fetchOrderById,
  updateOrderStatus,
} from "../../services/api";
import { ArrowLeftIcon } from "@heroicons/react/24/outline";
import { toast } from "sonner";

const OrderDetails = () => {
  const { id: orderId } = useParams();
  const queryClient = useQueryClient();

  // State for status update dropdown
  const [newStatus, setNewStatus] = useState("");

  const {
    data: orderData,
    isLoading,
    isError,
    error,
    refetch,
  } = useQuery({
    queryKey: ["order", orderId],
    queryFn: async () => {
      const response = await fetchOrderById(orderId);
      return response;
    },
    select: (response) => {
      const selectedData = response.data; // This is { order: { ... }, items: [...] }
      return selectedData; // Return the whole object
    },
    enabled: !!orderId,
  });

  // Destructure the order summary and items from the fetched data
  const { order: orderSummary, items: orderItems } = orderData || {}; // Use optional chaining in case orderData is initially undefined

  const updateStatusMutation = useMutation({
    // Adjust the mutation function if the API response structure for status update is also nested
    // mutationFn: ({ id, status }) => updateOrderStatus(id, { status }).then(res => res.data), // Example if update also returns { data: { order: {...}, items: [...] } }
    mutationFn: ({ id, status }) => updateOrderStatus(id, { status }), // Keep as is if update returns the plain response or a different structure
    onSuccess: (data) => { // 'data' here will be the response from updateOrderStatus
      // Invalidate and refetch the specific order and the list
      queryClient.invalidateQueries({ queryKey: ["order", orderId] });
      queryClient.invalidateQueries({ queryKey: ["orders"] });
      toast.success("Order status updated successfully!");
      refetch(); // Refetch the order details after successful update
    },
    onError: (error) => {
      console.error("Update Status Error:", error);
      toast.error(
        `Failed to update status: ${error.message || "Unknown error"}`,
      );
    },
  });

  const cancelOrderMutation = useMutation({
    // Adjust the mutation function if the API response structure for cancel is also nested
    // mutationFn: cancelOrder.then(res => res.data), // Example if cancel also returns { data: { order: {...}, items: [...] } }
    mutationFn: cancelOrder, // Keep as is if cancel returns the plain response or a different structure
    onSuccess: (data, cancelledOrderId) => { // 'data' here will be the response from cancelOrder
      // Invalidate and refetch the specific order and the list
      queryClient.invalidateQueries({ queryKey: ["order", cancelledOrderId] });
      queryClient.invalidateQueries({ queryKey: ["orders"] });
      toast.success("Order cancelled successfully!");
      refetch(); // Refetch the order details after successful cancellation
    },
    onError: (error) => {
      console.error("Cancel Order Error:", error);
      toast.error(
        `Failed to cancel order: ${error.message || "Unknown error"}`,
      );
    },
  });

  // Handler for status update submission
  const handleStatusUpdate = (e) => {
    e.preventDefault();
    if (!newStatus || !orderSummary) return;

    console.log(
      `Attempting to update order ${orderId} to status: ${newStatus}`,
    );
    updateStatusMutation.mutate({ id: orderId, status: newStatus });
  };

  // Handler for cancel order confirmation
  const handleCancelOrder = () => {
    if (!orderSummary) return;

    if (
      window.confirm(
        `Are you sure you want to cancel order ${orderSummary.id}?`,
      )
    ) {
      console.log(`Attempting to cancel order ${orderId}`);
      cancelOrderMutation.mutate(orderId);
    }
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  }

  if (isError) {
    return (
      <div className="alert alert-error">
        Error loading order: {error.message}
        <Link to="/admin/orders" className="btn btn-sm ml-4">
          Go Back to List
        </Link>
      </div>
    );
  }

  if (!orderSummary) { // Check for the existence of the order summary object
    return (
      <div className="alert alert-warning">
        Order not found.
        <Link to="/admin/orders" className="btn btn-sm ml-4">
          Go Back to List
        </Link>
      </div>
    );
  }

  // Helper function to truncate UUID
  const truncateUuid = (uuid) => {
    if (!uuid || typeof uuid !== "string") return "N/A";
    return `${uuid.substring(0, 8)}...`;
  };

  // Calculate totals using the orderItems array
  const subtotalCents = orderItems?.reduce(
    (sum, item) => sum + (item.price_cents * item.quantity),
    0,
  ) || 0;
  const discountTotalCents = orderSummary.discount_amount_cents || 0; // Adjust field name if different
  const deliveryCostCents = orderSummary.delivery_service?.base_cost_cents || 0; // Adjust field name if different
  const totalCents = subtotalCents - discountTotalCents + deliveryCostCents;

  // --- Determine valid status transitions based on backend rules ---
  const getStatusOptions = (currentStatus) => {
    switch (currentStatus) {
      case "pending":
        return ["confirmed", "cancelled"];
      case "confirmed":
        return ["shipped", "cancelled"];
      case "shipped":
        return ["delivered"];
      case "delivered":
      case "cancelled":
        return []; // No further transitions allowed
      default:
        return []; // For unknown statuses, allow none
    }
  };

  const validStatusOptions = getStatusOptions(orderSummary.status);

  // Determine if cancellation is allowed (based on backend rules - only from pending or confirmed)
  const canCancel = orderSummary.status === "pending" ||
    orderSummary.status === "confirmed";

  return (
    // ... (JSX remains mostly the same) ...
    <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
      <Link to="/admin/orders" className="btn btn-accent btn-outline mb-6">
        <ArrowLeftIcon className="h-4 w-4 mr-2" />
        Back to Orders
      </Link>

      <div className="divider"></div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
        {/* Left Column: Order Summary */}
        <div className="lg:col-span-2">
          <div className="bg-neutral p-6 rounded-lg shadow-md mb-6">
            <h2 className="text-xl font-bold mb-4">
              Order #{truncateUuid(orderSummary.id)}
            </h2>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <p>
                  <strong>Status:</strong>{" "}
                  <span
                    className={`badge ${
                      orderSummary.status === "pending"
                        ? "badge-warning"
                        : orderSummary.status === "confirmed"
                        ? "badge-info"
                        : orderSummary.status === "shipped"
                        ? "badge-primary"
                        : orderSummary.status === "delivered"
                        ? "badge-success"
                        : "badge-error"
                    }`}
                  >
                    {orderSummary.status}
                  </span>
                </p>
                <p>
                  <strong>Date:</strong>{" "}
                  {new Date(orderSummary.created_at).toLocaleString()}
                </p>
                {orderSummary.cancelled_at && (
                  <p>
                    <strong>Cancelled At:</strong>{" "}
                    {new Date(orderSummary.cancelled_at).toLocaleString()}
                  </p>
                )}
              </div>
              <div>
                <p>
                  <strong>User:</strong> {orderSummary.user_full_name || "N/A"}
                </p>
                <p>
                  <strong>User ID:</strong> {truncateUuid(orderSummary.user_id)}
                </p>
              </div>
            </div>
          </div>

          {/* Order Items Table */}
          <div className="bg-neutral p-6 rounded-lg shadow-md mb-6">
            <h3 className="text-lg font-bold mb-4">Items</h3>
            <div className="overflow-x-auto">
              <table className="table">
                <thead>
                  <tr>
                    <th>Product</th>
                    <th>SKU/ID</th>
                    <th>Price (DZD)</th>
                    <th>Quantity</th>
                    <th>Total (DZD)</th>
                  </tr>
                </thead>
                <tbody>
                  {orderItems && orderItems.length > 0
                    ? (
                      orderItems.map((item) => (
                        <tr key={item.id}>
                          <td>{item.product_name}</td>
                          <td className="font-mono">
                            {truncateUuid(item.product_id)}
                          </td>
                          <td>{(item.price_cents / 100).toFixed(2)}</td>
                          <td>{item.quantity}</td>
                          <td>
                            {((item.price_cents * item.quantity) / 100).toFixed(
                              2,
                            )}
                          </td>
                        </tr>
                      ))
                    )
                    : (
                      <tr>
                        <td colSpan="5" className="text-center py-4">
                          No items found for this order.
                        </td>
                      </tr>
                    )}
                </tbody>
              </table>
            </div>
          </div>
        </div>

        {/* Right Column: Totals, Actions, Shipping, Payment */}
        <div>
          {/* Order Totals */}
          <div className="bg-neutral p-6 rounded-lg shadow-md mb-6">
            <h3 className="text-lg font-bold mb-4">Totals</h3>
            <div className="space-y-2">
              <div className="flex justify-between">
                <span>Subtotal:</span>
                <span>{(subtotalCents / 100).toFixed(2)}</span>
              </div>
              {discountTotalCents > 0 && (
                <div className="flex justify-between">
                  <span>Discount:</span>
                  <span>-{(discountTotalCents / 100).toFixed(2)}</span>
                </div>
              )}
              {deliveryCostCents > 0 && (
                <div className="flex justify-between">
                  <span>Delivery:</span>
                  <span>{(deliveryCostCents / 100).toFixed(2)}</span>
                </div>
              )}
              <div className="divider"></div>
              <div className="flex justify-between font-bold text-lg">
                <span>Total:</span>
                <span>{(totalCents / 100).toFixed(2)}</span>
              </div>
            </div>
          </div>

          {/* Status Update & Actions */}
          <div className="bg-neutral p-6 rounded-lg shadow-md mb-6">
            <h3 className="text-lg font-bold mb-4">Update Status</h3>
            <form onSubmit={handleStatusUpdate} className="space-y-2">
              <select
                className="select select-bordered w-full"
                value={newStatus}
                onChange={(e) => setNewStatus(e.target.value)}
                disabled={updateStatusMutation.isPending}
              >
                <option value="">Select new status...</option>
                {validStatusOptions.map((opt) => ( // Use filtered options
                  <option key={opt} value={opt}>
                    {opt.charAt(0).toUpperCase() + opt.slice(1)}{" "}
                    {/* Capitalize */}
                  </option>
                ))}
              </select>
              <button
                type="submit"
                className="btn btn-primary w-full"
                disabled={!newStatus || updateStatusMutation.isPending} // Disable if no status selected or mutation pending
              >
                {updateStatusMutation.isPending
                  ? (
                    <>
                      <span className="loading loading-spinner loading-xs mr-2">
                      </span>{" "}
                      Updating...
                    </>
                  )
                  : "Update Status"}
              </button>
            </form>
          </div>

          {/* Shipping Address */}
          <div className="bg-neutral p-6 rounded-lg shadow-md mb-6">
            <h3 className="text-lg font-bold mb-4">Shipping Address</h3>
            <p>{orderSummary.address_line_1}</p>
            {orderSummary.address_line_2 && <p>{orderSummary.address_line_2}
            </p>}
            <p>
              {orderSummary.city}, {orderSummary.province}{" "}
              {orderSummary.postal_code}
            </p>
            <p>{orderSummary.country}</p>
          </div>

          {/* Delivery Service */}
          <div className="bg-neutral p-6 rounded-lg shadow-md mb-6">
            <h3 className="text-lg font-bold mb-4">Delivery Service</h3>
            <p>
              <strong>ID:</strong>{" "}
              {truncateUuid(orderSummary.delivery_service_id)}
            </p>
          </div>

          {/* Payment Information (if available) */}
          <div className="bg-neutral p-6 rounded-lg shadow-md mb-6">
            <h3 className="text-lg font-bold mb-4">Payment Information</h3>
            <p>
              <strong>Method:</strong> {orderSummary.payment_method || "N/A"}
            </p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default OrderDetails;


File: dashboard/src/pages/delivery/AddDeliveryService.jsx
================================================
// src/pages/delivery/AddDeliveryService.jsx
import React from "react";
import { Link, useNavigate } from "react-router-dom";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { createDeliveryService } from "../../services/api";
import { ArrowLeftIcon } from "@heroicons/react/24/outline";
import { toast } from "sonner";

// Define the Zod schema for validation
const addDeliveryServiceSchema = z.object({
  name: z.string().min(1, { message: "Name is required." }),
  description: z.string().min(1, { message: "Description is required." }),
  base_cost_cents: z.number().int().min(0, {
    message: "Base cost must be zero or positive.",
  }),
  estimated_days: z.number().int().min(1, {
    message: "Estimated days must be at least 1.",
  }),
  is_active: z.boolean(), // Assuming this is a boolean in the form
});

const AddDeliveryService = () => {
  const navigate = useNavigate();
  const queryClient = useQueryClient();

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm({
    resolver: zodResolver(addDeliveryServiceSchema),
    defaultValues: {
      name: "",
      description: "",
      base_cost_cents: 0,
      estimated_days: 1,
      is_active: true,
    },
  });

  const createDeliveryServiceMutation = useMutation({
    mutationFn: createDeliveryService,
    onSuccess: (data) => {
      // Invalidate and refetch the delivery services list to include the new one
      queryClient.invalidateQueries({ queryKey: ["deliveryServices"] });
      toast.success("Delivery Service created successfully!");
      navigate("/admin/delivery"); // Redirect back to the list
    },
    onError: (error) => {
      console.error("Create Error:", error);
      toast.error(
        `Failed to create delivery service: ${
          error.message || "Unknown error"
        }`,
      );
    },
  });

  const onSubmit = (data) => {
    console.log("Submitting Add Delivery Service Data:", data);
    // Convert base_cost_cents to integer if it's a string from input
    const submitData = {
      ...data,
      base_cost_cents: parseInt(data.base_cost_cents, 10),
      estimated_days: parseInt(data.estimated_days, 10),
    };
    createDeliveryServiceMutation.mutate(submitData);
  };

  return (
    <div className="bg-neutral p-6 rounded-lg shadow-md max-w-2xl mx-auto">
      <Link to="/admin/delivery" className="btn btn-ghost btn-sm mb-6">
        <ArrowLeftIcon className="h-4 w-4 mr-2" />
        Back to Delivery Services
      </Link>

      <h2 className="text-xl font-bold mb-6">Add New Delivery Service</h2>

      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
        <div className="form-control">
          <label className="label">
            <span className="label-text">Name *</span>
          </label>
          <input
            type="text"
            className={`input input-bordered ${
              errors.name ? "input-error" : ""
            }`}
            placeholder="Enter service name..."
            {...register("name")}
          />
          {errors.name && (
            <label className="label">
              <span className="label-text-alt text-error">
                {errors.name.message}
              </span>
            </label>
          )}
        </div>

        <div className="form-control">
          <label className="label">
            <span className="label-text">Description *</span>
          </label>
          <textarea
            className={`textarea textarea-bordered ${
              errors.description ? "textarea-error" : ""
            }`}
            placeholder="Enter service description..."
            rows="3"
            {...register("description")}
          >
          </textarea>
          {errors.description && (
            <label className="label">
              <span className="label-text-alt text-error">
                {errors.description.message}
              </span>
            </label>
          )}
        </div>

        <div className="form-control">
          <label className="label">
            <span className="label-text">Base Cost (cents) *</span>
          </label>
          <input
            type="number"
            min="0"
            className={`input input-bordered ${
              errors.base_cost_cents ? "input-error" : ""
            }`}
            placeholder="Enter cost in cents (e.g., 1500 for 15.00 DZD)..."
            {...register("base_cost_cents", { valueAsNumber: true })}
          />
          {errors.base_cost_cents && (
            <label className="label">
              <span className="label-text-alt text-error">
                {errors.base_cost_cents.message}
              </span>
            </label>
          )}
        </div>

        <div className="form-control">
          <label className="label">
            <span className="label-text">Estimated Days *</span>
          </label>
          <input
            type="number"
            min="1"
            className={`input input-bordered ${
              errors.estimated_days ? "input-error" : ""
            }`}
            placeholder="Enter estimated delivery days..."
            {...register("estimated_days", { valueAsNumber: true })}
          />
          {errors.estimated_days && (
            <label className="label">
              <span className="label-text-alt text-error">
                {errors.estimated_days.message}
              </span>
            </label>
          )}
        </div>

        <div className="form-control">
          <label className="label cursor-pointer justify-between">
            <span className="label-text">Active *</span>
            <input
              type="checkbox"
              className="toggle toggle-primary"
              {...register("is_active")}
            />
          </label>
        </div>

        <div className="form-control mt-6">
          <button
            type="submit"
            className="btn btn-primary"
            disabled={createDeliveryServiceMutation.isPending}
          >
            {createDeliveryServiceMutation.isPending
              ? (
                <>
                  <span className="loading loading-spinner loading-xs mr-2">
                  </span>{" "}
                  Creating...
                </>
              )
              : "Create Service"}
          </button>
        </div>
      </form>
    </div>
  );
};

export default AddDeliveryService;


File: dashboard/src/pages/categories/AddCategory.jsx
================================================
import React from "react";
import { Link, useNavigate } from "react-router-dom";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { createCategory } from "../../services/api";
import { ArrowLeftIcon } from "@heroicons/react/24/outline";
import { toast } from "sonner";

// Define the Zod schema for validation
const addCategorySchema = z.object({
  name: z.string().min(1, { message: "Name is required." }),
  type: z.string().min(1, { message: "Type is required." }),
});

const AddCategory = () => {
  const navigate = useNavigate();
  const queryClient = useQueryClient();

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm({
    resolver: zodResolver(addCategorySchema),
    defaultValues: {
      name: "",
      type: "",
    },
  });

  const createCategoryMutation = useMutation({
    mutationFn: createCategory,
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["categories"] });
      toast.success("Category created successfully!");
      navigate("/admin/categories"); // Redirect back to the list
    },
    onError: (error) => {
      console.error("Create Error:", error);
      toast.error(
        `Failed to create category: ${error.message || "Unknown error"}`,
      );
    },
  });

  const onSubmit = (data) => {
    console.log("Submitting Add Category Data:", data);
    createCategoryMutation.mutate(data);
  };

  return (
    <div className="bg-neutral p-6 rounded-lg shadow-md max-w-2xl mx-auto">
      <Link to="/admin/categories" className="btn btn-ghost btn-sm mb-6">
        <ArrowLeftIcon className="h-4 w-4 mr-2" />
        Back to Categories
      </Link>

      <h2 className="text-xl font-bold mb-6">Add New Category</h2>

      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
        <div className="form-control">
          <label className="label">
            <span className="label-text">Name *</span>
          </label>
          <input
            type="text"
            className={`input input-bordered ${
              errors.name ? "input-error" : ""
            }`}
            placeholder="Enter category name..."
            {...register("name")}
          />
          {errors.name && (
            <label className="label">
              <span className="label-text-alt text-error">
                {errors.name.message}
              </span>
            </label>
          )}
        </div>

        <div className="form-control">
          <label className="label">
            <span className="label-text">Type *</span>
          </label>
          <input
            type="text"
            className={`input input-bordered ${
              errors.type ? "input-error" : ""
            }`}
            placeholder="Enter category type..."
            {...register("type")}
          />
          {errors.type && (
            <label className="label">
              <span className="label-text-alt text-error">
                {errors.type.message}
              </span>
            </label>
          )}
        </div>

        <div className="form-control mt-6">
          <button
            type="submit"
            className="btn btn-primary"
            disabled={createCategoryMutation.isPending}
          >
            {createCategoryMutation.isPending
              ? (
                <>
                  <span className="loading loading-spinner loading-xs mr-2">
                  </span>{" "}
                  Creating...
                </>
              )
              : "Create Category"}
          </button>
        </div>
      </form>
    </div>
  );
};

export default AddCategory;


File: dashboard/src/index.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;


File: dashboard/postcss.config.js
================================================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


File: Dockerfile
================================================
# Use the official Golang image as the base image
FROM golang:1.25.5-alpine AS builder

# Install git (required for go mod download in alpine)
RUN apk add --no-cache git

# Set the working directory inside the container
WORKDIR /app

# Copy go.mod and go.sum files
COPY go.mod go.sum ./

# Download dependencies
RUN go mod download

# Copy the rest of the application source code
COPY . .

# Build the Go binary statically (CGO_ENABLED=0) for smaller image size and portability
# Adjust the path to your main.go file if it's located elsewhere (e.g., cmd/server/main.go)
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o yc-informatique-backend cmd/server/main.go

# Use a minimal base image for the final stage
FROM alpine:latest

# Install ca-certificates for HTTPS requests if your app makes them
RUN apk --no-cache add ca-certificates

# Create a non-root user for running the application
RUN adduser -D -s /bin/sh appuser

# Set the working directory
WORKDIR /app

# Copy the compiled binary from the builder stage
COPY --from=builder /app/yc-informatique-backend .

# COPY the migrations directory from the builder stage
COPY --from=builder /app/migrations ./migrations

# Change ownership of the binary and migrations directory to the non-root user
RUN chown -R appuser:appuser /app

# Switch to the non-root user
USER appuser

# Expose the port your application listens on (adjust if different)
EXPOSE 8080

# Command to run the application
CMD ["./yc-informatique-backend"]


File: internal/db/discounts.sql.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: discounts.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const applyDiscountToCategory = `-- name: ApplyDiscountToCategory :exec
INSERT INTO category_discounts (category_id, discount_id)
VALUES ($1, $2)
`

type ApplyDiscountToCategoryParams struct {
	CategoryID uuid.UUID `json:"category_id"`
	DiscountID uuid.UUID `json:"discount_id"`
}

// Associates a discount with a specific category (simplified version, might need more checks).
func (q *Queries) ApplyDiscountToCategory(ctx context.Context, arg ApplyDiscountToCategoryParams) error {
	_, err := q.db.Exec(ctx, applyDiscountToCategory, arg.CategoryID, arg.DiscountID)
	return err
}

const applyDiscountToProduct = `-- name: ApplyDiscountToProduct :exec

INSERT INTO product_discounts (product_id, discount_id)
VALUES ($1, $2)
`

type ApplyDiscountToProductParams struct {
	ProductID  uuid.UUID `json:"product_id"`
	DiscountID uuid.UUID `json:"discount_id"`
}

// Include usage limit check
// Associates a discount with a specific product (simplified version, might need more checks).
func (q *Queries) ApplyDiscountToProduct(ctx context.Context, arg ApplyDiscountToProductParams) error {
	_, err := q.db.Exec(ctx, applyDiscountToProduct, arg.ProductID, arg.DiscountID)
	return err
}

const countDiscounts = `-- name: CountDiscounts :one
SELECT COUNT(*) FROM discounts
WHERE ($1::boolean IS NULL OR is_active = $1) -- Filter by active status if provided
  AND ($2::timestamptz IS NULL OR valid_from <= $2) -- Filter by valid from date if provided
  AND ($3::timestamptz IS NULL OR valid_until >= $3)
`

type CountDiscountsParams struct {
	IsActive  bool               `json:"is_active"`
	FromDate  pgtype.Timestamptz `json:"from_date"`
	UntilDate pgtype.Timestamptz `json:"until_date"`
}

// Counts discounts based on the same filters as ListDiscounts.
func (q *Queries) CountDiscounts(ctx context.Context, arg CountDiscountsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDiscounts, arg.IsActive, arg.FromDate, arg.UntilDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDiscount = `-- name: CreateDiscount :one
INSERT INTO discounts (
    code, description, discount_type, discount_value,
    min_order_value_cents, max_uses, valid_from, valid_until, is_active
) VALUES (
    $1, $2, $3, $4,
    $5, $6, $7, $8, $9
) RETURNING id, code, description, discount_type, discount_value, min_order_value_cents, max_uses, current_uses, valid_from, valid_until, is_active, created_at, updated_at
`

type CreateDiscountParams struct {
	Code               string             `json:"code"`
	Description        *string            `json:"description"`
	DiscountType       string             `json:"discount_type"`
	DiscountValue      int64              `json:"discount_value"`
	MinOrderValueCents *int64             `json:"min_order_value_cents"`
	MaxUses            *int32             `json:"max_uses"`
	ValidFrom          pgtype.Timestamptz `json:"valid_from"`
	ValidUntil         pgtype.Timestamptz `json:"valid_until"`
	IsActive           bool               `json:"is_active"`
}

// Inserts a new discount record.
func (q *Queries) CreateDiscount(ctx context.Context, arg CreateDiscountParams) (Discount, error) {
	row := q.db.QueryRow(ctx, createDiscount,
		arg.Code,
		arg.Description,
		arg.DiscountType,
		arg.DiscountValue,
		arg.MinOrderValueCents,
		arg.MaxUses,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.IsActive,
	)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.MinOrderValueCents,
		&i.MaxUses,
		&i.CurrentUses,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDiscount = `-- name: DeleteDiscount :exec
DELETE FROM discounts WHERE id = $1
`

// Deletes a discount record (and associated links via CASCADE).
func (q *Queries) DeleteDiscount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDiscount, id)
	return err
}

const getActiveDiscounts = `-- name: GetActiveDiscounts :many

SELECT
    d.id,
    d.code,
    d.description,
    d.discount_type,
    d.discount_value,
    d.min_order_value_cents,
    d.max_uses,
    d.current_uses,
    d.valid_from,
    d.valid_until,
    d.is_active,
    d.created_at,
    d.updated_at
FROM
    discounts d
WHERE
    d.is_active = TRUE AND NOW() BETWEEN d.valid_from AND d.valid_until
    AND (d.max_uses IS NULL OR d.current_uses < d.max_uses)
`

// Check usage limit
// Fetches all currently active discounts (within date range and usage limits).
func (q *Queries) GetActiveDiscounts(ctx context.Context) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getActiveDiscounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Discount
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValueCents,
			&i.MaxUses,
			&i.CurrentUses,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountByCode = `-- name: GetDiscountByCode :one
SELECT id, code, description, discount_type, discount_value, min_order_value_cents, max_uses, current_uses, valid_from, valid_until, is_active, created_at, updated_at FROM discounts WHERE code = $1 AND is_active = TRUE AND valid_from <= NOW() AND valid_until >= NOW()
`

// Fetches a discount by its unique code.
func (q *Queries) GetDiscountByCode(ctx context.Context, code string) (Discount, error) {
	row := q.db.QueryRow(ctx, getDiscountByCode, code)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.MinOrderValueCents,
		&i.MaxUses,
		&i.CurrentUses,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDiscountByID = `-- name: GetDiscountByID :one
SELECT id, code, description, discount_type, discount_value, min_order_value_cents, max_uses, current_uses, valid_from, valid_until, is_active, created_at, updated_at FROM discounts WHERE id = $1
`

// Fetches a discount by its ID.
func (q *Queries) GetDiscountByID(ctx context.Context, id uuid.UUID) (Discount, error) {
	row := q.db.QueryRow(ctx, getDiscountByID, id)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.MinOrderValueCents,
		&i.MaxUses,
		&i.CurrentUses,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDiscountsByCategoryID = `-- name: GetDiscountsByCategoryID :many
SELECT d.id, d.code, d.description, d.discount_type, d.discount_value, d.min_order_value_cents, d.max_uses, d.current_uses, d.valid_from, d.valid_until, d.is_active, d.created_at, d.updated_at FROM discounts d
JOIN category_discounts cd ON d.id = cd.discount_id
WHERE cd.category_id = $1
  AND d.is_active = TRUE
  AND d.valid_from <= NOW()
  AND d.valid_until >= NOW()
  AND (d.max_uses IS NULL OR d.current_uses < d.max_uses)
`

// Fetches active discounts applicable to a specific category.
func (q *Queries) GetDiscountsByCategoryID(ctx context.Context, categoryID uuid.UUID) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getDiscountsByCategoryID, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Discount
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValueCents,
			&i.MaxUses,
			&i.CurrentUses,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountsByProductID = `-- name: GetDiscountsByProductID :many
SELECT d.id, d.code, d.description, d.discount_type, d.discount_value, d.min_order_value_cents, d.max_uses, d.current_uses, d.valid_from, d.valid_until, d.is_active, d.created_at, d.updated_at FROM discounts d
JOIN product_discounts pd ON d.id = pd.discount_id
WHERE pd.product_id = $1
  AND d.is_active = TRUE
  AND d.valid_from <= NOW()
  AND d.valid_until >= NOW()
  AND (d.max_uses IS NULL OR d.current_uses < d.max_uses)
`

// Fetches active discounts applicable to a specific product.
func (q *Queries) GetDiscountsByProductID(ctx context.Context, productID uuid.UUID) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getDiscountsByProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Discount
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValueCents,
			&i.MaxUses,
			&i.CurrentUses,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementDiscountUsage = `-- name: IncrementDiscountUsage :exec

UPDATE discounts
SET current_uses = current_uses + 1, updated_at = NOW()
WHERE id = $1 AND (max_uses IS NULL OR current_uses < max_uses)
`

// Pagination using limit and offset
// Increments the current_uses count for a specific discount.
// This should ideally be called within a transaction when applying the discount.
func (q *Queries) IncrementDiscountUsage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementDiscountUsage, id)
	return err
}

const linkCategoryToDiscount = `-- name: LinkCategoryToDiscount :exec

INSERT INTO category_discounts (category_id, discount_id) VALUES ($1, $2)
`

type LinkCategoryToDiscountParams struct {
	CategoryID uuid.UUID `json:"category_id"`
	DiscountID uuid.UUID `json:"discount_id"`
}

// Check usage limit
// Associates a category with a discount.
func (q *Queries) LinkCategoryToDiscount(ctx context.Context, arg LinkCategoryToDiscountParams) error {
	_, err := q.db.Exec(ctx, linkCategoryToDiscount, arg.CategoryID, arg.DiscountID)
	return err
}

const linkProductToDiscount = `-- name: LinkProductToDiscount :exec


INSERT INTO product_discounts (product_id, discount_id) VALUES ($1, $2)
`

type LinkProductToDiscountParams struct {
	ProductID  uuid.UUID `json:"product_id"`
	DiscountID uuid.UUID `json:"discount_id"`
}

// Prevent exceeding max_uses
// --- Link/Unlink Queries ---
// Associates a product with a discount.
func (q *Queries) LinkProductToDiscount(ctx context.Context, arg LinkProductToDiscountParams) error {
	_, err := q.db.Exec(ctx, linkProductToDiscount, arg.ProductID, arg.DiscountID)
	return err
}

const listDiscounts = `-- name: ListDiscounts :many
SELECT id, code, description, discount_type, discount_value, min_order_value_cents, max_uses, current_uses, valid_from, valid_until, is_active, created_at, updated_at FROM discounts
WHERE ($1::boolean IS NULL OR is_active = $1) -- Filter by active status if provided
  AND ($2::timestamptz IS NULL OR valid_from <= $2) -- Filter by valid from date if provided
  AND ($3::timestamptz IS NULL OR valid_until >= $3) -- Filter by valid until date if provided
ORDER BY created_at DESC -- Or another default order
LIMIT $5 OFFSET $4
`

type ListDiscountsParams struct {
	IsActive   bool               `json:"is_active"`
	FromDate   pgtype.Timestamptz `json:"from_date"`
	UntilDate  pgtype.Timestamptz `json:"until_date"`
	PageOffset int32              `json:"page_offset"`
	PageLimit  int32              `json:"page_limit"`
}

// Fetches a list of discounts, potentially with filters and pagination.
func (q *Queries) ListDiscounts(ctx context.Context, arg ListDiscountsParams) ([]Discount, error) {
	rows, err := q.db.Query(ctx, listDiscounts,
		arg.IsActive,
		arg.FromDate,
		arg.UntilDate,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Discount
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValueCents,
			&i.MaxUses,
			&i.CurrentUses,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unlinkCategoryFromDiscount = `-- name: UnlinkCategoryFromDiscount :exec
DELETE FROM category_discounts WHERE category_id = $1 AND discount_id = $2
`

type UnlinkCategoryFromDiscountParams struct {
	CategoryID uuid.UUID `json:"category_id"`
	DiscountID uuid.UUID `json:"discount_id"`
}

// Removes association between a category and a discount.
func (q *Queries) UnlinkCategoryFromDiscount(ctx context.Context, arg UnlinkCategoryFromDiscountParams) error {
	_, err := q.db.Exec(ctx, unlinkCategoryFromDiscount, arg.CategoryID, arg.DiscountID)
	return err
}

const unlinkProductFromDiscount = `-- name: UnlinkProductFromDiscount :exec
DELETE FROM product_discounts WHERE product_id = $1 AND discount_id = $2
`

type UnlinkProductFromDiscountParams struct {
	ProductID  uuid.UUID `json:"product_id"`
	DiscountID uuid.UUID `json:"discount_id"`
}

// Removes association between a product and a discount.
func (q *Queries) UnlinkProductFromDiscount(ctx context.Context, arg UnlinkProductFromDiscountParams) error {
	_, err := q.db.Exec(ctx, unlinkProductFromDiscount, arg.ProductID, arg.DiscountID)
	return err
}

const updateDiscount = `-- name: UpdateDiscount :one
UPDATE discounts
SET code = $2,
    description = $3,
    discount_type = $4,
    discount_value = $5,
    min_order_value_cents = $6,
    max_uses = $7,
    valid_from = $8,
    valid_until = $9,
    is_active = $10,
    updated_at = NOW()
WHERE id = $1
RETURNING id, code, description, discount_type, discount_value, min_order_value_cents, max_uses, current_uses, valid_from, valid_until, is_active, created_at, updated_at
`

type UpdateDiscountParams struct {
	ID                 uuid.UUID          `json:"id"`
	Code               string             `json:"code"`
	Description        *string            `json:"description"`
	DiscountType       string             `json:"discount_type"`
	DiscountValue      int64              `json:"discount_value"`
	MinOrderValueCents *int64             `json:"min_order_value_cents"`
	MaxUses            *int32             `json:"max_uses"`
	ValidFrom          pgtype.Timestamptz `json:"valid_from"`
	ValidUntil         pgtype.Timestamptz `json:"valid_until"`
	IsActive           bool               `json:"is_active"`
}

// Updates an existing discount record.
func (q *Queries) UpdateDiscount(ctx context.Context, arg UpdateDiscountParams) (Discount, error) {
	row := q.db.QueryRow(ctx, updateDiscount,
		arg.ID,
		arg.Code,
		arg.Description,
		arg.DiscountType,
		arg.DiscountValue,
		arg.MinOrderValueCents,
		arg.MaxUses,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.IsActive,
	)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.MinOrderValueCents,
		&i.MaxUses,
		&i.CurrentUses,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}


File: internal/db/products_view.sql.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products_view.sql

package db

import (
	"context"
)

const getProductsWithDiscountInfoView = `-- name: GetProductsWithDiscountInfoView :many
SELECT product_id, category_id, product_name, product_slug, product_description, product_short_description, original_price_cents, product_stock_quantity, product_status, product_brand, product_image_urls, product_spec_highlights, product_created_at, product_updated_at, product_deleted_at, avg_rating, num_ratings, discounted_price_cents, active_discount_code, active_discount_type, active_discount_value, has_active_discount
FROM v_products_with_current_discounts
`

func (q *Queries) GetProductsWithDiscountInfoView(ctx context.Context) ([]VProductsWithCurrentDiscount, error) {
	rows, err := q.db.Query(ctx, getProductsWithDiscountInfoView)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VProductsWithCurrentDiscount
	for rows.Next() {
		var i VProductsWithCurrentDiscount
		if err := rows.Scan(
			&i.ProductID,
			&i.CategoryID,
			&i.ProductName,
			&i.ProductSlug,
			&i.ProductDescription,
			&i.ProductShortDescription,
			&i.OriginalPriceCents,
			&i.ProductStockQuantity,
			&i.ProductStatus,
			&i.ProductBrand,
			&i.ProductImageUrls,
			&i.ProductSpecHighlights,
			&i.ProductCreatedAt,
			&i.ProductUpdatedAt,
			&i.ProductDeletedAt,
			&i.AvgRating,
			&i.NumRatings,
			&i.DiscountedPriceCents,
			&i.ActiveDiscountCode,
			&i.ActiveDiscountType,
			&i.ActiveDiscountValue,
			&i.HasActiveDiscount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}


File: internal/db/queries/multi_discounts.sql
================================================
-- name: GetProductWithMultiDiscountDetails :one
-- Fetches a product and its active product-specific discounts.
-- This might return multiple rows if there are multiple discounts.
-- Aggregation into a list happens in Go.
SELECT
    p.id,
    p.category_id,
    p.name,
    p.price_cents AS original_price_cents,
    -- ... other product fields ...
    d.id AS discount_id,
    d.code AS discount_code,
    d.discount_type AS discount_type,
    d.discount_value AS discount_value,
    d.created_at 
FROM products p
LEFT JOIN product_discounts pd ON p.id = pd.product_id
LEFT JOIN discounts d ON pd.discount_id = d.id AND d.is_active = TRUE AND NOW() BETWEEN d.valid_from AND d.valid_until
WHERE p.id = $1 AND p.deleted_at IS NULL
ORDER BY d.created_at ASC;


File: internal/db/queries/refresh_token.sql
================================================
-- name: CreateRefreshToken :exec
INSERT INTO refresh_tokens (jti, user_id, token_hash, expires_at)
VALUES (@jti::text, @user_id::uuid, @token_hash::char(64), @expires_at::timestamptz);

-- name: GetValidRefreshTokenRecord :one
SELECT id, jti, user_id, token_hash, expires_at, revoked_at, created_at, updated_at
FROM refresh_tokens
WHERE jti = @jti::text AND expires_at > NOW() AND revoked_at IS NULL;

-- name: RevokeRefreshTokenByJTI :exec
UPDATE refresh_tokens SET revoked_at = NOW(), updated_at = NOW() WHERE jti = @jti::text;

-- name: CleanupExpiredRefreshTokens :exec
DELETE FROM refresh_tokens WHERE expires_at < NOW() AND revoked_at IS NULL;

-- name: RevokeAllRefreshTokensByUserID :exec
-- Revokes all refresh tokens for a specific user.
UPDATE refresh_tokens
SET revoked_at = NOW(), updated_at = NOW()
WHERE user_id = @user_id::uuid AND revoked_at IS NULL; -- Only revoke non-already-revoked tokens


File: internal/models/cart.go
================================================
package models

import (
	"time"

	"github.com/google/uuid"
)

// Cart represents the main cart entity.
type Cart struct {
	ID        uuid.UUID `json:"id"`
	UserID    uuid.UUID `json:"user_id,omitempty"`
	SessionID *string   `json:"session_id,omitempty"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// CartItem represents an individual item within a cart.
type CartItem struct {
	ID        uuid.UUID `json:"id"`
	CartID    uuid.UUID `json:"cart_id"`
	ProductID uuid.UUID `json:"product_id"`
	Quantity  int       `json:"quantity"`
}

// CartItemSummary includes the cart item details plus the associated product information.
type CartItemSummary struct {
	ID       uuid.UUID    `json:"id"`
	CartID   uuid.UUID    `json:"cart_id"`
	Product  *ProductLite `json:"product"`
	Quantity int          `json:"quantity"`
}

// ProductLite holds essential product info for display in cart/order summaries.
type ProductLite struct {
	ID                 uuid.UUID `json:"id"`
	Name               string    `json:"name"`
	OriginalPriceCents int64     `json:"original_price_cents"` // The base price from the product table
	FinalPriceCents    int64     `json:"final_price_cents"`    // The price after applying any active discounts
	StockQuantity      int32     `json:"stock_quantity"`
	ImageUrls          []string  `json:"image_urls"`
	Brand              string    `json:"brand"`
	DiscountCode       *string   `json:"discount_code,omitempty"`
	DiscountType       *string   `json:"discount_type,omitempty"`
	DiscountValue      *int64    `json:"discount_value,omitempty"`
	HasActiveDiscount  bool      `json:"has_active_discount"`
}

// CartSummary represents the complete state of a cart for display purposes.
type CartSummary struct {
	ID                        uuid.UUID         `json:"id"`
	UserID                    uuid.UUID         `json:"user_id,omitempty"`
	SessionID                 *string           `json:"session_id,omitempty"`
	CreatedAt                 time.Time         `json:"created_at"`
	UpdatedAt                 time.Time         `json:"updated_at"`
	Items                     []CartItemSummary `json:"items"`
	TotalItems                int               `json:"total_items"`                  // Number of distinct items in the cart
	TotalQty                  int               `json:"total_quantity"`               // Total quantity of all items
	TotalOriginalValueCents   int64             `json:"total_original_value_cents"`   // Sum of (original_price * quantity) for all items
	TotalDiscountedValueCents int64             `json:"total_discounted_value_cents"` // Sum of (final_price * quantity) for all items (what the user pays)
	TotalSavingsCents         int64             `json:"total_savings_cents"`          // TotalOriginal - TotalDiscounted
}
type AddItemRequest struct {
	ProductID string `json:"product_id" validate:"required,uuid"` // Expecting UUID string
	Quantity  int    `json:"quantity" validate:"required,min=1"`  // Minimum quantity is 1
}
type BulkAddItemRequest_Item struct {
	ProductID uuid.UUID `json:"product_id"`
	Quantity  int       `json:"quantity"`
}
type BulkAddItemRequest struct {
	Items []BulkAddItemRequest_Item `json:"items"`
}

func (ir *AddItemRequest) Validate() error {
	return Validate.Struct(ir)
}

type UpdateItemQuantityRequest struct {
	Quantity int `json:"quantity" validate:"required,min=1"` // Minimum quantity is 1
}

func (uir *UpdateItemQuantityRequest) Validate() error {
	return Validate.Struct(uir)
}


File: internal/models/review.go
================================================
package models

import (
	"time"

	"github.com/google/uuid"
)

// Review represents a user's rating for a product (core model, potentially used internally).
type Review struct {
	ID        uuid.UUID `json:"id"`
	UserID    uuid.UUID `json:"user_id"` // Core ID
	ProductID uuid.UUID `json:"product_id"`
	Rating    int       `json:"rating" validate:"required,min=1,max=5"` // Star rating (1 to 5)
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// ReviewListItem represents a review for display purposes, including the reviewer's name.
type ReviewListItem struct {
	ID           uuid.UUID `json:"id"`
	UserID       uuid.UUID `json:"user_id,omitempty"` // Potentially omit if name is shown
	ReviewerName string    `json:"reviewer_name"`     // Added field for display
	ProductID    uuid.UUID `json:"product_id"`        // Might be omitted if fetched for a specific product
	Rating       int       `json:"rating"`            // The star rating (1-5)
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
}

// ReviewByUserListItem represents a review submitted by the user, including the product name.
type ReviewByUserListItem struct {
	ID          uuid.UUID `json:"id"`
	UserID      uuid.UUID `json:"user_id,omitempty"` // Potentially omit if context is clear
	ProductID   uuid.UUID `json:"product_id"`
	ProductName string    `json:"product_name"` // Added field for display
	Rating      int       `json:"rating"`       // The star rating (1-5)
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// CreateReviewRequest represents the request body for creating a review.
type CreateReviewRequest struct {
	ProductID uuid.UUID `json:"product_id" validate:"required,uuid"`
	Rating    int       `json:"rating" validate:"required,min=1,max=5"`
}

// UpdateReviewRequest represents the request body for updating a review's rating.
type UpdateReviewRequest struct {
	Rating int `json:"rating" validate:"required,min=1,max=5"`
}

type GetReviewsByProductResponse struct {
	Reviews []ReviewListItem `json:"reviews"`
	Page    int              `json:"page,omitempty"`
	Limit   int              `json:"limit,omitempty"`
	Total   int64            `json:"total,omitempty"`
}

type GetReviewsByUserResponse struct {
	Reviews []ReviewByUserListItem `json:"reviews"`
	Page    int                    `json:"page,omitempty"`
	Limit   int                    `json:"limit,omitempty"`
	Total   int64                  `json:"total,omitempty"`
}

func (cr *CreateReviewRequest) Validate() error {
	return Validate.Struct(cr)
}

func (ur *UpdateReviewRequest) Validate() error {
	return Validate.Struct(ur)
}


File: internal/handlers/cart.go
================================================
package handlers

import (
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"strings"

	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/MihoZaki/DzTech/internal/services"
	"github.com/MihoZaki/DzTech/internal/utils"
	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
)

type CartHandler struct {
	cartService    *services.CartService
	productService *services.ProductService // Might be needed for future operations
	logger         *slog.Logger
}

func NewCartHandler(cartService *services.CartService, productService *services.ProductService, logger *slog.Logger) *CartHandler {
	return &CartHandler{
		cartService:    cartService,
		productService: productService,
		logger:         logger,
	}
}
func (h *CartHandler) RegisterRoutes(r chi.Router) {
	r.Get("/", h.GetCart)                            // GET /cart
	r.Post("/items", h.AddItem)                      // POST /cart/items <- Add this line
	r.Patch("/items/{itemID}", h.UpdateItemQuantity) // PATCH /cart/items/{id}
	r.Post("/add-bulk", h.AddBulkItemsToCart)
	r.Delete("/items/{itemID}", h.RemoveItem) // DELETE /cart/items/{id} - Add this line
	r.Delete("/", h.ClearCart)                // DELETE /cart - Add this line
}

// getSessionIDFromCookie extracts the session ID from the "session_id" cookie.
// It logs if the cookie is missing but doesn't send an error response.
func (h *CartHandler) getSessionIDFromCookie(r *http.Request) (string, bool) {
	cookie, err := r.Cookie("session_id")
	if err != nil {
		h.logger.Debug("Session cookie not found in request", "error", err)
		return "", false
	}
	return cookie.Value, true
}

// setSessionIDCookie sets the "session_id" cookie in the response.
// It generates a new UUID if no session ID exists yet.
// It configures the cookie with HttpOnly and SameSite flags for security.
// Adjust Secure flag based on whether you are using HTTPS.
func (h *CartHandler) setSessionIDCookie(w http.ResponseWriter, sessionID string) {
	if sessionID == "" {
		// Generate a new session ID if none exists
		sessionID = uuid.New().String()
		h.logger.Debug("Generated new session ID for cookie", "session_id", sessionID)
	}

	cookie := &http.Cookie{
		Name:     "session_id",            // Name of the cookie
		Value:    sessionID,               // The session ID value
		Path:     "/",                     // Cookie is valid for the entire site
		HttpOnly: true,                    // Prevents JavaScript access (security)
		Secure:   false,                   // Set to true if using HTTPS in production
		SameSite: http.SameSiteStrictMode, // Mitigate CSRF (adjust if needed for cross-origin requests)
		MaxAge:   86400,                   // Cookie expires in 24 hours (86400 seconds)
		// Expires:  time.Now().Add(24 * time.Hour), // Alternative to MaxAge
	}

	http.SetCookie(w, cookie) // Add the cookie to the response headers
}

// GetCart retrieves the current user's or guest's cart.
// Expected Headers: Authorization (Bearer token) for authenticated users.
//
//	Session ID is retrieved from the "session_id" cookie for guest users.
//
// Response: 200 OK with CartSummary JSON. Sets "session_id" cookie if it didn't exist for guests.
//
//	400 Bad Request if neither auth nor session cookie is provided (for guests).
//	500 Internal Server Error if backend fails.
func (h *CartHandler) GetCart(w http.ResponseWriter, r *http.Request) {
	var userID *uuid.UUID
	var sessionID string

	// Extract user ID from context if authenticated
	if user, ok := models.GetUserFromContext(r.Context()); ok {
		h.logger.Debug("Authenticated user accessing cart", "user_id", user.ID)
		userID = &user.ID
		// sessionID remains empty for authenticated users
	} else {
		// Fall back to session ID from cookie for guest users
		var hasSessionCookie bool
		sessionID, hasSessionCookie = h.getSessionIDFromCookie(r)
		if !hasSessionCookie {
			// If no session cookie exists, we might still want to initialize a cart for a guest,
			// but we need a session ID. The service layer will generate one if needed.
			// The handler should then set the cookie.
			// For now, let's assume we want to allow the request to proceed to the service,
			// which will generate a session ID if necessary, and then we set the cookie here.
			sessionID = uuid.New().String()
			h.logger.Debug("No session cookie found, generated new session ID for guest cart request", "session_id", sessionID)
			// Do NOT set the cookie yet. We need to call the service first to ensure the cart exists/gets created.
			// The service might need to interact with the database based on the session ID.
		}
		h.logger.Debug("Guest user accessing cart", "session_id", sessionID)
	}

	// Call the service with the determined userID or sessionID
	cartSummary, err := h.cartService.GetCartForContext(r.Context(), userID, sessionID)
	if err != nil {
		// Log the specific error from the service
		if userID != nil {
			h.logger.Error("Failed to get user cart", "user_id", *userID, "error", err)
		} else {
			h.logger.Error("Failed to get guest cart", "session_id", sessionID, "error", err)
		}
		utils.SendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to retrieve cart.")
		return
	}

	// If the request was for a guest and we generated a new session ID (or just read an existing one),
	// ensure the cookie is set in the response.
	if userID == nil { // Only for guests
		if !h.hasSessionCookie(r) {
			h.setSessionIDCookie(w, sessionID) // Set the cookie with the session ID used
		}
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(cartSummary)
}

// AddItem adds an item to the current user's or guest's cart.
// Expected Headers: Authorization (Bearer token) for authenticated users.
//
//	Session ID is retrieved from the "session_id" cookie for guest users.
//
// Expected Body: JSON { "product_id": "uuid-string", "quantity": number }
// Response: 200 OK with updated CartItem JSON. Sets "session_id" cookie if it didn't exist for guests.
//
//	400 Bad Request if input is invalid, or neither auth nor session cookie is provided (for guests).
//	404 Not Found if product doesn't exist.
//	409 Conflict if requested quantity exceeds stock (handled by DB/service).
//	500 Internal Server Error if backend fails.
func (h *CartHandler) AddItem(w http.ResponseWriter, r *http.Request) {
	var userID *uuid.UUID
	var sessionID string

	// Extract user ID from context if authenticated
	if user, ok := models.GetUserFromContext(r.Context()); ok {
		h.logger.Debug("Authenticated user adding item to cart", "user_id", user.ID)
		userID = &user.ID
		// sessionID remains empty for authenticated users
	} else {
		// Fall back to session ID from cookie for guest users
		var hasSessionCookie bool
		sessionID, hasSessionCookie = h.getSessionIDFromCookie(r)
		if !hasSessionCookie {
			// Generate a new session ID if the cookie is missing for a guest request
			sessionID = uuid.New().String()
			h.logger.Debug("No session cookie found, generated new session ID for guest add item request", "session_id", sessionID)
		}
		h.logger.Debug("Guest user adding item to cart", "session_id", sessionID)
	}

	h.logger.Debug("Handling cart add item request")

	// Parse the request body
	var req models.AddItemRequest // Use the struct from models package
	err := json.NewDecoder(r.Body).Decode(&req)
	if err != nil {
		utils.SendErrorResponse(w, http.StatusBadRequest, "Bad Request", "Invalid JSON body.")
		h.logger.Debug("Failed to decode add item request body", "error", err)
		return
	}

	// Validate the request struct using the Validate method defined in models/cart.go
	err = req.Validate() // Call the Validate method on the received struct
	if err != nil {
		utils.SendErrorResponse(w, http.StatusBadRequest, "Bad Request", fmt.Sprintf("Validation failed: %v", err))
		h.logger.Debug("Add item request validation failed", "request", req, "error", err)
		return
	}

	// Parse the product ID string into a UUID (validate tag already checked format)
	productID, err := uuid.Parse(req.ProductID)
	if err != nil {
		// This should theoretically not happen if validator worked correctly,
		// but good practice to handle it.
		utils.SendErrorResponse(w, http.StatusBadRequest, "Bad Request", "Invalid product ID format after validation.")
		h.logger.Error("Unexpected parsing error after validation", "product_id_str", req.ProductID, "error", err)
		return
	}

	h.logger.Debug("Adding item to cart", "user_id", userID, "session_id", sessionID, "product_id", productID, "quantity", req.Quantity)

	// Call the service to add the item (passes userID if present, otherwise sessionID)
	updatedOrNewItem, err := h.cartService.AddItemToCart(r.Context(), userID, sessionID, productID, req.Quantity)
	if err != nil {
		// Log the specific error from the service
		h.logger.Error("Failed to add item to cart", "user_id", userID, "session_id", sessionID, "product_id", productID, "quantity", req.Quantity, "error", err)

		// Check for specific known errors like stock issues
		errMsg := strings.ToLower(err.Error())
		if strings.Contains(errMsg, "stock") || strings.Contains(errMsg, "check") {
			utils.SendErrorResponse(w, http.StatusConflict, "Conflict", "Requested quantity exceeds available stock or other constraint violated.")
			return
		}

		// Generic error for other failures
		utils.SendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to add item to cart.")
		return
	}

	// If the request was for a guest and we generated a new session ID, set the cookie.
	if userID == nil && !h.hasSessionCookie(r) { // Only for guests who didn't have a cookie initially
		h.setSessionIDCookie(w, sessionID)
	}

	// Successfully added/updated item
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(updatedOrNewItem) // Encode the item returned by the service
}

// Helper to check if session cookie exists (used in AddItem, UpdateItemQuantity, RemoveItem, ClearCart)
func (h *CartHandler) hasSessionCookie(r *http.Request) bool {
	_, err := r.Cookie("session_id")
	return err == nil
}

// UpdateItemQuantity updates the quantity of an existing item in the current user's or guest's cart.
// Expected Headers: Authorization (Bearer token) for authenticated users.
//
//	Session ID is retrieved from the "session_id" cookie for guest users.
//
// Expected URL Param: itemID (UUID string)
// Expected Body: JSON { "quantity": number }
// Response: 200 OK with updated CartItem JSON. Sets "session_id" cookie if it didn't exist for guests.
//
//	400 Bad Request if input is invalid, session ID is missing, or item ID is invalid.
//	404 Not Found if the cart item doesn't exist.
//	403 Forbidden if the item doesn't belong to the user's/guest's cart.
//	409 Conflict if requested quantity exceeds stock (handled by DB/service).
//	500 Internal Server Error if backend fails.
func (h *CartHandler) UpdateItemQuantity(w http.ResponseWriter, r *http.Request) {
	var userID *uuid.UUID
	var sessionID string

	// Extract user ID from context if authenticated
	if user, ok := models.GetUserFromContext(r.Context()); ok {
		h.logger.Debug("Authenticated user updating item quantity in cart", "user_id", user.ID)
		userID = &user.ID
		// sessionID remains empty for authenticated users
	} else {
		// Fall back to session ID from cookie for guest users
		var hasSessionCookie bool
		sessionID, hasSessionCookie = h.getSessionIDFromCookie(r)
		if !hasSessionCookie {
			utils.SendErrorResponse(w, http.StatusBadRequest, "Bad Request", "A session ID cookie ('session_id') is required for guest carts.")
			h.logger.Debug("Missing session cookie for guest cart update item request and no authenticated user in context")
			return
		}
		h.logger.Debug("Guest user updating item quantity in cart", "session_id", sessionID)
	}

	itemID, err := ParseUUIDPathParam(w, r, "itemID")
	if err != nil {
		h.logger.Debug("Update item request failed to parse itemID", "error", err)
		return // Error response already sent by helper
	}

	h.logger.Debug("Handling cart update item request", "user_id", userID, "session_id", sessionID, "item_id", itemID)

	var req models.UpdateItemQuantityRequest // Use the struct from models package
	if err := DecodeAndValidateJSON(w, r, &req); err != nil {
		h.logger.Debug("Update item request failed validation/decoding", "error", err)
		return // Error response already sent by helper
	}

	h.logger.Debug("Updating item quantity in cart", "user_id", userID, "session_id", sessionID, "item_id", itemID, "new_quantity", req.Quantity)

	updatedItem, err := h.cartService.UpdateItemQuantityInCart(r.Context(), userID, sessionID, itemID, req.Quantity)
	if err != nil {
		SendServiceError(w, h.logger, "update item quantity in cart", err)
		return
	}

	// If the request was for a guest and we generated a new session ID, set the cookie.
	// Note: This specific endpoint (UpdateItemQuantity) might not typically be the first interaction
	// for a guest, so the cookie likely already exists. We only set it if it was missing at the start.
	if userID == nil && !h.hasSessionCookie(r) { // Only for guests who didn't have a cookie initially
		h.setSessionIDCookie(w, sessionID)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(updatedItem) // Encode the item returned by the service
}

// RemoveItem removes a specific item from the current user's or guest's cart.
// Expected Headers: Authorization (Bearer token) for authenticated users.
//
//	Session ID is retrieved from the "session_id" cookie for guest users.
//
// Expected URL Param: itemID (UUID string)
// Response: 204 No Content on success. Sets "session_id" cookie if it didn't exist for guests.
//
//	400 Bad Request if input is invalid, session ID is missing, or item ID is invalid.
//	404 Not Found if the cart item doesn't exist.
//	403 Forbidden if the item doesn't belong to the user's/guest's cart.
//	500 Internal Server Error if backend fails.
func (h *CartHandler) RemoveItem(w http.ResponseWriter, r *http.Request) {
	var userID *uuid.UUID
	var sessionID string

	// Extract user ID from context if authenticated
	if user, ok := models.GetUserFromContext(r.Context()); ok {
		h.logger.Debug("Authenticated user removing item from cart", "user_id", user.ID)
		userID = &user.ID
		// sessionID remains empty for authenticated users
	} else {
		// Fall back to session ID from cookie for guest users
		var hasSessionCookie bool
		sessionID, hasSessionCookie = h.getSessionIDFromCookie(r)
		if !hasSessionCookie {
			utils.SendErrorResponse(w, http.StatusBadRequest, "Bad Request", "A session ID cookie ('session_id') is required for guest carts.")
			h.logger.Debug("Missing session cookie for guest cart remove item request and no authenticated user in context")
			return
		}
		h.logger.Debug("Guest user removing item from cart", "session_id", sessionID)
	}

	itemID, err := ParseUUIDPathParam(w, r, "itemID")
	if err != nil {
		h.logger.Debug("Remove item request failed to parse itemID", "error", err)
		return // Error response already sent by helper
	}

	h.logger.Debug("Handling cart remove item request", "user_id", userID, "session_id", sessionID, "item_id", itemID)

	err = h.cartService.RemoveItemFromCart(r.Context(), userID, sessionID, itemID)
	if err != nil {
		// Log the specific error from the service
		h.logger.Error("Failed to remove item from cart", "user_id", userID, "session_id", sessionID, "item_id", itemID, "error", err)

		// Check for specific known errors
		errMsg := strings.ToLower(err.Error())
		if strings.Contains(errMsg, "not found") {
			utils.SendErrorResponse(w, http.StatusNotFound, "Not Found", "Cart item not found.")
			return
		}
		if strings.Contains(errMsg, "access denied") || strings.Contains(errMsg, "does not belong") {
			utils.SendErrorResponse(w, http.StatusForbidden, "Forbidden", "Access denied: Cannot remove item from another user's/guest's cart.")
			return
		}

		// Generic error for other failures
		utils.SendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to remove item from cart.")
		return
	}

	// If the request was for a guest and we generated a new session ID, set the cookie.
	// Note: This specific endpoint (RemoveItem) might not typically be the first interaction
	// for a guest, so the cookie likely already exists. We only set it if it was missing at the start.
	if userID == nil && !h.hasSessionCookie(r) { // Only for guests who didn't have a cookie initially
		h.setSessionIDCookie(w, sessionID)
	}

	// Successfully removed item - Return 204 No Content
	w.WriteHeader(http.StatusNoContent)
}

// ClearCart removes all items from the current user's or guest's cart.
// Expected Headers: Authorization (Bearer token) for authenticated users.
//
//	Session ID is retrieved from the "session_id" cookie for guest users.
//
// Response: 204 No Content on success. Sets "session_id" cookie if it didn't exist for guests.
//
//	400 Bad Request if session ID is missing (for guests).
//	500 Internal Server Error if backend fails.
func (h *CartHandler) ClearCart(w http.ResponseWriter, r *http.Request) {
	var userID *uuid.UUID
	var sessionID string

	// Extract user ID from context if authenticated
	if user, ok := models.GetUserFromContext(r.Context()); ok {
		h.logger.Debug("Authenticated user clearing cart", "user_id", user.ID)
		userID = &user.ID
		// sessionID remains empty for authenticated users
	} else {
		// Fall back to session ID from cookie for guest users
		var hasSessionCookie bool
		sessionID, hasSessionCookie = h.getSessionIDFromCookie(r)
		if !hasSessionCookie {
			utils.SendErrorResponse(w, http.StatusBadRequest, "Bad Request", "A session ID cookie ('session_id') is required for guest carts.")
			h.logger.Debug("Missing session cookie for guest cart clear request and no authenticated user in context")
			return
		}
		h.logger.Debug("Guest user clearing cart", "session_id", sessionID)
	}

	h.logger.Debug("Handling cart clear request", "user_id", userID, "session_id", sessionID)

	// Call the service to clear the cart (passes userID if present, otherwise sessionID)
	err := h.cartService.ClearCart(r.Context(), userID, sessionID)
	if err != nil {
		// Log the specific error from the service
		h.logger.Error("Failed to clear cart", "user_id", userID, "session_id", sessionID, "error", err)
		utils.SendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to clear cart.")
		return
	}

	// If the request was for a guest and we generated a new session ID, set the cookie.
	// Note: This specific endpoint (ClearCart) might not typically be the first interaction
	// for a guest, so the cookie likely already exists. We only set it if it was missing at the start.
	if userID == nil && !h.hasSessionCookie(r) { // Only for guests who didn't have a cookie initially
		h.setSessionIDCookie(w, sessionID)
	}

	// Successfully cleared cart - Return 204 No Content
	w.WriteHeader(http.StatusNoContent)
}

// AddBulkItemsToCart adds multiple items to the user's or guest's cart in a single request.
// It expects a JSON body with an array of {product_id, quantity} objects.
func (h *CartHandler) AddBulkItemsToCart(w http.ResponseWriter, r *http.Request) {
	var userID *uuid.UUID
	var sessionID string

	// Extract user ID from context if authenticated
	if user, ok := models.GetUserFromContext(r.Context()); ok {
		h.logger.Debug("Authenticated user adding bulk items to cart", "user_id", user.ID)
		userID = &user.ID
		// sessionID remains empty for authenticated users
	} else {
		// Fall back to session ID from cookie for guest users
		var hasSessionCookie bool
		sessionID, hasSessionCookie = h.getSessionIDFromCookie(r)
		if !hasSessionCookie {
			// Generate a new session ID if the cookie is missing for a guest request
			sessionID = uuid.New().String()
			h.logger.Debug("No session cookie found, generated new session ID for guest bulk add request", "session_id", sessionID)
		}
		h.logger.Debug("Guest user adding bulk items to cart", "session_id", sessionID)
	}

	h.logger.Debug("Handling cart bulk add items request")

	// Parse the request body
	var req models.BulkAddItemRequest
	err := json.NewDecoder(r.Body).Decode(&req)
	if err != nil {
		utils.SendErrorResponse(w, http.StatusBadRequest, "Bad Request", "Invalid JSON body.")
		h.logger.Debug("Failed to decode bulk add items request body", "error", err)
		return
	}

	// Validate the request structure (check for nil or empty items array)
	if req.Items == nil {
		utils.SendErrorResponse(w, http.StatusBadRequest, "Bad Request", "Request body must contain an 'items' array.")
		h.logger.Debug("Bulk add request body missing 'items' array", "request", req)
		return
	}
	if len(req.Items) == 0 {
		utils.SendErrorResponse(w, http.StatusBadRequest, "Bad Request", "Request body 'items' array cannot be empty.")
		h.logger.Debug("Bulk add request 'items' array is empty", "request", req)
		return
	}

	h.logger.Debug("Adding bulk items to cart", "user_id", userID, "session_id", sessionID, "num_items", len(req.Items))

	// Call the service to add the items (passes userID if present, otherwise sessionID)
	err = h.cartService.AddBulkItems(r.Context(), userID, sessionID, req.Items)
	if err != nil {
		// Log the specific error from the service
		h.logger.Error("Failed to add bulk items to cart", "user_id", userID, "session_id", sessionID, "num_items", len(req.Items), "error", err)

		// Check for specific known errors like stock issues
		errMsg := strings.ToLower(err.Error())
		if strings.Contains(errMsg, "stock") || strings.Contains(errMsg, "check") {
			utils.SendErrorResponse(w, http.StatusConflict, "Conflict", "Requested quantity for one or more items exceeds available stock or other constraint violated.")
			return
		}

		// Generic error for other failures
		utils.SendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to add items to cart.")
		return
	}

	// If the request was for a guest and we generated a new session ID, set the cookie.
	if userID == nil && !h.hasSessionCookie(r) { // Only for guests who didn't have a cookie initially
		h.setSessionIDCookie(w, sessionID)
	}

	w.WriteHeader(http.StatusOK) // 200 OK indicates successful addition
	fmt.Fprintf(w, "Successfully added %d items to cart", len(req.Items))
}


File: internal/handlers/auth.go
================================================
package handlers

import (
	"encoding/json"
	"log/slog"
	"net/http"
	"time"

	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/MihoZaki/DzTech/internal/services"
	"github.com/MihoZaki/DzTech/internal/utils"
	"github.com/go-chi/chi/v5"
	"github.com/go-playground/validator/v10"
)

const RefreshTokenCookieName = "refresh_token" // Define a constant for the cookie name

type AuthHandler struct {
	authService *services.AuthService // Use AuthService instead of UserService directly for auth logic
}

func NewAuthHandler(authService *services.AuthService) *AuthHandler { // Take AuthService
	return &AuthHandler{
		authService: authService,
	}
}

// deleteGuestSessionCookie sets the 'session_id' cookie to be deleted by the browser.
func deleteGuestSessionCookie(w http.ResponseWriter) {
	cookie := &http.Cookie{
		Name:  "session_id", // Name of the cookie to delete
		Value: "",           // Empty value
		Path:  "/",          // Same path it was set with (usually '/')
		// Domain:  "",                      // Same domain it was set with (or inferred)
		MaxAge:   -1,              // Delete cookie immediately
		Expires:  time.Unix(0, 0), // Expire immediately (Unix epoch)
		HttpOnly: true,
		Secure:   true,
		SameSite: http.SameSiteStrictMode,
	}
	http.SetCookie(w, cookie) // Add the deletion instruction to the response headers
}

// Helper function to set the refresh token cookie
func setRefreshTokenCookie(w http.ResponseWriter, token string) {
	cookie := &http.Cookie{
		Name:     RefreshTokenCookieName,
		Value:    token,
		Path:     "/",                                 // Accessible from all paths under /
		HttpOnly: true,                                // Prevents JavaScript access (crucial for security)
		Secure:   true,                                // Requires HTTPS (set to false for local testing with http)
		SameSite: http.SameSiteStrictMode,             // CSRF protection
		MaxAge:   int((7 * 24 * time.Hour).Seconds()), // 7 days expiry (should match RT expiry in service)
		// Expires: time.Now().Add(7 * 24 * time.Hour), // Alternative to MaxAge
	}
	http.SetCookie(w, cookie)
}

// Helper function to clear the refresh token cookie
func clearRefreshTokenCookie(w http.ResponseWriter) {
	cookie := &http.Cookie{
		Name:     RefreshTokenCookieName,
		Value:    "", // Empty value
		Path:     "/",
		HttpOnly: true,
		Secure:   true, // Should match how it was set
		SameSite: http.SameSiteStrictMode,
		MaxAge:   -1,              // Delete cookie
		Expires:  time.Unix(0, 0), // Expire immediately
	}
	http.SetCookie(w, cookie)
}

func (h *AuthHandler) Register(w http.ResponseWriter, r *http.Request) {
	var req models.UserRegister
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.SendErrorResponse(w, http.StatusBadRequest, "Invalid JSON", "Request body contains invalid JSON")
		return
	}

	if err := req.Validate(); err != nil {
		fieldErrors := make(map[string]string)
		if validationErrors, ok := err.(validator.ValidationErrors); ok {
			for _, err := range validationErrors {
				fieldErrors[err.Field()] = formatValidationError(err)
			}
		}
		utils.SendValidationError(w, fieldErrors)
		return
	}
	var guestSessionID string
	sessionCookie, err := r.Cookie("session_id") // Read the session_id cookie
	if err == nil {                              // Cookie found
		guestSessionID = sessionCookie.Value
		slog.Debug("Found guest session ID in cookie for registration", "session_id", guestSessionID)
	} else {
		slog.Debug("No guest session ID cookie found during registration", "error", err) // Usually means no guest cart
	}
	loginResp, refreshTokenStr, err := h.authService.Register(r.Context(), req.Email, req.Password, req.FullName, guestSessionID)
	if err != nil {
		if err.Error() == "user already exists" {
			utils.SendErrorResponse(w, http.StatusConflict, "User Already Exists", "A user with this email already exists")
			return
		}
		slog.Error("Failed to register user", "error", err, "email", req.Email)
		utils.SendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to register user")
		return
	}

	slog.Info("User registered successfully", "user_id", loginResp.User.ID, "email", req.Email)

	// Set the refresh token as a secure HTTP-only cookie
	setRefreshTokenCookie(w, refreshTokenStr)

	// --- DELETE THE GUEST SESSION COOKIE AFTER SUCCESSFUL REGISTRATION ---
	if guestSessionID != "" {
		deleteGuestSessionCookie(w)
		slog.Debug("Guest session ID cookie marked for deletion after registration", "session_id", guestSessionID)
	}

	// Send the response containing only the access token and user details (refresh token is in cookie)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)    // 201 Created for registration
	json.NewEncoder(w).Encode(loginResp) // Encode LoginResponse (without refresh token)
}

func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) {
	var req models.UserLogin
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.SendErrorResponse(w, http.StatusBadRequest, "Invalid JSON", "Request body contains invalid JSON")
		return
	}

	if err := req.Validate(); err != nil {
		fieldErrors := make(map[string]string)
		if validationErrors, ok := err.(validator.ValidationErrors); ok {
			for _, err := range validationErrors {
				fieldErrors[err.Field()] = formatValidationError(err)
			}
		}
		utils.SendValidationError(w, fieldErrors)
		return
	}
	var guestSessionID string
	sessionCookie, err := r.Cookie("session_id") // Read the session_id cookie
	if err == nil {                              // Cookie found
		guestSessionID = sessionCookie.Value
		slog.Debug("Found guest session ID in cookie for login", "session_id", guestSessionID)
	} else {
		slog.Debug("No guest session ID cookie found during login", "error", err) // Usually means no guest cart
	}

	// Use AuthService to handle login - now expects (LoginResponse, refreshTokenString, error)
	loginResp, refreshTokenStr, err := h.authService.Login(r.Context(), req.Email, req.Password, guestSessionID)
	if err != nil {
		if err.Error() == "invalid credentials" {
			slog.Info("Login failed: invalid credentials", "email", req.Email)
			utils.SendErrorResponse(w, http.StatusUnauthorized, "Invalid Credentials", "Invalid email or password")
			return
		}
		slog.Error("Failed to authenticate user", "error", err, "email", req.Email)
		utils.SendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to authenticate user")
		return
	}

	slog.Info("User logged in successfully", "user_id", loginResp.User.ID, "email", loginResp.User.Email)

	// Set the refresh token as a secure HTTP-only cookie
	setRefreshTokenCookie(w, refreshTokenStr)

	// --- DELETE THE GUEST SESSION COOKIE AFTER SUCCESSFUL LOGIN ---
	if guestSessionID != "" {
		deleteGuestSessionCookie(w)
		slog.Debug("Guest session ID cookie marked for deletion after login", "session_id", guestSessionID)
	}

	// Send the response containing only the access token and user details (refresh token is in cookie)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(loginResp) // Encode LoginResponse (without refresh token)
}

func (h *AuthHandler) Refresh(w http.ResponseWriter, r *http.Request) {
	// Read the refresh token from the cookie
	refreshTokenCookie, err := r.Cookie(RefreshTokenCookieName)
	if err != nil {
		// Cookie not found or invalid
		slog.Warn("Refresh token cookie not found or invalid", "error", err)
		utils.SendErrorResponse(w, http.StatusUnauthorized, "Unauthorized", "Refresh token not found or invalid")
		return
	}
	refreshTokenStr := refreshTokenCookie.Value

	// Call AuthService to perform the refresh logic (returns new access token and new refresh token string)
	newAccessToken, newRefreshTokenStr, err := h.authService.Refresh(r.Context(), refreshTokenStr)
	if err != nil {
		slog.Error("Failed to refresh token", "error", err)
		// Clear the invalid cookie if the token was rejected
		clearRefreshTokenCookie(w)
		// Return 401 for invalid/expired/revoked token
		utils.SendErrorResponse(w, http.StatusUnauthorized, "Unauthorized", err.Error())
		return
	}

	// If rotation is enabled, set the *new* refresh token as the cookie
	if newRefreshTokenStr != "" {
		setRefreshTokenCookie(w, newRefreshTokenStr)
	}
	slog.Debug("user asked for a refresh token", "refresh_token", newRefreshTokenStr)

	// Send the response containing only the new access token
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)                                                   // 200 OK
	json.NewEncoder(w).Encode(models.RefreshResponse{AccessToken: newAccessToken}) // Encode RefreshResponse (without refresh token)
}

func (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) {
	// Read the refresh token from the cookie
	refreshTokenCookie, err := r.Cookie(RefreshTokenCookieName)
	if err != nil {
		// Cookie not found. Log as warning, but treat as successful logout attempt.
		slog.Warn("Logout attempt without refresh token cookie", "error", err)
		// Still clear the cookie if it exists (might be stale)
		clearRefreshTokenCookie(w)
		w.WriteHeader(http.StatusNoContent) // 204 No Content
		return
	}
	refreshTokenStr := refreshTokenCookie.Value

	// Call AuthService to perform the logout/revocation logic
	err = h.authService.Logout(r.Context(), refreshTokenStr)
	if err != nil {
		slog.Error("Failed to logout", "error", err)
		utils.SendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to logout")
		return
	}

	// Clear the refresh token cookie after successful revocation
	clearRefreshTokenCookie(w)

	// Send 204 No Content on successful logout
	w.WriteHeader(http.StatusNoContent) // 204 No Content
}

func formatValidationError(err validator.FieldError) string {
	switch err.Tag() {
	case "required":
		return "This field is required"
	case "email":
		return "Must be a valid email address"
	case "min":
		return "Must be at least " + err.Param() + " characters"
	case "max":
		return "Must be no more than " + err.Param() + " characters"
	default:
		return "Invalid value"
	}
}

func (h *AuthHandler) RegisterRoutes(r chi.Router) {
	r.Post("/register", h.Register)
	r.Post("/login", h.Login)
	r.Post("/refresh", h.Refresh)
	r.Post("/logout", h.Logout) // Add logout route
}


File: internal/server/server.go
================================================
package server

import (
	"context"
	"fmt"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/MihoZaki/DzTech/db"
	"github.com/MihoZaki/DzTech/internal/config"
	"github.com/MihoZaki/DzTech/internal/router"
	"github.com/redis/go-redis/v9"
)

type Server struct {
	httpServer  *http.Server
	cfg         *config.Config
	redisClient *redis.Client
}

func New(cfg *config.Config) *Server {
	// Initialize database first
	if err := db.Init(); err != nil {
		slog.Error("Failed to initialize database", "error", err)
		panic(fmt.Sprintf("failed to initialize database: %v", err))
	}

	// Run migrations
	if err := db.RunMigrations(); err != nil {
		slog.Error("Failed to run migrations", "error", err)
		panic(fmt.Sprintf("failed to run migrations: %v", err))
	}

	// Double-check that the pool is initialized
	pool := db.GetPool()
	if pool == nil {
		panic("database pool is nil after initialization")
	}
	// --- Initialize Redis Client ---
	redisClient := redis.NewClient(&redis.Options{
		Addr:     cfg.RedisHost + ":" + cfg.RedisPort,
		Password: cfg.RedisPassword, // no password set
		DB:       cfg.RedisDB,       // use default DB
	})

	// Test the Redis connection
	ctx := context.Background()
	pong, err := redisClient.Ping(ctx).Result()
	if err != nil {
		slog.Error("Failed to connect to Redis", "error", err)
		panic(fmt.Sprintf("failed to connect to Redis: %v", err)) // Panic if Redis connection fails
	}
	slog.Info("Connected to Redis", "pong", pong)

	httpRouter := router.New(cfg, redisClient)

	return &Server{
		httpServer: &http.Server{
			Addr:    ":" + cfg.ServerPort,
			Handler: httpRouter,
		},
		cfg:         cfg,
		redisClient: redisClient,
	}
}

func (s *Server) Start() error {
	// Start server in a goroutine
	go func() {
		slog.Info("Server starting", "port", s.cfg.ServerPort)
		if err := s.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			slog.Error("Server failed to start", "error", err)
		}
	}()

	// Wait for interrupt signal to gracefully shutdown
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	slog.Info("Shutting down server...")

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := s.httpServer.Shutdown(ctx); err != nil {
		slog.Error("Server forced to shutdown", "error", err)
		return err
	}

	slog.Info("Server exited")
	return nil
}

func (s *Server) Stop() error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Shutdown HTTP server first
	httpErr := s.httpServer.Shutdown(ctx)

	// Close Redis client
	redisErr := s.redisClient.Close()

	// Return the first error encountered (preferably the HTTP shutdown error)
	if httpErr != nil {
		return httpErr
	}
	return redisErr // Return Redis close error if HTTP shutdown was successful
}


File: internal/services/user_service.go
================================================
package services

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"errors"
	"fmt"
	"log/slog"
	"time"

	"github.com/MihoZaki/DzTech/internal/db"
	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
	"golang.org/x/crypto/bcrypt"
)

type UserService struct {
	querier db.Querier
	// emailService EmailService
}

func NewUserService(querier db.Querier) *UserService {
	return &UserService{
		querier: querier,
	}
}

func (s *UserService) Register(ctx context.Context, email, password, fullName string) (uuid.UUID, error) {
	// Check if user already exists
	_, err := s.querier.GetUserByEmail(ctx, email)
	if err == nil {
		return uuid.Nil, errors.New("user already exists")
	}
	if !errors.Is(err, pgx.ErrNoRows) {
		return uuid.Nil, err
	}

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return uuid.Nil, err
	}

	// Create user
	now := pgtype.Timestamptz{Time: time.Now(), Valid: true}
	params := db.CreateUserParams{
		Email:        email,
		PasswordHash: hashedPassword,
		FullName:     &fullName,
		IsAdmin:      false,
		CreatedAt:    now,
		UpdatedAt:    now,
	}
	user, err := s.querier.CreateUser(ctx, params)
	if err != nil {
		return uuid.Nil, err
	}

	// Return uuid.UUID directly
	return user.ID, nil
}

func (s *UserService) Authenticate(ctx context.Context, email, password string) (*models.User, error) {
	dbUser, err := s.querier.GetUserByEmail(ctx, email)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("invalid credentials")
		}
		return nil, err
	}

	// Compare the provided password with the hashed password from DB
	if err := bcrypt.CompareHashAndPassword(dbUser.PasswordHash, []byte(password)); err != nil {
		return nil, errors.New("invalid credentials")
	}

	// Convert database user to service user
	user := &models.User{
		ID:        dbUser.ID, // Now uuid.UUID
		Email:     dbUser.Email,
		Password:  string(dbUser.PasswordHash),
		FullName:  *dbUser.FullName,
		IsAdmin:   dbUser.IsAdmin,
		CreatedAt: dbUser.CreatedAt.Time,
		UpdatedAt: dbUser.UpdatedAt.Time,
	}

	if dbUser.DeletedAt.Valid {
		user.DeletedAt = &dbUser.DeletedAt.Time
	}

	return user, nil
}

func (s *UserService) GetByID(ctx context.Context, id string) (*models.User, error) {
	// Parse the UUID string
	userUUID, err := uuid.Parse(id)
	if err != nil {
		return nil, errors.New("invalid user ID format")
	}

	dbUser, err := s.querier.GetUser(ctx, userUUID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("user not found")
		}
		return nil, err
	}

	user := &models.User{
		ID:        dbUser.ID, // Now uuid.UUID
		Email:     dbUser.Email,
		Password:  string(dbUser.PasswordHash),
		FullName:  *dbUser.FullName,
		IsAdmin:   dbUser.IsAdmin,
		CreatedAt: dbUser.CreatedAt.Time,
		UpdatedAt: dbUser.UpdatedAt.Time,
	}

	if dbUser.DeletedAt.Valid {
		user.DeletedAt = &dbUser.DeletedAt.Time
	}

	return user, nil
}

// UpdateProfile updates the user's full name and/or email address.
func (s *UserService) UpdateProfile(ctx context.Context, userID uuid.UUID, req models.UpdateProfileRequest) (*models.UserProfileResponse, error) {
	var updatedUser db.UpdateUserFullNameRow

	if req.FullName != nil {
		updateFullNameParams := db.UpdateUserFullNameParams{
			FullName: req.FullName,
			ID:       userID,
		}
		dbUser, err := s.querier.UpdateUserFullName(ctx, updateFullNameParams)
		if err != nil {
			return nil, fmt.Errorf("failed to update user full name: %w", err)
		}
		updatedUser = dbUser // Store the result
		slog.Info("User full name updated successfully", "user_id", userID, "new_full_name", *req.FullName)
	}

	if req.Email != nil {
		// Optional: Check if the new email already exists for another user
		existingUser, err := s.querier.GetUserByEmail(ctx, *req.Email)
		if err == nil && existingUser.ID != userID {
			return nil, fmt.Errorf("email %s is already taken", *req.Email)
		}
		// Ignore error if user doesn't exist (expected for new email)

		updateEmailParams := db.UpdateUserEmailParams{
			Email: *req.Email,
			ID:    userID,
		}
		dbUser, err := s.querier.UpdateUserEmail(ctx, updateEmailParams)
		if err != nil {
			// Check for unique constraint violation (email uniqueness) if applicable
			// This depends on your DB schema and constraints.
			// Example using pgx:
			var pgErr *pgconn.PgError
			if errors.As(err, &pgErr) && pgErr.Code == "23505" && pgErr.ConstraintName == "users_email_key" {
				return nil, fmt.Errorf("email %s is already taken", *req.Email)
			}
			return nil, fmt.Errorf("failed to update user email: %w", err)
		}
		updatedUser = db.UpdateUserFullNameRow(dbUser)
		slog.Info("User email updated successfully", "user_id", userID, "new_email", *req.Email)
	}

	// If neither field was updated, it's an error state, though validation might prevent this
	if req.FullName == nil && req.Email == nil {
		return nil, errors.New("nothing to update: both full_name and email are nil in request")
	}

	// Map the database result to the application model
	profileRes := &models.UserProfileResponse{
		ID:        updatedUser.ID,
		Email:     updatedUser.Email,
		FullName:  updatedUser.FullName,
		CreatedAt: updatedUser.CreatedAt.Time,
		UpdatedAt: updatedUser.UpdatedAt.Time,
	}

	return profileRes, nil
}

// ChangePassword updates the user's password after verifying the current password.
func (s *UserService) ChangePassword(ctx context.Context, userID uuid.UUID, req models.ChangePasswordRequest) error {
	// 1. Fetch the current user details (especially the hashed password) using the user ID
	// Use the existing GetUser query which returns the password_hash
	dbUser, err := s.querier.GetUser(ctx, userID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return errors.New("user not found")
		}
		return fmt.Errorf("failed to fetch user credentials for password change: %w", err)
	}

	// 2. Verify the provided current password against the stored hash
	err = checkPassword(dbUser.PasswordHash, req.CurrentPassword)
	if err != nil {
		// Password verification failed
		return errors.New("current password is incorrect")
	}

	// 3. Validate the new password requirements
	if len(req.NewPassword) < 8 {
		return errors.New("new password must be at least 8 characters long")
	}
	if req.NewPassword != req.ConfirmPassword {
		return errors.New("new password and confirmation do not match")
	}

	// 4. Hash the new password
	hashedNewPassword, err := hashPassword(req.NewPassword)
	if err != nil {
		return fmt.Errorf("failed to hash new password: %w", err)
	}

	// 5. Update the user's password in the database
	updatePasswordParams := db.UpdateUserPasswordParams{
		PasswordHash: hashedNewPassword,
		ID:           userID,
	}
	_, err = s.querier.UpdateUserPassword(ctx, updatePasswordParams)
	if err != nil {
		return fmt.Errorf("failed to update user password in database: %w", err)
	}

	slog.Info("User password updated successfully", "user_id", userID)
	return nil
}

// // ForgotPassword initiates the password recovery process for a user.
// func (s *UserService) ForgotPassword(ctx context.Context, req models.ForgotPasswordRequest) error {
// 	email := req.Email

// 	// Fetch the user by email to check if they exist
// 	// This query excludes soft-deleted users
// 	dbUser, err := s.querier.GetUserByEmail(ctx, email)
// 	if err != nil {
// 		// Treat non-existent user the same as success to prevent email enumeration
// 		// Log the attempt for monitoring if desired
// 		slog.Info("Forgot password attempt for non-existent email", "email", email)
// 		return nil // Return success to the client (generic message)
// 	}

// 	// Generate a secure token
// 	token, err := generateSecureToken(32) // 32 bytes = 64 character hex string
// 	if err != nil {
// 		return fmt.Errorf("failed to generate password reset token: %w", err)
// 	}

// 	// Set expiration time (e.g., 1 hour from now)
// 	expirationTime := time.Now().Add(1 * time.Hour)

// 	// Store the token in the database
// 	tokenParams := db.CreatePasswordResetTokenParams{
// 		UserID:    dbUser.ID, // Associate the token with the user ID
// 		Token:     token,
// 		ExpiresAt: ToPgTimestamptz(expirationTime), // Helper to convert time.Time to pgtype.Timestamptz
// 	}
// 	err = s.querier.CreatePasswordResetToken(ctx, tokenParams)
// 	if err != nil {
// 		// Check for potential unique constraint violation if tokens table has a unique token column
// 		// var pgErr *pgconn.PgError
// 		// if errors.As(err, &pgErr) && pgErr.Code == "23505" && pgErr.ConstraintName == "password_reset_tokens_token_key" {
// 		//     // This should ideally not happen with a cryptographically secure random token
// 		//     return fmt.Errorf("failed to store password reset token due to a conflict, please try again")
// 		// }
// 		return fmt.Errorf("failed to store password reset token: %w", err)
// 	}

// 	err = s.emailService.SendPasswordResetEmail(ctx, email, token)
// 	if err != nil {
// 		slog.Error("Failed to send password reset email", "email", email, "error", err)
// 		// IMPORTANT: Returning an error here might reveal information about user existence
// 		return fmt.Errorf("failed to send password reset email: %w", err)
// 	}
// 	slog.Info("Password reset token generated and stored", "user_id", dbUser.ID, "email", email, "token_preview", token[:10]+"...") // Log only a preview

// 	return nil
// }

// // ResetPassword completes the password recovery process using a token.
// func (s *UserService) ResetPassword(ctx context.Context, req models.ResetPasswordRequest) error {
// 	token := req.Token

// 	// Validate the new password
// 	if len(req.NewPassword) < 8 {
// 		return errors.New("new password must be at least 8 characters long")
// 	}
// 	if req.NewPassword != req.ConfirmPassword {
// 		return errors.New("new password and confirmation do not match")
// 	}

// 	// Fetch the user associated with the token (checks validity and expiry)
// 	dbUser, err := s.querier.GetUserByResetToken(ctx, token)
// 	if err != nil {
// 		if errors.Is(err, pgx.ErrNoRows) {
// 			return errors.New("invalid or expired password reset token")
// 		}
// 		return fmt.Errorf("failed to verify password reset token: %w", err)
// 	}

// 	// Hash the new password
// 	hashedNewPassword, err := hashPassword(req.NewPassword)
// 	if err != nil {
// 		return fmt.Errorf("failed to hash new password: %w", err)
// 	}

// 	// Update the user's password in the database
// 	updatePasswordParams := db.UpdateUserPasswordParams{
// 		PasswordHash: hashedNewPassword,
// 		ID:           dbUser.ID, // Use the user ID from the token verification
// 	}
// 	_, err = s.querier.UpdateUserPassword(ctx, updatePasswordParams)
// 	if err != nil {
// 		return fmt.Errorf("failed to update user password in database: %w", err)
// 	}

// 	// Delete the used token to prevent reuse
// 	err = s.querier.DeletePasswordResetToken(ctx, token)
// 	if err != nil {
// 		// Log the error, but don't fail the reset itself as the password was updated
// 		slog.Error("Failed to delete used password reset token", "token", token, "error", err)
// 		// Consider if you want to return an error here or just log it.
// 		// Returning an error might be safer to ensure token cleanup.
// 		// For now, let's just log.
// 	}

// 	slog.Info("Password reset completed successfully", "user_id", dbUser.ID)
// 	return nil
// }

// hashPassword hashes a plain-text password using bcrypt.
func hashPassword(password string) ([]byte, error) {
	// Use a cost of 12 for bcrypt (consider adjusting based on performance needs)
	return bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
}

// checkPassword compares a plain-text password with a hashed password.
func checkPassword(hashedPassword []byte, password string) error {
	return bcrypt.CompareHashAndPassword(hashedPassword, []byte(password))
}

// generateSecureToken generates a cryptographically secure random token string.
func generateSecureToken(length int) (string, error) {
	bytes := make([]byte, length)
	if _, err := rand.Read(bytes); err != nil {
		return "", err
	}
	return hex.EncodeToString(bytes), nil
}


File: internal/services/admin_user_service.go
================================================
package services

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"math"
	"time"

	"github.com/MihoZaki/DzTech/internal/db"
	"github.com/MihoZaki/DzTech/internal/models"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

// AdminUserService handles business logic for admin user management operations.
type AdminUserService struct {
	querier db.Querier
	logger  *slog.Logger
}

// NewAdminUserService creates a new instance of AdminUserService.
func NewAdminUserService(querier db.Querier, logger *slog.Logger) *AdminUserService {
	return &AdminUserService{
		querier: querier,
		logger:  logger,
	}
}

// ListUsers retrieves a list of users, optionally filtered by active status and paginated.
// Returns a PaginatedResponse containing the user list and pagination metadata.
func (s *AdminUserService) ListUsers(ctx context.Context, activeOnly bool, page, limit int) (*models.PaginatedResponse, error) {
	if limit <= 0 {
		limit = 20 // Default limit
	}
	if page <= 0 {
		page = 1 // Default page
	}
	offset := (page - 1) * limit

	params := db.ListUsersWithListDetailsParams{ // Use the new query's params struct
		ActiveOnly: activeOnly,
		PageOffset: int32(offset),
		PageLimit:  int32(limit),
	}

	dbUsers, err := s.querier.ListUsersWithListDetails(ctx, params) // Use the new query method
	if err != nil {
		return nil, fmt.Errorf("failed to list users: %w", err)
	}

	apiUsers := make([]models.AdminUserListItem, len(dbUsers))
	for i, dbUser := range dbUsers {
		apiUsers[i] = s.toAdminUserListItemModelFromListRow(dbUser) // Use the new helper
	}

	total, err := s.querier.CountUsers(ctx, activeOnly)
	if err != nil {
		return nil, fmt.Errorf("failed to count users for pagination: %w", err)
	}
	// ---

	totalPages := int(math.Ceil(float64(total) / float64(limit)))

	paginatedResponse := &models.PaginatedResponse{
		Data:       apiUsers,   // The list of users
		Page:       page,       // The current page number
		Limit:      limit,      // The number of items per page
		Total:      total,      // The total number of users matching the filters
		TotalPages: totalPages, // The total number of pages
	}

	return paginatedResponse, nil
}

// GetUser retrieves a specific user's details for admin view.
func (s *AdminUserService) GetUser(ctx context.Context, id uuid.UUID) (*models.AdminUserListItem, error) {
	dbUser, err := s.querier.GetUserWithDetails(ctx, id)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, ErrUserNotFound
		}
		return nil, fmt.Errorf("failed to fetch user details: %w", err)
	}

	apiUser := s.toAdminUserListItemModel(dbUser)
	return apiUser, nil
}

func (s *AdminUserService) ActivateUser(ctx context.Context, id uuid.UUID) error {
	err := s.querier.ActivateUser(ctx, id)
	if err != nil {
		return fmt.Errorf("failed to activate user: %w", err)
	}
	return nil
}

func (s *AdminUserService) DeactivateUser(ctx context.Context, id uuid.UUID) error {
	err := s.querier.SoftDeleteUser(ctx, id)
	if err != nil {
		return fmt.Errorf("failed to deactivate user: %w", err)
	}
	return nil
}

// toAdminUserListItemModel converts a DB row (from GetUserWithDetails) to the API list item model.
// Handles the interface{} type for LastOrderDate.
func (s *AdminUserService) toAdminUserListItemModel(dbUser db.GetUserWithDetailsRow) *models.AdminUserListItem {
	// Determine activity status
	activityStatus := "Active"
	if dbUser.DeletedAt.Valid {
		activityStatus = "Inactive"
	}

	// Determine name (use full name if available, fall back to email prefix)
	name := dbUser.Email // Default to email
	if dbUser.FullName != nil && *dbUser.FullName != "" {
		name = *dbUser.FullName
	}

	lastOrderDate := s.interfaceToTimePtr(dbUser.LastOrderDate)

	return &models.AdminUserListItem{
		ID:               dbUser.ID,
		Name:             name,
		Email:            dbUser.Email,
		RegistrationDate: dbUser.RegistrationDate.Time, // Use the alias from the query
		LastOrderDate:    lastOrderDate,
		OrderCount:       dbUser.TotalOrderCount,
		ActivityStatus:   activityStatus,
	}
}

// toAdminUserListItemModelFromListRow converts a DB row (from ListUsersWithListDetailsRow) to the API list item model.
// Handles the interface{} type for LastOrderDate.
func (s *AdminUserService) toAdminUserListItemModelFromListRow(dbUser db.ListUsersWithListDetailsRow) models.AdminUserListItem {
	// Determine activity status based on deleted_at (pgtype.Timestamptz)
	activityStatus := s.getActivityStatus(dbUser.DeletedAt)

	// Determine name (use full name if available, fall back to email)
	name := dbUser.Email
	if dbUser.FullName != nil && *dbUser.FullName != "" {
		name = *dbUser.FullName
	}

	// Convert last order date from interface{} to *time.Time
	lastOrderDate := s.interfaceToTimePtr(dbUser.LastOrderDate)

	// Convert registration date (pgtype.Timestamptz) to time.Time
	registrationDate := dbUser.RegistrationDate.Time

	return models.AdminUserListItem{
		ID:               dbUser.ID,
		Name:             name,
		Email:            dbUser.Email,
		RegistrationDate: registrationDate,
		LastOrderDate:    lastOrderDate,
		OrderCount:       dbUser.TotalOrderCount,
		ActivityStatus:   activityStatus,
	}
}

// Helper function to convert interface{} (from SQLC MAX/MIN potentially returning NULL as interface{}) to *time.Time
func (s *AdminUserService) interfaceToTimePtr(v interface{}) *time.Time {
	if v != nil {
		if t, ok := v.(time.Time); ok {
			return &t
		}
		// Log if the type assertion fails
		s.logger.Warn("Failed to assert value to time.Time in interfaceToTimePtr", "value_type", fmt.Sprintf("%T", v))
	}
	return nil
}

// Helper function to determine activity status from pgtype.Timestamptz (deleted_at)
func (s *AdminUserService) getActivityStatus(deletedAt pgtype.Timestamptz) string {
	if deletedAt.Valid {
		return "Inactive"
	}
	return "Active"
}

// --- Error Definitions ---
var (
	ErrUserNotFound = errors.New("user not found")
)


File: internal/services/order_service.go
================================================
package services

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"math"

	"github.com/MihoZaki/DzTech/internal/db"
	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/MihoZaki/DzTech/internal/utils"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/redis/go-redis/v9"
)

var (
	ErrOrderNotFound = errors.New("order not found")
)

// OrderService handles business logic for orders.
type OrderService struct {
	querier        db.Querier
	pool           *pgxpool.Pool // Add pool for transactions
	cartService    *CartService  // Required for checkout logic
	cache          *redis.Client
	productService *ProductService // Required for fetching product details/prices during checkout
	logger         *slog.Logger
}

func NewOrderService(querier db.Querier, pool *pgxpool.Pool, cartService *CartService, cache *redis.Client, productService *ProductService, logger *slog.Logger) *OrderService {
	return &OrderService{
		querier:        querier,
		pool:           pool, // Store the pool
		cartService:    cartService,
		cache:          cache,
		productService: productService,
		logger:         logger,
	}
}

// CreateOrder creates a new order from the user's current cart state (database or session).
// It fetches the cart internally based on userID or sessionID, validates state (implicitly through cart fetch),
// calculates the total, creates the order and its items transactionally,
// and clears the cart afterwards (only for authenticated users).
// Exactly one of userID or sessionID must be non-nil.
func (s *OrderService) CreateOrder(ctx context.Context, req models.CreateOrderFromCartRequest, userID *uuid.UUID, sessionID string) (*models.OrderWithItems, error) {
	// Validate input: exactly one of userID or sessionID must be provided
	if (userID == nil) == (sessionID == "") {
		return nil, fmt.Errorf("exactly one of userID or sessionID must be provided")
	}

	// --- STEP 1: Fetch the current cart state based on userID or sessionID ---
	// This implicitly validates the user has a cart and items in it (for db carts).
	// The cart summary includes TotalDiscountedValueCents.
	cartSummary, err := s.cartService.GetCartForContext(ctx, userID, sessionID)
	if err != nil {
		if userID != nil {
			return nil, fmt.Errorf("failed to fetch current cart state for user %s: %w", *userID, err)
		} else {
			return nil, fmt.Errorf("failed to fetch current cart state for session %s: %w", sessionID, err)
		}
	}
	if len(cartSummary.Items) == 0 {
		return nil, fmt.Errorf("cannot create order from an empty cart")
	}

	var actualUserID uuid.UUID
	if userID != nil {
		actualUserID = *userID
		s.logger.Debug("successfully fetched cart summary for authenticated user order creation", "summary cart id", cartSummary.ID, "user_id", actualUserID)
	} else {
		// Generate a temporary user ID for the guest order
		temporaryUserID, err := uuid.Parse(sessionID)
		if err != nil {
			return nil, fmt.Errorf("failed to generate user ID from session ID %s: %w", sessionID, err)
		}
		actualUserID = temporaryUserID
		s.logger.Debug("successfully fetched cart summary for guest order creation", "summary cart id", cartSummary.ID, "session_user", actualUserID, "session_id", temporaryUserID)
	}

	// --- STEP 2: Fetch delivery service details ---
	deliveryService, err := s.querier.GetDeliveryServiceByID(ctx, req.DeliveryServiceID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch delivery service with ID %s: %w", req.DeliveryServiceID, err)
	}

	// --- STEP 3: Calculate total amount ---
	// Use the validated total from the cart summary (sum of final discounted prices) + delivery fee
	totalAmountCents := cartSummary.TotalDiscountedValueCents + deliveryService.BaseCostCents
	totalAmountCentsRounded := utils.RoundToDinarCents(totalAmountCents)
	// --- STEP 4: Prepare order creation parameters ---
	createOrderParams := db.CreateOrderParams{
		UserID:            actualUserID, // Use the determined user ID (original or temporary)
		UserFullName:      req.ShippingAddress.FullName,
		Status:            "pending",
		TotalAmountCents:  totalAmountCentsRounded,
		PaymentMethod:     "Cash on Delivery", // Or get from req if variable
		Province:          req.ShippingAddress.Province,
		City:              req.ShippingAddress.City,
		PhoneNumber1:      req.ShippingAddress.PhoneNumber1,
		PhoneNumber2:      req.ShippingAddress.PhoneNumber2,
		Notes:             req.Notes,
		DeliveryServiceID: req.DeliveryServiceID,
	}

	// --- STEP 5: TRANSACTION BEGINS ---
	queries, ok := s.querier.(*db.Queries) // Get the concrete type to enable WithTx
	if !ok {
		return nil, errors.New("querier type assertion to *db.Queries failed, cannot create transactional querier")
	}
	tx, err := s.pool.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction for order creation: %w", err)
	}
	// Defer rollback to ensure cleanup on error or panic
	defer func() {
		if rbErr := tx.Rollback(ctx); rbErr != nil && !errors.Is(rbErr, pgx.ErrTxClosed) {
			s.logger.Error("Error during transaction rollback", "error", rbErr)
		}
	}()

	txQuerier := queries.WithTx(tx)

	// 5a. Create the main order record
	dbOrder, err := txQuerier.CreateOrder(ctx, createOrderParams)
	if err != nil {
		return nil, fmt.Errorf("failed to create order record in transaction: %w", err)
	}
	orderID := dbOrder.ID

	// 5b. Insert order items directly from the user's current cart (using the cart ID fetched earlier)
	// This ensures the items are captured exactly as they were in the validated cart state.
	insertOrderItemsFromCartParams := db.InsertOrderItemsFromCartParams{
		OrderID: orderID,
		CartID:  cartSummary.ID, // Use the validated cart ID from the summary (works for both db and session carts if mapped correctly)
	}
	err = txQuerier.InsertOrderItemsFromCart(ctx, insertOrderItemsFromCartParams)
	if err != nil {
		return nil, fmt.Errorf("failed to insert order items from cart in transaction: %w", err)
	}

	// 5c. Commit the transaction
	err = tx.Commit(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to commit order creation transaction: %w", err)
	}

	// --- STEP 6: Post-Creation Actions (Outside Transaction for Resilience) ---
	// Clear the user's cart after successful order creation *only* if it was a database cart (authenticated user)
	if userID != nil {
		err = s.cartService.ClearCart(ctx, userID, "") // Use the original userID that placed the order
		if err != nil {
			// Log as a critical error, but don't fail the order creation itself
			s.logger.Error("CRITICAL: Failed to clear user's cart after successful order creation",
				"cart_id", cartSummary.ID, "user_id", *userID, "order_id", orderID, "error", err)
		}
	} else {
		err = s.cartService.ClearCart(ctx, nil, sessionID) // Use the original userID that placed the order
		if err != nil {
			// Log as a critical error, but don't fail the order creation itself
			s.logger.Error("CRITICAL: Failed to clear session's cart after successful order creation",
				"cart_id", cartSummary.ID, "session", sessionID, "order_id", orderID, "error", err)
		}
		s.logger.Info("Guest order created, session cart cleared", "session_id", sessionID, "order_id", orderID, "session", actualUserID)
	}

	// Fetch and return the newly created order with its items
	createdOrderWithItems, err := s.GetOrder(ctx, orderID)
	if err != nil {
		s.logger.Error("CRITICAL: Failed to fetch newly created order", "order_id", orderID, "error", err)
		// This is critical, as the order exists but couldn't be fetched.
		// Return an error to indicate the inconsistency.
		return nil, fmt.Errorf("order created successfully, but failed to fetch details: %w", err)
	}

	return createdOrderWithItems, nil
}

// GetOrder retrieves an order by its ID along with its associated items.
// It aggregates the results from the GetOrderWithItems query which returns multiple rows.
func (s *OrderService) GetOrder(ctx context.Context, orderID uuid.UUID) (*models.OrderWithItems, error) {
	rows, err := s.querier.GetOrderWithItems(ctx, orderID)
	errorOrderNotFound := errors.New("order not found")
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, fmt.Errorf("%w: order with id %s not found", errorOrderNotFound, orderID)
		}
		return nil, fmt.Errorf("failed to fetch order with items from DB: %w", err)
	}

	if len(rows) == 0 {
		return nil, fmt.Errorf("%w: order with id %s not found (no rows returned)", errorOrderNotFound, orderID)
	}

	// Aggregate rows into OrderWithItems structure
	var order *models.Order
	items := make([]models.OrderItem, 0)

	for _, row := range rows {
		// Process the order header data (only needs to be done once, ideally from the first row where item fields might be NULL)
		if order == nil {
			// Initialize the main Order object from the first row's order fields
			order = &models.Order{
				ID:                row.ID,
				UserID:            row.UserID,
				UserFullName:      row.UserFullName,
				Status:            row.Status,
				TotalAmountCents:  row.TotalAmountCents,
				PaymentMethod:     row.PaymentMethod,
				Province:          row.Province,
				City:              row.City,
				PhoneNumber1:      row.PhoneNumber1,
				PhoneNumber2:      row.PhoneNumber2,
				DeliveryServiceID: row.DeliveryServiceID,
				Notes:             row.Notes,
				CreatedAt:         row.CreatedAt.Time,
				UpdatedAt:         row.UpdatedAt.Time,
				CompletedAt:       nil, // Initialize, will set if not null
				CancelledAt:       nil, // Initialize, will set if not null
			}
			// Set nullable timestamps
			if row.CompletedAt.Valid {
				order.CompletedAt = &row.CompletedAt.Time
			}
			if row.CancelledAt.Valid {
				order.CancelledAt = &row.CancelledAt.Time
			}
		}

		// Process the item data if the item fields are not null (i.e., if an order item exists in this row)
		// Check if item_id is not null (assuming ItemID is a UUID and will be uuid.Nil if NULL from the LEFT JOIN)
		// However, checking ItemID for uuid.Nil might not be reliable if uuid.Nil is a valid ID.
		// A better check is if row.ItemProductName is not nil, or if any of the item-specific fields (other than IDs potentially) are not null.
		// Since ProductName is text, checking for nil is a good indicator.
		if row.ItemProductName != nil { // If this is nil, the LEFT JOIN found no item for this order row iteration
			item := models.OrderItem{
				ID:            row.ItemID,
				OrderID:       row.ItemOrderID,
				ProductID:     row.ItemProductID,
				ProductName:   *row.ItemProductName,   // Safe to dereference if we checked for nil above
				PriceCents:    *row.ItemPriceCents,    // Safe to dereference if we checked for nil above
				Quantity:      *row.ItemQuantity,      // Safe to dereference if we checked for nil above
				SubtotalCents: *row.ItemSubtotalCents, // Safe to dereference if we checked for nil above
				CreatedAt:     row.ItemCreatedAt.Time,
				UpdatedAt:     row.ItemUpdatedAt.Time,
			}
			items = append(items, item)
		}
	}

	// Ensure we got the order header data
	if order == nil {
		// This should not happen if the query returned rows for an existing order.
		// Indicates a potential issue with the query or data.
		return nil, fmt.Errorf("internal error: no order header data found in query results for order %s", orderID)
	}

	return &models.OrderWithItems{
		Order: *order, // Dereference the pointer we created
		Items: items,
	}, nil
}

// dbOrderToModelOrder converts a db.Order (generated by SQLC based on new schema) to a models.Order.
// This function now primarily ensures the struct types match, as most fields are direct mappings.
// It handles the conversion of pgtype.Timestamptz to time.Time and nullable timestamps.
func (s *OrderService) dbOrderToModelOrder(dbOrder db.Order) models.Order {
	var order models.Order
	order.ID = dbOrder.ID
	order.UserID = dbOrder.UserID
	order.UserFullName = dbOrder.UserFullName
	order.Status = dbOrder.Status
	order.TotalAmountCents = dbOrder.TotalAmountCents
	order.PaymentMethod = dbOrder.PaymentMethod
	order.Province = dbOrder.Province
	order.City = dbOrder.City
	order.PhoneNumber1 = dbOrder.PhoneNumber1
	order.PhoneNumber2 = dbOrder.PhoneNumber2
	order.DeliveryServiceID = dbOrder.DeliveryServiceID
	order.Notes = dbOrder.Notes
	order.CreatedAt = dbOrder.CreatedAt.Time
	order.UpdatedAt = dbOrder.UpdatedAt.Time
	if dbOrder.CompletedAt.Valid {
		order.CompletedAt = &dbOrder.CompletedAt.Time
	}
	if dbOrder.CancelledAt.Valid {
		order.CancelledAt = &dbOrder.CancelledAt.Time
	}

	return order
}

// ListUserOrders retrieves a paginated list of orders for a specific user, optionally filtered by status.
func (s *OrderService) ListUserOrders(ctx context.Context, userID uuid.UUID, statusFilter string, page, limit int) (*models.PaginatedResponse, error) {
	if limit <= 0 {
		limit = 20 // Default limit
	}
	if page <= 0 {
		page = 1 // Default page
	}
	offset := (page - 1) * limit

	params := db.ListUserOrdersParams{
		UserID:       userID,
		FilterStatus: statusFilter,
		PageOffset:   int32(offset),
		PageLimit:    int32(limit),
	}

	dbOrders, err := s.querier.ListUserOrders(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to list user orders from DB: %w", err)
	}

	apiOrders := make([]models.Order, len(dbOrders))
	for i, dbOrder := range dbOrders {
		apiOrders[i] = s.dbOrderToModelOrder(dbOrder)
	}

	var statusFilterPtr *string
	if statusFilter != "" {
		statusFilterPtr = &statusFilter
	}
	// UserID is required, so we pass it directly. FilterStatus is optional, so we pass the pointer.
	countParams := db.CountUserOrdersParams{
		UserID:       userID,          // Pass the specific user ID, required
		FilterStatus: statusFilterPtr, // Use the nullable pointer for status filter
	}
	// ---

	// --- DEBUG LOGGING ---
	s.logger.Debug("Calling CountUserOrders query", "params", countParams)
	// ---

	total, err := s.querier.CountUserOrders(ctx, countParams)

	// --- DEBUG LOGGING ---
	s.logger.Debug("CountUserOrders query result", "total", total, "error", err)
	// ---

	if err != nil {
		return nil, fmt.Errorf("failed to count user orders for pagination: %w", err)
	}
	// --- (rest of the method) ---
	totalPages := int(math.Ceil(float64(total) / float64(limit)))

	paginatedResponse := &models.PaginatedResponse{
		Data:       apiOrders,
		Page:       page,
		Limit:      limit,
		Total:      total,
		TotalPages: totalPages,
	}

	return paginatedResponse, nil
}

// ListAllOrders retrieves a paginated list of *all* orders, optionally filtered by user ID and/or status.
func (s *OrderService) ListAllOrders(ctx context.Context, userIDFilter uuid.UUID, statusFilter string, page, limit int) (*models.PaginatedResponse, error) {
	if limit <= 0 {
		limit = 20
	}
	if page <= 0 {
		page = 1
	}
	offset := (page - 1) * limit

	// Prepare parameters for the ListAllOrders query
	params := db.ListAllOrdersParams{
		FilterUserID: userIDFilter, // Pass the UUID (even if Nil) for List query - it handles uuid.Nil correctly if written properly
		FilterStatus: statusFilter, // Pass the string (even if empty) for List query - it handles "" correctly if written properly
		PageOffset:   int32(offset),
		PageLimit:    int32(limit),
	}

	dbOrders, err := s.querier.ListAllOrders(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to list all orders from DB: %w", err)
	}
	apiOrders := make([]models.Order, len(dbOrders))
	for i, dbOrder := range dbOrders {
		apiOrders[i] = s.dbOrderToModelOrder(dbOrder)
	}

	// --- COUNT TOTAL MATCHING RECORDS ---

	countParams := db.CountAllOrdersParams{
		FilterUserID: userIDFilter, // Use the nullable pointer (nil if uuid.Nil)
		FilterStatus: statusFilter, // Use the nullable pointer (nil if "")
	}
	// ---

	// --- DEBUG LOGGING ---
	s.logger.Debug("Calling CountAllOrders query", "params", countParams)
	// ---

	total, err := s.querier.CountAllOrders(ctx, countParams)

	// --- DEBUG LOGGING ---
	s.logger.Debug("CountAllOrders query result", "total", total, "error", err)
	// ---

	if err != nil {
		return nil, fmt.Errorf("failed to count all orders for pagination: %w", err)
	}
	// ---

	totalPages := int(math.Ceil(float64(total) / float64(limit)))

	paginatedResponse := &models.PaginatedResponse{
		Data:       apiOrders,
		Page:       page,
		Limit:      limit,
		Total:      total,
		TotalPages: totalPages,
	}
	return paginatedResponse, nil
}

// Valid status transitions
// Assuming states: pending, confirmed, shipped, delivered, cancelled
// Basic rules:
// pending -> confirmed
// confirmed -> shipped
// shipped -> delivered
// Any -> cancelled (maybe only from pending/confirmed?)
// Prevent going backwards from delivered/cancelled

// isValidStatusTransition checks if a status change is allowed.
func isValidStatusTransition(current, requested string) bool {
	switch current {
	case "pending":
		return requested == "confirmed" || requested == "cancelled"
	case "confirmed":
		return requested == "shipped" || requested == "cancelled"
	case "shipped":
		return requested == "delivered"
	case "delivered", "cancelled":
		return false
	default:
		return false
	}
}

// UpdateOrderStatus updates the status of an order.
// It validates the transition and may perform stock deduction if transitioning to a reserved state.
func (s *OrderService) UpdateOrderStatus(ctx context.Context, orderID uuid.UUID, req models.UpdateOrderStatusRequest) (*models.Order, error) {
	// 1. Fetch the current order details
	currentOrder, err := s.querier.GetOrder(ctx, orderID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, ErrOrderNotFound
		}
		return nil, fmt.Errorf("failed to fetch current order state: %w", err)
	}

	// 2. Validate the requested status transition
	if !isValidStatusTransition(currentOrder.Status, req.Status) {
		return nil, &StatusTransitionError{
			CurrentStatus:   currentOrder.Status,
			RequestedStatus: req.Status,
			Msg:             fmt.Sprintf("transition from '%s' to '%s' is not allowed", currentOrder.Status, req.Status),
		}
	}

	// 3. Determine if stock deduction or release is needed based on the transition
	needsStockDeduction := (currentOrder.Status == "pending" && req.Status == "confirmed")
	needsStockRelease := (req.Status == "cancelled") // Stock release happens when the *new* status is 'cancelled'

	// --- Fetch Order Items for Cache Invalidation (Do this *before* the transaction) ---
	var orderItemsForCache []db.OrderItem
	if needsStockDeduction || needsStockRelease {
		orderItemsForCache, err = s.querier.GetOrderItemsByOrderID(ctx, orderID) // Fetch *outside* the main TX to get items as they were
		if err != nil {
			return nil, fmt.Errorf("failed to fetch order items for cache invalidation: %w", err)
		}
	}
	// --- END Fetch Order Items for Cache Invalidation ---

	queries, ok := s.querier.(*db.Queries)
	if !ok {
		return nil, errors.New("querier type assertion to *db.Queries failed, cannot create transactional querier")
	}
	var updatedOrder db.Order

	// 4. Begin transaction
	tx, err := s.pool.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction for status update: %w", err)
	}
	defer func() {
		if err := tx.Rollback(ctx); err != nil && !errors.Is(err, pgx.ErrTxClosed) {
			s.logger.Error("Error during transaction rollback in UpdateOrderStatus", "error", err)
		}
	}()

	txQuerier := queries.WithTx(tx)

	// 5. Handle Stock Release (if cancelling)
	if needsStockRelease {
		// 5a. Fetch order items within the transaction (already fetched outside for cache, but ensure TX consistency if needed)
		// orderItems, err := txQuerier.GetOrderItemsByOrderID(ctx, orderID) // Use txQuerier if needed within TX for absolute consistency
		orderItems := orderItemsForCache // Use the list fetched before the TX started

		// 5b. Perform stock release for each item within the transaction using the IncrementStock query
		for _, item := range orderItems {
			// Call the existing SQLC-generated query to increment stock
			updatedProduct, err := txQuerier.IncrementStock(ctx, db.IncrementStockParams{
				ProductID:       item.ProductID,
				IncrementAmount: item.Quantity, // item.Quantity is int32
			})

			if err != nil {
				// Some database error occurred during stock increment
				// Rollback happens via defer
				return nil, fmt.Errorf("failed to release stock for product %s (ID: %s) during cancellation (status update): %w", item.ProductName, item.ProductID, err)
			}
			// Optionally log the new stock level if needed
			s.logger.Debug("Stock incremented for product during order cancellation (via status update)",
				"product_id", item.ProductID, "new_stock", updatedProduct.StockQuantity)
		}
	}

	// 6. Handle Stock Deduction (if confirming)
	if needsStockDeduction {
		// 6a. Fetch order items within the transaction (already fetched outside for cache, but ensure TX consistency if needed)
		// orderItems, err := txQuerier.GetOrderItemsByOrderID(ctx, orderID) // Use txQuerier if needed within TX for absolute consistency
		orderItems := orderItemsForCache // Use the list fetched before the TX started

		// 6b. Perform stock deduction for each item within the transaction using the DecrementStockIfSufficient query
		for _, item := range orderItems {
			updatedProduct, err := txQuerier.DecrementStockIfSufficient(ctx, db.DecrementStockIfSufficientParams{
				ProductID:       item.ProductID,
				DecrementAmount: item.Quantity,
			})

			if err != nil {
				// Check if the error is due to no rows being affected (insufficient stock)
				if errors.Is(err, pgx.ErrNoRows) {
					// This means the WHERE condition (stock >= decrement_amount) failed for this product
					// Rollback happens via defer
					return nil, fmt.Errorf("insufficient stock for product %s (ID: %s) during confirmation (status update)", item.ProductName, item.ProductID)
				}
				// Some other database error occurred
				// Rollback happens via defer
				return nil, fmt.Errorf("failed to update stock for product %s (ID: %s) during confirmation (status update): %w", item.ProductName, item.ProductID, err)
			}
			// Optionally log the new stock level if needed
			s.logger.Debug("Stock decremented for product during order confirmation (via status update)",
				"product_id", item.ProductID, "new_stock", updatedProduct.StockQuantity)
		}
	}

	// 7. Update the order status within the same transaction
	updatedOrder, err = txQuerier.UpdateOrderStatus(ctx, db.UpdateOrderStatusParams{
		Status:  req.Status, // Use the requested status
		OrderID: orderID,
	})
	if err != nil {
		// Rollback happens via defer
		return nil, fmt.Errorf("failed to update order status in transaction: %w", err)
	}

	// 8. Commit the transaction
	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction for status update and potential stock change: %w", err)
	}

	// --- Invalidate Product Caches After Successful Transaction ---
	// Only invalidate if stock was actually changed
	if needsStockDeduction || needsStockRelease {
		for _, item := range orderItemsForCache { // Use the list fetched before the TX
			productID := item.ProductID

			// Invalidate by Product ID
			productCacheKeyByID := fmt.Sprintf(CacheKeyProductByID, productID.String())
			if err := s.cache.Del(ctx, productCacheKeyByID).Err(); err != nil {
				s.logger.Error("Failed to invalidate product cache by ID after stock change (status update)",
					"product_id", productID, "order_id", orderID, "status_change", fmt.Sprintf("%s->%s", currentOrder.Status, req.Status), "key", productCacheKeyByID, "error", err)
				// Log but don't fail the order status update itself
			} else {
				s.logger.Debug("Product cache invalidated by ID after stock change (status update)",
					"product_id", productID, "order_id", orderID, "status_change", fmt.Sprintf("%s->%s", currentOrder.Status, req.Status), "key", productCacheKeyByID)
			}
		}
	}
	// --- END Invalidate Product Caches After Successful Transaction ---

	// 9. Convert the updated db.Order to models.Order using the helper
	updOrder := s.dbOrderToModelOrder(updatedOrder)

	// 10. Return the updated order details
	return &updOrder, nil
}

// Valid cancellation rules
// Allow cancelling from 'pending' or 'confirmed'
// Do NOT allow cancelling from 'shipped', 'delivered', or 'cancelled'

// canCancelOrder checks if an order can be cancelled based on its current status.
func canCancelOrder(currentStatus string) bool {
	switch currentStatus {
	case "pending", "confirmed":
		return true
	case "shipped", "delivered", "cancelled":
		return false
	default:
		return false
	}
}

// CancelOrder cancels an order.
// It validates if cancellation is allowed and may perform stock release if the order was confirmed.
func (s *OrderService) CancelOrder(ctx context.Context, orderID uuid.UUID) (*models.Order, error) {
	// 1. Fetch the current order details
	currentOrder, err := s.querier.GetOrder(ctx, orderID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, ErrOrderNotFound
		}
		return nil, fmt.Errorf("failed to fetch current order state: %w", err)
	}

	// 2. Validate if cancellation is allowed based on the current status
	if !canCancelOrder(currentOrder.Status) {
		return nil, fmt.Errorf("order cannot be cancelled from status '%s'", currentOrder.Status)
	}

	// 3. Determine if stock release is needed based on the current status
	needsStockRelease := (currentOrder.Status == "confirmed") // Add other statuses if they also deducted stock

	queries, ok := s.querier.(*db.Queries)
	if !ok {
		return nil, errors.New("querier type assertion to *db.Queries failed, cannot create transactional querier")
	}
	var updatedOrder db.Order
	if needsStockRelease {
		// 4. Begin transaction for stock release and cancellation
		tx, err := s.pool.Begin(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to begin transaction for cancellation and stock release: %w", err)
		}
		defer func() {
			if err := tx.Rollback(ctx); err != nil && !errors.Is(err, pgx.ErrTxClosed) {
				s.logger.Error("Error during transaction rollback in CancelOrder", "error", err)
			}
		}()

		txQuerier := queries.WithTx(tx)

		// 5. Fetch order items within the transaction
		orderItems, err := txQuerier.GetOrderItemsByOrderID(ctx, orderID)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch order items for stock release: %w", err)
		}

		// 6. Perform stock release for each item within the transaction using the new query
		for _, item := range orderItems {
			// Call the new SQLC-generated query to increment stock
			updatedProduct, err := txQuerier.IncrementStock(ctx, db.IncrementStockParams{
				ProductID:       item.ProductID,
				IncrementAmount: item.Quantity, // item.Quantity is int32
			})

			if err != nil {
				// Some database error occurred during stock increment
				// Rollback happens via defer
				return nil, fmt.Errorf("failed to release stock for product %s (ID: %s) during cancellation: %w", item.ProductName, item.ProductID, err)
			}
			// Optionally log the new stock level if needed
			s.logger.Debug("Stock incremented for product during order cancellation",
				"product_id", item.ProductID, "new_stock", updatedProduct.StockQuantity)
		}

		// 7. Execute the cancellation within the same transaction
		updatedOrder, err = txQuerier.CancelOrder(ctx, orderID) // Use the existing CancelOrder query
		if err != nil {
			// Rollback happens via defer
			return nil, fmt.Errorf("failed to cancel order in transaction: %w", err)
		}

		// 8. Commit the transaction
		if err := tx.Commit(ctx); err != nil {
			return nil, fmt.Errorf("failed to commit transaction for cancellation and stock release: %w", err)
		}

	} else {
		// 9. If no stock release needed, execute cancellation directly in a simple transaction
		// For consistency and to ensure atomicity of the cancellation itself, use a transaction.
		tx, err := s.pool.Begin(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to begin transaction for cancellation: %w", err)
		}
		defer func() {
			if err := tx.Rollback(ctx); err != nil && !errors.Is(err, pgx.ErrTxClosed) {
				s.logger.Error("Error during transaction rollback in CancelOrder (simple cancellation)", "error", err)
			}
		}()

		txQuerier := queries.WithTx(tx)

		updatedOrder, err = txQuerier.CancelOrder(ctx, orderID) // Use the existing CancelOrder query
		if err != nil {
			// Rollback happens via defer
			return nil, fmt.Errorf("failed to cancel order: %w", err)
		}

		if err := tx.Commit(ctx); err != nil {
			return nil, fmt.Errorf("failed to commit transaction for cancellation: %w", err)
		}
	}

	// 10. Convert the updated db.Order to models.Order using the helper
	updOrder := s.dbOrderToModelOrder(updatedOrder)

	// 11. Return the updated order details
	return &updOrder, nil
}

type StatusTransitionError struct {
	CurrentStatus   string
	RequestedStatus string
	Msg             string
}

func (e *StatusTransitionError) Error() string {
	return fmt.Sprintf("invalid status transition: %s -> %s: %s", e.CurrentStatus, e.RequestedStatus, e.Msg)
}

type CannotCancelError struct {
	CurrentStatus string
	Msg           string
}

func (e *CannotCancelError) Error() string {
	return fmt.Sprintf("cannot cancel order in status '%s': %s", e.CurrentStatus, e.Msg)
}


File: migrations/00008_insert_test_data.sql
================================================
-- -- +goose Up
-- -- +goose StatementBegin
-- -- Insert random products for each category
-- -- Placeholder images are used for all products

-- -- CPU Products
-- INSERT INTO products (
--     id, category_id, name, slug, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at
-- ) VALUES (
--     gen_random_uuid(), '8c4cfda5-ecc8-4eef-a40d-cb5877351b77', 'Intel Core i9-13900K', 'intel-core-i9-13900k', 79999, 15, 'active', 'Intel', '["https://placehold.co/300x300?text=Intel+Core+i9-13900K"]', '{"cores": 24, "base_clock_ghz": 3.0, "boost_clock_ghz": 5.8}', NOW(), NOW()
-- );

-- INSERT INTO products (
--     id, category_id, name, slug, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at
-- ) VALUES (
--     gen_random_uuid(), '8c4cfda5-ecc8-4eef-a40d-cb5877351b77', 'AMD Ryzen 9 7950X', 'amd-ryzen-9-7950x', 69999, 20, 'active', 'AMD', '["https://placehold.co/300x300?text=AMD+Ryzen+9+7950X"]', '{"cores": 16, "base_clock_ghz": 4.5, "boost_clock_ghz": 5.7}', NOW(), NOW()
-- );

-- -- GPU Products
-- INSERT INTO products (
--     id, category_id, name, slug, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at
-- ) VALUES (
--     gen_random_uuid(), '2d21b8db-9fc4-43c5-8acc-e150e85b2252', 'NVIDIA RTX 4090', 'nvidia-rtx-4090', 199999, 8, 'active', 'NVIDIA', '["https://placehold.co/300x300?text=NVIDIA+RTX+4090"]', '{"cores": 16384, "memory_gb": 24, "boost_clock_ghz": 2.5}', NOW(), NOW()
-- );

-- INSERT INTO products (
--     id, category_id, name, slug, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at
-- ) VALUES (
--     gen_random_uuid(), '2d21b8db-9fc4-43c5-8acc-e150e85b2252', 'AMD Radeon RX 7900 XTX', 'amd-radeon-rx-7900-xtx', 149999, 12, 'active', 'AMD', '["https://placehold.co/300x300?text=AMD+Radeon+RX+7900+XTX"]', '{"cores": 6144, "memory_gb": 24, "boost_clock_ghz": 2.3}', NOW(), NOW()
-- );

-- -- Motherboard Products
-- INSERT INTO products (
--     id, category_id, name, slug, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at
-- ) VALUES (
--     gen_random_uuid(), 'b2e74ef7-fb6e-479f-a6ad-8cb84b7d88f9', 'ASUS ROG Strix Z790-E', 'asus-rog-strix-z790-e', 39999, 12, 'active', 'ASUS', '["https://placehold.co/300x300?text=ASUS+ROG+Strix+Z790-E"]', '{"form_factor": "ATX", "memory_slots": 4, "max_memory_gb": 128}', NOW(), NOW()
-- );

-- -- RAM Products
-- INSERT INTO products (
--     id, category_id, name, slug, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at
-- ) VALUES (
--     gen_random_uuid(), '316cab45-abe7-4370-bc31-28be8cc7b114', 'Corsair Vengeance RGB 32GB', 'corsair-vengeance-rgb-32gb', 14999, 20, 'active', 'Corsair', '["https://placehold.co/300x300?text=Corsair+Vengeance+RGB+32GB"]', '{"capacity_gb": 32, "speed_mhz": 3600, "type": "DDR4"}', NOW(), NOW()
-- );

-- -- Storage Products
-- INSERT INTO products (
--     id, category_id, name, slug, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at
-- ) VALUES (
--     gen_random_uuid(), 'c3c93459-a7ce-4f62-ac04-483d6b3ed87e', 'Samsung 980 Pro 1TB', 'samsung-980-pro-1tb', 12999, 18, 'active', 'Samsung', '["https://placehold.co/300x300?text=Samsung+980+Pro+1TB"]', '{"capacity_gb": 1000, "interface": "PCIe 4.0", "read_speed_mbps": 7000}', NOW(), NOW()
-- );

-- -- Power Supply Products
-- INSERT INTO products (
--     id, category_id, name, slug, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at
-- ) VALUES (
--     gen_random_uuid(), 'ee496395-3373-44e2-9063-1d3df4ce06fa', 'Corsair RM850x', 'corsair-rm850x', 17999, 10, 'active', 'Corsair', '["https://placehold.co/300x300?text=Corsair+RM850x"]', '{"wattage": 850, "efficiency": "80+ Gold", "modular": "Fully"}', NOW(), NOW()
-- );

-- -- Case Products
-- INSERT INTO products (
--     id, category_id, name, slug, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at
-- ) VALUES (
--     gen_random_uuid(), '02f90259-a0e9-4e0a-b2ed-138a6f0cf02e', 'NZXT H5 Flow', 'nzxt-h5-flow', 9999, 14, 'active', 'NZXT', '["https://placehold.co/300x300?text=NZXT+H5+Flow"]', '{"form_factor": "ATX", "material": "Steel/Tempered Glass", "fans_included": 2}', NOW(), NOW()
-- );

-- -- Laptop Products
-- INSERT INTO products (
--     id, category_id, name, slug, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at
-- ) VALUES (
--     gen_random_uuid(), '8af9d2a7-50bf-41df-913e-3f3423bdfa30', 'MacBook Pro 14-inch', 'macbook-pro-14-inch', 249999, 5, 'active', 'Apple', '["https://placehold.co/300x300?text=MacBook+Pro+14-inch"]', '{"cpu": "M2 Pro", "ram_gb": 16, "storage_gb": 512, "display": "14.2-inch Liquid Retina XDR"}', NOW(), NOW()
-- );

-- -- Accessories Products
-- INSERT INTO products (
--     id, category_id, name, slug, price_cents, stock_quantity, status, brand, image_urls, spec_highlights, created_at, updated_at
-- ) VALUES (
--     gen_random_uuid(), 'cfb1f1da-166e-4d4a-a253-f4e1158dc957', 'Logitech MX Master 3S', 'logitech-mx-master-3s', 11999, 22, 'active', 'Logitech', '["https://placehold.co/300x300?text=Logitech+MX+Master+3S"]', '{"type": "Wireless Mouse", "dpi": 8000, "battery_life_days": 70}', NOW(), NOW()
-- );

-- -- +goose StatementEnd

-- -- +goose Down
-- -- +goose StatementBegin
-- DELETE FROM products WHERE slug IN (
--     'intel-core-i9-13900k',
--     'amd-ryzen-9-7950x',
--     'nvidia-rtx-4090',
--     'amd-radeon-rx-7900-xtx',
--     'asus-rog-strix-z790-e',
--     'corsair-vengeance-rgb-32gb',
--     'samsung-980-pro-1tb',
--     'corsair-rm850x',
--     'nzxt-h5-flow',
--     'macbook-pro-14-inch',
--     'logitech-mx-master-3s'
-- );
-- -- +goose StatementEnd


File: website/Dockerfile
================================================
# Build stage
FROM node:20-alpine as build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Serve stage
FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]



File: website/src/components/Footer.jsx
================================================
// src/components/Footer.jsx - Simplified Version
import React from "react";
// Remove ExternalLinkIcon if it's causing issues
import {
  EnvelopeIcon,
  MapPinIcon,
  PhoneIcon,
} from "@heroicons/react/24/outline"; // Using MapPinIcon instead of LocationMarkerIcon
import { Link } from "react-router-dom";

const Footer = () => {
  return (
    <footer className="footer bg-base-200 text-base-content p-10">
      <div className="p-5">
        <span className="footer-title font-black ">Services</span>
        <Link to="/build-pc" className="link link-hover">
          Build Your PC
        </Link>
        <Link to="/products" className="link link-hover">
          Browse Products
        </Link>
        <Link to="/cart" className="link link-hover">
          Shopping Cart
        </Link>
      </div>
      <div className="p-5">
        <span className="footer-title font-black ">Company</span>
        <Link to="#" className="link link-hover">
          About Us
        </Link>
        <Link to="#" className="link link-hover">
          Contact
        </Link>
      </div>
      <div className="p-5">
        <span className="footer-title font-black ">Legal</span>
        <a href="#" className="link link-hover">
          Terms of Use
        </a>
        <a href="#" className="link link-hover">
          Privacy Policy
        </a>
        <a href="#" className="link link-hover">
          Cookie Policy
        </a>
      </div>
      <div className="p-5">
        <span className="footer-title font-black ">Contact</span>
        <div className="flex items-center gap-2">
          <EnvelopeIcon className="h-5 w-5 text-gray-400" />

          <span>ycinfo2026@gmail.com</span>
        </div>
        <div className="flex items-center gap-2">
          <PhoneIcon className="h-5 w-5 text-gray-400" />
          <span>+0791781303</span>
        </div>
        <div className="flex items-start gap-2">
          {/* Changed LocationMarkerIcon to MapPinIcon */}
          <MapPinIcon className="h-5 w-5 text-gray-400 mt-1" />
          <span>TAHER, Jijel, Algeria</span>
        </div>
      </div>
    </footer>
  );
};

export default Footer;


File: website/src/pages/Account.jsx
================================================
import React, { useEffect, useState } from "react";
import { Link, useLocation } from "react-router-dom"; // Added useLocation
import { useAuth } from "../contexts/AuthContext"; // Import useAuth
import { fetchUserOrders } from "../services/api"; // Import the API function
import { toast } from "sonner"; // Import toast for error handling

const BACKEND_BASE_URL = import.meta.env.VITE_BACKEND_BASE_URL ||
  "http://localhost:8080";

const Account = () => {
  const { user, logout } = useAuth(); // Get user and logout function
  const location = useLocation(); // Get current location
  const [recentOrders, setRecentOrders] = useState([]);
  const [loading, setLoading] = useState(true);

  // Helper function to truncate UUID
  const truncateUuid = (uuid) => {
    if (!uuid || typeof uuid !== "string") return "N/A";
    return `${uuid.substring(0, 8)}...`;
  };
  // Function to construct full image URL
  const constructImageUrl = (imageUrl) => {
    if (!imageUrl) return "";

    // If it's already a full URL, return as is
    if (imageUrl.startsWith("http://") || imageUrl.startsWith("https://")) {
      return imageUrl;
    }

    // Otherwise, prepend the backend base URL
    return `${BACKEND_BASE_URL}${imageUrl}`;
  };

  // Fetch recent orders (limit 3)
  useEffect(() => {
    const loadRecentOrders = async () => {
      if (!user) return; // Don't fetch if user is not logged in

      setLoading(true);
      try {
        // Fetch first page with limit of 3 for recent orders
        const response = await fetchUserOrders(1, 3);

        // Process the orders to ensure image URLs are properly formatted if needed
        const processedOrders = response.data?.map((order) => ({
          ...order,
          // If there are product images in the order, format them here
        })) || [];

        setRecentOrders(processedOrders);
      } catch (error) {
        console.error("Error fetching recent orders:", error);

        // Handle unauthorized error specifically
        if (error.response?.status === 401) {
          toast.error("Session expired. Please log in again.");
          // Optionally trigger logout
          logout();
        } else {
          toast.error("Failed to load recent orders. Please try again.");
        }
        setRecentOrders([]); // Set to empty array on error
      } finally {
        setLoading(false);
      }
    };

    loadRecentOrders();
  }, [user, logout]);

  // If no user is logged in, maybe redirect or show a message
  // For now, let's just render nothing if not logged in, assuming the router handles protection
  if (!user) {
    return (
      <div className="container mx-auto px-4 py-8 bg-base-200 min-h-screen flex items-center justify-center">
        <div className="text-center">
          <p className="text-xl mb-4">You are not logged in.</p>
          <Link to="/auth" className="btn btn-primary">
            Go to Login/Signup
          </Link>
        </div>
      </div>
    );
  }

  // Helper function to check if the current link is active
  const isActiveLink = (path) => {
    return location.pathname === path;
  };

  // Format date helper function
  const formatDate = (dateString) => {
    if (!dateString) return "";
    const date = new Date(dateString);
    return date.toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
    });
  };

  // Format currency helper function
  const formatCurrency = (cents) => {
    if (!cents) return "DZD 0.00";
    return `DZD ${(cents / 100).toFixed(2)}`;
  };

  return (
    <div className="container mx-auto px-4 py-8 bg-inherit min-h-screen">
      <h1 className="text-3xl font-bold mb-8">My Account</h1>

      <div className="grid grid-cols-1 lg:grid-cols-4 gap-8">
        {/* Sidebar Navigation */}
        <div className="lg:col-span-1">
          <div className="card bg-base-100 shadow-lg border border-base-200">
            <div className="card-body">
              <h2 className="card-title text-lg mb-4">Account Menu</h2>
              <ul className="menu bg-base-100 w-full rounded-box">
                <li>
                  <Link
                    to="/account"
                    className={isActiveLink("/account") ? "active" : ""}
                  >
                    Dashboard
                  </Link>
                </li>
                <li>
                  <Link
                    to="/account/orders"
                    className={isActiveLink("/account/orders") ? "active" : ""}
                  >
                    My Orders
                  </Link>
                </li>
                <li>
                  <Link
                    to="/account/settings"
                    className={isActiveLink("/account/settings")
                      ? "active"
                      : ""}
                  >
                    Account Settings
                  </Link>
                </li>

                <li>
                  <button onClick={logout} className="btn w-full text-left">
                    Log Out
                  </button>
                </li>
              </ul>
            </div>
          </div>
        </div>

        {/* Main Content Area */}
        <div className="lg:col-span-3">
          {/* Welcome Section */}
          <div className="card bg-base-100 shadow-lg mb-6 border border-base-200">
            <div className="card-body">
              <h2 className="card-title">
                Welcome, {user.full_name || user.name}!
              </h2>
              <p className="text-gray-600">
                Member since {formatDate(user.created_at)}
              </p>
              <div className="mt-4">
                <p>
                  <strong>Email:</strong> {user.email}
                </p>
              </div>
            </div>
          </div>

          {/* Recent Orders */}
          <div className="card bg-base-100 shadow-lg mb-6 border border-base-200">
            <div className="card-body">
              <h3 className="card-title text-lg">Recent Orders</h3>

              {loading
                ? (
                  <div className="flex justify-center items-center py-8">
                    <span className="loading loading-spinner loading-lg"></span>
                  </div>
                )
                : recentOrders.length === 0
                ? (
                  <div className="text-center py-8">
                    <p className="text-gray-500">No recent orders found.</p>
                  </div>
                )
                : (
                  <div className="overflow-x-auto">
                    <table className="table">
                      <thead>
                        <tr>
                          <th className="font-bold">Order #</th>
                          <th className="font-bold">Date</th>
                          <th className="font-bold">Recent Update</th>
                          <th className="font-bold">Status</th>
                          <th className="font-bold">Total</th>
                          <th className="font-bold">Actions</th>
                        </tr>
                      </thead>
                      <tbody>
                        {recentOrders.map((order) => (
                          <tr key={order.id}>
                            <td>{truncateUuid(order.id)}</td>
                            <td>{formatDate(order.created_at)}</td>
                            <td>{formatDate(order.updated_at)}</td>
                            <td>
                              <span
                                className={`badge ${
                                  order.status === "delivered" ||
                                    order.status === "Delivered"
                                    ? "badge-success"
                                    : order.status === "shipped" ||
                                        order.status === "Shipped"
                                    ? "badge-info"
                                    : order.status === "processing" ||
                                        order.status === "Processing"
                                    ? "badge-warning"
                                    : "badge-neutral"
                                }`}
                              >
                                {order.status.charAt(0).toUpperCase() +
                                  order.status.slice(1)}
                              </span>
                            </td>
                            <td>{formatCurrency(order.total_amount_cents)}</td>
                            <td>
                              <Link
                                to={`/account/order/${order.id}`}
                                className="btn btn-xs"
                              >
                                View
                              </Link>
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )}

              <div className="card-actions justify-end mt-4">
                <Link to="/account/orders" className="btn btn-outline">
                  View All Orders
                </Link>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Account;


File: website/src/main.jsx
================================================
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.jsx";
import "./index.css";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query"; // Import QueryClient and Provider

// Create a single client instance for the application
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      retry: 1, // Retry failed requests once
      refetchOnWindowFocus: false, // Uncomment if you don't want auto-refetching on window focus
    },
  },
});

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </React.StrictMode>,
);


File: dashboard/README.md
================================================
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.


File: dashboard/Dockerfile
================================================
# Build stage
FROM node:20-alpine as build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Serve stage
FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]



File: dashboard/src/stores/authStore.js
================================================
import { create } from "zustand";

export const useAuthStore = create((set) => ({
  user: (() => {
    const storedUser = localStorage.getItem("user");
    return storedUser ? JSON.parse(storedUser) : null; // Load user from localStorage on initialization
  })(),
  token: (() => {
    const storedToken = localStorage.getItem("access_token");
    return storedToken; // Load token from localStorage on initialization
  })(), // Initialize from storage

  login: (userData, accessToken) => {
    // Update Zustand state
    set({ user: userData, token: accessToken });
    // Persist to localStorage
    localStorage.setItem("user", JSON.stringify(userData));
    localStorage.setItem("access_token", accessToken);
  },

  logout: () => {
    set({ user: null, token: null });
    localStorage.removeItem("user");
    localStorage.removeItem("access_token");
  },
}));


File: dashboard/src/pages/auth/SigupPage.jsx
================================================
import React, { useState } from "react";
import { useNavigate } from "react-router-dom";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod"; // Import z from zod

// Define the validation schema using Zod
const signupSchema = z.object({
  name: z.string().min(2, {
    message: "Name must be at least 2 characters long.",
  }),
  email: z.string().email({ message: "Please enter a valid email address." }),
  password: z.string().min(6, {
    message: "Password must be at least 6 characters long.",
  }),
  confirmPassword: z.string().min(6, {
    message: "Please confirm your password.",
  }),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords don't match.",
  path: ["confirmPassword"], // Path of error
});

const SignupPage = () => {
  const navigate = useNavigate();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  // Initialize react-hook-form with zodResolver
  const { register, handleSubmit, formState: { errors }, reset } = useForm({
    resolver: zodResolver(signupSchema), // Pass the Zod schema
  });

  const onSubmit = async (data) => {
    console.log("Signup Data:", data); // Log form data on submit
    setLoading(true);
    setError(""); // Clear previous errors

    try {
      await new Promise((resolve) => setTimeout(resolve, 1500)); // Simulate network delay
      // Example simulated response:
      // const response = await axios.post('/api/auth/signup', data);
      // const { user, token } = response.data;
      // --- End Simulation ---

      // Example success handling (replace with real API logic)
      // login(user, token); // Update auth store if applicable
      reset(); // Reset form fields on success
      // Optionally, show a success toast notification using Sonner
      // toast.success('Account created successfully!');
      // Navigate to login page after successful signup
      navigate("/auth/login");
    } catch (err) {
      // Example error handling (replace with real API logic)
      console.error("Signup Error:", err);
      setError(err.message || "An error occurred during signup.");
    } finally {
      setLoading(false); // Stop loading indicator
    }
  };

  return (
    <div className="card flex-shrink-0 w-full max-w-sm shadow-2xl bg-base-100">
      <div className="card-body">
        <h1 className="text-2xl font-bold text-center">Sign Up</h1>
        {/* Display general error message if any */}
        {error && <p className="text-red-500 text-sm">{error}</p>}

        {/* Form using react-hook-form */}
        <form onSubmit={handleSubmit(onSubmit)}>
          {/* Full Name Field */}
          <div className="form-control">
            <label className="label">
              <span className="label-text">Full Name</span>
            </label>
            <input
              type="text"
              placeholder="John Doe"
              className={`input input-bordered ${
                errors.name ? "input-error" : ""
              }`} // Apply error style if validation fails
              {...register("name")}
            />
            {/* Display specific error message for name */}
            {errors.name && (
              <p className="text-red-500 text-xs">{errors.name.message}</p>
            )}
          </div>

          {/* Email Field */}
          <div className="form-control">
            <label className="label">
              <span className="label-text">Email</span>
            </label>
            <input
              type="email"
              placeholder="email@domain.com"
              className={`input input-bordered ${
                errors.email ? "input-error" : ""
              }`}
              {...register("email")}
            />
            {errors.email && (
              <p className="text-red-500 text-xs">{errors.email.message}</p>
            )}
          </div>

          {/* Password Field */}
          <div className="form-control">
            <label className="label">
              <span className="label-text">Password</span>
            </label>
            <input
              type="password"
              placeholder="password"
              className={`input input-bordered ${
                errors.password ? "input-error" : ""
              }`}
              {...register("password")}
            />
            {errors.password && (
              <p className="text-red-500 text-xs">{errors.password.message}</p>
            )}
          </div>

          {/* Confirm Password Field */}
          <div className="form-control">
            <label className="label">
              <span className="label-text">Confirm Password</span>
            </label>
            <input
              type="password"
              placeholder="password again"
              className={`input input-bordered ${
                errors.confirmPassword ? "input-error" : ""
              }`}
              {...register("confirmPassword")}
            />
            {errors.confirmPassword && (
              <p className="text-red-500 text-xs">
                {errors.confirmPassword.message}
              </p>
            )}
          </div>

          {/* Submit Button */}
          <div className="form-control mt-6">
            <button
              type="submit"
              className="btn btn-primary"
              disabled={loading}
            >
              {/* Show loading spinner or text depending on loading state */}
              {loading
                ? (
                  <>
                    <span className="loading loading-spinner loading-xs mr-2">
                    </span>{" "}
                    Signing Up...
                  </>
                )
                : "Sign Up"}
            </button>
          </div>
        </form>

        {/* Link to Login Page */}
        <div className="text-center mt-4">
          <p>
            Already have an account?{" "}
            <a href="/auth/login" className="link link-primary">Login</a>
          </p>
        </div>
      </div>
    </div>
  );
};

export default SignupPage;


File: dashboard/src/pages/discounts/EditDiscount.jsx
================================================
// src/pages/discounts/EditDiscount.jsx
import React from "react";
import { Link, useNavigate, useParams } from "react-router-dom";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { fetchDiscountById, updateDiscount } from "../../services/api";
import { ArrowLeftIcon } from "@heroicons/react/24/outline";
import { toast } from "sonner";

// Define the Zod schema for validation based on DB/API schema
// Adjust regex for YYYY-MM-DDTHH:mm format (as provided by datetime-local)
const dateTimeLocalRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/;

const editDiscountSchema = z.object({
  code: z.string().min(1, { message: "Code is required." }),
  description: z.string().optional(),
  discount_type: z.enum(["percentage", "fixed"], {
    errorMap: () => ({ message: "Invalid discount type." }),
  }),
  discount_value: z.number().min(0, {
    message: "Discount value must be zero or positive.",
  }),
  valid_from: z.string().regex(dateTimeLocalRegex, {
    message: "Invalid date format for Valid From (expected YYYY-MM-DDTHH:mm).",
  }),
  valid_until: z.string().regex(dateTimeLocalRegex, {
    message: "Invalid date format for Valid Until (expected YYYY-MM-DDTHH:mm).",
  }),
  is_active: z.boolean(), // Add back is_active
});

const EditDiscount = () => {
  const { id: discountId } = useParams();
  const navigate = useNavigate();
  const queryClient = useQueryClient();

  const {
    data: discount,
    isLoading: discountLoading,
    isError: discountError,
    error: discountFetchError,
  } = useQuery({
    queryKey: ["discount", discountId],
    queryFn: () => fetchDiscountById(discountId),
    select: (response) => response.data, // Adjust based on your API response structure
    enabled: !!discountId,
  });

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm({
    resolver: zodResolver(editDiscountSchema),
    defaultValues: {
      code: "",
      description: "",
      discount_type: "percentage",
      discount_value: 0,
      valid_from: new Date().toISOString().slice(0, 16),
      valid_until: new Date().toISOString().slice(0, 16),
      is_active: true, // Default
    },
  });

  // Prefill form when data is loaded
  React.useEffect(() => {
    if (discount) {
      reset({
        code: discount.code,
        description: discount.description,
        discount_type: discount.discount_type,
        discount_value: discount.discount_value,
        // Format fetched dates for datetime-local input (YYYY-MM-DDTHH:mm)
        valid_from: discount.valid_from
          ? new Date(discount.valid_from).toISOString().slice(0, 16)
          : "",
        valid_until: discount.valid_until
          ? new Date(discount.valid_until).toISOString().slice(0, 16)
          : "",
        is_active: discount.is_active, // Pre-fill is_active
      });
    }
  }, [discount, reset]);

  const updateDiscountMutation = useMutation({
    mutationFn: ({ id, data }) => updateDiscount(id, data),
    onSuccess: (data, variables) => {
      queryClient.invalidateQueries({ queryKey: ["discount", variables.id] });
      queryClient.invalidateQueries({ queryKey: ["discounts"] });
      toast.success("Discount updated successfully!");
      navigate("/admin/discounts"); // Redirect back to the list
    },
    onError: (error) => {
      console.error("Update Error:", error);
      toast.error(
        `Failed to update discount: ${error.message || "Unknown error"}`,
      );
    },
  });

  const onSubmit = (data) => {
    console.log("Raw Form Data from RHF:", data);
    const validFromDate = new Date(data.valid_from).toISOString();
    const validUntilDate = new Date(data.valid_until).toISOString();
    const submitData = {
      code: data.code.trim(),
      description: data.description?.trim() || null,
      discount_type: data.discount_type,
      discount_value: data.discount_value,
      valid_from: validFromDate,
      valid_until: validUntilDate,
      is_active: data.is_active,
    };
    console.log("Processed Submit Data before API call:", submitData);
    console.log(
      "Type of submitData:",
      typeof submitData,
      Array.isArray(submitData),
    );

    updateDiscountMutation.mutate({ id: discountId, data: { ...submitData } });
  };
  if (discountLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  }

  if (discountError) {
    return (
      <div className="alert alert-error">
        Error loading discount: {discountFetchError.message}
        <Link to="/admin/discounts" className="btn btn-sm ml-4">
          Go Back to List
        </Link>
      </div>
    );
  }

  if (!discount) {
    return (
      <div className="alert alert-warning">
        Discount not found.
        <Link to="/admin/discounts" className="btn btn-sm ml-4">
          Go Back to List
        </Link>
      </div>
    );
  }

  return (
    <div className="bg-neutral p-6 rounded-lg shadow-md max-w-4xl mx-auto">
      <Link to="/admin/discounts" className="btn btn-ghost btn-sm mb-6">
        <ArrowLeftIcon className="h-4 w-4 mr-2" />
        Back to Discounts
      </Link>

      <h2 className="text-xl font-bold mb-6">Edit Discount: {discount.code}</h2>

      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div className="form-control">
            <label className="label">
              <span className="label-text">Code *</span>
            </label>
            <input
              type="text"
              className={`input input-bordered ${
                errors.code ? "input-error" : ""
              }`}
              placeholder="Enter discount code..."
              {...register("code")}
            />
            {errors.code && (
              <label className="label">
                <span className="label-text-alt text-error">
                  {errors.code.message}
                </span>
              </label>
            )}
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Description</span>
            </label>
            <textarea
              className={`textarea textarea-bordered ${
                errors.description ? "textarea-error" : ""
              }`}
              placeholder="Enter discount description..."
              rows="2"
              {...register("description")}
            >
            </textarea>
            {errors.description && (
              <label className="label">
                <span className="label-text-alt text-error">
                  {errors.description.message}
                </span>
              </label>
            )}
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Discount Type *</span>
            </label>
            <select
              className={`select select-bordered ${
                errors.discount_type ? "select-error" : ""
              }`}
              {...register("discount_type")}
            >
              <option value="percentage">Percentage</option>
              <option value="fixed">Fixed Amount</option>
            </select>
            {errors.discount_type && (
              <label className="label">
                <span className="label-text-alt text-error">
                  {errors.discount_type.message}
                </span>
              </label>
            )}
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Discount Value *</span>
            </label>
            <input
              type="number"
              step="0.01"
              min="0"
              className={`input input-bordered ${
                errors.discount_value ? "input-error" : ""
              }`}
              placeholder="Enter discount value..."
              {...register("discount_value", { valueAsNumber: true })}
            />
            {errors.discount_value && (
              <label className="label">
                <span className="label-text-alt text-error">
                  {errors.discount_value.message}
                </span>
              </label>
            )}
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Valid From *</span>
            </label>
            <input
              type="datetime-local"
              className={`input input-bordered ${
                errors.valid_from ? "input-error" : ""
              }`}
              {...register("valid_from")}
            />
            {errors.valid_from && (
              <label className="label">
                <span className="label-text-alt text-error">
                  {errors.valid_from.message}
                </span>
              </label>
            )}
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Valid Until *</span>
            </label>
            <input
              type="datetime-local"
              className={`input input-bordered ${
                errors.valid_until ? "input-error" : ""
              }`}
              {...register("valid_until")}
            />
            {errors.valid_until && (
              <label className="label">
                <span className="label-text-alt text-error">
                  {errors.valid_until.message}
                </span>
              </label>
            )}
          </div>

          {/* Add is_active toggle */}
          <div className="form-control md:col-span-2">
            <label className="label cursor-pointer justify-between">
              <span className="label-text">Active *</span>
              <input
                type="checkbox"
                className="toggle toggle-primary"
                {...register("is_active")}
              />
            </label>
          </div>
        </div>

        <div className="form-control mt-6">
          <div className="flex gap-2">
            <button
              type="submit"
              className="btn btn-primary flex-1"
              disabled={updateDiscountMutation.isPending}
            >
              {updateDiscountMutation.isPending
                ? (
                  <>
                    <span className="loading loading-spinner loading-xs mr-2">
                    </span>{" "}
                    Saving...
                  </>
                )
                : "Save Changes"}
            </button>
            <button
              type="button"
              className="btn btn-ghost"
              onClick={() => navigate(-1)} // Go back
            >
              Cancel
            </button>
          </div>
        </div>
      </form>
    </div>
  );
};

export default EditDiscount;


File: dashboard/src/pages/products/ProductsList.jsx
================================================
import React, { useState } from "react";
import { Link, useNavigate } from "react-router-dom";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import {
  deleteProduct,
  fetchProducts,
  searchProducts,
} from "../../services/api";
import {
  MagnifyingGlassIcon,
  PencilSquareIcon,
  PlusCircleIcon,
  TrashIcon,
} from "@heroicons/react/24/outline";
import { toast } from "sonner";

const ProductsList = () => {
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const BACKEND_BASE_URL = import.meta.env.VITE_BACKEND_BASE_URL ||
    "http://localhost:8080";

  // State for pagination
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage, setItemsPerPage] = useState(20);

  // --- State for Effective Search Criteria (drives the query) ---
  const [effectiveSearchCriteria, setEffectiveSearchCriteria] = useState({
    query: "",
    in_stock_only: false,
    include_discounted_only: false,
    category_id: "", // Include category_id in the criteria object
    brand: "",
    min_price: "",
    max_price: "",
    spec_filter: "",
  });

  // --- State for Input Fields (controls the UI) ---
  const [inputSearchTerm, setInputSearchTerm] = useState("");
  const [inputInStockOnly, setInputInStockOnly] = useState(false);
  const [inputIncludeDiscountedOnly, setInputIncludeDiscountedOnly] = useState(
    false,
  );
  const [inputCategoryId, setInputCategoryId] = useState("");
  const [inputBrand, setInputBrand] = useState("");
  const [inputMinPrice, setInputMinPrice] = useState("");
  const [inputMaxPrice, setInputMaxPrice] = useState("");
  const [inputSpecFilter, setInputSpecFilter] = useState("");

  // Function to update effective criteria and reset page
  const updateEffectiveCriteriaAndResetPage = (newCriteria) => {
    setEffectiveSearchCriteria(newCriteria);
    setCurrentPage(1); // Reset page when criteria change
  };

  // --- Handlers for Input Changes (update UI state) ---
  const handleInputSearchTermChange = (e) => {
    setInputSearchTerm(e.target.value);
  };

  const handleInputInStockOnlyChange = (e) => {
    setInputInStockOnly(e.target.checked);
  };

  const handleInputIncludeDiscountedOnlyChange = (e) => {
    setInputIncludeDiscountedOnly(e.target.checked);
  };

  const handleInputCategoryIdChange = (e) => {
    setInputCategoryId(e.target.value);
  };

  const handleInputBrandChange = (e) => {
    setInputBrand(e.target.value);
  };

  const handleInputMinPriceChange = (e) => {
    setInputMinPrice(e.target.value);
  };

  const handleInputMaxPriceChange = (e) => {
    setInputMaxPrice(e.target.value);
  };

  const handleInputSpecFilterChange = (e) => {
    setInputSpecFilter(e.target.value);
  };

  // --- Handler for Search Button Click ---
  const handleSearchClick = () => {
    // Construct the new effective criteria object from input states
    const newCriteria = {
      query: inputSearchTerm,
      in_stock_only: inputInStockOnly,
      include_discounted_only: inputIncludeDiscountedOnly,
      category_id: inputCategoryId,
      brand: inputBrand,
      min_price: inputMinPrice !== "" ? parseInt(inputMinPrice, 10) : "",
      max_price: inputMaxPrice !== "" ? parseInt(inputMaxPrice, 10) : "",
      spec_filter: inputSpecFilter,
    };
    // Update the effective criteria which triggers the query
    updateEffectiveCriteriaAndResetPage(newCriteria);
  };

  // --- Handler for Search Form Submission ---
  const handleSearchSubmit = (e) => {
    e.preventDefault();
    handleSearchClick();
  };

  // --- Determine query function and key based on effective criteria ---
  const hasEffectiveCriteria = Object.values(effectiveSearchCriteria).some(
    (value) => value !== "" && value !== false, // Check if any value is truthy (non-empty string, true boolean, non-zero number)
  );

  const queryFunction = hasEffectiveCriteria ? searchProducts : fetchProducts;

  // Build query parameters object for the API call
  const buildQueryParams = () => {
    const params = {
      page: currentPage,
      limit: itemsPerPage,
    };
    // Add criteria if they are active
    if (effectiveSearchCriteria.query) {
      params.query = effectiveSearchCriteria.query;
    }
    if (effectiveSearchCriteria.in_stock_only) params.in_stock_only = true;
    if (effectiveSearchCriteria.include_discounted_only) {
      params.include_discounted_only = true;
    }
    if (effectiveSearchCriteria.category_id) {
      params.category_id = effectiveSearchCriteria.category_id;
    }
    if (effectiveSearchCriteria.brand) {
      params.brand = effectiveSearchCriteria.brand;
    }
    if (effectiveSearchCriteria.min_price !== "") {
      params.min_price = effectiveSearchCriteria.min_price;
    }
    if (effectiveSearchCriteria.max_price !== "") {
      params.max_price = effectiveSearchCriteria.max_price;
    }
    if (effectiveSearchCriteria.spec_filter) {
      params.spec_filter = effectiveSearchCriteria.spec_filter;
    }
    return params;
  };

  // Build the query key including all criteria values
  const queryKey = hasEffectiveCriteria
    ? ["searchProducts", ...Object.values(buildQueryParams()).slice(2)] // Exclude page and limit from key if they are last two elements
    : ["products", currentPage, itemsPerPage];

  const {
    data,
    isLoading,
    isError,
    error,
    refetch,
  } = useQuery({
    queryKey: queryKey,
    queryFn: () => {
      const queryParams = buildQueryParams();
      if (hasEffectiveCriteria) {
        const { query, ...filters } = queryParams;
        return queryFunction(query, currentPage, itemsPerPage, filters);
      } else {
        return queryFunction(currentPage, itemsPerPage);
      }
    },
    select: (response) => {
      const { data, page, limit, total, total_pages } = response.data;
      return {
        products: data,
        pagination: { page, limit, total, totalPages: total_pages },
      };
    },
    staleTime: 1500,
    gcTime: 5 * 60 * 1000,
  });

  // Destructure data and pagination metadata
  const { products = [], pagination } = data || {};

  // Define the delete mutation
  const deleteMutation = useMutation({
    mutationFn: deleteProduct,
    onSuccess: (data, deletedId) => {
      queryClient.invalidateQueries({ queryKey: ["products"] });
      queryClient.invalidateQueries({ queryKey: ["searchProducts"] });
      toast.success(`Product ID ${deletedId} deleted successfully.`);
    },
    onError: (error, deletedId) => {
      console.error("Delete Error:", error);
      toast.error(
        `Failed to delete product ID ${deletedId}: ${
          error.message || "Unknown error"
        }`,
      );
    },
  });

  const handleDelete = (productId) => {
    if (
      window.confirm(
        `Are you sure you want to delete product ID: ${productId}? This action cannot be undone.`,
      )
    ) {
      deleteMutation.mutate(productId);
    }
  };

  // Handler for changing pages
  const goToPage = (newPage) => {
    if (pagination) {
      const { page: currentPageFromMeta, totalPages } = pagination;
      if (newPage >= 1 && (!totalPages || newPage <= totalPages)) {
        setCurrentPage(newPage);
      }
    } else {
      if (newPage >= 1) {
        setCurrentPage(newPage);
      }
    }
  };

  // Handler for changing items per page
  const handleItemsPerPageChange = (newLimit) => {
    setItemsPerPage(newLimit);
    setCurrentPage(1);
  };

  // Helper function to truncate UUID
  const truncateUuid = (uuid) => {
    if (!uuid || typeof uuid !== "string") return "N/A";
    return `${uuid.substring(0, 8)}...`;
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  }

  if (isError) {
    return (
      <div className="alert alert-error shadow-lg">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          className="stroke-current flex-shrink-0 h-6 w-6"
          fill="none"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="2"
            d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"
          />
        </svg>
        <span>Error: {error.message}</span>
        <button onClick={() => refetch()} className="btn btn-sm">Retry</button>
      </div>
    );
  }

  return (
    <div className="bg-neutral p-6 rounded-lg shadow-md">
      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-6">
        <h2 className="text-xl font-bold">Products</h2>
        <div className="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
          <form onSubmit={handleSearchSubmit} className="flex-1 flex gap-2">
            <input
              type="text"
              placeholder="Search by name/desc..."
              className="input input-bordered w-full flex-grow"
              value={inputSearchTerm}
              onChange={handleInputSearchTermChange}
              onClick={handleInputSearchTermChange}
            />
            <button type="submit" className="btn btn-primary">
              <MagnifyingGlassIcon className="w-5 h-5" />
            </button>
          </form>
          <Link
            to="/admin/products/add"
            className="btn btn-accent flex items-center gap-2"
          >
            <PlusCircleIcon className="w-5 h-5" />
            Add Product
          </Link>
        </div>
      </div>

      {/* --- Filter Controls --- */}
      <div className="bg-base-100 p-4 rounded-box mb-4 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        <div className="form-control">
          <label className="cursor-pointer label flex items-center justify-between">
            <span className="label-text">In Stock Only</span>
            <input
              type="checkbox"
              className="toggle toggle-primary"
              checked={effectiveSearchCriteria.in_stock_only}
              onChange={handleInputInStockOnlyChange}
            />
          </label>
        </div>
        <div className="form-control">
          <label className="cursor-pointer label flex items-center justify-between">
            <span className="label-text">Discounted Only</span>
            <input
              type="checkbox"
              className="toggle toggle-primary"
              checked={effectiveSearchCriteria.include_discounted_only}
              onChange={handleInputIncludeDiscountedOnlyChange}
            />
          </label>
        </div>
        <div className="form-control">
          <label className="label">
            <span className="label-text">Brand</span>
          </label>
          <input
            type="text"
            placeholder="e.g., Intel, AMD..."
            className="input input-bordered input-sm"
            value={inputBrand}
            onChange={handleInputBrandChange}
          />
        </div>
        <div className="form-control">
          <label className="label">
            <span className="label-text">Min Price (cents)</span>
          </label>
          <input
            type="number"
            min="0"
            placeholder="e.g., 10000"
            className="input input-bordered input-sm"
            value={inputMinPrice}
            onChange={handleInputMinPriceChange}
          />
        </div>
        <div className="form-control">
          <label className="label">
            <span className="label-text">Max Price (cents)</span>
          </label>
          <input
            type="number"
            min="0"
            placeholder="e.g., 1000000"
            className="input input-bordered input-sm"
            value={inputMaxPrice}
            onChange={handleInputMaxPriceChange}
          />
        </div>
        <div className="form-control md:col-span-2 lg:col-span-1">
          <label className="label">
            <span className="label-text">Spec Filter (key:value)</span>
          </label>
          <input
            type="text"
            placeholder="e.g., socket:AM5, memory:16..."
            className="input input-bordered input-sm"
            value={inputSpecFilter}
            onChange={handleInputSpecFilterChange}
          />
        </div>
      </div>

      {pagination && (
        <div className="flex flex-col sm:flex-row justify-between items-center mb-4 gap-2">
          <div className="text-sm">
            Showing {(pagination.page - 1) * pagination.limit + 1} -
            {Math.min(pagination.page * pagination.limit, pagination.total)} of
            {" "}
            {pagination.total} products
          </div>
          <div className="join">
            <button
              className="join-item btn btn-xs"
              onClick={() => goToPage(pagination.page - 1)}
              disabled={pagination.page <= 1}
            >
              « Prev
            </button>
            <button className="join-item btn btn-xs">
              Page {pagination.page} of {pagination.totalPages}
            </button>
            <button
              className="join-item btn btn-xs"
              onClick={() => goToPage(pagination.page + 1)}
              disabled={pagination.page >= pagination.totalPages}
            >
              Next »
            </button>
          </div>
          <select
            className="select select-bordered select-xs w-24"
            value={itemsPerPage}
            onChange={(e) => handleItemsPerPageChange(Number(e.target.value))}
          >
            <option value={10}>10/page</option>
            <option value={20}>20/page</option>
            <option value={50}>50/page</option>
            <option value={100}>100/page</option>
          </select>
        </div>
      )}

      <div className="overflow-x-auto">
        <table className="table table-zebra w-full">
          <thead>
            <tr>
              <th>Thumbnail</th>
              <th>ID (Truncated)</th>
              <th>Name</th>
              <th>Category</th>
              <th>Price (DZD)</th>
              <th>Stock</th>
              <th>Status</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {products.length > 0
              ? (
                products.map((product) => {
                  const priceInDZD = (product.price_cents / 100).toFixed(2);
                  let statusClass = "badge-ghost";
                  if (product.status === "active") {
                    statusClass = "badge-success";
                  } else if (product.status === "draft") {
                    statusClass = "badge-warning";
                  } else if (product.status === "discontinued") {
                    statusClass = "badge-error";
                  }

                  let stockClass = "badge-info";
                  if (product.stock_quantity === 0) stockClass = "badge-error";
                  else if (product.stock_quantity < 5) {
                    stockClass = "badge-warning";
                  } else if (
                    product.stock_quantity > 20
                  ) stockClass = "badge-success";

                  let firstImageUrl =
                    "https://placehold.co/60x60?text=No+Image  ";
                  if (
                    product.image_urls && Array.isArray(product.image_urls) &&
                    product.image_urls.length > 0
                  ) {
                    const imagePath = product.image_urls[0];
                    firstImageUrl = `${BACKEND_BASE_URL}${imagePath}`;
                  }

                  return (
                    <tr key={product.id}>
                      <td>
                        <div className="avatar">
                          <div className="mask mask-squircle w-12 h-12">
                            <img
                              src={firstImageUrl}
                              alt={`${product.name} thumbnail`}
                              onError={(e) => {
                                e.target.src =
                                  "https://placehold.co/60x60?text=Err  ";
                              }}
                            />
                          </div>
                        </div>
                      </td>
                      <td title={product.id}>{truncateUuid(product.id)}</td>
                      <td>{product.name}</td>
                      <td>
                        {product.category_name || product.category_id || "N/A"}
                      </td>
                      <td>{priceInDZD}</td>
                      <td>
                        <span className={`badge ${stockClass}`}>
                          {product.stock_quantity}
                        </span>
                      </td>
                      <td>
                        <span className={`badge ${statusClass}`}>
                          {product.status}
                        </span>
                      </td>
                      <td>
                        <div className="flex gap-2">
                          <Link
                            to={`/admin/products/${product.id}/edit`}
                            className="btn btn-xs btn-info"
                          >
                            <PencilSquareIcon className="w-4 h-4" />
                          </Link>
                          <button
                            className="btn btn-xs btn-error"
                            onClick={() => handleDelete(product.id)}
                            disabled={deleteMutation.isPending}
                          >
                            {deleteMutation.isPending &&
                                deleteMutation.variables === product.id
                              ? (
                                <span className="loading loading-spinner loading-xs">
                                </span>
                              )
                              : <TrashIcon className="w-4 h-4" />}
                          </button>
                          <Link
                            to={`/admin/products/${product.id}`}
                            className="btn btn-xs btn-info mr-1"
                          >
                            View
                          </Link>
                        </div>
                      </td>
                    </tr>
                  );
                })
              )
              : (
                <tr>
                  <td colSpan="8" className="text-center py-4">
                    No products found.
                  </td>
                </tr>
              )}
          </tbody>
        </table>
      </div>

      {pagination && (
        <div className="flex flex-col sm:flex-row justify-between items-center mt-4 gap-2">
          <div className="text-sm">
            Showing {(pagination.page - 1) * pagination.limit + 1} -
            {Math.min(pagination.page * pagination.limit, pagination.total)} of
            {" "}
            {pagination.total} products
          </div>
          <div className="join">
            <button
              className="join-item btn btn-xs"
              onClick={() => goToPage(pagination.page - 1)}
              disabled={pagination.page <= 1}
            >
              « Prev
            </button>
            <button className="join-item btn btn-xs">
              Page {pagination.page} of {pagination.totalPages}
            </button>
            <button
              className="join-item btn btn-xs"
              onClick={() => goToPage(pagination.page + 1)}
              disabled={pagination.page >= pagination.totalPages}
            >
              Next »
            </button>
          </div>
          <select
            className="select select-bordered select-xs w-24"
            value={itemsPerPage}
            onChange={(e) => handleItemsPerPageChange(Number(e.target.value))}
          >
            <option value={10}>10/page</option>
            <option value={20}>20/page</option>
            <option value={50}>50/page</option>
            <option value={100}>100/page</option>
          </select>
        </div>
      )}
    </div>
  );
};

export default ProductsList;


File: dashboard/src/pages/AdminDashboard.jsx
================================================
import React, { useMemo, useState } from "react";
import { Link } from "react-router-dom";
import { useQuery } from "@tanstack/react-query";
import {
  fetchAverageOrderValueAnalytics,
  fetchLowStockAnalytics,
  fetchNewCustomersAnalytics,
  fetchOrderStatusCountsAnalytics, // Import the new function
  fetchRevenueAnalytics,
  fetchSalesVolumeAnalytics,
  fetchTopCategoriesAnalytics,
  fetchTopProductsAnalytics,
} from "../services/api";
import {
  CurrencyDollarIcon,
  ShoppingCartIcon,
  UserPlusIcon,
} from "@heroicons/react/24/outline";

const AdminDashboard = () => {
  const [timeRange, setTimeRange] = useState("month"); // "day", "week", "month", "year"

  // State for low stock threshold
  const [lowStockThreshold, setLowStockThreshold] = useState(10); // Default to 10

  // Calculate start/end dates based on timeRange using useMemo
  const { start, end } = useMemo(() => {
    const now = new Date();
    let start = new Date(now);

    if (timeRange === "day") {
      start.setDate(start.getDate() - 1);
    } else if (timeRange === "week") {
      start.setDate(start.getDate() - 7);
    } else if (timeRange === "month") {
      start.setMonth(start.getMonth() - 1);
    } else if (timeRange === "year") {
      start.setFullYear(start.getFullYear() - 1);
    }
    return { start: start.toISOString(), end: now.toISOString() };
  }, [timeRange]);

  // Fetch revenue, sales volume, average order value, new customers, top products, top categories, AND order status counts data (dependent on time range)
  const {
    data: metricsData,
    isLoading: metricsLoading,
    isError: metricsError,
    error: metricsApiError,
    refetch: refetchMetrics,
  } = useQuery({
    queryKey: ["dashboardMetrics", timeRange],
    queryFn: async () => {
      const [
        revenueRes,
        volumeRes,
        aovRes,
        newCustomersRes,
        topProductsRes,
        topCategoriesRes,
        orderStatusCountsRes,
      ] = await Promise.all([
        fetchRevenueAnalytics({ start_date: start, end_date: end }),
        fetchSalesVolumeAnalytics({ start_date: start, end_date: end }),
        fetchAverageOrderValueAnalytics({ start_date: start, end_date: end }),
        fetchNewCustomersAnalytics({ start_date: start, end_date: end }),
        fetchTopProductsAnalytics({
          start_date: start,
          end_date: end,
          limit: 5,
        }), // Example: top 5
        fetchTopCategoriesAnalytics({
          start_date: start,
          end_date: end,
          limit: 5,
        }), // Example: top 5
        fetchOrderStatusCountsAnalytics({ start_date: start, end_date: end }), // Fetch status counts
      ]);
      return {
        revenue: revenueRes.data,
        salesVolume: volumeRes.data,
        averageOrderValue: aovRes.data,
        newCustomers: newCustomersRes.data,
        topProducts: topProductsRes.data,
        topCategories: topCategoriesRes.data,
        orderStatusCounts: orderStatusCountsRes.data, // Add order status counts data
      };
    },
    staleTime: 5 * 60 * 1000,
    retry: false,
  });

  // Fetch low stock data separately (independent of time range, dependent on threshold)
  const {
    data: lowStockData,
    isLoading: lowStockLoading,
    isError: lowStockError,
    error: lowStockApiError,
    refetch: refetchLowStock,
  } = useQuery({
    queryKey: ["analytics", "lowStock", lowStockThreshold],
    queryFn: () => fetchLowStockAnalytics({ threshold: lowStockThreshold }),
    select: (response) => response.data,
    staleTime: 1 * 60 * 1000,
    retry: false,
  });

  // Destructure the time-range dependent metrics data
  const {
    revenue,
    salesVolume,
    averageOrderValue,
    newCustomers,
    topProducts,
    topCategories,
    orderStatusCounts,
  } = metricsData || {};

  // Helper function to format currency from cents
  const formatCurrency = (cents) => {
    if (typeof cents !== "number") return "N/A";
    return (cents / 100).toFixed(2);
  };

  // Helper function to truncate UUID
  const truncateUuid = (uuid) => {
    if (!uuid || typeof uuid !== "string") return "N/A";
    return `${uuid.substring(0, 8)}...`;
  };

  // Determine the label for the time range
  let timeRangeLabel = "Last Month";
  if (timeRange === "day") {
    timeRangeLabel = "Last Day";
  } else if (timeRange === "week") {
    timeRangeLabel = "Last Week";
  } else if (timeRange === "year") {
    timeRangeLabel = "Last Year";
  }

  // Determine overall loading state for main metrics
  const overallMetricsLoading = metricsLoading;

  // Determine overall error state for main metrics
  const overallMetricsError = metricsError;

  if (overallMetricsLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  }

  if (overallMetricsError) {
    return (
      <div className="alert alert-error shadow-lg">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          className="stroke-current flex-shrink-0 h-6 w-6"
          fill="none"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="2"
            d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"
          />
        </svg>
        <span>
          Error loading dashboard metrics:{" "}
          {metricsApiError.message || "An unknown error occurred"}. Please try
          again.
        </span>
        <button onClick={refetchMetrics} className="btn btn-sm">Retry</button>
      </div>
    );
  }

  return (
    <div className="container bg-primary-content mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">Admin Dashboard</h1>

      {/* Time Range Selector */}
      <div className="bg-base-100 p-4 rounded-box mb-6">
        <div className="form-control">
          <label className="label">
            <span className="label-text">Select Time Range</span>
          </label>
          <div className="flex flex-wrap gap-4">
            <div className="form-control">
              <label className="cursor-pointer label">
                <span className="label-text">Day</span>
                <input
                  type="radio"
                  name="timeRange"
                  className="radio radio-primary"
                  checked={timeRange === "day"}
                  onChange={() => setTimeRange("day")}
                />
              </label>
            </div>
            <div className="form-control">
              <label className="cursor-pointer label">
                <span className="label-text">Week</span>
                <input
                  type="radio"
                  name="timeRange"
                  className="radio radio-primary"
                  checked={timeRange === "week"}
                  onChange={() => setTimeRange("week")}
                />
              </label>
            </div>
            <div className="form-control">
              <label className="cursor-pointer label">
                <span className="label-text">Month</span>
                <input
                  type="radio"
                  name="timeRange"
                  className="radio radio-primary"
                  checked={timeRange === "month"}
                  onChange={() => setTimeRange("month")}
                />
              </label>
            </div>
            <div className="form-control">
              <label className="cursor-pointer label">
                <span className="label-text">Year</span>
                <input
                  type="radio"
                  name="timeRange"
                  className="radio radio-primary"
                  checked={timeRange === "year"}
                  onChange={() => setTimeRange("year")}
                />
              </label>
            </div>
          </div>
        </div>
      </div>

      {/* Metrics Cards Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
        {/* Revenue Card */}
        <div className="card bg-primary text-primary-content shadow-xl">
          <div className="card-body">
            <h2 className="card-title">
              <CurrencyDollarIcon className="w-6 h-6" />
              Revenue ({timeRangeLabel})
            </h2>
            <p className="text-3xl font-bold">
              {revenue
                ? `DZD ${formatCurrency(revenue.total_revenue_cents)}`
                : "N/A"}
            </p>
            <p className="text-xs opacity-75">
              {revenue
                ? `${new Date(revenue.start_date).toLocaleDateString()} - ${
                  new Date(revenue.end_date).toLocaleDateString()
                }`
                : "Calculating..."}
            </p>
          </div>
        </div>

        {/* Sales Volume Card */}
        <div className="card bg-secondary text-secondary-content shadow-xl">
          <div className="card-body">
            <h2 className="card-title">
              <ShoppingCartIcon className="w-6 h-6" />
              Sales Volume ({timeRangeLabel})
            </h2>
            <p className="text-3xl font-bold">
              {salesVolume ? salesVolume.total_orders : "N/A"}
            </p>
            <p className="text-xs opacity-75">Delivered Orders</p>
          </div>
        </div>

        {/* Average Order Value Card */}
        <div className="card bg-accent text-accent-content shadow-xl">
          <div className="card-body">
            <h2 className="card-title">
              <CurrencyDollarIcon className="w-6 h-6" />
              Avg. Order Value ({timeRangeLabel})
            </h2>
            <p className="text-3xl font-bold">
              {averageOrderValue
                ? `DZD ${formatCurrency(averageOrderValue.aov_cents)}`
                : "N/A"}
            </p>
            <p className="text-xs opacity-75">AOV</p>
          </div>
        </div>

        {/* New Customers Card */}
        <div className="card bg-info text-info-content shadow-xl">
          <div className="card-body">
            <h2 className="card-title">
              <UserPlusIcon className="w-6 h-6" />
              New Customers ({timeRangeLabel})
            </h2>
            <p className="text-3xl font-bold">
              {newCustomers ? newCustomers.new_customers_count : "N/A"}
            </p>
            <p className="text-xs opacity-75">Registrations</p>
          </div>
        </div>
      </div>

      {/* Low Stock Alert Section */}
      <div className="bg-neutral p-6 rounded-lg shadow-md mb-8">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-bold">Low Stock Alerts</h2>
          {/* Threshold Selector */}
          <div className="form-control">
            <label className="label">
              <span className="label-text">Threshold</span>
            </label>
            <select
              className="select select-bordered select-sm w-full max-w-xs"
              value={lowStockThreshold}
              onChange={(e) => setLowStockThreshold(Number(e.target.value))}
            >
              <option value={5}>5</option>
              <option value={10}>10</option>
              <option value={15}>15</option>
              <option value={50}>50</option>
            </select>
          </div>
        </div>

        {lowStockLoading && (
          <div className="flex justify-center items-center h-24">
            <span className="loading loading-spinner loading-lg"></span>
          </div>
        )}
        {lowStockError && (
          <div className="alert alert-error">
            Error loading low stock {lowStockApiError.message}
            <button onClick={refetchLowStock} className="btn btn-sm ml-4">
              Retry
            </button>
          </div>
        )}
        {lowStockData && lowStockData.data && lowStockData.data.length > 0
          ? (
            <div className="overflow-x-auto">
              <table className="table">
                <thead>
                  <tr>
                    <th>Product ID</th> {/* Column header remains the same */}
                    <th>Name</th>
                    <th>Stock Quantity</th>
                  </tr>
                </thead>
                <tbody>
                  {lowStockData.data.map((product) => (
                    <tr key={product.id} className="hover:bg-base-200">
                      <td title={product.id}>
                        {/* Wrap the truncated ID in a Link */}
                        <Link
                          to={`/admin/products/${product.id}`} // Navigate to product detail page
                          className="link link-hover link-primary" // Add styling for links
                        >
                          {truncateUuid(product.id)}
                        </Link>
                      </td>
                      <td>{product.name}</td>
                      <td>
                        <span className="badge badge-error">
                          {product.stock_quantity}
                        </span>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )
          : (
            <p>
              No products found with stock below the threshold
              ({lowStockThreshold}).
            </p>
          )}
      </div>

      {/* Top Products Sold Section */}
      <div className="bg-neutral p-6 rounded-lg shadow-md mb-8">
        <h2 className="text-xl font-bold mb-4">
          Top Products Sold ({timeRangeLabel})
        </h2>
        {metricsLoading && (
          <div className="flex justify-center items-center h-24">
            <span className="loading loading-spinner loading-lg"></span>
          </div>
        )}
        {metricsError && (
          <div className="alert alert-error">
            Error loading top products {metricsApiError.message}
            <button onClick={refetchMetrics} className="btn btn-sm ml-4">
              Retry
            </button>
          </div>
        )}
        {topProducts?.data && topProducts.data.length > 0
          ? (
            <div className="overflow-x-auto">
              <table className="table">
                <thead>
                  <tr>
                    <th>Rank</th>
                    <th>Product ID</th> {/* Add column header */}
                    <th>Product Name</th>
                    <th>Units Sold</th>
                  </tr>
                </thead>
                <tbody>
                  {topProducts.data.map((product, index) => (
                    <tr key={product.id} className="hover:bg-base-200">
                      <td>{index + 1}</td>
                      <td title={product.id}>
                        {/* Wrap the truncated ID in a Link */}
                        <Link
                          to={`/admin/products/${product.id}`} // Navigate to product detail page
                          className="link link-hover " // Add styling for links
                        >
                          {truncateUuid(product.id)}
                        </Link>
                      </td>
                      <td>{product.name}</td>
                      <td>{product.total_units_sold}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )
          : <p>No top products data available for the selected time range.</p>}
      </div>

      {/* Top Categories Sold Section */}
      <div className="bg-neutral p-6 rounded-lg shadow-md mb-8">
        <h2 className="text-xl font-bold mb-4">
          Top Categories Sold ({timeRangeLabel})
        </h2>
        {metricsLoading && (
          <div className="flex justify-center items-center h-24">
            <span className="loading loading-spinner loading-lg"></span>
          </div>
        )}
        {metricsError && (
          <div className="alert alert-error">
            Error loading top categories {metricsApiError.message}
            <button onClick={refetchMetrics} className="btn btn-sm ml-4">
              Retry
            </button>
          </div>
        )}
        {topCategories?.data && topCategories.data.length > 0
          ? (
            <div className="overflow-x-auto">
              <table className="table">
                <thead>
                  <tr>
                    <th>Rank</th>
                    <th>Category Name</th>
                    <th>Units Sold</th>
                  </tr>
                </thead>
                <tbody>
                  {topCategories.data.map((category, index) => (
                    <tr key={category.id} className="hover:bg-base-200">
                      <td>{index + 1}</td>
                      <td>{category.name}</td>
                      <td>{category.total_units_sold}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )
          : (
            <p>
              No top categories data available for the selected time range.
            </p>
          )}
      </div>

      {/* Order Status Counts Section - New */}
      <div className="bg-neutral p-6 rounded-lg shadow-md mb-8">
        <h2 className="text-xl font-bold mb-4">
          Order Status Counts ({timeRangeLabel})
        </h2>
        {metricsLoading && (
          <div className="flex justify-center items-center h-24">
            <span className="loading loading-spinner loading-lg"></span>
          </div>
        )}
        {metricsError && (
          <div className="alert alert-error">
            Error loading order status counts {metricsApiError.message}
            <button onClick={refetchMetrics} className="btn btn-sm ml-4">
              Retry
            </button>
          </div>
        )}
        {orderStatusCounts?.data && orderStatusCounts.data.length > 0
          ? (
            <div className="flex flex-wrap gap-4">
              {orderStatusCounts.data.map((statusCount) => (
                <div key={statusCount.status} className="stats shadow">
                  <div className="stat">
                    <div className="stat-title capitalize">
                      {statusCount.status}
                    </div>
                    <div className="stat-value">{statusCount.count}</div>
                    <div className="stat-desc">&nbsp;</div>
                  </div>
                </div>
              ))}
            </div>
          )
          : <p>No order status data available for the selected time range.</p>}
      </div>
    </div>
  );
};

export default AdminDashboard;


File: docker-compose.yml
================================================
services:
  # --- PostgreSQL Database Service ---
  postgres:
    image: postgres:16-alpine
    container_name: tech_store_postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: ${DB_NAME}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5433:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER} -d ${DB_NAME}"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - app-network

  # --- Redis Cache Service ---
  redis:
    image: redis:7-alpine
    container_name: tech_store_redis
    restart: unless-stopped
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - app-network

  # --- Go Backend Application Service ---
  backend:
    build: .
    container_name: tech_store_backend
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      DATABASE_URL: postgresql://${DB_USER}:${DB_PASSWORD}@postgres:5432/${DB_NAME}?sslmode=disable
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD}
      REDIS_DB: 0
      PORT: 8080
      JWT_SECRET: ${JWT_SECRET}
    env_file:
      - .env
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:8080/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 45s
    networks:
      - app-network

  # --- Website Service ---
  website:
    build:
      context: ./website
      dockerfile: Dockerfile
    container_name: yc_info_website
    restart: unless-stopped
    depends_on:
      backend:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost"]
      interval: 10s
      timeout: 5s
      retries: 3
    networks:
      - app-network

  # --- Dashboard Service ---
  dashboard:
    build:
      context: ./dashboard
      dockerfile: Dockerfile
    container_name: yc_info_dashboard
    restart: unless-stopped
    depends_on:
      backend:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost"]
      interval: 10s
      timeout: 5s
      retries: 3
    networks:
      - app-network

  # --- Nginx Service ---
  nginx:
    image: nginx:alpine
    container_name: tech_store_nginx
    restart: unless-stopped
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf
    depends_on:
      website:
        condition: service_healthy
      dashboard:
        condition: service_healthy
      backend:
        condition: service_healthy
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  postgres_data:
  redis_data:


File: internal/db/multi_discounts.sql.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: multi_discounts.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getProductWithMultiDiscountDetails = `-- name: GetProductWithMultiDiscountDetails :one
SELECT
    p.id,
    p.category_id,
    p.name,
    p.price_cents AS original_price_cents,
    -- ... other product fields ...
    d.id AS discount_id,
    d.code AS discount_code,
    d.discount_type AS discount_type,
    d.discount_value AS discount_value,
    d.created_at 
FROM products p
LEFT JOIN product_discounts pd ON p.id = pd.product_id
LEFT JOIN discounts d ON pd.discount_id = d.id AND d.is_active = TRUE AND NOW() BETWEEN d.valid_from AND d.valid_until
WHERE p.id = $1 AND p.deleted_at IS NULL
ORDER BY d.created_at ASC
`

type GetProductWithMultiDiscountDetailsRow struct {
	ID                 uuid.UUID          `json:"id"`
	CategoryID         uuid.UUID          `json:"category_id"`
	Name               string             `json:"name"`
	OriginalPriceCents int64              `json:"original_price_cents"`
	DiscountID         uuid.UUID          `json:"discount_id"`
	DiscountCode       *string            `json:"discount_code"`
	DiscountType       *string            `json:"discount_type"`
	DiscountValue      *int64             `json:"discount_value"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

// Fetches a product and its active product-specific discounts.
// This might return multiple rows if there are multiple discounts.
// Aggregation into a list happens in Go.
func (q *Queries) GetProductWithMultiDiscountDetails(ctx context.Context, id uuid.UUID) (GetProductWithMultiDiscountDetailsRow, error) {
	row := q.db.QueryRow(ctx, getProductWithMultiDiscountDetails, id)
	var i GetProductWithMultiDiscountDetailsRow
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.OriginalPriceCents,
		&i.DiscountID,
		&i.DiscountCode,
		&i.DiscountType,
		&i.DiscountValue,
		&i.CreatedAt,
	)
	return i, err
}


File: internal/db/db.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"context"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}


File: internal/db/delivery_services.sql.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: delivery_services.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createDeliveryService = `-- name: CreateDeliveryService :one
INSERT INTO delivery_services (
    name, description, base_cost_cents, estimated_days, is_active
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
`

type CreateDeliveryServiceParams struct {
	Name          string  `json:"name"`
	Description   *string `json:"description"`
	BaseCostCents int64   `json:"base_cost_cents"`
	EstimatedDays *int32  `json:"estimated_days"`
	IsActive      bool    `json:"is_active"`
}

func (q *Queries) CreateDeliveryService(ctx context.Context, arg CreateDeliveryServiceParams) (DeliveryService, error) {
	row := q.db.QueryRow(ctx, createDeliveryService,
		arg.Name,
		arg.Description,
		arg.BaseCostCents,
		arg.EstimatedDays,
		arg.IsActive,
	)
	var i DeliveryService
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BaseCostCents,
		&i.EstimatedDays,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDeliveryService = `-- name: DeleteDeliveryService :exec
DELETE FROM delivery_services WHERE id = $1
`

// Soft delete could be achieved by updating is_active to FALSE
// For hard delete:
func (q *Queries) DeleteDeliveryService(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDeliveryService, id)
	return err
}

const getActiveDeliveryServices = `-- name: GetActiveDeliveryServices :many
SELECT id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
FROM delivery_services
WHERE is_active = TRUE
ORDER BY name ASC
`

// Retrieves all delivery services that are currently active.
// Suitable for user-facing contexts like checkout.
func (q *Queries) GetActiveDeliveryServices(ctx context.Context) ([]DeliveryService, error) {
	rows, err := q.db.Query(ctx, getActiveDeliveryServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeliveryService
	for rows.Next() {
		var i DeliveryService
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.BaseCostCents,
			&i.EstimatedDays,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeliveryService = `-- name: GetDeliveryService :one
SELECT id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
FROM delivery_services
WHERE id = $1 AND is_active = $2
`

type GetDeliveryServiceParams struct {
	ID           uuid.UUID `json:"id"`
	ActiveFilter bool      `json:"active_filter"`
}

func (q *Queries) GetDeliveryService(ctx context.Context, arg GetDeliveryServiceParams) (DeliveryService, error) {
	row := q.db.QueryRow(ctx, getDeliveryService, arg.ID, arg.ActiveFilter)
	var i DeliveryService
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BaseCostCents,
		&i.EstimatedDays,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDeliveryServiceByID = `-- name: GetDeliveryServiceByID :one
SELECT id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
FROM delivery_services
WHERE id = $1
`

// Retrieves a delivery service by its ID, regardless of its active status.
// Suitable for admin operations.
func (q *Queries) GetDeliveryServiceByID(ctx context.Context, id uuid.UUID) (DeliveryService, error) {
	row := q.db.QueryRow(ctx, getDeliveryServiceByID, id)
	var i DeliveryService
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BaseCostCents,
		&i.EstimatedDays,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDeliveryServiceByName = `-- name: GetDeliveryServiceByName :one

SELECT id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
FROM delivery_services
WHERE name = $1 AND is_active = $2
`

type GetDeliveryServiceByNameParams struct {
	Name         string `json:"name"`
	ActiveFilter bool   `json:"active_filter"`
}

// Allow filtering by active status
func (q *Queries) GetDeliveryServiceByName(ctx context.Context, arg GetDeliveryServiceByNameParams) (DeliveryService, error) {
	row := q.db.QueryRow(ctx, getDeliveryServiceByName, arg.Name, arg.ActiveFilter)
	var i DeliveryService
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BaseCostCents,
		&i.EstimatedDays,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllDeliveryServices = `-- name: ListAllDeliveryServices :many
SELECT id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
FROM delivery_services
WHERE is_active = $1 -- Filter by active status
ORDER BY name ASC
LIMIT $3 OFFSET $2
`

type ListAllDeliveryServicesParams struct {
	ActiveFilter bool  `json:"active_filter"`
	PageOffset   int32 `json:"page_offset"`
	PageLimit    int32 `json:"page_limit"`
}

// Retrieves delivery services, optionally filtered by active status.
// Suitable for admin operations.
func (q *Queries) ListAllDeliveryServices(ctx context.Context, arg ListAllDeliveryServicesParams) ([]DeliveryService, error) {
	rows, err := q.db.Query(ctx, listAllDeliveryServices, arg.ActiveFilter, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeliveryService
	for rows.Next() {
		var i DeliveryService
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.BaseCostCents,
			&i.EstimatedDays,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDeliveryService = `-- name: UpdateDeliveryService :one

UPDATE delivery_services
SET
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    base_cost_cents = COALESCE($3, base_cost_cents),
    estimated_days = COALESCE($4, estimated_days),
    is_active = COALESCE($5, is_active),
    updated_at = NOW()
WHERE id = $6
RETURNING id, name, description, base_cost_cents, estimated_days, is_active, created_at, updated_at
`

type UpdateDeliveryServiceParams struct {
	Name          *string   `json:"name"`
	Description   *string   `json:"description"`
	BaseCostCents *int64    `json:"base_cost_cents"`
	EstimatedDays *int32    `json:"estimated_days"`
	IsActive      *bool     `json:"is_active"`
	ID            uuid.UUID `json:"id"`
}

// Allow filtering by active status
func (q *Queries) UpdateDeliveryService(ctx context.Context, arg UpdateDeliveryServiceParams) (DeliveryService, error) {
	row := q.db.QueryRow(ctx, updateDeliveryService,
		arg.Name,
		arg.Description,
		arg.BaseCostCents,
		arg.EstimatedDays,
		arg.IsActive,
		arg.ID,
	)
	var i DeliveryService
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BaseCostCents,
		&i.EstimatedDays,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}


File: internal/db/queries/profile.sql
================================================
-- --- Profile & Password Management ---

-- name: UpdateUserFullName :one
-- Updates the user's full name.
UPDATE users
SET full_name = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, email, full_name, is_admin, created_at, updated_at, deleted_at;

-- name: UpdateUserEmail :one
-- Updates the user's email address.
UPDATE users
SET email = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, email, full_name, is_admin, created_at, updated_at, deleted_at;

-- name: UpdateUserPassword :one
-- Updates the user's hashed password.
UPDATE users
SET password_hash = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, email, full_name, is_admin, created_at, updated_at, deleted_at;

-- --- Password Reset Tokens ---

-- name: CreatePasswordResetToken :exec
-- Inserts a new password reset token record.
INSERT INTO password_reset_tokens (user_id, token, expires_at)
VALUES ($1, $2, $3); -- $1=user_id, $2=token_string, $3=expiry_time

-- name: GetResetToken :one
-- Fetches a password reset token record by its token string.
SELECT id, user_id, token, expires_at, created_at
FROM password_reset_tokens
WHERE token = $1; -- $1=token_string

-- name: GetUserByResetToken :one
-- Fetches the user associated with a valid, non-expired reset token.
SELECT u.id, u.email, u.full_name, u.password_hash, u.is_admin, u.created_at, u.updated_at, u.deleted_at
FROM users u
JOIN password_reset_tokens prt ON u.id = prt.user_id
WHERE prt.token = $1 -- $1=token_string
  AND prt.expires_at > NOW(); -- Ensure token hasn't expired

-- name: DeletePasswordResetToken :exec
-- Deletes a specific password reset token record by its token string.
DELETE FROM password_reset_tokens
WHERE token = $1; -- $1=token_string

-- name: DeleteExpiredPasswordResetTokens :exec
-- Deletes all password reset tokens that have expired.
DELETE FROM password_reset_tokens
WHERE expires_at <= NOW();



File: internal/db/queries/cart.sql
================================================
-- Cart Management
-- name: CreateUserCart :one
INSERT INTO carts (user_id, created_at, updated_at, deleted_at) -- Only user_id in the INSERT
VALUES (sqlc.arg(user_id), NOW(), NOW(), NULL) -- Uses sqlc.arg(user_id)
RETURNING id, user_id, session_id, created_at, updated_at, deleted_at;

-- name: CreateGuestCart :one
INSERT INTO carts (session_id, created_at, updated_at, deleted_at) -- Only session_id in the INSERT
VALUES (sqlc.arg(session_id), NOW(), NOW(), NULL) -- Uses sqlc.arg(session_id)
RETURNING id, user_id, session_id, created_at, updated_at, deleted_at;

-- name: GetCartByID :one
SELECT
    id,
    user_id,
    session_id,
    created_at,
    updated_at
FROM carts
WHERE id = sqlc.arg(cart_id) AND deleted_at IS NULL;

-- name: GetCartByUserID :one
SELECT
    id,
    user_id,
    session_id,
    created_at,
    updated_at
FROM carts
WHERE user_id = sqlc.arg(user_id) AND deleted_at IS NULL;

-- name: GetCartBySessionID :one
SELECT
    id,
    user_id,
    session_id,
    created_at,
    updated_at
FROM carts
WHERE session_id = sqlc.arg(session_id) AND deleted_at IS NULL;

-- Cart Item Management
-- name: CreateCartItem :one
INSERT INTO cart_items (cart_id, product_id, quantity, created_at, updated_at)
SELECT
    sqlc.arg(cart_id), -- $1
    sqlc.arg(product_id), -- $2
    sqlc.arg(quantity), -- $3
    NOW(),
    NOW()
FROM products
WHERE id = sqlc.arg(product_id) -- Check product exists
    AND stock_quantity >= sqlc.arg(quantity) -- Ensure enough stock for the INSERT
    AND status = 'active'
    AND deleted_at IS NULL
ON CONFLICT (cart_id, product_id)
DO UPDATE SET
    quantity = CASE
        WHEN cart_items.deleted_at IS NOT NULL THEN
            -- If the existing row was soft-deleted, check stock for the NEW requested quantity
            CASE
                WHEN (SELECT stock_quantity FROM products WHERE id = sqlc.arg(product_id)) >= sqlc.arg(quantity) THEN
                    sqlc.arg(quantity) -- Set to the NEW requested quantity if stock allows
                ELSE
                    -- Keep old quantity if stock check fails here
                    cart_items.quantity
            END
        ELSE
            -- If the existing row was NOT soft-deleted, add the new quantity and check total against stock
            LEAST(
                cart_items.quantity + sqlc.arg(quantity), -- Add new quantity
                (SELECT stock_quantity FROM products WHERE id = sqlc.arg(product_id)) -- Cap at stock
            )
    END,
    deleted_at = CASE
        WHEN cart_items.deleted_at IS NOT NULL THEN NULL -- Undelete if it was soft-deleted
        ELSE cart_items.deleted_at -- Keep deleted_at if it wasn't soft-deleted
    END,
    updated_at = NOW()
RETURNING
    id,
    cart_id,
    product_id,
    quantity,
    created_at,
    updated_at,
    deleted_at; -- Include deleted_at to see if undeletion happened

-- name: AddCartItemsBulk :execrows
-- Adds multiple items to a cart, handling upserts and soft deletes.
-- Checks stock availability for each item during the insert/update process.
INSERT INTO cart_items (cart_id, product_id, quantity, created_at, updated_at)
SELECT 
  sqlc.arg(cart_id), -- $1: The target cart ID
  input.product_id,
  input.quantity, -- Use the new requested quantity
  NOW(),
  NOW()
FROM (
  -- Prepare input data using UNNEST
  SELECT 
    UNNEST(sqlc.arg(product_ids)::uuid[]) as product_id, -- $2: Array of product IDs
    UNNEST(sqlc.arg(quantities)::int[]) as quantity      -- $3: Array of corresponding quantities
) as input
-- Join with products table to validate existence, status, deletion, and stock for the INSERT
INNER JOIN products p ON p.id = input.product_id
  AND p.stock_quantity >= input.quantity -- Ensure sufficient stock for the NEW quantity during INSERT
  AND p.status = 'active'
  AND p.deleted_at IS NULL
ON CONFLICT (cart_id, product_id)
DO UPDATE SET
  quantity = CASE
    -- If the existing row in cart_items was soft-deleted, check stock and set to NEW quantity
    WHEN cart_items.deleted_at IS NOT NULL THEN
      CASE
        -- Re-check stock against the NEW quantity being added via EXCLUDED (the values that would have been inserted)
        WHEN (SELECT stock_quantity FROM products WHERE id = EXCLUDED.product_id) >= EXCLUDED.quantity THEN
          EXCLUDED.quantity -- Set to the NEW quantity from the INSERT attempt (overwrites old soft-deleted quantity)
        ELSE
          -- If stock check fails for the new quantity, keep the old soft-deleted quantity.
          -- Alternatively, could raise an exception depending on desired behavior.
          cart_items.quantity
      END
    -- If the existing row was NOT soft-deleted, add the new quantity and check total against stock
    ELSE
      LEAST(
        cart_items.quantity + EXCLUDED.quantity, -- Add the new quantity
        (SELECT stock_quantity FROM products WHERE id = EXCLUDED.product_id) -- Cap at product's stock
      )
  END,
  -- Undelete the item if it was soft-deleted, otherwise leave its status unchanged
  deleted_at = CASE
    WHEN cart_items.deleted_at IS NOT NULL THEN NULL -- Undelete
    ELSE cart_items.deleted_at -- Keep as is
  END,
  updated_at = NOW();

-- name: SyncGuestCartItemsToUserCart :exec
-- Merges items from a guest cart into a user's cart using upsert logic.
-- Handles quantity updates, stock checks, and soft-delete state transitions (undeletion).
-- This query performs the core merge operation efficiently in a single statement.
INSERT INTO cart_items (cart_id, product_id, quantity, created_at, updated_at)
SELECT
    sqlc.arg(target_user_cart_id), -- $1: The destination user's cart ID
    ci.product_id,
    ci.quantity, -- Quantity from the guest cart item
    NOW(), -- New created_at timestamp for the entry in the user's cart
    NOW()  -- New updated_at timestamp for the user's cart
FROM
    cart_items ci -- Primary table: items from the source guest cart
INNER JOIN products p ON p.id = ci.product_id -- Join with products table to validate and get stock info at INSERT time
    AND p.stock_quantity >= ci.quantity -- Ensure sufficient stock for the NEW quantity during INSERT
    AND p.status = 'active'
    AND p.deleted_at IS NULL
WHERE
    ci.cart_id = sqlc.arg(source_guest_cart_id) -- Filter items from the specific guest cart
    AND ci.deleted_at IS NULL -- Only sync items not marked as deleted in the guest cart
ON CONFLICT (cart_id, product_id)
DO UPDATE SET
    -- In the UPDATE part (conflict resolution), handle merging with existing items in the user's cart
    quantity = CASE
        -- Scenario: The item exists in the user's cart but was soft-deleted.
        WHEN cart_items.deleted_at IS NOT NULL THEN
            CASE
                -- Re-check stock against the quantity being added from the guest cart (EXCLUDED.quantity).
                WHEN (SELECT stock_quantity FROM products WHERE id = EXCLUDED.product_id) >= EXCLUDED.quantity THEN
                    EXCLUDED.quantity -- Set to the guest cart's quantity (overwrites old soft-deleted quantity)
                ELSE
                    -- If stock check fails for the guest quantity, keep the old soft-deleted quantity.
                    cart_items.quantity
            END
        -- Scenario: The item exists in the user's cart and is NOT soft-deleted.
        ELSE
            -- Add the guest cart's quantity to the user's existing quantity.
            -- Use LEAST to cap the total at the product's available stock.
            LEAST(
                cart_items.quantity + EXCLUDED.quantity, -- Add guest quantity to existing quantity
                (SELECT stock_quantity FROM products WHERE id = EXCLUDED.product_id) -- Cap at product's stock
            )
    END,
    -- Handle the soft-delete state during the update.
    -- If the item was soft-deleted in the user's cart, undelete it.
    deleted_at = CASE
        WHEN cart_items.deleted_at IS NOT NULL THEN NULL -- Undelete if it was soft-deleted
        ELSE cart_items.deleted_at -- Keep existing state (likely NULL)
    END,
    updated_at = NOW(); -- Update the timestamp

-- name: GetCartItemsCount :one
-- Counts the number of active (non-deleted) items in a specific cart.
SELECT COUNT(*) AS num_cart_items
FROM cart_items
WHERE cart_id = sqlc.arg(cart_id) AND deleted_at IS NULL;

-- name: UpdateCartItemQuantity :one
UPDATE cart_items ci
SET quantity = sqlc.arg(new_quantity), updated_at = NOW()
FROM products p
WHERE ci.id = sqlc.arg(item_id)
    AND ci.product_id = p.id
    AND sqlc.arg(new_quantity) > 0
    AND sqlc.arg(new_quantity) <= p.stock_quantity  -- Stock validation
RETURNING
    ci.id,
    ci.cart_id,
    ci.product_id,
    ci.quantity,
    ci.created_at,
    ci.updated_at,
    p.name as product_name,
    p.price_cents as product_price_cents,
    p.stock_quantity as product_stock_quantity,
    p.image_urls as product_image_urls,
    p.brand as product_brand;

-- name: GetCartItemByID :one
SELECT
    id,
    cart_id,
    product_id,
    quantity,
    created_at,
    updated_at
FROM cart_items
WHERE id = sqlc.arg(item_id);

-- name: GetCartItemByCartAndProduct :one
SELECT
    id,
    cart_id,
    product_id,
    quantity,
    created_at,
    updated_at
FROM cart_items
WHERE cart_id = sqlc.arg(cart_id) AND product_id = sqlc.arg(product_id);

-- Enhanced Cart Data Retrieval
-- name: GetCartItemsWithProductDetails :many
SELECT
    ci.id,
    ci.cart_id,
    ci.product_id,
    ci.quantity,
    ci.created_at,
    ci.updated_at,
    p.name as product_name,
    p.price_cents as product_price_cents,
    p.stock_quantity as product_stock_quantity,
    p.image_urls as product_image_urls,
    p.brand as product_brand
FROM cart_items ci
JOIN products p ON ci.product_id = p.id
WHERE ci.cart_id = sqlc.arg(cart_id)
    AND p.deleted_at IS NULL
    AND p.status = 'active'
ORDER BY ci.created_at DESC;

-- name: GetCartWithItemsAndProducts :many
SELECT
    c.id as cart_id,
    c.user_id as cart_user_id,
    c.session_id as cart_session_id,
    c.created_at as cart_created_at,
    c.updated_at as cart_updated_at,
    ci.id as cart_item_id,
    ci.cart_id as cart_item_cart_id,
    ci.product_id as cart_item_product_id,
    ci.quantity as cart_item_quantity,
    ci.created_at as cart_item_created_at,
    ci.updated_at as cart_item_updated_at,
    p.name as product_name,
    p.price_cents as product_price_cents,
    p.stock_quantity as product_stock_quantity,
    p.image_urls as product_image_urls,
    p.brand as product_brand
FROM carts c
LEFT JOIN cart_items ci ON c.id = ci.cart_id
LEFT JOIN products p ON ci.product_id = p.id
WHERE c.id = sqlc.arg(cart_id)
    AND ci.deleted_at is Null
    AND (p.deleted_at IS NULL OR p.id IS NULL)
ORDER BY ci.created_at DESC;

-- name: GetCartStats :one
SELECT
    COUNT(ci.id) as total_items,
    SUM(ci.quantity) FILTER (WHERE p.id IS NOT NULL) as total_quantity,
    SUM(ci.quantity * p.price_cents) FILTER (WHERE p.id IS NOT NULL) as total_value
FROM carts c
LEFT JOIN cart_items ci ON c.id = ci.cart_id
LEFT JOIN products p ON ci.product_id = p.id
WHERE c.id = sqlc.arg(cart_id)
    AND p.deleted_at IS NULL
    AND p.status = 'active';

-- Cart Cleanup
-- name: DeleteCartItem :exec
UPDATE cart_items
SET deleted_at = NOW()
WHERE id = sqlc.arg(item_id);

-- name: ClearCart :exec
UPDATE cart_items
SET deleted_at = NOW()
WHERE cart_id = sqlc.arg(cart_id);

-- name: DeleteCart :exec
UPDATE carts
SET deleted_at = NOW()
WHERE id = sqlc.arg(cart_id);


File: internal/models/context.go
================================================
package models

import (
	"context" // Import context package
)

type ContextUserKey string
const ContextKeyUser ContextUserKey = "user"

func GetUserFromContext(ctx context.Context) (*User, bool) {
	// Retrieve the value associated with the ContextKeyUser key from the context
	user, ok := ctx.Value(ContextKeyUser).(*User) // Type assertion
	// ctx.Value returns interface{}, so we assert it to *User
	return user, ok // Return the user object (or nil) and a boolean indicating success/failure
}



File: internal/models/auth.go
================================================
package models

type LoginResponse struct {
	Token string `json:"access_token"` // Rename for clarity
	User  User   `json:"user"`
}

type RefreshResponse struct {
	AccessToken string `json:"access_token"` // New access token
}

type RefreshRequest struct {
}

type LogoutRequest struct {
}

func (lr *LoginResponse) Validate() error {
	return nil
}

func (rr *RefreshResponse) Validate() error {
	return nil
}

func (rr *RefreshRequest) Validate() error {
	return Validate.Struct(rr)
}

func (lr *LogoutRequest) Validate() error {
	return Validate.Struct(lr)
}


File: internal/handlers/category.go
================================================
package handlers

import (
	"encoding/json"
	"errors"
	"log/slog"
	"net/http"
	"strconv"
	"strings"

	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/MihoZaki/DzTech/internal/services"
	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

// CategoryHandler handles HTTP requests for categories.
type CategoryHandler struct {
	service *services.CategoryService
	logger  *slog.Logger
}

// NewCategoryHandler creates a new instance of CategoryHandler.
func NewCategoryHandler(service *services.CategoryService, logger *slog.Logger) *CategoryHandler {
	return &CategoryHandler{
		service: service,
		logger:  logger,
	}
}

// RegisterRoutes registers the category-related routes under the given router.
// This should be mounted under the admin routes (e.g., /api/v1/admin/categories).
func (h *CategoryHandler) RegisterRoutes(r chi.Router) {
	r.Post("/", h.CreateCategory)       // POST /api/v1/admin/categories
	r.Get("/{id}", h.GetCategory)       // GET /api/v1/admin/categories/{id}
	r.Get("/", h.ListCategories)        // GET /api/v1/admin/categories
	r.Put("/{id}", h.UpdateCategory)    // PUT /api/v1/admin/categories/{id}
	r.Delete("/{id}", h.DeleteCategory) // DELETE /api/v1/admin/categories/{id}
}

// CreateCategory handles creating a new category.
func (h *CategoryHandler) CreateCategory(w http.ResponseWriter, r *http.Request) {
	var req models.CreateCategoryRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Error("Invalid JSON in CreateCategory request", "error", err)
		sendErrorResponse(w, http.StatusBadRequest, "Invalid JSON", "Request body contains invalid JSON")
		return
	}

	// Validate the request payload
	if err := req.Validate(); err != nil {
		h.logger.Error("Validation failed for CreateCategory request", "error", err)
		sendValidationError(w, err)
		return
	}

	createdCategory, err := h.service.CreateCategory(r.Context(), req)
	if err != nil {
		h.logger.Error("Failed to create category", "error", err)
		if errors.Is(err, pgx.ErrNoRows) && strings.Contains(err.Error(), "parent category") {
			sendErrorResponse(w, http.StatusBadRequest, "Bad Request", "Parent category not found")
			return
		}
		sendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to create category")
		return
	}

	h.logger.Info("Category created successfully", "category_id", createdCategory.ID, "name", createdCategory.Name)
	sendSuccessResponse(w, http.StatusCreated, createdCategory)
}

// GetCategory handles retrieving a specific category by its ID.
func (h *CategoryHandler) GetCategory(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		h.logger.Error("Invalid ID parameter in GetCategory request", "value", idStr, "error", err)
		sendErrorResponse(w, http.StatusBadRequest, "Invalid Parameter", "Parameter 'id' must be a valid UUID")
		return
	}

	category, err := h.service.GetCategory(r.Context(), id)
	if err != nil {
		h.logger.Error("Failed to get category", "id", id, "error", err)
		if errors.Is(err, pgx.ErrNoRows) {
			sendErrorResponse(w, http.StatusNotFound, "Not Found", "Category not found")
			return
		}
		sendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to retrieve category")
		return
	}

	h.logger.Info("Category retrieved successfully", "category_id", id)
	sendSuccessResponse(w, http.StatusOK, category)
}

// ListCategories handles retrieving a paginated list of categories.
func (h *CategoryHandler) ListCategories(w http.ResponseWriter, r *http.Request) {
	pageStr := r.URL.Query().Get("page")
	page, err := strconv.Atoi(pageStr)
	if err != nil || page < 1 {
		page = 1 // Default to page 1
	}

	limitStr := r.URL.Query().Get("limit")
	limit, err := strconv.Atoi(limitStr)
	if err != nil || limit < 1 {
		limit = 20 // Default to 20 per page
	}
	if limit > 100 {
		limit = 100 // Enforce maximum limit
	}

	paginatedResult, err := h.service.ListCategories(r.Context(), page, limit)
	if err != nil {
		h.logger.Error("Failed to list categories", "page", page, "limit", limit, "error", err)
		sendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to retrieve category list")
		return
	}

	h.logger.Info("Category list retrieved successfully", "page", page, "limit", limit, "total", paginatedResult.Total)
	sendSuccessResponse(w, http.StatusOK, paginatedResult)
}

// UpdateCategory handles updating an existing category.
func (h *CategoryHandler) UpdateCategory(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		h.logger.Error("Invalid ID parameter in UpdateCategory request", "value", idStr, "error", err)
		sendErrorResponse(w, http.StatusBadRequest, "Invalid Parameter", "Parameter 'id' must be a valid UUID")
		return
	}

	var req models.UpdateCategoryRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Error("Invalid JSON in UpdateCategory request", "error", err)
		sendErrorResponse(w, http.StatusBadRequest, "Invalid JSON", "Request body contains invalid JSON")
		return
	}

	// Validate the request payload
	if err := req.Validate(); err != nil {
		h.logger.Error("Validation failed for UpdateCategory request", "error", err)
		sendValidationError(w, err)
		return
	}

	updatedCategory, err := h.service.UpdateCategory(r.Context(), id, req)
	if err != nil {
		h.logger.Error("Failed to update category", "id", id, "error", err)
		if errors.Is(err, pgx.ErrNoRows) {
			sendErrorResponse(w, http.StatusNotFound, "Not Found", "Category not found")
			return
		}
		if strings.Contains(err.Error(), "category not found") {
			sendErrorResponse(w, http.StatusBadRequest, "Bad Request", "category not found")
			return
		}
		if strings.Contains(err.Error(), "cannot be its own parent") {
			sendErrorResponse(w, http.StatusBadRequest, "Bad Request", "Category cannot be its own parent")
			return
		}
		sendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to update category")
		return
	}

	h.logger.Info("Category updated successfully", "category_id", id, "name", updatedCategory.Name)
	sendSuccessResponse(w, http.StatusOK, updatedCategory)
}

// DeleteCategory handles deleting a category by its ID.
func (h *CategoryHandler) DeleteCategory(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		h.logger.Error("Invalid ID parameter in DeleteCategory request", "value", idStr, "error", err)
		sendErrorResponse(w, http.StatusBadRequest, "Invalid Parameter", "Parameter 'id' must be a valid UUID")
		return
	}

	err = h.service.DeleteCategory(r.Context(), id)
	if err != nil {
		h.logger.Error("Failed to delete category", "id", id, "error", err)
		if errors.Is(err, pgx.ErrNoRows) {
			sendErrorResponse(w, http.StatusNotFound, "Not Found", "Category not found")
			return
		}
		sendErrorResponse(w, http.StatusInternalServerError, "Internal Server Error", "Failed to delete category")
		return
	}

	h.logger.Info("Category deleted successfully", "category_id", id)
	w.WriteHeader(http.StatusNoContent) // 204 No Content on successful deletion
}

// --- Helper Functions (Local to Handler) ---

// sendSuccessResponse sends a standard success response.
func sendSuccessResponse(w http.ResponseWriter, statusCode int, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"success": true,
		"data":    data,
	})
}

// sendErrorResponse sends a standard error response.
func sendErrorResponse(w http.ResponseWriter, statusCode int, title, detail string) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"success": false,
		"error":   title,
		"message": detail,
	})
}

// sendValidationError sends a standard validation error response.
// This is a basic example, adjust based on your validation library's error format.
func sendValidationError(w http.ResponseWriter, err error) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusBadRequest)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"success": false,
		"error":   "Validation Error",
		"message": err.Error(), // Provide the validation error message
	})
}


File: internal/handlers/delivery_options.go
================================================
package handlers

import (
	"encoding/json"
	"log/slog"
	"net/http"

	"github.com/MihoZaki/DzTech/internal/services"
	"github.com/go-chi/chi/v5"
)

// DeliveryOptionsHandler manages HTTP requests for fetching delivery options.
type DeliveryOptionsHandler struct {
	service *services.DeliveryServiceService // Inject the DeliveryServiceService
	logger  *slog.Logger
}

// NewDeliveryOptionsHandler creates a new instance of DeliveryOptionsHandler.
func NewDeliveryOptionsHandler(service *services.DeliveryServiceService, logger *slog.Logger) *DeliveryOptionsHandler {
	return &DeliveryOptionsHandler{
		service: service,
		logger:  logger,
	}
}

// GetActiveDeliveryOptions handles retrieving the list of active delivery services.
func (h *DeliveryOptionsHandler) GetActiveDeliveryOptions(w http.ResponseWriter, r *http.Request) {
	deliveryServices, err := h.service.GetActiveDeliveryServices(r.Context())
	if err != nil {
		h.logger.Error("Failed to fetch active delivery options", "error", err)
		http.Error(w, "Failed to retrieve delivery options", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK) // 200 OK
	if err := json.NewEncoder(w).Encode(deliveryServices); err != nil {
		h.logger.Error("Failed to encode GetActiveDeliveryOptions response", "error", err)
	}
}

// RegisterRoutes registers the delivery options-related routes with the provided Chi router.
func (h *DeliveryOptionsHandler) RegisterRoutes(r chi.Router) {
	r.Get("/", h.GetActiveDeliveryOptions) // GET /api/v1/delivery-options/
}


File: internal/utils/errors.go
================================================
package utils

import (
	"encoding/json"
	"log/slog"
	"net/http"
)

type ErrorResponse struct {
	Type     string                 `json:"type"`
	Title    string                 `json:"title"`
	Status   int                    `json:"status"`
	Detail   string                 `json:"detail"`
	Instance string                 `json:"instance,omitempty"`
	Errors   map[string]interface{} `json:"errors,omitempty"`
}

func SendErrorResponse(w http.ResponseWriter, status int, title, detail string) {
	resp := ErrorResponse{
		Type:   "https://techstore.dev/errors/" + getStatusType(status),
		Title:  title,
		Status: status,
		Detail: detail,
	}

	slog.Warn("Sending error response",
		"status", status,
		"title", title,
		"detail", detail,
	)

	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(status)
	json.NewEncoder(w).Encode(resp)
}

func SendValidationError(w http.ResponseWriter, fieldErrors map[string]string) {
	resp := ErrorResponse{
		Type:   "https://techstore.dev/errors/validation-error",
		Title:  "Validation Error",
		Status: http.StatusBadRequest,
		Detail: "One or more fields failed validation",
		Errors: make(map[string]interface{}),
	}

	for field, message := range fieldErrors {
		resp.Errors[field] = map[string]string{"reason": message}
	}

	slog.Warn("Sending validation error response",
		"field_errors", fieldErrors,
	)

	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(http.StatusBadRequest)
	json.NewEncoder(w).Encode(resp)
}

func getStatusType(status int) string {
	switch status {
	case http.StatusBadRequest:
		return "bad-request"
	case http.StatusUnauthorized:
		return "unauthorized"
	case http.StatusForbidden:
		return "forbidden"
	case http.StatusNotFound:
		return "not-found"
	case http.StatusConflict:
		return "conflict"
	case http.StatusUnprocessableEntity:
		return "unprocessable-entity"
	default:
		return "server-error"
	}
}


File: internal/services/delivery_service.go
================================================
package services

import (
	"context"
	"errors"
	"fmt"
	"log/slog"

	"github.com/MihoZaki/DzTech/internal/db"
	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

// DeliveryServiceService handles business logic for delivery services.
type DeliveryServiceService struct {
	querier db.Querier
	logger  *slog.Logger
}

// NewDeliveryServiceService creates a new instance of DeliveryServiceService.
func NewDeliveryServiceService(querier db.Querier, logger *slog.Logger) *DeliveryServiceService {
	return &DeliveryServiceService{
		querier: querier,
		logger:  logger,
	}
}

// GetDeliveryServiceByID retrieves a delivery service by its ID, regardless of active status.
// Suitable for admin operations.
func (s *DeliveryServiceService) GetDeliveryServiceByID(ctx context.Context, id uuid.UUID) (*models.DeliveryService, error) {
	dbDeliveryService, err := s.querier.GetDeliveryServiceByID(ctx, id)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, ErrDeliveryServiceNotFound
		}
		return nil, fmt.Errorf("failed to fetch delivery service by ID: %w", err)
	}

	apiDeliveryService := s.toDeliveryServiceModel(dbDeliveryService)
	return &apiDeliveryService, nil
}

// GetActiveDeliveryServices retrieves all delivery services that are currently active.
// Suitable for user-facing contexts like checkout.
func (s *DeliveryServiceService) GetActiveDeliveryServices(ctx context.Context) ([]models.DeliveryService, error) {
	dbDeliveryServices, err := s.querier.GetActiveDeliveryServices(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch active delivery services: %w", err)
	}

	apiDeliveryServices := make([]models.DeliveryService, len(dbDeliveryServices))
	for i, dbDS := range dbDeliveryServices {
		apiDeliveryServices[i] = s.toDeliveryServiceModel(dbDS)
	}

	return apiDeliveryServices, nil
}

// ListAllDeliveryServices retrieves a list of delivery services, optionally filtered by active status.
// Suitable for admin operations.
func (s *DeliveryServiceService) ListAllDeliveryServices(ctx context.Context, activeOnly bool, limit, offset int) ([]models.DeliveryService, error) {
	if limit <= 0 {
		limit = 20 // Default limit
	}
	if offset < 0 {
		offset = 0 // Default offset
	}

	params := db.ListAllDeliveryServicesParams{
		ActiveFilter: activeOnly, // Pass the filter to the query
		PageLimit:    int32(limit),
		PageOffset:   int32(offset),
	}

	dbDeliveryServices, err := s.querier.ListAllDeliveryServices(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to list delivery services: %w", err)
	}

	apiDeliveryServices := make([]models.DeliveryService, len(dbDeliveryServices))
	for i, dbDS := range dbDeliveryServices {
		apiDeliveryServices[i] = s.toDeliveryServiceModel(dbDS)
	}

	return apiDeliveryServices, nil
}

// CreateDeliveryService creates a new delivery service.
func (s *DeliveryServiceService) CreateDeliveryService(ctx context.Context, req models.CreateDeliveryServiceRequest) (*models.DeliveryService, error) {
	var estimatedDays *int32
	if req.EstimatedDays != nil {
		converted := int32(*req.EstimatedDays)
		estimatedDays = &converted
	} else {
		estimatedDays = nil
	}
	params := db.CreateDeliveryServiceParams{
		Name:          req.Name,
		Description:   req.Description,
		BaseCostCents: req.BaseCostCents,
		EstimatedDays: estimatedDays,
		IsActive:      req.IsActive,
	}

	dbDeliveryService, err := s.querier.CreateDeliveryService(ctx, params)
	if err != nil {
		// Check for unique_violation on 'name' if needed for specific error handling
		return nil, fmt.Errorf("failed to create delivery service: %w", err)
	}

	apiDeliveryService := s.toDeliveryServiceModel(dbDeliveryService)
	return &apiDeliveryService, nil
}

// UpdateDeliveryService updates an existing delivery service.
func (s *DeliveryServiceService) UpdateDeliveryService(ctx context.Context, id uuid.UUID, req models.UpdateDeliveryServiceRequest) (*models.DeliveryService, error) {
	// First, check if the delivery service exists (regardless of active status)
	_, err := s.querier.GetDeliveryServiceByID(ctx, id) // Use the dedicated GetByID query
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, ErrDeliveryServiceNotFound
		}
		return nil, fmt.Errorf("failed to check existence of delivery service before update: %w", err)
	}

	var estimatedDays *int32
	if req.EstimatedDays != nil {
		converted := int32(*req.EstimatedDays)
		estimatedDays = &converted
	} else {
		estimatedDays = nil
	}

	params := db.UpdateDeliveryServiceParams{
		ID:            id,
		Name:          req.Name,
		Description:   req.Description,
		BaseCostCents: req.BaseCostCents,
		EstimatedDays: estimatedDays,
		IsActive:      req.IsActive,
	}

	dbDeliveryService, err := s.querier.UpdateDeliveryService(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to update delivery service: %w", err)
	}

	apiDeliveryService := s.toDeliveryServiceModel(dbDeliveryService)
	return &apiDeliveryService, nil
}

// DeleteDeliveryService deletes a delivery service (hard delete example).
// Consider soft deletion by updating is_active if required.
func (s *DeliveryServiceService) DeleteDeliveryService(ctx context.Context, id uuid.UUID) error {
	// First, check if the delivery service exists (regardless of active status)
	_, err := s.querier.GetDeliveryServiceByID(ctx, id) // Use the dedicated GetByID query
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return ErrDeliveryServiceNotFound
		}
		return fmt.Errorf("failed to check existence of delivery service before delete: %w", err)
	}

	err = s.querier.DeleteDeliveryService(ctx, id)
	if err != nil {
		return fmt.Errorf("failed to delete delivery service: %w", err)
	}
	return nil
}

// --- Helper Functions ---

func (s *DeliveryServiceService) toDeliveryServiceModel(dbDS db.DeliveryService) models.DeliveryService {
	return models.DeliveryService{
		ID:            dbDS.ID,
		Name:          dbDS.Name,
		Description:   dbDS.Description,
		BaseCostCents: dbDS.BaseCostCents,
		EstimatedDays: dbDS.EstimatedDays,
		IsActive:      dbDS.IsActive,
		CreatedAt:     dbDS.CreatedAt.Time,
		UpdatedAt:     dbDS.UpdatedAt.Time,
	}
}

var (
	ErrDeliveryServiceNotFound = errors.New("delivery service not found")
)


File: internal/services/analytics_service.go
================================================
package services

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"time"

	"github.com/MihoZaki/DzTech/internal/db"
	"github.com/MihoZaki/DzTech/internal/models"
	"github.com/redis/go-redis/v9"
)

// AnalyticsService handles business logic for analytics queries.
type AnalyticsService struct {
	querier db.Querier
	cache   *redis.Client // Optional: for caching results
	logger  *slog.Logger
}

// NewAnalyticsService creates a new instance of AnalyticsService.
func NewAnalyticsService(querier db.Querier, cache *redis.Client, logger *slog.Logger) *AnalyticsService {
	return &AnalyticsService{
		querier: querier,
		cache:   cache,
		logger:  logger,
	}
}

// GetTotalRevenue calculates the total revenue from delivered orders within a time range.
func (s *AnalyticsService) GetTotalRevenue(ctx context.Context, startDate, endDate time.Time) (*models.TotalRevenueResponse, error) {
	params := db.GetTotalRevenueParams{
		StartDate: ToPgTimestamptz(startDate),
		EndDate:   ToPgTimestamptz(endDate),
	}

	// Execute the query
	totalRevenueCents, err := s.querier.GetTotalRevenue(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch total revenue: %w", err)
	}

	// Map the result to the response model
	response := &models.TotalRevenueResponse{
		TotalRevenueCents: totalRevenueCents,
		StartDate:         startDate,
		EndDate:           endDate,
	}

	return response, nil
}

// GetSalesVolume counts the total number of delivered orders within a time range.
func (s *AnalyticsService) GetSalesVolume(ctx context.Context, startDate, endDate time.Time) (*models.SalesVolumeResponse, error) {
	// Prepare query parameters
	params := db.GetSalesVolumeParams{
		StartDate: ToPgTimestamptz(startDate),
		EndDate:   ToPgTimestamptz(endDate),
	}

	// Execute the query
	totalOrders, err := s.querier.GetSalesVolume(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch sales volume: %w", err)
	}

	// Map the result to the response model
	response := &models.SalesVolumeResponse{
		TotalOrders: int(totalOrders), // Assuming totalOrders is int64 from the query
		StartDate:   startDate,
		EndDate:     endDate,
	}

	return response, nil
}

// GetAverageOrderValue calculates the average order value for delivered orders within a time range.
func (s *AnalyticsService) GetAverageOrderValue(ctx context.Context, startDate, endDate time.Time) (*models.AverageOrderValueResponse, error) {
	// Prepare query parameters
	params := db.GetAverageOrderValueParams{
		StartDate: ToPgTimestamptz(startDate),
		EndDate:   ToPgTimestamptz(endDate),
	}

	// Execute the query
	aovCentsFloat, err := s.querier.GetAverageOrderValue(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch average order value: %w", err)
	}

	// Convert float64 (from AVG) to int64 for the response model
	// Consider rounding if necessary
	aovCents := int64(aovCentsFloat)

	// Map the result to the response model
	response := &models.AverageOrderValueResponse{
		AovCents:  aovCents,
		StartDate: startDate,
		EndDate:   endDate,
	}

	return response, nil
}

// GetTopSellingProducts retrieves the top N selling products within a time range.
func (s *AnalyticsService) GetTopSellingProducts(ctx context.Context, startDate, endDate time.Time, limit int) (*models.TopSellingProductsResponse, error) {
	// Prepare query parameters
	params := db.GetTopSellingProductsParams{
		StartDate: ToPgTimestamptz(startDate),
		EndDate:   ToPgTimestamptz(endDate),
		Limits:    int32(limit), // Assuming the SQL query expects int32 for LIMIT
	}

	// Execute the query
	dbResults, err := s.querier.GetTopSellingProducts(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch top selling products: %w", err)
	}

	// Map the database results to the application model
	data := make([]models.TopSellingItem, len(dbResults))
	for i, row := range dbResults {
		data[i] = models.TopSellingItem{
			ID:             row.ProductID,
			Name:           row.ProductName,
			TotalUnitsSold: row.TotalUnitsSold,
		}
	}

	// Map the result to the response model
	response := &models.TopSellingProductsResponse{
		Data:      data,
		StartDate: startDate,
		EndDate:   endDate,
		Limit:     limit,
	}

	return response, nil
}

// GetTopSellingCategories retrieves the top N selling categories within a time range.
func (s *AnalyticsService) GetTopSellingCategories(ctx context.Context, startDate, endDate time.Time, limit int) (*models.TopSellingCategoriesResponse, error) {
	// Prepare query parameters
	params := db.GetTopSellingCategoriesParams{
		StartDate: ToPgTimestamptz(startDate),
		EndDate:   ToPgTimestamptz(endDate),
		Limits:    int32(limit), // Assuming the SQL query expects int32 for LIMIT
	}

	// Execute the query
	dbResults, err := s.querier.GetTopSellingCategories(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch top selling categories: %w", err)
	}

	// Map the database results to the application model
	data := make([]models.TopSellingItem, len(dbResults))
	for i, row := range dbResults {
		data[i] = models.TopSellingItem{
			ID:             row.CategoryID,
			Name:           row.CategoryName,
			TotalUnitsSold: row.TotalUnitsSold,
		}
	}

	// Map the result to the response model
	response := &models.TopSellingCategoriesResponse{
		Data:      data,
		StartDate: startDate,
		EndDate:   endDate,
		Limit:     limit,
	}

	return response, nil
}

// GetLowStockProducts retrieves products with stock below a threshold.
func (s *AnalyticsService) GetLowStockProducts(ctx context.Context, threshold int) (*models.LowStockProductsResponse, error) {
	dbResults, err := s.querier.GetLowStockProducts(ctx, int32(threshold)) // Pass threshold directly
	if err != nil {
		return nil, fmt.Errorf("failed to fetch low stock products: %w", err)
	}

	// Map the database results to the application model
	data := make([]models.LowStockProduct, len(dbResults))
	for i, row := range dbResults {
		data[i] = models.LowStockProduct{
			ID:            row.ProductID,
			Name:          row.ProductName,
			StockQuantity: int(row.StockQuantity),
		}
	}

	// Map the result to the response model
	response := &models.LowStockProductsResponse{
		Data:      data,
		Threshold: threshold,
	}

	return response, nil
}

// GetNewCustomersCount counts new customers registered within a time range.
func (s *AnalyticsService) GetNewCustomersCount(ctx context.Context, startDate, endDate time.Time) (*models.CustomerInsightsResponse, error) {
	// Prepare query parameters
	params := db.GetNewCustomersCountParams{
		StartDate: ToPgTimestamptz(startDate),
		EndDate:   ToPgTimestamptz(endDate),
	}

	// Execute the query
	count, err := s.querier.GetNewCustomersCount(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch new customers count: %w", err)
	}

	// Map the result to the response model
	response := &models.CustomerInsightsResponse{
		NewCustomersCount: int(count), // Assuming count is int64 from the query
		StartDate:         startDate,
		EndDate:           endDate,
	}

	return response, nil
}

// GetOrderStatusCounts counts orders by status within a time range.
func (s *AnalyticsService) GetOrderStatusCounts(ctx context.Context, startDate, endDate time.Time) (*models.OrderStatusCountsResponse, error) {
	// Prepare query parameters
	params := db.GetOrderStatusCountsParams{
		StartDate: ToPgTimestamptz(startDate),
		EndDate:   ToPgTimestamptz(endDate),
	}

	// Execute the query
	dbResults, err := s.querier.GetOrderStatusCounts(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch order status counts: %w", err)
	}

	// Map the database results to the application model
	data := make([]models.OrderStatusCount, len(dbResults))
	for i, row := range dbResults {
		data[i] = models.OrderStatusCount{
			Status: row.Status,
			Count:  row.Count,
		}
	}

	// Map the result to the response model
	response := &models.OrderStatusCountsResponse{
		Data:      data,
		StartDate: startDate,
		EndDate:   endDate,
	}

	return response, nil
}

// GetDiscountUsage retrieves usage count and revenue for discounts within a time range.
func (s *AnalyticsService) GetDiscountUsage(ctx context.Context, startDate, endDate time.Time) (*models.DiscountUsageResponse, error) {
	// Prepare query parameters
	params := db.GetDiscountUsageParams{
		StartDate: ToPgTimestamptz(startDate),
		EndDate:   ToPgTimestamptz(endDate),
	}

	// Execute the query
	dbResults, err := s.querier.GetDiscountUsage(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch discount usage: %w", err)
	}

	// Map the database results to the application model
	data := make([]models.DiscountUsageReport, len(dbResults))
	for i, row := range dbResults {
		data[i] = models.DiscountUsageReport{
			Code:                     row.DiscountCode,
			DiscountType:             row.DiscountType,
			DiscountValue:            row.DiscountValue,
			UsageCount:               row.UsageCount,
			TotalRevenueWithDiscount: row.TotalRevenueWithDiscount,
		}
	}

	// Map the result to the response model
	response := &models.DiscountUsageResponse{
		Data:      data,
		StartDate: startDate,
		EndDate:   endDate,
	}

	return response, nil
}

// --- Helper Functions (Optional, for common logic like date validation) ---

// ValidateDateRange checks if start date is before end date.
func ValidateDateRange(startDate, endDate *time.Time) error {
	if startDate != nil && endDate != nil && !endDate.After(*startDate) {
		return errors.New("end date must be after start date")
	}
	return nil
}


Summary:
Total files: 180
Total size: 1572354 bytes
